// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "mzIdentML110.h"

namespace mzIdentML110
{
  // CVListType
  // 

  const CVListType::cv_sequence& CVListType::
  cv () const
  {
    return this->cv_;
  }

  CVListType::cv_sequence& CVListType::
  cv ()
  {
    return this->cv_;
  }

  void CVListType::
  cv (const cv_sequence& s)
  {
    this->cv_ = s;
  }


  // AnalysisSoftwareListType
  // 

  const AnalysisSoftwareListType::AnalysisSoftware_sequence& AnalysisSoftwareListType::
  AnalysisSoftware () const
  {
    return this->AnalysisSoftware_;
  }

  AnalysisSoftwareListType::AnalysisSoftware_sequence& AnalysisSoftwareListType::
  AnalysisSoftware ()
  {
    return this->AnalysisSoftware_;
  }

  void AnalysisSoftwareListType::
  AnalysisSoftware (const AnalysisSoftware_sequence& s)
  {
    this->AnalysisSoftware_ = s;
  }


  // AnalysisSampleCollectionType
  // 

  const AnalysisSampleCollectionType::Sample_sequence& AnalysisSampleCollectionType::
  Sample () const
  {
    return this->Sample_;
  }

  AnalysisSampleCollectionType::Sample_sequence& AnalysisSampleCollectionType::
  Sample ()
  {
    return this->Sample_;
  }

  void AnalysisSampleCollectionType::
  Sample (const Sample_sequence& s)
  {
    this->Sample_ = s;
  }


  // SequenceCollectionType
  // 

  const SequenceCollectionType::DBSequence_sequence& SequenceCollectionType::
  DBSequence () const
  {
    return this->DBSequence_;
  }

  SequenceCollectionType::DBSequence_sequence& SequenceCollectionType::
  DBSequence ()
  {
    return this->DBSequence_;
  }

  void SequenceCollectionType::
  DBSequence (const DBSequence_sequence& s)
  {
    this->DBSequence_ = s;
  }

  const SequenceCollectionType::Peptide_sequence& SequenceCollectionType::
  Peptide () const
  {
    return this->Peptide_;
  }

  SequenceCollectionType::Peptide_sequence& SequenceCollectionType::
  Peptide ()
  {
    return this->Peptide_;
  }

  void SequenceCollectionType::
  Peptide (const Peptide_sequence& s)
  {
    this->Peptide_ = s;
  }

  const SequenceCollectionType::PeptideEvidence_sequence& SequenceCollectionType::
  PeptideEvidence () const
  {
    return this->PeptideEvidence_;
  }

  SequenceCollectionType::PeptideEvidence_sequence& SequenceCollectionType::
  PeptideEvidence ()
  {
    return this->PeptideEvidence_;
  }

  void SequenceCollectionType::
  PeptideEvidence (const PeptideEvidence_sequence& s)
  {
    this->PeptideEvidence_ = s;
  }


  // AnalysisCollectionType
  // 

  const AnalysisCollectionType::SpectrumIdentification_sequence& AnalysisCollectionType::
  SpectrumIdentification () const
  {
    return this->SpectrumIdentification_;
  }

  AnalysisCollectionType::SpectrumIdentification_sequence& AnalysisCollectionType::
  SpectrumIdentification ()
  {
    return this->SpectrumIdentification_;
  }

  void AnalysisCollectionType::
  SpectrumIdentification (const SpectrumIdentification_sequence& s)
  {
    this->SpectrumIdentification_ = s;
  }

  const AnalysisCollectionType::ProteinDetection_optional& AnalysisCollectionType::
  ProteinDetection () const
  {
    return this->ProteinDetection_;
  }

  AnalysisCollectionType::ProteinDetection_optional& AnalysisCollectionType::
  ProteinDetection ()
  {
    return this->ProteinDetection_;
  }

  void AnalysisCollectionType::
  ProteinDetection (const ProteinDetection_type& x)
  {
    this->ProteinDetection_.set (x);
  }

  void AnalysisCollectionType::
  ProteinDetection (const ProteinDetection_optional& x)
  {
    this->ProteinDetection_ = x;
  }

  void AnalysisCollectionType::
  ProteinDetection (::std::unique_ptr< ProteinDetection_type > x)
  {
    this->ProteinDetection_.set (std::move (x));
  }


  // AnalysisProtocolCollectionType
  // 

  const AnalysisProtocolCollectionType::SpectrumIdentificationProtocol_sequence& AnalysisProtocolCollectionType::
  SpectrumIdentificationProtocol () const
  {
    return this->SpectrumIdentificationProtocol_;
  }

  AnalysisProtocolCollectionType::SpectrumIdentificationProtocol_sequence& AnalysisProtocolCollectionType::
  SpectrumIdentificationProtocol ()
  {
    return this->SpectrumIdentificationProtocol_;
  }

  void AnalysisProtocolCollectionType::
  SpectrumIdentificationProtocol (const SpectrumIdentificationProtocol_sequence& s)
  {
    this->SpectrumIdentificationProtocol_ = s;
  }

  const AnalysisProtocolCollectionType::ProteinDetectionProtocol_optional& AnalysisProtocolCollectionType::
  ProteinDetectionProtocol () const
  {
    return this->ProteinDetectionProtocol_;
  }

  AnalysisProtocolCollectionType::ProteinDetectionProtocol_optional& AnalysisProtocolCollectionType::
  ProteinDetectionProtocol ()
  {
    return this->ProteinDetectionProtocol_;
  }

  void AnalysisProtocolCollectionType::
  ProteinDetectionProtocol (const ProteinDetectionProtocol_type& x)
  {
    this->ProteinDetectionProtocol_.set (x);
  }

  void AnalysisProtocolCollectionType::
  ProteinDetectionProtocol (const ProteinDetectionProtocol_optional& x)
  {
    this->ProteinDetectionProtocol_ = x;
  }

  void AnalysisProtocolCollectionType::
  ProteinDetectionProtocol (::std::unique_ptr< ProteinDetectionProtocol_type > x)
  {
    this->ProteinDetectionProtocol_.set (std::move (x));
  }


  // InputsType
  // 

  const InputsType::SourceFile_sequence& InputsType::
  SourceFile () const
  {
    return this->SourceFile_;
  }

  InputsType::SourceFile_sequence& InputsType::
  SourceFile ()
  {
    return this->SourceFile_;
  }

  void InputsType::
  SourceFile (const SourceFile_sequence& s)
  {
    this->SourceFile_ = s;
  }

  const InputsType::SearchDatabase_sequence& InputsType::
  SearchDatabase () const
  {
    return this->SearchDatabase_;
  }

  InputsType::SearchDatabase_sequence& InputsType::
  SearchDatabase ()
  {
    return this->SearchDatabase_;
  }

  void InputsType::
  SearchDatabase (const SearchDatabase_sequence& s)
  {
    this->SearchDatabase_ = s;
  }

  const InputsType::SpectraData_sequence& InputsType::
  SpectraData () const
  {
    return this->SpectraData_;
  }

  InputsType::SpectraData_sequence& InputsType::
  SpectraData ()
  {
    return this->SpectraData_;
  }

  void InputsType::
  SpectraData (const SpectraData_sequence& s)
  {
    this->SpectraData_ = s;
  }


  // AnalysisDataType
  // 

  const AnalysisDataType::SpectrumIdentificationList_sequence& AnalysisDataType::
  SpectrumIdentificationList () const
  {
    return this->SpectrumIdentificationList_;
  }

  AnalysisDataType::SpectrumIdentificationList_sequence& AnalysisDataType::
  SpectrumIdentificationList ()
  {
    return this->SpectrumIdentificationList_;
  }

  void AnalysisDataType::
  SpectrumIdentificationList (const SpectrumIdentificationList_sequence& s)
  {
    this->SpectrumIdentificationList_ = s;
  }

  const AnalysisDataType::ProteinDetectionList_optional& AnalysisDataType::
  ProteinDetectionList () const
  {
    return this->ProteinDetectionList_;
  }

  AnalysisDataType::ProteinDetectionList_optional& AnalysisDataType::
  ProteinDetectionList ()
  {
    return this->ProteinDetectionList_;
  }

  void AnalysisDataType::
  ProteinDetectionList (const ProteinDetectionList_type& x)
  {
    this->ProteinDetectionList_.set (x);
  }

  void AnalysisDataType::
  ProteinDetectionList (const ProteinDetectionList_optional& x)
  {
    this->ProteinDetectionList_ = x;
  }

  void AnalysisDataType::
  ProteinDetectionList (::std::unique_ptr< ProteinDetectionList_type > x)
  {
    this->ProteinDetectionList_.set (std::move (x));
  }


  // DataCollectionType
  // 

  const DataCollectionType::Inputs_type& DataCollectionType::
  Inputs () const
  {
    return this->Inputs_.get ();
  }

  DataCollectionType::Inputs_type& DataCollectionType::
  Inputs ()
  {
    return this->Inputs_.get ();
  }

  void DataCollectionType::
  Inputs (const Inputs_type& x)
  {
    this->Inputs_.set (x);
  }

  void DataCollectionType::
  Inputs (::std::unique_ptr< Inputs_type > x)
  {
    this->Inputs_.set (std::move (x));
  }

  const DataCollectionType::AnalysisData_type& DataCollectionType::
  AnalysisData () const
  {
    return this->AnalysisData_.get ();
  }

  DataCollectionType::AnalysisData_type& DataCollectionType::
  AnalysisData ()
  {
    return this->AnalysisData_.get ();
  }

  void DataCollectionType::
  AnalysisData (const AnalysisData_type& x)
  {
    this->AnalysisData_.set (x);
  }

  void DataCollectionType::
  AnalysisData (::std::unique_ptr< AnalysisData_type > x)
  {
    this->AnalysisData_.set (std::move (x));
  }


  // IdentifiableType
  // 

  const IdentifiableType::id_type& IdentifiableType::
  id () const
  {
    return this->id_.get ();
  }

  IdentifiableType::id_type& IdentifiableType::
  id ()
  {
    return this->id_.get ();
  }

  void IdentifiableType::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void IdentifiableType::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const IdentifiableType::name_optional& IdentifiableType::
  name () const
  {
    return this->name_;
  }

  IdentifiableType::name_optional& IdentifiableType::
  name ()
  {
    return this->name_;
  }

  void IdentifiableType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void IdentifiableType::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void IdentifiableType::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }


  // MzIdentMLType
  // 

  const MzIdentMLType::cvList_type& MzIdentMLType::
  cvList () const
  {
    return this->cvList_.get ();
  }

  MzIdentMLType::cvList_type& MzIdentMLType::
  cvList ()
  {
    return this->cvList_.get ();
  }

  void MzIdentMLType::
  cvList (const cvList_type& x)
  {
    this->cvList_.set (x);
  }

  void MzIdentMLType::
  cvList (::std::unique_ptr< cvList_type > x)
  {
    this->cvList_.set (std::move (x));
  }

  const MzIdentMLType::AnalysisSoftwareList_optional& MzIdentMLType::
  AnalysisSoftwareList () const
  {
    return this->AnalysisSoftwareList_;
  }

  MzIdentMLType::AnalysisSoftwareList_optional& MzIdentMLType::
  AnalysisSoftwareList ()
  {
    return this->AnalysisSoftwareList_;
  }

  void MzIdentMLType::
  AnalysisSoftwareList (const AnalysisSoftwareList_type& x)
  {
    this->AnalysisSoftwareList_.set (x);
  }

  void MzIdentMLType::
  AnalysisSoftwareList (const AnalysisSoftwareList_optional& x)
  {
    this->AnalysisSoftwareList_ = x;
  }

  void MzIdentMLType::
  AnalysisSoftwareList (::std::unique_ptr< AnalysisSoftwareList_type > x)
  {
    this->AnalysisSoftwareList_.set (std::move (x));
  }

  const MzIdentMLType::Provider_optional& MzIdentMLType::
  Provider () const
  {
    return this->Provider_;
  }

  MzIdentMLType::Provider_optional& MzIdentMLType::
  Provider ()
  {
    return this->Provider_;
  }

  void MzIdentMLType::
  Provider (const Provider_type& x)
  {
    this->Provider_.set (x);
  }

  void MzIdentMLType::
  Provider (const Provider_optional& x)
  {
    this->Provider_ = x;
  }

  void MzIdentMLType::
  Provider (::std::unique_ptr< Provider_type > x)
  {
    this->Provider_.set (std::move (x));
  }

  const MzIdentMLType::AuditCollection_optional& MzIdentMLType::
  AuditCollection () const
  {
    return this->AuditCollection_;
  }

  MzIdentMLType::AuditCollection_optional& MzIdentMLType::
  AuditCollection ()
  {
    return this->AuditCollection_;
  }

  void MzIdentMLType::
  AuditCollection (const AuditCollection_type& x)
  {
    this->AuditCollection_.set (x);
  }

  void MzIdentMLType::
  AuditCollection (const AuditCollection_optional& x)
  {
    this->AuditCollection_ = x;
  }

  void MzIdentMLType::
  AuditCollection (::std::unique_ptr< AuditCollection_type > x)
  {
    this->AuditCollection_.set (std::move (x));
  }

  const MzIdentMLType::AnalysisSampleCollection_optional& MzIdentMLType::
  AnalysisSampleCollection () const
  {
    return this->AnalysisSampleCollection_;
  }

  MzIdentMLType::AnalysisSampleCollection_optional& MzIdentMLType::
  AnalysisSampleCollection ()
  {
    return this->AnalysisSampleCollection_;
  }

  void MzIdentMLType::
  AnalysisSampleCollection (const AnalysisSampleCollection_type& x)
  {
    this->AnalysisSampleCollection_.set (x);
  }

  void MzIdentMLType::
  AnalysisSampleCollection (const AnalysisSampleCollection_optional& x)
  {
    this->AnalysisSampleCollection_ = x;
  }

  void MzIdentMLType::
  AnalysisSampleCollection (::std::unique_ptr< AnalysisSampleCollection_type > x)
  {
    this->AnalysisSampleCollection_.set (std::move (x));
  }

  const MzIdentMLType::SequenceCollection_optional& MzIdentMLType::
  SequenceCollection () const
  {
    return this->SequenceCollection_;
  }

  MzIdentMLType::SequenceCollection_optional& MzIdentMLType::
  SequenceCollection ()
  {
    return this->SequenceCollection_;
  }

  void MzIdentMLType::
  SequenceCollection (const SequenceCollection_type& x)
  {
    this->SequenceCollection_.set (x);
  }

  void MzIdentMLType::
  SequenceCollection (const SequenceCollection_optional& x)
  {
    this->SequenceCollection_ = x;
  }

  void MzIdentMLType::
  SequenceCollection (::std::unique_ptr< SequenceCollection_type > x)
  {
    this->SequenceCollection_.set (std::move (x));
  }

  const MzIdentMLType::AnalysisCollection_type& MzIdentMLType::
  AnalysisCollection () const
  {
    return this->AnalysisCollection_.get ();
  }

  MzIdentMLType::AnalysisCollection_type& MzIdentMLType::
  AnalysisCollection ()
  {
    return this->AnalysisCollection_.get ();
  }

  void MzIdentMLType::
  AnalysisCollection (const AnalysisCollection_type& x)
  {
    this->AnalysisCollection_.set (x);
  }

  void MzIdentMLType::
  AnalysisCollection (::std::unique_ptr< AnalysisCollection_type > x)
  {
    this->AnalysisCollection_.set (std::move (x));
  }

  const MzIdentMLType::AnalysisProtocolCollection_type& MzIdentMLType::
  AnalysisProtocolCollection () const
  {
    return this->AnalysisProtocolCollection_.get ();
  }

  MzIdentMLType::AnalysisProtocolCollection_type& MzIdentMLType::
  AnalysisProtocolCollection ()
  {
    return this->AnalysisProtocolCollection_.get ();
  }

  void MzIdentMLType::
  AnalysisProtocolCollection (const AnalysisProtocolCollection_type& x)
  {
    this->AnalysisProtocolCollection_.set (x);
  }

  void MzIdentMLType::
  AnalysisProtocolCollection (::std::unique_ptr< AnalysisProtocolCollection_type > x)
  {
    this->AnalysisProtocolCollection_.set (std::move (x));
  }

  const MzIdentMLType::DataCollection_type& MzIdentMLType::
  DataCollection () const
  {
    return this->DataCollection_.get ();
  }

  MzIdentMLType::DataCollection_type& MzIdentMLType::
  DataCollection ()
  {
    return this->DataCollection_.get ();
  }

  void MzIdentMLType::
  DataCollection (const DataCollection_type& x)
  {
    this->DataCollection_.set (x);
  }

  void MzIdentMLType::
  DataCollection (::std::unique_ptr< DataCollection_type > x)
  {
    this->DataCollection_.set (std::move (x));
  }

  const MzIdentMLType::BibliographicReference_sequence& MzIdentMLType::
  BibliographicReference () const
  {
    return this->BibliographicReference_;
  }

  MzIdentMLType::BibliographicReference_sequence& MzIdentMLType::
  BibliographicReference ()
  {
    return this->BibliographicReference_;
  }

  void MzIdentMLType::
  BibliographicReference (const BibliographicReference_sequence& s)
  {
    this->BibliographicReference_ = s;
  }

  const MzIdentMLType::creationDate_optional& MzIdentMLType::
  creationDate () const
  {
    return this->creationDate_;
  }

  MzIdentMLType::creationDate_optional& MzIdentMLType::
  creationDate ()
  {
    return this->creationDate_;
  }

  void MzIdentMLType::
  creationDate (const creationDate_type& x)
  {
    this->creationDate_.set (x);
  }

  void MzIdentMLType::
  creationDate (const creationDate_optional& x)
  {
    this->creationDate_ = x;
  }

  void MzIdentMLType::
  creationDate (::std::unique_ptr< creationDate_type > x)
  {
    this->creationDate_.set (std::move (x));
  }

  const MzIdentMLType::version_type& MzIdentMLType::
  version () const
  {
    return this->version_.get ();
  }

  MzIdentMLType::version_type& MzIdentMLType::
  version ()
  {
    return this->version_.get ();
  }

  void MzIdentMLType::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void MzIdentMLType::
  version (::std::unique_ptr< version_type > x)
  {
    this->version_.set (std::move (x));
  }


  // ExternalDataType
  // 

  const ExternalDataType::ExternalFormatDocumentation_optional& ExternalDataType::
  ExternalFormatDocumentation () const
  {
    return this->ExternalFormatDocumentation_;
  }

  ExternalDataType::ExternalFormatDocumentation_optional& ExternalDataType::
  ExternalFormatDocumentation ()
  {
    return this->ExternalFormatDocumentation_;
  }

  void ExternalDataType::
  ExternalFormatDocumentation (const ExternalFormatDocumentation_type& x)
  {
    this->ExternalFormatDocumentation_.set (x);
  }

  void ExternalDataType::
  ExternalFormatDocumentation (const ExternalFormatDocumentation_optional& x)
  {
    this->ExternalFormatDocumentation_ = x;
  }

  void ExternalDataType::
  ExternalFormatDocumentation (::std::unique_ptr< ExternalFormatDocumentation_type > x)
  {
    this->ExternalFormatDocumentation_.set (std::move (x));
  }

  const ExternalDataType::FileFormat_optional& ExternalDataType::
  FileFormat () const
  {
    return this->FileFormat_;
  }

  ExternalDataType::FileFormat_optional& ExternalDataType::
  FileFormat ()
  {
    return this->FileFormat_;
  }

  void ExternalDataType::
  FileFormat (const FileFormat_type& x)
  {
    this->FileFormat_.set (x);
  }

  void ExternalDataType::
  FileFormat (const FileFormat_optional& x)
  {
    this->FileFormat_ = x;
  }

  void ExternalDataType::
  FileFormat (::std::unique_ptr< FileFormat_type > x)
  {
    this->FileFormat_.set (std::move (x));
  }

  const ExternalDataType::location_type& ExternalDataType::
  location () const
  {
    return this->location_.get ();
  }

  ExternalDataType::location_type& ExternalDataType::
  location ()
  {
    return this->location_.get ();
  }

  void ExternalDataType::
  location (const location_type& x)
  {
    this->location_.set (x);
  }

  void ExternalDataType::
  location (::std::unique_ptr< location_type > x)
  {
    this->location_.set (std::move (x));
  }


  // SearchDatabaseType
  // 

  const SearchDatabaseType::DatabaseName_type& SearchDatabaseType::
  DatabaseName () const
  {
    return this->DatabaseName_.get ();
  }

  SearchDatabaseType::DatabaseName_type& SearchDatabaseType::
  DatabaseName ()
  {
    return this->DatabaseName_.get ();
  }

  void SearchDatabaseType::
  DatabaseName (const DatabaseName_type& x)
  {
    this->DatabaseName_.set (x);
  }

  void SearchDatabaseType::
  DatabaseName (::std::unique_ptr< DatabaseName_type > x)
  {
    this->DatabaseName_.set (std::move (x));
  }

  const SearchDatabaseType::cvParam_sequence& SearchDatabaseType::
  cvParam () const
  {
    return this->cvParam_;
  }

  SearchDatabaseType::cvParam_sequence& SearchDatabaseType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void SearchDatabaseType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }

  const SearchDatabaseType::version_optional& SearchDatabaseType::
  version () const
  {
    return this->version_;
  }

  SearchDatabaseType::version_optional& SearchDatabaseType::
  version ()
  {
    return this->version_;
  }

  void SearchDatabaseType::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void SearchDatabaseType::
  version (const version_optional& x)
  {
    this->version_ = x;
  }

  void SearchDatabaseType::
  version (::std::unique_ptr< version_type > x)
  {
    this->version_.set (std::move (x));
  }

  const SearchDatabaseType::releaseDate_optional& SearchDatabaseType::
  releaseDate () const
  {
    return this->releaseDate_;
  }

  SearchDatabaseType::releaseDate_optional& SearchDatabaseType::
  releaseDate ()
  {
    return this->releaseDate_;
  }

  void SearchDatabaseType::
  releaseDate (const releaseDate_type& x)
  {
    this->releaseDate_.set (x);
  }

  void SearchDatabaseType::
  releaseDate (const releaseDate_optional& x)
  {
    this->releaseDate_ = x;
  }

  void SearchDatabaseType::
  releaseDate (::std::unique_ptr< releaseDate_type > x)
  {
    this->releaseDate_.set (std::move (x));
  }

  const SearchDatabaseType::numDatabaseSequences_optional& SearchDatabaseType::
  numDatabaseSequences () const
  {
    return this->numDatabaseSequences_;
  }

  SearchDatabaseType::numDatabaseSequences_optional& SearchDatabaseType::
  numDatabaseSequences ()
  {
    return this->numDatabaseSequences_;
  }

  void SearchDatabaseType::
  numDatabaseSequences (const numDatabaseSequences_type& x)
  {
    this->numDatabaseSequences_.set (x);
  }

  void SearchDatabaseType::
  numDatabaseSequences (const numDatabaseSequences_optional& x)
  {
    this->numDatabaseSequences_ = x;
  }

  const SearchDatabaseType::numResidues_optional& SearchDatabaseType::
  numResidues () const
  {
    return this->numResidues_;
  }

  SearchDatabaseType::numResidues_optional& SearchDatabaseType::
  numResidues ()
  {
    return this->numResidues_;
  }

  void SearchDatabaseType::
  numResidues (const numResidues_type& x)
  {
    this->numResidues_.set (x);
  }

  void SearchDatabaseType::
  numResidues (const numResidues_optional& x)
  {
    this->numResidues_ = x;
  }


  // SourceFileType
  // 

  const SourceFileType::cvParam_sequence& SourceFileType::
  cvParam () const
  {
    return this->cvParam_;
  }

  SourceFileType::cvParam_sequence& SourceFileType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void SourceFileType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }

  const SourceFileType::userParam_sequence& SourceFileType::
  userParam () const
  {
    return this->userParam_;
  }

  SourceFileType::userParam_sequence& SourceFileType::
  userParam ()
  {
    return this->userParam_;
  }

  void SourceFileType::
  userParam (const userParam_sequence& s)
  {
    this->userParam_ = s;
  }


  // ModificationParamsType
  // 

  const ModificationParamsType::SearchModification_sequence& ModificationParamsType::
  SearchModification () const
  {
    return this->SearchModification_;
  }

  ModificationParamsType::SearchModification_sequence& ModificationParamsType::
  SearchModification ()
  {
    return this->SearchModification_;
  }

  void ModificationParamsType::
  SearchModification (const SearchModification_sequence& s)
  {
    this->SearchModification_ = s;
  }


  // FilterType
  // 

  const FilterType::FilterType1_type& FilterType::
  FilterType1 () const
  {
    return this->FilterType1_.get ();
  }

  FilterType::FilterType1_type& FilterType::
  FilterType1 ()
  {
    return this->FilterType1_.get ();
  }

  void FilterType::
  FilterType1 (const FilterType1_type& x)
  {
    this->FilterType1_.set (x);
  }

  void FilterType::
  FilterType1 (::std::unique_ptr< FilterType1_type > x)
  {
    this->FilterType1_.set (std::move (x));
  }

  const FilterType::Include_optional& FilterType::
  Include () const
  {
    return this->Include_;
  }

  FilterType::Include_optional& FilterType::
  Include ()
  {
    return this->Include_;
  }

  void FilterType::
  Include (const Include_type& x)
  {
    this->Include_.set (x);
  }

  void FilterType::
  Include (const Include_optional& x)
  {
    this->Include_ = x;
  }

  void FilterType::
  Include (::std::unique_ptr< Include_type > x)
  {
    this->Include_.set (std::move (x));
  }

  const FilterType::Exclude_optional& FilterType::
  Exclude () const
  {
    return this->Exclude_;
  }

  FilterType::Exclude_optional& FilterType::
  Exclude ()
  {
    return this->Exclude_;
  }

  void FilterType::
  Exclude (const Exclude_type& x)
  {
    this->Exclude_.set (x);
  }

  void FilterType::
  Exclude (const Exclude_optional& x)
  {
    this->Exclude_ = x;
  }

  void FilterType::
  Exclude (::std::unique_ptr< Exclude_type > x)
  {
    this->Exclude_.set (std::move (x));
  }


  // DatabaseFiltersType
  // 

  const DatabaseFiltersType::Filter_sequence& DatabaseFiltersType::
  Filter () const
  {
    return this->Filter_;
  }

  DatabaseFiltersType::Filter_sequence& DatabaseFiltersType::
  Filter ()
  {
    return this->Filter_;
  }

  void DatabaseFiltersType::
  Filter (const Filter_sequence& s)
  {
    this->Filter_ = s;
  }


  // TranslationTableType
  // 

  const TranslationTableType::cvParam_sequence& TranslationTableType::
  cvParam () const
  {
    return this->cvParam_;
  }

  TranslationTableType::cvParam_sequence& TranslationTableType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void TranslationTableType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }


  // DatabaseTranslationType
  // 

  const DatabaseTranslationType::TranslationTable_sequence& DatabaseTranslationType::
  TranslationTable () const
  {
    return this->TranslationTable_;
  }

  DatabaseTranslationType::TranslationTable_sequence& DatabaseTranslationType::
  TranslationTable ()
  {
    return this->TranslationTable_;
  }

  void DatabaseTranslationType::
  TranslationTable (const TranslationTable_sequence& s)
  {
    this->TranslationTable_ = s;
  }

  const DatabaseTranslationType::frames_optional& DatabaseTranslationType::
  frames () const
  {
    return this->frames_;
  }

  DatabaseTranslationType::frames_optional& DatabaseTranslationType::
  frames ()
  {
    return this->frames_;
  }

  void DatabaseTranslationType::
  frames (const frames_type& x)
  {
    this->frames_.set (x);
  }

  void DatabaseTranslationType::
  frames (const frames_optional& x)
  {
    this->frames_ = x;
  }

  void DatabaseTranslationType::
  frames (::std::unique_ptr< frames_type > x)
  {
    this->frames_.set (std::move (x));
  }


  // SpectrumIdentificationProtocolType
  // 

  const SpectrumIdentificationProtocolType::SearchType_type& SpectrumIdentificationProtocolType::
  SearchType () const
  {
    return this->SearchType_.get ();
  }

  SpectrumIdentificationProtocolType::SearchType_type& SpectrumIdentificationProtocolType::
  SearchType ()
  {
    return this->SearchType_.get ();
  }

  void SpectrumIdentificationProtocolType::
  SearchType (const SearchType_type& x)
  {
    this->SearchType_.set (x);
  }

  void SpectrumIdentificationProtocolType::
  SearchType (::std::unique_ptr< SearchType_type > x)
  {
    this->SearchType_.set (std::move (x));
  }

  const SpectrumIdentificationProtocolType::AdditionalSearchParams_optional& SpectrumIdentificationProtocolType::
  AdditionalSearchParams () const
  {
    return this->AdditionalSearchParams_;
  }

  SpectrumIdentificationProtocolType::AdditionalSearchParams_optional& SpectrumIdentificationProtocolType::
  AdditionalSearchParams ()
  {
    return this->AdditionalSearchParams_;
  }

  void SpectrumIdentificationProtocolType::
  AdditionalSearchParams (const AdditionalSearchParams_type& x)
  {
    this->AdditionalSearchParams_.set (x);
  }

  void SpectrumIdentificationProtocolType::
  AdditionalSearchParams (const AdditionalSearchParams_optional& x)
  {
    this->AdditionalSearchParams_ = x;
  }

  void SpectrumIdentificationProtocolType::
  AdditionalSearchParams (::std::unique_ptr< AdditionalSearchParams_type > x)
  {
    this->AdditionalSearchParams_.set (std::move (x));
  }

  const SpectrumIdentificationProtocolType::ModificationParams_optional& SpectrumIdentificationProtocolType::
  ModificationParams () const
  {
    return this->ModificationParams_;
  }

  SpectrumIdentificationProtocolType::ModificationParams_optional& SpectrumIdentificationProtocolType::
  ModificationParams ()
  {
    return this->ModificationParams_;
  }

  void SpectrumIdentificationProtocolType::
  ModificationParams (const ModificationParams_type& x)
  {
    this->ModificationParams_.set (x);
  }

  void SpectrumIdentificationProtocolType::
  ModificationParams (const ModificationParams_optional& x)
  {
    this->ModificationParams_ = x;
  }

  void SpectrumIdentificationProtocolType::
  ModificationParams (::std::unique_ptr< ModificationParams_type > x)
  {
    this->ModificationParams_.set (std::move (x));
  }

  const SpectrumIdentificationProtocolType::Enzymes_optional& SpectrumIdentificationProtocolType::
  Enzymes () const
  {
    return this->Enzymes_;
  }

  SpectrumIdentificationProtocolType::Enzymes_optional& SpectrumIdentificationProtocolType::
  Enzymes ()
  {
    return this->Enzymes_;
  }

  void SpectrumIdentificationProtocolType::
  Enzymes (const Enzymes_type& x)
  {
    this->Enzymes_.set (x);
  }

  void SpectrumIdentificationProtocolType::
  Enzymes (const Enzymes_optional& x)
  {
    this->Enzymes_ = x;
  }

  void SpectrumIdentificationProtocolType::
  Enzymes (::std::unique_ptr< Enzymes_type > x)
  {
    this->Enzymes_.set (std::move (x));
  }

  const SpectrumIdentificationProtocolType::MassTable_sequence& SpectrumIdentificationProtocolType::
  MassTable () const
  {
    return this->MassTable_;
  }

  SpectrumIdentificationProtocolType::MassTable_sequence& SpectrumIdentificationProtocolType::
  MassTable ()
  {
    return this->MassTable_;
  }

  void SpectrumIdentificationProtocolType::
  MassTable (const MassTable_sequence& s)
  {
    this->MassTable_ = s;
  }

  const SpectrumIdentificationProtocolType::FragmentTolerance_optional& SpectrumIdentificationProtocolType::
  FragmentTolerance () const
  {
    return this->FragmentTolerance_;
  }

  SpectrumIdentificationProtocolType::FragmentTolerance_optional& SpectrumIdentificationProtocolType::
  FragmentTolerance ()
  {
    return this->FragmentTolerance_;
  }

  void SpectrumIdentificationProtocolType::
  FragmentTolerance (const FragmentTolerance_type& x)
  {
    this->FragmentTolerance_.set (x);
  }

  void SpectrumIdentificationProtocolType::
  FragmentTolerance (const FragmentTolerance_optional& x)
  {
    this->FragmentTolerance_ = x;
  }

  void SpectrumIdentificationProtocolType::
  FragmentTolerance (::std::unique_ptr< FragmentTolerance_type > x)
  {
    this->FragmentTolerance_.set (std::move (x));
  }

  const SpectrumIdentificationProtocolType::ParentTolerance_optional& SpectrumIdentificationProtocolType::
  ParentTolerance () const
  {
    return this->ParentTolerance_;
  }

  SpectrumIdentificationProtocolType::ParentTolerance_optional& SpectrumIdentificationProtocolType::
  ParentTolerance ()
  {
    return this->ParentTolerance_;
  }

  void SpectrumIdentificationProtocolType::
  ParentTolerance (const ParentTolerance_type& x)
  {
    this->ParentTolerance_.set (x);
  }

  void SpectrumIdentificationProtocolType::
  ParentTolerance (const ParentTolerance_optional& x)
  {
    this->ParentTolerance_ = x;
  }

  void SpectrumIdentificationProtocolType::
  ParentTolerance (::std::unique_ptr< ParentTolerance_type > x)
  {
    this->ParentTolerance_.set (std::move (x));
  }

  const SpectrumIdentificationProtocolType::Threshold_type& SpectrumIdentificationProtocolType::
  Threshold () const
  {
    return this->Threshold_.get ();
  }

  SpectrumIdentificationProtocolType::Threshold_type& SpectrumIdentificationProtocolType::
  Threshold ()
  {
    return this->Threshold_.get ();
  }

  void SpectrumIdentificationProtocolType::
  Threshold (const Threshold_type& x)
  {
    this->Threshold_.set (x);
  }

  void SpectrumIdentificationProtocolType::
  Threshold (::std::unique_ptr< Threshold_type > x)
  {
    this->Threshold_.set (std::move (x));
  }

  const SpectrumIdentificationProtocolType::DatabaseFilters_optional& SpectrumIdentificationProtocolType::
  DatabaseFilters () const
  {
    return this->DatabaseFilters_;
  }

  SpectrumIdentificationProtocolType::DatabaseFilters_optional& SpectrumIdentificationProtocolType::
  DatabaseFilters ()
  {
    return this->DatabaseFilters_;
  }

  void SpectrumIdentificationProtocolType::
  DatabaseFilters (const DatabaseFilters_type& x)
  {
    this->DatabaseFilters_.set (x);
  }

  void SpectrumIdentificationProtocolType::
  DatabaseFilters (const DatabaseFilters_optional& x)
  {
    this->DatabaseFilters_ = x;
  }

  void SpectrumIdentificationProtocolType::
  DatabaseFilters (::std::unique_ptr< DatabaseFilters_type > x)
  {
    this->DatabaseFilters_.set (std::move (x));
  }

  const SpectrumIdentificationProtocolType::DatabaseTranslation_optional& SpectrumIdentificationProtocolType::
  DatabaseTranslation () const
  {
    return this->DatabaseTranslation_;
  }

  SpectrumIdentificationProtocolType::DatabaseTranslation_optional& SpectrumIdentificationProtocolType::
  DatabaseTranslation ()
  {
    return this->DatabaseTranslation_;
  }

  void SpectrumIdentificationProtocolType::
  DatabaseTranslation (const DatabaseTranslation_type& x)
  {
    this->DatabaseTranslation_.set (x);
  }

  void SpectrumIdentificationProtocolType::
  DatabaseTranslation (const DatabaseTranslation_optional& x)
  {
    this->DatabaseTranslation_ = x;
  }

  void SpectrumIdentificationProtocolType::
  DatabaseTranslation (::std::unique_ptr< DatabaseTranslation_type > x)
  {
    this->DatabaseTranslation_.set (std::move (x));
  }

  const SpectrumIdentificationProtocolType::analysisSoftware_ref_type& SpectrumIdentificationProtocolType::
  analysisSoftware_ref () const
  {
    return this->analysisSoftware_ref_.get ();
  }

  SpectrumIdentificationProtocolType::analysisSoftware_ref_type& SpectrumIdentificationProtocolType::
  analysisSoftware_ref ()
  {
    return this->analysisSoftware_ref_.get ();
  }

  void SpectrumIdentificationProtocolType::
  analysisSoftware_ref (const analysisSoftware_ref_type& x)
  {
    this->analysisSoftware_ref_.set (x);
  }

  void SpectrumIdentificationProtocolType::
  analysisSoftware_ref (::std::unique_ptr< analysisSoftware_ref_type > x)
  {
    this->analysisSoftware_ref_.set (std::move (x));
  }


  // InputSpectraType
  // 

  const InputSpectraType::spectraData_ref_optional& InputSpectraType::
  spectraData_ref () const
  {
    return this->spectraData_ref_;
  }

  InputSpectraType::spectraData_ref_optional& InputSpectraType::
  spectraData_ref ()
  {
    return this->spectraData_ref_;
  }

  void InputSpectraType::
  spectraData_ref (const spectraData_ref_type& x)
  {
    this->spectraData_ref_.set (x);
  }

  void InputSpectraType::
  spectraData_ref (const spectraData_ref_optional& x)
  {
    this->spectraData_ref_ = x;
  }

  void InputSpectraType::
  spectraData_ref (::std::unique_ptr< spectraData_ref_type > x)
  {
    this->spectraData_ref_.set (std::move (x));
  }


  // SearchDatabaseRefType
  // 

  const SearchDatabaseRefType::searchDatabase_ref_optional& SearchDatabaseRefType::
  searchDatabase_ref () const
  {
    return this->searchDatabase_ref_;
  }

  SearchDatabaseRefType::searchDatabase_ref_optional& SearchDatabaseRefType::
  searchDatabase_ref ()
  {
    return this->searchDatabase_ref_;
  }

  void SearchDatabaseRefType::
  searchDatabase_ref (const searchDatabase_ref_type& x)
  {
    this->searchDatabase_ref_.set (x);
  }

  void SearchDatabaseRefType::
  searchDatabase_ref (const searchDatabase_ref_optional& x)
  {
    this->searchDatabase_ref_ = x;
  }

  void SearchDatabaseRefType::
  searchDatabase_ref (::std::unique_ptr< searchDatabase_ref_type > x)
  {
    this->searchDatabase_ref_.set (std::move (x));
  }


  // ProtocolApplicationType
  // 

  const ProtocolApplicationType::activityDate_optional& ProtocolApplicationType::
  activityDate () const
  {
    return this->activityDate_;
  }

  ProtocolApplicationType::activityDate_optional& ProtocolApplicationType::
  activityDate ()
  {
    return this->activityDate_;
  }

  void ProtocolApplicationType::
  activityDate (const activityDate_type& x)
  {
    this->activityDate_.set (x);
  }

  void ProtocolApplicationType::
  activityDate (const activityDate_optional& x)
  {
    this->activityDate_ = x;
  }

  void ProtocolApplicationType::
  activityDate (::std::unique_ptr< activityDate_type > x)
  {
    this->activityDate_.set (std::move (x));
  }


  // SpectrumIdentificationType
  // 

  const SpectrumIdentificationType::InputSpectra_sequence& SpectrumIdentificationType::
  InputSpectra () const
  {
    return this->InputSpectra_;
  }

  SpectrumIdentificationType::InputSpectra_sequence& SpectrumIdentificationType::
  InputSpectra ()
  {
    return this->InputSpectra_;
  }

  void SpectrumIdentificationType::
  InputSpectra (const InputSpectra_sequence& s)
  {
    this->InputSpectra_ = s;
  }

  const SpectrumIdentificationType::SearchDatabaseRef_sequence& SpectrumIdentificationType::
  SearchDatabaseRef () const
  {
    return this->SearchDatabaseRef_;
  }

  SpectrumIdentificationType::SearchDatabaseRef_sequence& SpectrumIdentificationType::
  SearchDatabaseRef ()
  {
    return this->SearchDatabaseRef_;
  }

  void SpectrumIdentificationType::
  SearchDatabaseRef (const SearchDatabaseRef_sequence& s)
  {
    this->SearchDatabaseRef_ = s;
  }

  const SpectrumIdentificationType::spectrumIdentificationProtocol_ref_type& SpectrumIdentificationType::
  spectrumIdentificationProtocol_ref () const
  {
    return this->spectrumIdentificationProtocol_ref_.get ();
  }

  SpectrumIdentificationType::spectrumIdentificationProtocol_ref_type& SpectrumIdentificationType::
  spectrumIdentificationProtocol_ref ()
  {
    return this->spectrumIdentificationProtocol_ref_.get ();
  }

  void SpectrumIdentificationType::
  spectrumIdentificationProtocol_ref (const spectrumIdentificationProtocol_ref_type& x)
  {
    this->spectrumIdentificationProtocol_ref_.set (x);
  }

  void SpectrumIdentificationType::
  spectrumIdentificationProtocol_ref (::std::unique_ptr< spectrumIdentificationProtocol_ref_type > x)
  {
    this->spectrumIdentificationProtocol_ref_.set (std::move (x));
  }

  const SpectrumIdentificationType::spectrumIdentificationList_ref_type& SpectrumIdentificationType::
  spectrumIdentificationList_ref () const
  {
    return this->spectrumIdentificationList_ref_.get ();
  }

  SpectrumIdentificationType::spectrumIdentificationList_ref_type& SpectrumIdentificationType::
  spectrumIdentificationList_ref ()
  {
    return this->spectrumIdentificationList_ref_.get ();
  }

  void SpectrumIdentificationType::
  spectrumIdentificationList_ref (const spectrumIdentificationList_ref_type& x)
  {
    this->spectrumIdentificationList_ref_.set (x);
  }

  void SpectrumIdentificationType::
  spectrumIdentificationList_ref (::std::unique_ptr< spectrumIdentificationList_ref_type > x)
  {
    this->spectrumIdentificationList_ref_.set (std::move (x));
  }


  // MeasureType
  // 

  const MeasureType::cvParam_sequence& MeasureType::
  cvParam () const
  {
    return this->cvParam_;
  }

  MeasureType::cvParam_sequence& MeasureType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void MeasureType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }


  // FragmentationTableType
  // 

  const FragmentationTableType::Measure_sequence& FragmentationTableType::
  Measure () const
  {
    return this->Measure_;
  }

  FragmentationTableType::Measure_sequence& FragmentationTableType::
  Measure ()
  {
    return this->Measure_;
  }

  void FragmentationTableType::
  Measure (const Measure_sequence& s)
  {
    this->Measure_ = s;
  }


  // SpectrumIdentificationListType
  // 

  const SpectrumIdentificationListType::FragmentationTable_optional& SpectrumIdentificationListType::
  FragmentationTable () const
  {
    return this->FragmentationTable_;
  }

  SpectrumIdentificationListType::FragmentationTable_optional& SpectrumIdentificationListType::
  FragmentationTable ()
  {
    return this->FragmentationTable_;
  }

  void SpectrumIdentificationListType::
  FragmentationTable (const FragmentationTable_type& x)
  {
    this->FragmentationTable_.set (x);
  }

  void SpectrumIdentificationListType::
  FragmentationTable (const FragmentationTable_optional& x)
  {
    this->FragmentationTable_ = x;
  }

  void SpectrumIdentificationListType::
  FragmentationTable (::std::unique_ptr< FragmentationTable_type > x)
  {
    this->FragmentationTable_.set (std::move (x));
  }

  const SpectrumIdentificationListType::SpectrumIdentificationResult_sequence& SpectrumIdentificationListType::
  SpectrumIdentificationResult () const
  {
    return this->SpectrumIdentificationResult_;
  }

  SpectrumIdentificationListType::SpectrumIdentificationResult_sequence& SpectrumIdentificationListType::
  SpectrumIdentificationResult ()
  {
    return this->SpectrumIdentificationResult_;
  }

  void SpectrumIdentificationListType::
  SpectrumIdentificationResult (const SpectrumIdentificationResult_sequence& s)
  {
    this->SpectrumIdentificationResult_ = s;
  }

  const SpectrumIdentificationListType::cvParam_sequence& SpectrumIdentificationListType::
  cvParam () const
  {
    return this->cvParam_;
  }

  SpectrumIdentificationListType::cvParam_sequence& SpectrumIdentificationListType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void SpectrumIdentificationListType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }

  const SpectrumIdentificationListType::userParam_sequence& SpectrumIdentificationListType::
  userParam () const
  {
    return this->userParam_;
  }

  SpectrumIdentificationListType::userParam_sequence& SpectrumIdentificationListType::
  userParam ()
  {
    return this->userParam_;
  }

  void SpectrumIdentificationListType::
  userParam (const userParam_sequence& s)
  {
    this->userParam_ = s;
  }

  const SpectrumIdentificationListType::numSequencesSearched_optional& SpectrumIdentificationListType::
  numSequencesSearched () const
  {
    return this->numSequencesSearched_;
  }

  SpectrumIdentificationListType::numSequencesSearched_optional& SpectrumIdentificationListType::
  numSequencesSearched ()
  {
    return this->numSequencesSearched_;
  }

  void SpectrumIdentificationListType::
  numSequencesSearched (const numSequencesSearched_type& x)
  {
    this->numSequencesSearched_.set (x);
  }

  void SpectrumIdentificationListType::
  numSequencesSearched (const numSequencesSearched_optional& x)
  {
    this->numSequencesSearched_ = x;
  }


  // SpecificityRulesType
  // 

  const SpecificityRulesType::cvParam_sequence& SpecificityRulesType::
  cvParam () const
  {
    return this->cvParam_;
  }

  SpecificityRulesType::cvParam_sequence& SpecificityRulesType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void SpecificityRulesType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }


  // SearchModificationType
  // 

  const SearchModificationType::SpecificityRules_sequence& SearchModificationType::
  SpecificityRules () const
  {
    return this->SpecificityRules_;
  }

  SearchModificationType::SpecificityRules_sequence& SearchModificationType::
  SpecificityRules ()
  {
    return this->SpecificityRules_;
  }

  void SearchModificationType::
  SpecificityRules (const SpecificityRules_sequence& s)
  {
    this->SpecificityRules_ = s;
  }

  const SearchModificationType::cvParam_sequence& SearchModificationType::
  cvParam () const
  {
    return this->cvParam_;
  }

  SearchModificationType::cvParam_sequence& SearchModificationType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void SearchModificationType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }

  const SearchModificationType::fixedMod_type& SearchModificationType::
  fixedMod () const
  {
    return this->fixedMod_.get ();
  }

  SearchModificationType::fixedMod_type& SearchModificationType::
  fixedMod ()
  {
    return this->fixedMod_.get ();
  }

  void SearchModificationType::
  fixedMod (const fixedMod_type& x)
  {
    this->fixedMod_.set (x);
  }

  const SearchModificationType::massDelta_type& SearchModificationType::
  massDelta () const
  {
    return this->massDelta_.get ();
  }

  SearchModificationType::massDelta_type& SearchModificationType::
  massDelta ()
  {
    return this->massDelta_.get ();
  }

  void SearchModificationType::
  massDelta (const massDelta_type& x)
  {
    this->massDelta_.set (x);
  }

  const SearchModificationType::residues_type& SearchModificationType::
  residues () const
  {
    return this->residues_.get ();
  }

  SearchModificationType::residues_type& SearchModificationType::
  residues ()
  {
    return this->residues_.get ();
  }

  void SearchModificationType::
  residues (const residues_type& x)
  {
    this->residues_.set (x);
  }

  void SearchModificationType::
  residues (::std::unique_ptr< residues_type > x)
  {
    this->residues_.set (std::move (x));
  }


  // FragmentArrayType
  // 

  const FragmentArrayType::values_type& FragmentArrayType::
  values () const
  {
    return this->values_.get ();
  }

  FragmentArrayType::values_type& FragmentArrayType::
  values ()
  {
    return this->values_.get ();
  }

  void FragmentArrayType::
  values (const values_type& x)
  {
    this->values_.set (x);
  }

  void FragmentArrayType::
  values (::std::unique_ptr< values_type > x)
  {
    this->values_.set (std::move (x));
  }

  const FragmentArrayType::measure_ref_type& FragmentArrayType::
  measure_ref () const
  {
    return this->measure_ref_.get ();
  }

  FragmentArrayType::measure_ref_type& FragmentArrayType::
  measure_ref ()
  {
    return this->measure_ref_.get ();
  }

  void FragmentArrayType::
  measure_ref (const measure_ref_type& x)
  {
    this->measure_ref_.set (x);
  }

  void FragmentArrayType::
  measure_ref (::std::unique_ptr< measure_ref_type > x)
  {
    this->measure_ref_.set (std::move (x));
  }


  // IonTypeType
  // 

  const IonTypeType::FragmentArray_sequence& IonTypeType::
  FragmentArray () const
  {
    return this->FragmentArray_;
  }

  IonTypeType::FragmentArray_sequence& IonTypeType::
  FragmentArray ()
  {
    return this->FragmentArray_;
  }

  void IonTypeType::
  FragmentArray (const FragmentArray_sequence& s)
  {
    this->FragmentArray_ = s;
  }

  const IonTypeType::cvParam_type& IonTypeType::
  cvParam () const
  {
    return this->cvParam_.get ();
  }

  IonTypeType::cvParam_type& IonTypeType::
  cvParam ()
  {
    return this->cvParam_.get ();
  }

  void IonTypeType::
  cvParam (const cvParam_type& x)
  {
    this->cvParam_.set (x);
  }

  void IonTypeType::
  cvParam (::std::unique_ptr< cvParam_type > x)
  {
    this->cvParam_.set (std::move (x));
  }

  const IonTypeType::index_optional& IonTypeType::
  index () const
  {
    return this->index_;
  }

  IonTypeType::index_optional& IonTypeType::
  index ()
  {
    return this->index_;
  }

  void IonTypeType::
  index (const index_type& x)
  {
    this->index_.set (x);
  }

  void IonTypeType::
  index (const index_optional& x)
  {
    this->index_ = x;
  }

  void IonTypeType::
  index (::std::unique_ptr< index_type > x)
  {
    this->index_.set (std::move (x));
  }

  const IonTypeType::charge_type& IonTypeType::
  charge () const
  {
    return this->charge_.get ();
  }

  IonTypeType::charge_type& IonTypeType::
  charge ()
  {
    return this->charge_.get ();
  }

  void IonTypeType::
  charge (const charge_type& x)
  {
    this->charge_.set (x);
  }


  // FragmentationType
  // 

  const FragmentationType::IonType_sequence& FragmentationType::
  IonType () const
  {
    return this->IonType_;
  }

  FragmentationType::IonType_sequence& FragmentationType::
  IonType ()
  {
    return this->IonType_;
  }

  void FragmentationType::
  IonType (const IonType_sequence& s)
  {
    this->IonType_ = s;
  }


  // PeptideEvidenceRefType
  // 

  const PeptideEvidenceRefType::peptideEvidence_ref_type& PeptideEvidenceRefType::
  peptideEvidence_ref () const
  {
    return this->peptideEvidence_ref_.get ();
  }

  PeptideEvidenceRefType::peptideEvidence_ref_type& PeptideEvidenceRefType::
  peptideEvidence_ref ()
  {
    return this->peptideEvidence_ref_.get ();
  }

  void PeptideEvidenceRefType::
  peptideEvidence_ref (const peptideEvidence_ref_type& x)
  {
    this->peptideEvidence_ref_.set (x);
  }

  void PeptideEvidenceRefType::
  peptideEvidence_ref (::std::unique_ptr< peptideEvidence_ref_type > x)
  {
    this->peptideEvidence_ref_.set (std::move (x));
  }


  // SpectrumIdentificationItemType
  // 

  const SpectrumIdentificationItemType::PeptideEvidenceRef_sequence& SpectrumIdentificationItemType::
  PeptideEvidenceRef () const
  {
    return this->PeptideEvidenceRef_;
  }

  SpectrumIdentificationItemType::PeptideEvidenceRef_sequence& SpectrumIdentificationItemType::
  PeptideEvidenceRef ()
  {
    return this->PeptideEvidenceRef_;
  }

  void SpectrumIdentificationItemType::
  PeptideEvidenceRef (const PeptideEvidenceRef_sequence& s)
  {
    this->PeptideEvidenceRef_ = s;
  }

  const SpectrumIdentificationItemType::Fragmentation_optional& SpectrumIdentificationItemType::
  Fragmentation () const
  {
    return this->Fragmentation_;
  }

  SpectrumIdentificationItemType::Fragmentation_optional& SpectrumIdentificationItemType::
  Fragmentation ()
  {
    return this->Fragmentation_;
  }

  void SpectrumIdentificationItemType::
  Fragmentation (const Fragmentation_type& x)
  {
    this->Fragmentation_.set (x);
  }

  void SpectrumIdentificationItemType::
  Fragmentation (const Fragmentation_optional& x)
  {
    this->Fragmentation_ = x;
  }

  void SpectrumIdentificationItemType::
  Fragmentation (::std::unique_ptr< Fragmentation_type > x)
  {
    this->Fragmentation_.set (std::move (x));
  }

  const SpectrumIdentificationItemType::cvParam_sequence& SpectrumIdentificationItemType::
  cvParam () const
  {
    return this->cvParam_;
  }

  SpectrumIdentificationItemType::cvParam_sequence& SpectrumIdentificationItemType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void SpectrumIdentificationItemType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }

  const SpectrumIdentificationItemType::userParam_sequence& SpectrumIdentificationItemType::
  userParam () const
  {
    return this->userParam_;
  }

  SpectrumIdentificationItemType::userParam_sequence& SpectrumIdentificationItemType::
  userParam ()
  {
    return this->userParam_;
  }

  void SpectrumIdentificationItemType::
  userParam (const userParam_sequence& s)
  {
    this->userParam_ = s;
  }

  const SpectrumIdentificationItemType::chargeState_type& SpectrumIdentificationItemType::
  chargeState () const
  {
    return this->chargeState_.get ();
  }

  SpectrumIdentificationItemType::chargeState_type& SpectrumIdentificationItemType::
  chargeState ()
  {
    return this->chargeState_.get ();
  }

  void SpectrumIdentificationItemType::
  chargeState (const chargeState_type& x)
  {
    this->chargeState_.set (x);
  }

  const SpectrumIdentificationItemType::experimentalMassToCharge_type& SpectrumIdentificationItemType::
  experimentalMassToCharge () const
  {
    return this->experimentalMassToCharge_.get ();
  }

  SpectrumIdentificationItemType::experimentalMassToCharge_type& SpectrumIdentificationItemType::
  experimentalMassToCharge ()
  {
    return this->experimentalMassToCharge_.get ();
  }

  void SpectrumIdentificationItemType::
  experimentalMassToCharge (const experimentalMassToCharge_type& x)
  {
    this->experimentalMassToCharge_.set (x);
  }

  const SpectrumIdentificationItemType::calculatedMassToCharge_optional& SpectrumIdentificationItemType::
  calculatedMassToCharge () const
  {
    return this->calculatedMassToCharge_;
  }

  SpectrumIdentificationItemType::calculatedMassToCharge_optional& SpectrumIdentificationItemType::
  calculatedMassToCharge ()
  {
    return this->calculatedMassToCharge_;
  }

  void SpectrumIdentificationItemType::
  calculatedMassToCharge (const calculatedMassToCharge_type& x)
  {
    this->calculatedMassToCharge_.set (x);
  }

  void SpectrumIdentificationItemType::
  calculatedMassToCharge (const calculatedMassToCharge_optional& x)
  {
    this->calculatedMassToCharge_ = x;
  }

  const SpectrumIdentificationItemType::calculatedPI_optional& SpectrumIdentificationItemType::
  calculatedPI () const
  {
    return this->calculatedPI_;
  }

  SpectrumIdentificationItemType::calculatedPI_optional& SpectrumIdentificationItemType::
  calculatedPI ()
  {
    return this->calculatedPI_;
  }

  void SpectrumIdentificationItemType::
  calculatedPI (const calculatedPI_type& x)
  {
    this->calculatedPI_.set (x);
  }

  void SpectrumIdentificationItemType::
  calculatedPI (const calculatedPI_optional& x)
  {
    this->calculatedPI_ = x;
  }

  const SpectrumIdentificationItemType::peptide_ref_optional& SpectrumIdentificationItemType::
  peptide_ref () const
  {
    return this->peptide_ref_;
  }

  SpectrumIdentificationItemType::peptide_ref_optional& SpectrumIdentificationItemType::
  peptide_ref ()
  {
    return this->peptide_ref_;
  }

  void SpectrumIdentificationItemType::
  peptide_ref (const peptide_ref_type& x)
  {
    this->peptide_ref_.set (x);
  }

  void SpectrumIdentificationItemType::
  peptide_ref (const peptide_ref_optional& x)
  {
    this->peptide_ref_ = x;
  }

  void SpectrumIdentificationItemType::
  peptide_ref (::std::unique_ptr< peptide_ref_type > x)
  {
    this->peptide_ref_.set (std::move (x));
  }

  const SpectrumIdentificationItemType::rank_type& SpectrumIdentificationItemType::
  rank () const
  {
    return this->rank_.get ();
  }

  SpectrumIdentificationItemType::rank_type& SpectrumIdentificationItemType::
  rank ()
  {
    return this->rank_.get ();
  }

  void SpectrumIdentificationItemType::
  rank (const rank_type& x)
  {
    this->rank_.set (x);
  }

  const SpectrumIdentificationItemType::passThreshold_type& SpectrumIdentificationItemType::
  passThreshold () const
  {
    return this->passThreshold_.get ();
  }

  SpectrumIdentificationItemType::passThreshold_type& SpectrumIdentificationItemType::
  passThreshold ()
  {
    return this->passThreshold_.get ();
  }

  void SpectrumIdentificationItemType::
  passThreshold (const passThreshold_type& x)
  {
    this->passThreshold_.set (x);
  }

  const SpectrumIdentificationItemType::massTable_ref_optional& SpectrumIdentificationItemType::
  massTable_ref () const
  {
    return this->massTable_ref_;
  }

  SpectrumIdentificationItemType::massTable_ref_optional& SpectrumIdentificationItemType::
  massTable_ref ()
  {
    return this->massTable_ref_;
  }

  void SpectrumIdentificationItemType::
  massTable_ref (const massTable_ref_type& x)
  {
    this->massTable_ref_.set (x);
  }

  void SpectrumIdentificationItemType::
  massTable_ref (const massTable_ref_optional& x)
  {
    this->massTable_ref_ = x;
  }

  void SpectrumIdentificationItemType::
  massTable_ref (::std::unique_ptr< massTable_ref_type > x)
  {
    this->massTable_ref_.set (std::move (x));
  }

  const SpectrumIdentificationItemType::sample_ref_optional& SpectrumIdentificationItemType::
  sample_ref () const
  {
    return this->sample_ref_;
  }

  SpectrumIdentificationItemType::sample_ref_optional& SpectrumIdentificationItemType::
  sample_ref ()
  {
    return this->sample_ref_;
  }

  void SpectrumIdentificationItemType::
  sample_ref (const sample_ref_type& x)
  {
    this->sample_ref_.set (x);
  }

  void SpectrumIdentificationItemType::
  sample_ref (const sample_ref_optional& x)
  {
    this->sample_ref_ = x;
  }

  void SpectrumIdentificationItemType::
  sample_ref (::std::unique_ptr< sample_ref_type > x)
  {
    this->sample_ref_.set (std::move (x));
  }


  // SpectrumIdentificationResultType
  // 

  const SpectrumIdentificationResultType::SpectrumIdentificationItem_sequence& SpectrumIdentificationResultType::
  SpectrumIdentificationItem () const
  {
    return this->SpectrumIdentificationItem_;
  }

  SpectrumIdentificationResultType::SpectrumIdentificationItem_sequence& SpectrumIdentificationResultType::
  SpectrumIdentificationItem ()
  {
    return this->SpectrumIdentificationItem_;
  }

  void SpectrumIdentificationResultType::
  SpectrumIdentificationItem (const SpectrumIdentificationItem_sequence& s)
  {
    this->SpectrumIdentificationItem_ = s;
  }

  const SpectrumIdentificationResultType::cvParam_sequence& SpectrumIdentificationResultType::
  cvParam () const
  {
    return this->cvParam_;
  }

  SpectrumIdentificationResultType::cvParam_sequence& SpectrumIdentificationResultType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void SpectrumIdentificationResultType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }

  const SpectrumIdentificationResultType::userParam_sequence& SpectrumIdentificationResultType::
  userParam () const
  {
    return this->userParam_;
  }

  SpectrumIdentificationResultType::userParam_sequence& SpectrumIdentificationResultType::
  userParam ()
  {
    return this->userParam_;
  }

  void SpectrumIdentificationResultType::
  userParam (const userParam_sequence& s)
  {
    this->userParam_ = s;
  }

  const SpectrumIdentificationResultType::spectrumID_type& SpectrumIdentificationResultType::
  spectrumID () const
  {
    return this->spectrumID_.get ();
  }

  SpectrumIdentificationResultType::spectrumID_type& SpectrumIdentificationResultType::
  spectrumID ()
  {
    return this->spectrumID_.get ();
  }

  void SpectrumIdentificationResultType::
  spectrumID (const spectrumID_type& x)
  {
    this->spectrumID_.set (x);
  }

  void SpectrumIdentificationResultType::
  spectrumID (::std::unique_ptr< spectrumID_type > x)
  {
    this->spectrumID_.set (std::move (x));
  }

  const SpectrumIdentificationResultType::spectraData_ref_type& SpectrumIdentificationResultType::
  spectraData_ref () const
  {
    return this->spectraData_ref_.get ();
  }

  SpectrumIdentificationResultType::spectraData_ref_type& SpectrumIdentificationResultType::
  spectraData_ref ()
  {
    return this->spectraData_ref_.get ();
  }

  void SpectrumIdentificationResultType::
  spectraData_ref (const spectraData_ref_type& x)
  {
    this->spectraData_ref_.set (x);
  }

  void SpectrumIdentificationResultType::
  spectraData_ref (::std::unique_ptr< spectraData_ref_type > x)
  {
    this->spectraData_ref_.set (std::move (x));
  }


  // InputSpectrumIdentificationsType
  // 

  const InputSpectrumIdentificationsType::spectrumIdentificationList_ref_type& InputSpectrumIdentificationsType::
  spectrumIdentificationList_ref () const
  {
    return this->spectrumIdentificationList_ref_.get ();
  }

  InputSpectrumIdentificationsType::spectrumIdentificationList_ref_type& InputSpectrumIdentificationsType::
  spectrumIdentificationList_ref ()
  {
    return this->spectrumIdentificationList_ref_.get ();
  }

  void InputSpectrumIdentificationsType::
  spectrumIdentificationList_ref (const spectrumIdentificationList_ref_type& x)
  {
    this->spectrumIdentificationList_ref_.set (x);
  }

  void InputSpectrumIdentificationsType::
  spectrumIdentificationList_ref (::std::unique_ptr< spectrumIdentificationList_ref_type > x)
  {
    this->spectrumIdentificationList_ref_.set (std::move (x));
  }


  // ProteinDetectionType
  // 

  const ProteinDetectionType::InputSpectrumIdentifications_sequence& ProteinDetectionType::
  InputSpectrumIdentifications () const
  {
    return this->InputSpectrumIdentifications_;
  }

  ProteinDetectionType::InputSpectrumIdentifications_sequence& ProteinDetectionType::
  InputSpectrumIdentifications ()
  {
    return this->InputSpectrumIdentifications_;
  }

  void ProteinDetectionType::
  InputSpectrumIdentifications (const InputSpectrumIdentifications_sequence& s)
  {
    this->InputSpectrumIdentifications_ = s;
  }

  const ProteinDetectionType::proteinDetectionList_ref_type& ProteinDetectionType::
  proteinDetectionList_ref () const
  {
    return this->proteinDetectionList_ref_.get ();
  }

  ProteinDetectionType::proteinDetectionList_ref_type& ProteinDetectionType::
  proteinDetectionList_ref ()
  {
    return this->proteinDetectionList_ref_.get ();
  }

  void ProteinDetectionType::
  proteinDetectionList_ref (const proteinDetectionList_ref_type& x)
  {
    this->proteinDetectionList_ref_.set (x);
  }

  void ProteinDetectionType::
  proteinDetectionList_ref (::std::unique_ptr< proteinDetectionList_ref_type > x)
  {
    this->proteinDetectionList_ref_.set (std::move (x));
  }

  const ProteinDetectionType::proteinDetectionProtocol_ref_type& ProteinDetectionType::
  proteinDetectionProtocol_ref () const
  {
    return this->proteinDetectionProtocol_ref_.get ();
  }

  ProteinDetectionType::proteinDetectionProtocol_ref_type& ProteinDetectionType::
  proteinDetectionProtocol_ref ()
  {
    return this->proteinDetectionProtocol_ref_.get ();
  }

  void ProteinDetectionType::
  proteinDetectionProtocol_ref (const proteinDetectionProtocol_ref_type& x)
  {
    this->proteinDetectionProtocol_ref_.set (x);
  }

  void ProteinDetectionType::
  proteinDetectionProtocol_ref (::std::unique_ptr< proteinDetectionProtocol_ref_type > x)
  {
    this->proteinDetectionProtocol_ref_.set (std::move (x));
  }


  // ProteinDetectionProtocolType
  // 

  const ProteinDetectionProtocolType::AnalysisParams_optional& ProteinDetectionProtocolType::
  AnalysisParams () const
  {
    return this->AnalysisParams_;
  }

  ProteinDetectionProtocolType::AnalysisParams_optional& ProteinDetectionProtocolType::
  AnalysisParams ()
  {
    return this->AnalysisParams_;
  }

  void ProteinDetectionProtocolType::
  AnalysisParams (const AnalysisParams_type& x)
  {
    this->AnalysisParams_.set (x);
  }

  void ProteinDetectionProtocolType::
  AnalysisParams (const AnalysisParams_optional& x)
  {
    this->AnalysisParams_ = x;
  }

  void ProteinDetectionProtocolType::
  AnalysisParams (::std::unique_ptr< AnalysisParams_type > x)
  {
    this->AnalysisParams_.set (std::move (x));
  }

  const ProteinDetectionProtocolType::Threshold_type& ProteinDetectionProtocolType::
  Threshold () const
  {
    return this->Threshold_.get ();
  }

  ProteinDetectionProtocolType::Threshold_type& ProteinDetectionProtocolType::
  Threshold ()
  {
    return this->Threshold_.get ();
  }

  void ProteinDetectionProtocolType::
  Threshold (const Threshold_type& x)
  {
    this->Threshold_.set (x);
  }

  void ProteinDetectionProtocolType::
  Threshold (::std::unique_ptr< Threshold_type > x)
  {
    this->Threshold_.set (std::move (x));
  }

  const ProteinDetectionProtocolType::analysisSoftware_ref_type& ProteinDetectionProtocolType::
  analysisSoftware_ref () const
  {
    return this->analysisSoftware_ref_.get ();
  }

  ProteinDetectionProtocolType::analysisSoftware_ref_type& ProteinDetectionProtocolType::
  analysisSoftware_ref ()
  {
    return this->analysisSoftware_ref_.get ();
  }

  void ProteinDetectionProtocolType::
  analysisSoftware_ref (const analysisSoftware_ref_type& x)
  {
    this->analysisSoftware_ref_.set (x);
  }

  void ProteinDetectionProtocolType::
  analysisSoftware_ref (::std::unique_ptr< analysisSoftware_ref_type > x)
  {
    this->analysisSoftware_ref_.set (std::move (x));
  }


  // ProteinDetectionListType
  // 

  const ProteinDetectionListType::ProteinAmbiguityGroup_sequence& ProteinDetectionListType::
  ProteinAmbiguityGroup () const
  {
    return this->ProteinAmbiguityGroup_;
  }

  ProteinDetectionListType::ProteinAmbiguityGroup_sequence& ProteinDetectionListType::
  ProteinAmbiguityGroup ()
  {
    return this->ProteinAmbiguityGroup_;
  }

  void ProteinDetectionListType::
  ProteinAmbiguityGroup (const ProteinAmbiguityGroup_sequence& s)
  {
    this->ProteinAmbiguityGroup_ = s;
  }

  const ProteinDetectionListType::cvParam_sequence& ProteinDetectionListType::
  cvParam () const
  {
    return this->cvParam_;
  }

  ProteinDetectionListType::cvParam_sequence& ProteinDetectionListType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void ProteinDetectionListType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }

  const ProteinDetectionListType::userParam_sequence& ProteinDetectionListType::
  userParam () const
  {
    return this->userParam_;
  }

  ProteinDetectionListType::userParam_sequence& ProteinDetectionListType::
  userParam ()
  {
    return this->userParam_;
  }

  void ProteinDetectionListType::
  userParam (const userParam_sequence& s)
  {
    this->userParam_ = s;
  }


  // SpectrumIdentificationItemRefType
  // 

  const SpectrumIdentificationItemRefType::spectrumIdentificationItem_ref_type& SpectrumIdentificationItemRefType::
  spectrumIdentificationItem_ref () const
  {
    return this->spectrumIdentificationItem_ref_.get ();
  }

  SpectrumIdentificationItemRefType::spectrumIdentificationItem_ref_type& SpectrumIdentificationItemRefType::
  spectrumIdentificationItem_ref ()
  {
    return this->spectrumIdentificationItem_ref_.get ();
  }

  void SpectrumIdentificationItemRefType::
  spectrumIdentificationItem_ref (const spectrumIdentificationItem_ref_type& x)
  {
    this->spectrumIdentificationItem_ref_.set (x);
  }

  void SpectrumIdentificationItemRefType::
  spectrumIdentificationItem_ref (::std::unique_ptr< spectrumIdentificationItem_ref_type > x)
  {
    this->spectrumIdentificationItem_ref_.set (std::move (x));
  }


  // PeptideHypothesisType
  // 

  const PeptideHypothesisType::SpectrumIdentificationItemRef_sequence& PeptideHypothesisType::
  SpectrumIdentificationItemRef () const
  {
    return this->SpectrumIdentificationItemRef_;
  }

  PeptideHypothesisType::SpectrumIdentificationItemRef_sequence& PeptideHypothesisType::
  SpectrumIdentificationItemRef ()
  {
    return this->SpectrumIdentificationItemRef_;
  }

  void PeptideHypothesisType::
  SpectrumIdentificationItemRef (const SpectrumIdentificationItemRef_sequence& s)
  {
    this->SpectrumIdentificationItemRef_ = s;
  }

  const PeptideHypothesisType::peptideEvidence_ref_type& PeptideHypothesisType::
  peptideEvidence_ref () const
  {
    return this->peptideEvidence_ref_.get ();
  }

  PeptideHypothesisType::peptideEvidence_ref_type& PeptideHypothesisType::
  peptideEvidence_ref ()
  {
    return this->peptideEvidence_ref_.get ();
  }

  void PeptideHypothesisType::
  peptideEvidence_ref (const peptideEvidence_ref_type& x)
  {
    this->peptideEvidence_ref_.set (x);
  }

  void PeptideHypothesisType::
  peptideEvidence_ref (::std::unique_ptr< peptideEvidence_ref_type > x)
  {
    this->peptideEvidence_ref_.set (std::move (x));
  }


  // ProteinDetectionHypothesisType
  // 

  const ProteinDetectionHypothesisType::PeptideHypothesis_sequence& ProteinDetectionHypothesisType::
  PeptideHypothesis () const
  {
    return this->PeptideHypothesis_;
  }

  ProteinDetectionHypothesisType::PeptideHypothesis_sequence& ProteinDetectionHypothesisType::
  PeptideHypothesis ()
  {
    return this->PeptideHypothesis_;
  }

  void ProteinDetectionHypothesisType::
  PeptideHypothesis (const PeptideHypothesis_sequence& s)
  {
    this->PeptideHypothesis_ = s;
  }

  const ProteinDetectionHypothesisType::cvParam_sequence& ProteinDetectionHypothesisType::
  cvParam () const
  {
    return this->cvParam_;
  }

  ProteinDetectionHypothesisType::cvParam_sequence& ProteinDetectionHypothesisType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void ProteinDetectionHypothesisType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }

  const ProteinDetectionHypothesisType::userParam_sequence& ProteinDetectionHypothesisType::
  userParam () const
  {
    return this->userParam_;
  }

  ProteinDetectionHypothesisType::userParam_sequence& ProteinDetectionHypothesisType::
  userParam ()
  {
    return this->userParam_;
  }

  void ProteinDetectionHypothesisType::
  userParam (const userParam_sequence& s)
  {
    this->userParam_ = s;
  }

  const ProteinDetectionHypothesisType::dBSequence_ref_optional& ProteinDetectionHypothesisType::
  dBSequence_ref () const
  {
    return this->dBSequence_ref_;
  }

  ProteinDetectionHypothesisType::dBSequence_ref_optional& ProteinDetectionHypothesisType::
  dBSequence_ref ()
  {
    return this->dBSequence_ref_;
  }

  void ProteinDetectionHypothesisType::
  dBSequence_ref (const dBSequence_ref_type& x)
  {
    this->dBSequence_ref_.set (x);
  }

  void ProteinDetectionHypothesisType::
  dBSequence_ref (const dBSequence_ref_optional& x)
  {
    this->dBSequence_ref_ = x;
  }

  void ProteinDetectionHypothesisType::
  dBSequence_ref (::std::unique_ptr< dBSequence_ref_type > x)
  {
    this->dBSequence_ref_.set (std::move (x));
  }

  const ProteinDetectionHypothesisType::passThreshold_type& ProteinDetectionHypothesisType::
  passThreshold () const
  {
    return this->passThreshold_.get ();
  }

  ProteinDetectionHypothesisType::passThreshold_type& ProteinDetectionHypothesisType::
  passThreshold ()
  {
    return this->passThreshold_.get ();
  }

  void ProteinDetectionHypothesisType::
  passThreshold (const passThreshold_type& x)
  {
    this->passThreshold_.set (x);
  }


  // ProteinAmbiguityGroupType
  // 

  const ProteinAmbiguityGroupType::ProteinDetectionHypothesis_sequence& ProteinAmbiguityGroupType::
  ProteinDetectionHypothesis () const
  {
    return this->ProteinDetectionHypothesis_;
  }

  ProteinAmbiguityGroupType::ProteinDetectionHypothesis_sequence& ProteinAmbiguityGroupType::
  ProteinDetectionHypothesis ()
  {
    return this->ProteinDetectionHypothesis_;
  }

  void ProteinAmbiguityGroupType::
  ProteinDetectionHypothesis (const ProteinDetectionHypothesis_sequence& s)
  {
    this->ProteinDetectionHypothesis_ = s;
  }

  const ProteinAmbiguityGroupType::cvParam_sequence& ProteinAmbiguityGroupType::
  cvParam () const
  {
    return this->cvParam_;
  }

  ProteinAmbiguityGroupType::cvParam_sequence& ProteinAmbiguityGroupType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void ProteinAmbiguityGroupType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }

  const ProteinAmbiguityGroupType::userParam_sequence& ProteinAmbiguityGroupType::
  userParam () const
  {
    return this->userParam_;
  }

  ProteinAmbiguityGroupType::userParam_sequence& ProteinAmbiguityGroupType::
  userParam ()
  {
    return this->userParam_;
  }

  void ProteinAmbiguityGroupType::
  userParam (const userParam_sequence& s)
  {
    this->userParam_ = s;
  }


  // ModificationType
  // 

  const ModificationType::cvParam_sequence& ModificationType::
  cvParam () const
  {
    return this->cvParam_;
  }

  ModificationType::cvParam_sequence& ModificationType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void ModificationType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }

  const ModificationType::location_optional& ModificationType::
  location () const
  {
    return this->location_;
  }

  ModificationType::location_optional& ModificationType::
  location ()
  {
    return this->location_;
  }

  void ModificationType::
  location (const location_type& x)
  {
    this->location_.set (x);
  }

  void ModificationType::
  location (const location_optional& x)
  {
    this->location_ = x;
  }

  const ModificationType::residues_optional& ModificationType::
  residues () const
  {
    return this->residues_;
  }

  ModificationType::residues_optional& ModificationType::
  residues ()
  {
    return this->residues_;
  }

  void ModificationType::
  residues (const residues_type& x)
  {
    this->residues_.set (x);
  }

  void ModificationType::
  residues (const residues_optional& x)
  {
    this->residues_ = x;
  }

  void ModificationType::
  residues (::std::unique_ptr< residues_type > x)
  {
    this->residues_.set (std::move (x));
  }

  const ModificationType::avgMassDelta_optional& ModificationType::
  avgMassDelta () const
  {
    return this->avgMassDelta_;
  }

  ModificationType::avgMassDelta_optional& ModificationType::
  avgMassDelta ()
  {
    return this->avgMassDelta_;
  }

  void ModificationType::
  avgMassDelta (const avgMassDelta_type& x)
  {
    this->avgMassDelta_.set (x);
  }

  void ModificationType::
  avgMassDelta (const avgMassDelta_optional& x)
  {
    this->avgMassDelta_ = x;
  }

  const ModificationType::monoisotopicMassDelta_optional& ModificationType::
  monoisotopicMassDelta () const
  {
    return this->monoisotopicMassDelta_;
  }

  ModificationType::monoisotopicMassDelta_optional& ModificationType::
  monoisotopicMassDelta ()
  {
    return this->monoisotopicMassDelta_;
  }

  void ModificationType::
  monoisotopicMassDelta (const monoisotopicMassDelta_type& x)
  {
    this->monoisotopicMassDelta_.set (x);
  }

  void ModificationType::
  monoisotopicMassDelta (const monoisotopicMassDelta_optional& x)
  {
    this->monoisotopicMassDelta_ = x;
  }


  // PeptideType
  // 

  const PeptideType::PeptideSequence_type& PeptideType::
  PeptideSequence () const
  {
    return this->PeptideSequence_.get ();
  }

  PeptideType::PeptideSequence_type& PeptideType::
  PeptideSequence ()
  {
    return this->PeptideSequence_.get ();
  }

  void PeptideType::
  PeptideSequence (const PeptideSequence_type& x)
  {
    this->PeptideSequence_.set (x);
  }

  void PeptideType::
  PeptideSequence (::std::unique_ptr< PeptideSequence_type > x)
  {
    this->PeptideSequence_.set (std::move (x));
  }

  const PeptideType::Modification_sequence& PeptideType::
  Modification () const
  {
    return this->Modification_;
  }

  PeptideType::Modification_sequence& PeptideType::
  Modification ()
  {
    return this->Modification_;
  }

  void PeptideType::
  Modification (const Modification_sequence& s)
  {
    this->Modification_ = s;
  }

  const PeptideType::SubstitutionModification_sequence& PeptideType::
  SubstitutionModification () const
  {
    return this->SubstitutionModification_;
  }

  PeptideType::SubstitutionModification_sequence& PeptideType::
  SubstitutionModification ()
  {
    return this->SubstitutionModification_;
  }

  void PeptideType::
  SubstitutionModification (const SubstitutionModification_sequence& s)
  {
    this->SubstitutionModification_ = s;
  }

  const PeptideType::cvParam_sequence& PeptideType::
  cvParam () const
  {
    return this->cvParam_;
  }

  PeptideType::cvParam_sequence& PeptideType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void PeptideType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }

  const PeptideType::userParam_sequence& PeptideType::
  userParam () const
  {
    return this->userParam_;
  }

  PeptideType::userParam_sequence& PeptideType::
  userParam ()
  {
    return this->userParam_;
  }

  void PeptideType::
  userParam (const userParam_sequence& s)
  {
    this->userParam_ = s;
  }


  // SubstitutionModificationType
  // 

  const SubstitutionModificationType::originalResidue_type& SubstitutionModificationType::
  originalResidue () const
  {
    return this->originalResidue_.get ();
  }

  SubstitutionModificationType::originalResidue_type& SubstitutionModificationType::
  originalResidue ()
  {
    return this->originalResidue_.get ();
  }

  void SubstitutionModificationType::
  originalResidue (const originalResidue_type& x)
  {
    this->originalResidue_.set (x);
  }

  void SubstitutionModificationType::
  originalResidue (::std::unique_ptr< originalResidue_type > x)
  {
    this->originalResidue_.set (std::move (x));
  }

  const SubstitutionModificationType::replacementResidue_type& SubstitutionModificationType::
  replacementResidue () const
  {
    return this->replacementResidue_.get ();
  }

  SubstitutionModificationType::replacementResidue_type& SubstitutionModificationType::
  replacementResidue ()
  {
    return this->replacementResidue_.get ();
  }

  void SubstitutionModificationType::
  replacementResidue (const replacementResidue_type& x)
  {
    this->replacementResidue_.set (x);
  }

  void SubstitutionModificationType::
  replacementResidue (::std::unique_ptr< replacementResidue_type > x)
  {
    this->replacementResidue_.set (std::move (x));
  }

  const SubstitutionModificationType::location_optional& SubstitutionModificationType::
  location () const
  {
    return this->location_;
  }

  SubstitutionModificationType::location_optional& SubstitutionModificationType::
  location ()
  {
    return this->location_;
  }

  void SubstitutionModificationType::
  location (const location_type& x)
  {
    this->location_.set (x);
  }

  void SubstitutionModificationType::
  location (const location_optional& x)
  {
    this->location_ = x;
  }

  const SubstitutionModificationType::avgMassDelta_optional& SubstitutionModificationType::
  avgMassDelta () const
  {
    return this->avgMassDelta_;
  }

  SubstitutionModificationType::avgMassDelta_optional& SubstitutionModificationType::
  avgMassDelta ()
  {
    return this->avgMassDelta_;
  }

  void SubstitutionModificationType::
  avgMassDelta (const avgMassDelta_type& x)
  {
    this->avgMassDelta_.set (x);
  }

  void SubstitutionModificationType::
  avgMassDelta (const avgMassDelta_optional& x)
  {
    this->avgMassDelta_ = x;
  }

  const SubstitutionModificationType::monoisotopicMassDelta_optional& SubstitutionModificationType::
  monoisotopicMassDelta () const
  {
    return this->monoisotopicMassDelta_;
  }

  SubstitutionModificationType::monoisotopicMassDelta_optional& SubstitutionModificationType::
  monoisotopicMassDelta ()
  {
    return this->monoisotopicMassDelta_;
  }

  void SubstitutionModificationType::
  monoisotopicMassDelta (const monoisotopicMassDelta_type& x)
  {
    this->monoisotopicMassDelta_.set (x);
  }

  void SubstitutionModificationType::
  monoisotopicMassDelta (const monoisotopicMassDelta_optional& x)
  {
    this->monoisotopicMassDelta_ = x;
  }


  // SpectraDataType
  // 

  const SpectraDataType::SpectrumIDFormat_type& SpectraDataType::
  SpectrumIDFormat () const
  {
    return this->SpectrumIDFormat_.get ();
  }

  SpectraDataType::SpectrumIDFormat_type& SpectraDataType::
  SpectrumIDFormat ()
  {
    return this->SpectrumIDFormat_.get ();
  }

  void SpectraDataType::
  SpectrumIDFormat (const SpectrumIDFormat_type& x)
  {
    this->SpectrumIDFormat_.set (x);
  }

  void SpectraDataType::
  SpectrumIDFormat (::std::unique_ptr< SpectrumIDFormat_type > x)
  {
    this->SpectrumIDFormat_.set (std::move (x));
  }


  // AnalysisSoftwareType
  // 

  const AnalysisSoftwareType::ContactRole_optional& AnalysisSoftwareType::
  ContactRole () const
  {
    return this->ContactRole_;
  }

  AnalysisSoftwareType::ContactRole_optional& AnalysisSoftwareType::
  ContactRole ()
  {
    return this->ContactRole_;
  }

  void AnalysisSoftwareType::
  ContactRole (const ContactRole_type& x)
  {
    this->ContactRole_.set (x);
  }

  void AnalysisSoftwareType::
  ContactRole (const ContactRole_optional& x)
  {
    this->ContactRole_ = x;
  }

  void AnalysisSoftwareType::
  ContactRole (::std::unique_ptr< ContactRole_type > x)
  {
    this->ContactRole_.set (std::move (x));
  }

  const AnalysisSoftwareType::SoftwareName_type& AnalysisSoftwareType::
  SoftwareName () const
  {
    return this->SoftwareName_.get ();
  }

  AnalysisSoftwareType::SoftwareName_type& AnalysisSoftwareType::
  SoftwareName ()
  {
    return this->SoftwareName_.get ();
  }

  void AnalysisSoftwareType::
  SoftwareName (const SoftwareName_type& x)
  {
    this->SoftwareName_.set (x);
  }

  void AnalysisSoftwareType::
  SoftwareName (::std::unique_ptr< SoftwareName_type > x)
  {
    this->SoftwareName_.set (std::move (x));
  }

  const AnalysisSoftwareType::Customizations_optional& AnalysisSoftwareType::
  Customizations () const
  {
    return this->Customizations_;
  }

  AnalysisSoftwareType::Customizations_optional& AnalysisSoftwareType::
  Customizations ()
  {
    return this->Customizations_;
  }

  void AnalysisSoftwareType::
  Customizations (const Customizations_type& x)
  {
    this->Customizations_.set (x);
  }

  void AnalysisSoftwareType::
  Customizations (const Customizations_optional& x)
  {
    this->Customizations_ = x;
  }

  void AnalysisSoftwareType::
  Customizations (::std::unique_ptr< Customizations_type > x)
  {
    this->Customizations_.set (std::move (x));
  }

  const AnalysisSoftwareType::version_optional& AnalysisSoftwareType::
  version () const
  {
    return this->version_;
  }

  AnalysisSoftwareType::version_optional& AnalysisSoftwareType::
  version ()
  {
    return this->version_;
  }

  void AnalysisSoftwareType::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void AnalysisSoftwareType::
  version (const version_optional& x)
  {
    this->version_ = x;
  }

  void AnalysisSoftwareType::
  version (::std::unique_ptr< version_type > x)
  {
    this->version_.set (std::move (x));
  }

  const AnalysisSoftwareType::uri_optional& AnalysisSoftwareType::
  uri () const
  {
    return this->uri_;
  }

  AnalysisSoftwareType::uri_optional& AnalysisSoftwareType::
  uri ()
  {
    return this->uri_;
  }

  void AnalysisSoftwareType::
  uri (const uri_type& x)
  {
    this->uri_.set (x);
  }

  void AnalysisSoftwareType::
  uri (const uri_optional& x)
  {
    this->uri_ = x;
  }

  void AnalysisSoftwareType::
  uri (::std::unique_ptr< uri_type > x)
  {
    this->uri_.set (std::move (x));
  }


  // EnzymeType
  // 

  const EnzymeType::SiteRegexp_optional& EnzymeType::
  SiteRegexp () const
  {
    return this->SiteRegexp_;
  }

  EnzymeType::SiteRegexp_optional& EnzymeType::
  SiteRegexp ()
  {
    return this->SiteRegexp_;
  }

  void EnzymeType::
  SiteRegexp (const SiteRegexp_type& x)
  {
    this->SiteRegexp_.set (x);
  }

  void EnzymeType::
  SiteRegexp (const SiteRegexp_optional& x)
  {
    this->SiteRegexp_ = x;
  }

  void EnzymeType::
  SiteRegexp (::std::unique_ptr< SiteRegexp_type > x)
  {
    this->SiteRegexp_.set (std::move (x));
  }

  const EnzymeType::EnzymeName_optional& EnzymeType::
  EnzymeName () const
  {
    return this->EnzymeName_;
  }

  EnzymeType::EnzymeName_optional& EnzymeType::
  EnzymeName ()
  {
    return this->EnzymeName_;
  }

  void EnzymeType::
  EnzymeName (const EnzymeName_type& x)
  {
    this->EnzymeName_.set (x);
  }

  void EnzymeType::
  EnzymeName (const EnzymeName_optional& x)
  {
    this->EnzymeName_ = x;
  }

  void EnzymeType::
  EnzymeName (::std::unique_ptr< EnzymeName_type > x)
  {
    this->EnzymeName_.set (std::move (x));
  }

  const EnzymeType::nTermGain_optional& EnzymeType::
  nTermGain () const
  {
    return this->nTermGain_;
  }

  EnzymeType::nTermGain_optional& EnzymeType::
  nTermGain ()
  {
    return this->nTermGain_;
  }

  void EnzymeType::
  nTermGain (const nTermGain_type& x)
  {
    this->nTermGain_.set (x);
  }

  void EnzymeType::
  nTermGain (const nTermGain_optional& x)
  {
    this->nTermGain_ = x;
  }

  void EnzymeType::
  nTermGain (::std::unique_ptr< nTermGain_type > x)
  {
    this->nTermGain_.set (std::move (x));
  }

  const EnzymeType::cTermGain_optional& EnzymeType::
  cTermGain () const
  {
    return this->cTermGain_;
  }

  EnzymeType::cTermGain_optional& EnzymeType::
  cTermGain ()
  {
    return this->cTermGain_;
  }

  void EnzymeType::
  cTermGain (const cTermGain_type& x)
  {
    this->cTermGain_.set (x);
  }

  void EnzymeType::
  cTermGain (const cTermGain_optional& x)
  {
    this->cTermGain_ = x;
  }

  void EnzymeType::
  cTermGain (::std::unique_ptr< cTermGain_type > x)
  {
    this->cTermGain_.set (std::move (x));
  }

  const EnzymeType::semiSpecific_optional& EnzymeType::
  semiSpecific () const
  {
    return this->semiSpecific_;
  }

  EnzymeType::semiSpecific_optional& EnzymeType::
  semiSpecific ()
  {
    return this->semiSpecific_;
  }

  void EnzymeType::
  semiSpecific (const semiSpecific_type& x)
  {
    this->semiSpecific_.set (x);
  }

  void EnzymeType::
  semiSpecific (const semiSpecific_optional& x)
  {
    this->semiSpecific_ = x;
  }

  const EnzymeType::missedCleavages_optional& EnzymeType::
  missedCleavages () const
  {
    return this->missedCleavages_;
  }

  EnzymeType::missedCleavages_optional& EnzymeType::
  missedCleavages ()
  {
    return this->missedCleavages_;
  }

  void EnzymeType::
  missedCleavages (const missedCleavages_type& x)
  {
    this->missedCleavages_.set (x);
  }

  void EnzymeType::
  missedCleavages (const missedCleavages_optional& x)
  {
    this->missedCleavages_ = x;
  }

  const EnzymeType::minDistance_optional& EnzymeType::
  minDistance () const
  {
    return this->minDistance_;
  }

  EnzymeType::minDistance_optional& EnzymeType::
  minDistance ()
  {
    return this->minDistance_;
  }

  void EnzymeType::
  minDistance (const minDistance_type& x)
  {
    this->minDistance_.set (x);
  }

  void EnzymeType::
  minDistance (const minDistance_optional& x)
  {
    this->minDistance_ = x;
  }

  void EnzymeType::
  minDistance (::std::unique_ptr< minDistance_type > x)
  {
    this->minDistance_.set (std::move (x));
  }


  // EnzymesType
  // 

  const EnzymesType::Enzyme_sequence& EnzymesType::
  Enzyme () const
  {
    return this->Enzyme_;
  }

  EnzymesType::Enzyme_sequence& EnzymesType::
  Enzyme ()
  {
    return this->Enzyme_;
  }

  void EnzymesType::
  Enzyme (const Enzyme_sequence& s)
  {
    this->Enzyme_ = s;
  }

  const EnzymesType::independent_optional& EnzymesType::
  independent () const
  {
    return this->independent_;
  }

  EnzymesType::independent_optional& EnzymesType::
  independent ()
  {
    return this->independent_;
  }

  void EnzymesType::
  independent (const independent_type& x)
  {
    this->independent_.set (x);
  }

  void EnzymesType::
  independent (const independent_optional& x)
  {
    this->independent_ = x;
  }


  // ResidueType
  // 

  const ResidueType::code_type& ResidueType::
  code () const
  {
    return this->code_.get ();
  }

  ResidueType::code_type& ResidueType::
  code ()
  {
    return this->code_.get ();
  }

  void ResidueType::
  code (const code_type& x)
  {
    this->code_.set (x);
  }

  void ResidueType::
  code (::std::unique_ptr< code_type > x)
  {
    this->code_.set (std::move (x));
  }

  const ResidueType::mass_type& ResidueType::
  mass () const
  {
    return this->mass_.get ();
  }

  ResidueType::mass_type& ResidueType::
  mass ()
  {
    return this->mass_.get ();
  }

  void ResidueType::
  mass (const mass_type& x)
  {
    this->mass_.set (x);
  }


  // AmbiguousResidueType
  // 

  const AmbiguousResidueType::cvParam_sequence& AmbiguousResidueType::
  cvParam () const
  {
    return this->cvParam_;
  }

  AmbiguousResidueType::cvParam_sequence& AmbiguousResidueType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void AmbiguousResidueType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }

  const AmbiguousResidueType::userParam_sequence& AmbiguousResidueType::
  userParam () const
  {
    return this->userParam_;
  }

  AmbiguousResidueType::userParam_sequence& AmbiguousResidueType::
  userParam ()
  {
    return this->userParam_;
  }

  void AmbiguousResidueType::
  userParam (const userParam_sequence& s)
  {
    this->userParam_ = s;
  }

  const AmbiguousResidueType::code_type& AmbiguousResidueType::
  code () const
  {
    return this->code_.get ();
  }

  AmbiguousResidueType::code_type& AmbiguousResidueType::
  code ()
  {
    return this->code_.get ();
  }

  void AmbiguousResidueType::
  code (const code_type& x)
  {
    this->code_.set (x);
  }

  void AmbiguousResidueType::
  code (::std::unique_ptr< code_type > x)
  {
    this->code_.set (std::move (x));
  }


  // MassTableType
  // 

  const MassTableType::Residue_sequence& MassTableType::
  Residue () const
  {
    return this->Residue_;
  }

  MassTableType::Residue_sequence& MassTableType::
  Residue ()
  {
    return this->Residue_;
  }

  void MassTableType::
  Residue (const Residue_sequence& s)
  {
    this->Residue_ = s;
  }

  const MassTableType::AmbiguousResidue_sequence& MassTableType::
  AmbiguousResidue () const
  {
    return this->AmbiguousResidue_;
  }

  MassTableType::AmbiguousResidue_sequence& MassTableType::
  AmbiguousResidue ()
  {
    return this->AmbiguousResidue_;
  }

  void MassTableType::
  AmbiguousResidue (const AmbiguousResidue_sequence& s)
  {
    this->AmbiguousResidue_ = s;
  }

  const MassTableType::cvParam_sequence& MassTableType::
  cvParam () const
  {
    return this->cvParam_;
  }

  MassTableType::cvParam_sequence& MassTableType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void MassTableType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }

  const MassTableType::userParam_sequence& MassTableType::
  userParam () const
  {
    return this->userParam_;
  }

  MassTableType::userParam_sequence& MassTableType::
  userParam ()
  {
    return this->userParam_;
  }

  void MassTableType::
  userParam (const userParam_sequence& s)
  {
    this->userParam_ = s;
  }

  const MassTableType::msLevel_type& MassTableType::
  msLevel () const
  {
    return this->msLevel_.get ();
  }

  MassTableType::msLevel_type& MassTableType::
  msLevel ()
  {
    return this->msLevel_.get ();
  }

  void MassTableType::
  msLevel (const msLevel_type& x)
  {
    this->msLevel_.set (x);
  }

  void MassTableType::
  msLevel (::std::unique_ptr< msLevel_type > x)
  {
    this->msLevel_.set (std::move (x));
  }


  // PeptideEvidenceType
  // 

  const PeptideEvidenceType::cvParam_sequence& PeptideEvidenceType::
  cvParam () const
  {
    return this->cvParam_;
  }

  PeptideEvidenceType::cvParam_sequence& PeptideEvidenceType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void PeptideEvidenceType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }

  const PeptideEvidenceType::userParam_sequence& PeptideEvidenceType::
  userParam () const
  {
    return this->userParam_;
  }

  PeptideEvidenceType::userParam_sequence& PeptideEvidenceType::
  userParam ()
  {
    return this->userParam_;
  }

  void PeptideEvidenceType::
  userParam (const userParam_sequence& s)
  {
    this->userParam_ = s;
  }

  const PeptideEvidenceType::dBSequence_ref_type& PeptideEvidenceType::
  dBSequence_ref () const
  {
    return this->dBSequence_ref_.get ();
  }

  PeptideEvidenceType::dBSequence_ref_type& PeptideEvidenceType::
  dBSequence_ref ()
  {
    return this->dBSequence_ref_.get ();
  }

  void PeptideEvidenceType::
  dBSequence_ref (const dBSequence_ref_type& x)
  {
    this->dBSequence_ref_.set (x);
  }

  void PeptideEvidenceType::
  dBSequence_ref (::std::unique_ptr< dBSequence_ref_type > x)
  {
    this->dBSequence_ref_.set (std::move (x));
  }

  const PeptideEvidenceType::peptide_ref_type& PeptideEvidenceType::
  peptide_ref () const
  {
    return this->peptide_ref_.get ();
  }

  PeptideEvidenceType::peptide_ref_type& PeptideEvidenceType::
  peptide_ref ()
  {
    return this->peptide_ref_.get ();
  }

  void PeptideEvidenceType::
  peptide_ref (const peptide_ref_type& x)
  {
    this->peptide_ref_.set (x);
  }

  void PeptideEvidenceType::
  peptide_ref (::std::unique_ptr< peptide_ref_type > x)
  {
    this->peptide_ref_.set (std::move (x));
  }

  const PeptideEvidenceType::start_optional& PeptideEvidenceType::
  start () const
  {
    return this->start_;
  }

  PeptideEvidenceType::start_optional& PeptideEvidenceType::
  start ()
  {
    return this->start_;
  }

  void PeptideEvidenceType::
  start (const start_type& x)
  {
    this->start_.set (x);
  }

  void PeptideEvidenceType::
  start (const start_optional& x)
  {
    this->start_ = x;
  }

  const PeptideEvidenceType::end_optional& PeptideEvidenceType::
  end () const
  {
    return this->end_;
  }

  PeptideEvidenceType::end_optional& PeptideEvidenceType::
  end ()
  {
    return this->end_;
  }

  void PeptideEvidenceType::
  end (const end_type& x)
  {
    this->end_.set (x);
  }

  void PeptideEvidenceType::
  end (const end_optional& x)
  {
    this->end_ = x;
  }

  const PeptideEvidenceType::pre_optional& PeptideEvidenceType::
  pre () const
  {
    return this->pre_;
  }

  PeptideEvidenceType::pre_optional& PeptideEvidenceType::
  pre ()
  {
    return this->pre_;
  }

  void PeptideEvidenceType::
  pre (const pre_type& x)
  {
    this->pre_.set (x);
  }

  void PeptideEvidenceType::
  pre (const pre_optional& x)
  {
    this->pre_ = x;
  }

  void PeptideEvidenceType::
  pre (::std::unique_ptr< pre_type > x)
  {
    this->pre_.set (std::move (x));
  }

  const PeptideEvidenceType::post_optional& PeptideEvidenceType::
  post () const
  {
    return this->post_;
  }

  PeptideEvidenceType::post_optional& PeptideEvidenceType::
  post ()
  {
    return this->post_;
  }

  void PeptideEvidenceType::
  post (const post_type& x)
  {
    this->post_.set (x);
  }

  void PeptideEvidenceType::
  post (const post_optional& x)
  {
    this->post_ = x;
  }

  void PeptideEvidenceType::
  post (::std::unique_ptr< post_type > x)
  {
    this->post_.set (std::move (x));
  }

  const PeptideEvidenceType::translationTable_ref_optional& PeptideEvidenceType::
  translationTable_ref () const
  {
    return this->translationTable_ref_;
  }

  PeptideEvidenceType::translationTable_ref_optional& PeptideEvidenceType::
  translationTable_ref ()
  {
    return this->translationTable_ref_;
  }

  void PeptideEvidenceType::
  translationTable_ref (const translationTable_ref_type& x)
  {
    this->translationTable_ref_.set (x);
  }

  void PeptideEvidenceType::
  translationTable_ref (const translationTable_ref_optional& x)
  {
    this->translationTable_ref_ = x;
  }

  void PeptideEvidenceType::
  translationTable_ref (::std::unique_ptr< translationTable_ref_type > x)
  {
    this->translationTable_ref_.set (std::move (x));
  }

  const PeptideEvidenceType::frame_optional& PeptideEvidenceType::
  frame () const
  {
    return this->frame_;
  }

  PeptideEvidenceType::frame_optional& PeptideEvidenceType::
  frame ()
  {
    return this->frame_;
  }

  void PeptideEvidenceType::
  frame (const frame_type& x)
  {
    this->frame_.set (x);
  }

  void PeptideEvidenceType::
  frame (const frame_optional& x)
  {
    this->frame_ = x;
  }

  void PeptideEvidenceType::
  frame (::std::unique_ptr< frame_type > x)
  {
    this->frame_.set (std::move (x));
  }

  const PeptideEvidenceType::isDecoy_type& PeptideEvidenceType::
  isDecoy () const
  {
    return this->isDecoy_.get ();
  }

  PeptideEvidenceType::isDecoy_type& PeptideEvidenceType::
  isDecoy ()
  {
    return this->isDecoy_.get ();
  }

  void PeptideEvidenceType::
  isDecoy (const isDecoy_type& x)
  {
    this->isDecoy_.set (x);
  }

  PeptideEvidenceType::isDecoy_type PeptideEvidenceType::
  isDecoy_default_value ()
  {
    return isDecoy_type (false);
  }


  // ToleranceType
  // 

  const ToleranceType::cvParam_sequence& ToleranceType::
  cvParam () const
  {
    return this->cvParam_;
  }

  ToleranceType::cvParam_sequence& ToleranceType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void ToleranceType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }


  // SpectrumIDFormatType
  // 

  const SpectrumIDFormatType::cvParam_type& SpectrumIDFormatType::
  cvParam () const
  {
    return this->cvParam_.get ();
  }

  SpectrumIDFormatType::cvParam_type& SpectrumIDFormatType::
  cvParam ()
  {
    return this->cvParam_.get ();
  }

  void SpectrumIDFormatType::
  cvParam (const cvParam_type& x)
  {
    this->cvParam_.set (x);
  }

  void SpectrumIDFormatType::
  cvParam (::std::unique_ptr< cvParam_type > x)
  {
    this->cvParam_.set (std::move (x));
  }


  // DBSequenceType
  // 

  const DBSequenceType::Seq_optional& DBSequenceType::
  Seq () const
  {
    return this->Seq_;
  }

  DBSequenceType::Seq_optional& DBSequenceType::
  Seq ()
  {
    return this->Seq_;
  }

  void DBSequenceType::
  Seq (const Seq_type& x)
  {
    this->Seq_.set (x);
  }

  void DBSequenceType::
  Seq (const Seq_optional& x)
  {
    this->Seq_ = x;
  }

  void DBSequenceType::
  Seq (::std::unique_ptr< Seq_type > x)
  {
    this->Seq_.set (std::move (x));
  }

  const DBSequenceType::cvParam_sequence& DBSequenceType::
  cvParam () const
  {
    return this->cvParam_;
  }

  DBSequenceType::cvParam_sequence& DBSequenceType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void DBSequenceType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }

  const DBSequenceType::userParam_sequence& DBSequenceType::
  userParam () const
  {
    return this->userParam_;
  }

  DBSequenceType::userParam_sequence& DBSequenceType::
  userParam ()
  {
    return this->userParam_;
  }

  void DBSequenceType::
  userParam (const userParam_sequence& s)
  {
    this->userParam_ = s;
  }

  const DBSequenceType::length_optional& DBSequenceType::
  length () const
  {
    return this->length_;
  }

  DBSequenceType::length_optional& DBSequenceType::
  length ()
  {
    return this->length_;
  }

  void DBSequenceType::
  length (const length_type& x)
  {
    this->length_.set (x);
  }

  void DBSequenceType::
  length (const length_optional& x)
  {
    this->length_ = x;
  }

  const DBSequenceType::searchDatabase_ref_type& DBSequenceType::
  searchDatabase_ref () const
  {
    return this->searchDatabase_ref_.get ();
  }

  DBSequenceType::searchDatabase_ref_type& DBSequenceType::
  searchDatabase_ref ()
  {
    return this->searchDatabase_ref_.get ();
  }

  void DBSequenceType::
  searchDatabase_ref (const searchDatabase_ref_type& x)
  {
    this->searchDatabase_ref_.set (x);
  }

  void DBSequenceType::
  searchDatabase_ref (::std::unique_ptr< searchDatabase_ref_type > x)
  {
    this->searchDatabase_ref_.set (std::move (x));
  }

  const DBSequenceType::accession_type& DBSequenceType::
  accession () const
  {
    return this->accession_.get ();
  }

  DBSequenceType::accession_type& DBSequenceType::
  accession ()
  {
    return this->accession_.get ();
  }

  void DBSequenceType::
  accession (const accession_type& x)
  {
    this->accession_.set (x);
  }

  void DBSequenceType::
  accession (::std::unique_ptr< accession_type > x)
  {
    this->accession_.set (std::move (x));
  }


  // SampleType
  // 

  const SampleType::ContactRole_sequence& SampleType::
  ContactRole () const
  {
    return this->ContactRole_;
  }

  SampleType::ContactRole_sequence& SampleType::
  ContactRole ()
  {
    return this->ContactRole_;
  }

  void SampleType::
  ContactRole (const ContactRole_sequence& s)
  {
    this->ContactRole_ = s;
  }

  const SampleType::SubSample_sequence& SampleType::
  SubSample () const
  {
    return this->SubSample_;
  }

  SampleType::SubSample_sequence& SampleType::
  SubSample ()
  {
    return this->SubSample_;
  }

  void SampleType::
  SubSample (const SubSample_sequence& s)
  {
    this->SubSample_ = s;
  }

  const SampleType::cvParam_sequence& SampleType::
  cvParam () const
  {
    return this->cvParam_;
  }

  SampleType::cvParam_sequence& SampleType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void SampleType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }

  const SampleType::userParam_sequence& SampleType::
  userParam () const
  {
    return this->userParam_;
  }

  SampleType::userParam_sequence& SampleType::
  userParam ()
  {
    return this->userParam_;
  }

  void SampleType::
  userParam (const userParam_sequence& s)
  {
    this->userParam_ = s;
  }


  // SubSampleType
  // 

  const SubSampleType::sample_ref_type& SubSampleType::
  sample_ref () const
  {
    return this->sample_ref_.get ();
  }

  SubSampleType::sample_ref_type& SubSampleType::
  sample_ref ()
  {
    return this->sample_ref_.get ();
  }

  void SubSampleType::
  sample_ref (const sample_ref_type& x)
  {
    this->sample_ref_.set (x);
  }

  void SubSampleType::
  sample_ref (::std::unique_ptr< sample_ref_type > x)
  {
    this->sample_ref_.set (std::move (x));
  }


  // listOfIntegers
  //

  listOfIntegers::
  listOfIntegers ()
  : ::xsd::cxx::tree::list< ::xml_schema::integer, char > (this)
  {
  }

  listOfIntegers::
  listOfIntegers (size_type n, const ::xml_schema::integer& x)
  : ::xsd::cxx::tree::list< ::xml_schema::integer, char > (n, x, this)
  {
  }

  listOfIntegers::
  listOfIntegers (const listOfIntegers& o,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::integer, char > (o, f, this)
  {
  }

  // listOfFloats
  //

  listOfFloats::
  listOfFloats ()
  : ::xsd::cxx::tree::list< ::xml_schema::float_, char > (this)
  {
  }

  listOfFloats::
  listOfFloats (size_type n, const ::xml_schema::float_& x)
  : ::xsd::cxx::tree::list< ::xml_schema::float_, char > (n, x, this)
  {
  }

  listOfFloats::
  listOfFloats (const listOfFloats& o,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::float_, char > (o, f, this)
  {
  }

  // listOfChars
  //

  listOfChars::
  listOfChars ()
  : ::xsd::cxx::tree::list< ::mzIdentML110::chars, char > (this)
  {
  }

  listOfChars::
  listOfChars (size_type n, const ::mzIdentML110::chars& x)
  : ::xsd::cxx::tree::list< ::mzIdentML110::chars, char > (n, x, this)
  {
  }

  listOfChars::
  listOfChars (const listOfChars& o,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::mzIdentML110::chars, char > (o, f, this)
  {
  }

  // listOfCharsOrAny
  //

  listOfCharsOrAny::
  listOfCharsOrAny ()
  : ::xml_schema::string ()
  {
  }

  listOfCharsOrAny::
  listOfCharsOrAny (const char* s)
  : ::xml_schema::string (s)
  {
  }

  listOfCharsOrAny::
  listOfCharsOrAny (const ::std::string& s)
  : ::xml_schema::string (s)
  {
  }

  listOfCharsOrAny::
  listOfCharsOrAny (const listOfCharsOrAny& o,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (o, f, c)
  {
  }

  // chars
  // 


  // sequence
  // 


  // allowed_frames
  // 

  allowed_frames::
  allowed_frames ()
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > ()
  {
  }

  allowed_frames::
  allowed_frames (::xml_schema::int_ v): ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (v)
  {
  }

  allowed_frames::
  allowed_frames (const allowed_frames& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (v, f, c)
  {
  }


  // listOfAllowedFrames
  //

  listOfAllowedFrames::
  listOfAllowedFrames ()
  : ::xsd::cxx::tree::list< ::mzIdentML110::allowed_frames, char > (this)
  {
  }

  listOfAllowedFrames::
  listOfAllowedFrames (size_type n, const ::mzIdentML110::allowed_frames& x)
  : ::xsd::cxx::tree::list< ::mzIdentML110::allowed_frames, char > (n, x, this)
  {
  }

  listOfAllowedFrames::
  listOfAllowedFrames (const listOfAllowedFrames& o,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::mzIdentML110::allowed_frames, char > (o, f, this)
  {
  }

  // versionRegex
  // 


  // FileFormatType
  // 

  const FileFormatType::cvParam_type& FileFormatType::
  cvParam () const
  {
    return this->cvParam_.get ();
  }

  FileFormatType::cvParam_type& FileFormatType::
  cvParam ()
  {
    return this->cvParam_.get ();
  }

  void FileFormatType::
  cvParam (const cvParam_type& x)
  {
    this->cvParam_.set (x);
  }

  void FileFormatType::
  cvParam (::std::unique_ptr< cvParam_type > x)
  {
    this->cvParam_.set (std::move (x));
  }


  // AbstractContactType
  // 

  const AbstractContactType::cvParam_sequence& AbstractContactType::
  cvParam () const
  {
    return this->cvParam_;
  }

  AbstractContactType::cvParam_sequence& AbstractContactType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void AbstractContactType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }

  const AbstractContactType::userParam_sequence& AbstractContactType::
  userParam () const
  {
    return this->userParam_;
  }

  AbstractContactType::userParam_sequence& AbstractContactType::
  userParam ()
  {
    return this->userParam_;
  }

  void AbstractContactType::
  userParam (const userParam_sequence& s)
  {
    this->userParam_ = s;
  }


  // PersonType
  // 

  const PersonType::Affiliation_sequence& PersonType::
  Affiliation () const
  {
    return this->Affiliation_;
  }

  PersonType::Affiliation_sequence& PersonType::
  Affiliation ()
  {
    return this->Affiliation_;
  }

  void PersonType::
  Affiliation (const Affiliation_sequence& s)
  {
    this->Affiliation_ = s;
  }

  const PersonType::lastName_optional& PersonType::
  lastName () const
  {
    return this->lastName_;
  }

  PersonType::lastName_optional& PersonType::
  lastName ()
  {
    return this->lastName_;
  }

  void PersonType::
  lastName (const lastName_type& x)
  {
    this->lastName_.set (x);
  }

  void PersonType::
  lastName (const lastName_optional& x)
  {
    this->lastName_ = x;
  }

  void PersonType::
  lastName (::std::unique_ptr< lastName_type > x)
  {
    this->lastName_.set (std::move (x));
  }

  const PersonType::firstName_optional& PersonType::
  firstName () const
  {
    return this->firstName_;
  }

  PersonType::firstName_optional& PersonType::
  firstName ()
  {
    return this->firstName_;
  }

  void PersonType::
  firstName (const firstName_type& x)
  {
    this->firstName_.set (x);
  }

  void PersonType::
  firstName (const firstName_optional& x)
  {
    this->firstName_ = x;
  }

  void PersonType::
  firstName (::std::unique_ptr< firstName_type > x)
  {
    this->firstName_.set (std::move (x));
  }

  const PersonType::midInitials_optional& PersonType::
  midInitials () const
  {
    return this->midInitials_;
  }

  PersonType::midInitials_optional& PersonType::
  midInitials ()
  {
    return this->midInitials_;
  }

  void PersonType::
  midInitials (const midInitials_type& x)
  {
    this->midInitials_.set (x);
  }

  void PersonType::
  midInitials (const midInitials_optional& x)
  {
    this->midInitials_ = x;
  }

  void PersonType::
  midInitials (::std::unique_ptr< midInitials_type > x)
  {
    this->midInitials_.set (std::move (x));
  }


  // AffiliationType
  // 

  const AffiliationType::organization_ref_type& AffiliationType::
  organization_ref () const
  {
    return this->organization_ref_.get ();
  }

  AffiliationType::organization_ref_type& AffiliationType::
  organization_ref ()
  {
    return this->organization_ref_.get ();
  }

  void AffiliationType::
  organization_ref (const organization_ref_type& x)
  {
    this->organization_ref_.set (x);
  }

  void AffiliationType::
  organization_ref (::std::unique_ptr< organization_ref_type > x)
  {
    this->organization_ref_.set (std::move (x));
  }


  // OrganizationType
  // 

  const OrganizationType::Parent_optional& OrganizationType::
  Parent () const
  {
    return this->Parent_;
  }

  OrganizationType::Parent_optional& OrganizationType::
  Parent ()
  {
    return this->Parent_;
  }

  void OrganizationType::
  Parent (const Parent_type& x)
  {
    this->Parent_.set (x);
  }

  void OrganizationType::
  Parent (const Parent_optional& x)
  {
    this->Parent_ = x;
  }

  void OrganizationType::
  Parent (::std::unique_ptr< Parent_type > x)
  {
    this->Parent_.set (std::move (x));
  }


  // ParentOrganizationType
  // 

  const ParentOrganizationType::organization_ref_type& ParentOrganizationType::
  organization_ref () const
  {
    return this->organization_ref_.get ();
  }

  ParentOrganizationType::organization_ref_type& ParentOrganizationType::
  organization_ref ()
  {
    return this->organization_ref_.get ();
  }

  void ParentOrganizationType::
  organization_ref (const organization_ref_type& x)
  {
    this->organization_ref_.set (x);
  }

  void ParentOrganizationType::
  organization_ref (::std::unique_ptr< organization_ref_type > x)
  {
    this->organization_ref_.set (std::move (x));
  }


  // ContactRoleType
  // 

  const ContactRoleType::Role_type& ContactRoleType::
  Role () const
  {
    return this->Role_.get ();
  }

  ContactRoleType::Role_type& ContactRoleType::
  Role ()
  {
    return this->Role_.get ();
  }

  void ContactRoleType::
  Role (const Role_type& x)
  {
    this->Role_.set (x);
  }

  void ContactRoleType::
  Role (::std::unique_ptr< Role_type > x)
  {
    this->Role_.set (std::move (x));
  }

  const ContactRoleType::contact_ref_type& ContactRoleType::
  contact_ref () const
  {
    return this->contact_ref_.get ();
  }

  ContactRoleType::contact_ref_type& ContactRoleType::
  contact_ref ()
  {
    return this->contact_ref_.get ();
  }

  void ContactRoleType::
  contact_ref (const contact_ref_type& x)
  {
    this->contact_ref_.set (x);
  }

  void ContactRoleType::
  contact_ref (::std::unique_ptr< contact_ref_type > x)
  {
    this->contact_ref_.set (std::move (x));
  }


  // RoleType
  // 

  const RoleType::cvParam_type& RoleType::
  cvParam () const
  {
    return this->cvParam_.get ();
  }

  RoleType::cvParam_type& RoleType::
  cvParam ()
  {
    return this->cvParam_.get ();
  }

  void RoleType::
  cvParam (const cvParam_type& x)
  {
    this->cvParam_.set (x);
  }

  void RoleType::
  cvParam (::std::unique_ptr< cvParam_type > x)
  {
    this->cvParam_.set (std::move (x));
  }


  // BibliographicReferenceType
  // 

  const BibliographicReferenceType::authors_optional& BibliographicReferenceType::
  authors () const
  {
    return this->authors_;
  }

  BibliographicReferenceType::authors_optional& BibliographicReferenceType::
  authors ()
  {
    return this->authors_;
  }

  void BibliographicReferenceType::
  authors (const authors_type& x)
  {
    this->authors_.set (x);
  }

  void BibliographicReferenceType::
  authors (const authors_optional& x)
  {
    this->authors_ = x;
  }

  void BibliographicReferenceType::
  authors (::std::unique_ptr< authors_type > x)
  {
    this->authors_.set (std::move (x));
  }

  const BibliographicReferenceType::publication_optional& BibliographicReferenceType::
  publication () const
  {
    return this->publication_;
  }

  BibliographicReferenceType::publication_optional& BibliographicReferenceType::
  publication ()
  {
    return this->publication_;
  }

  void BibliographicReferenceType::
  publication (const publication_type& x)
  {
    this->publication_.set (x);
  }

  void BibliographicReferenceType::
  publication (const publication_optional& x)
  {
    this->publication_ = x;
  }

  void BibliographicReferenceType::
  publication (::std::unique_ptr< publication_type > x)
  {
    this->publication_.set (std::move (x));
  }

  const BibliographicReferenceType::publisher_optional& BibliographicReferenceType::
  publisher () const
  {
    return this->publisher_;
  }

  BibliographicReferenceType::publisher_optional& BibliographicReferenceType::
  publisher ()
  {
    return this->publisher_;
  }

  void BibliographicReferenceType::
  publisher (const publisher_type& x)
  {
    this->publisher_.set (x);
  }

  void BibliographicReferenceType::
  publisher (const publisher_optional& x)
  {
    this->publisher_ = x;
  }

  void BibliographicReferenceType::
  publisher (::std::unique_ptr< publisher_type > x)
  {
    this->publisher_.set (std::move (x));
  }

  const BibliographicReferenceType::editor_optional& BibliographicReferenceType::
  editor () const
  {
    return this->editor_;
  }

  BibliographicReferenceType::editor_optional& BibliographicReferenceType::
  editor ()
  {
    return this->editor_;
  }

  void BibliographicReferenceType::
  editor (const editor_type& x)
  {
    this->editor_.set (x);
  }

  void BibliographicReferenceType::
  editor (const editor_optional& x)
  {
    this->editor_ = x;
  }

  void BibliographicReferenceType::
  editor (::std::unique_ptr< editor_type > x)
  {
    this->editor_.set (std::move (x));
  }

  const BibliographicReferenceType::year_optional& BibliographicReferenceType::
  year () const
  {
    return this->year_;
  }

  BibliographicReferenceType::year_optional& BibliographicReferenceType::
  year ()
  {
    return this->year_;
  }

  void BibliographicReferenceType::
  year (const year_type& x)
  {
    this->year_.set (x);
  }

  void BibliographicReferenceType::
  year (const year_optional& x)
  {
    this->year_ = x;
  }

  const BibliographicReferenceType::volume_optional& BibliographicReferenceType::
  volume () const
  {
    return this->volume_;
  }

  BibliographicReferenceType::volume_optional& BibliographicReferenceType::
  volume ()
  {
    return this->volume_;
  }

  void BibliographicReferenceType::
  volume (const volume_type& x)
  {
    this->volume_.set (x);
  }

  void BibliographicReferenceType::
  volume (const volume_optional& x)
  {
    this->volume_ = x;
  }

  void BibliographicReferenceType::
  volume (::std::unique_ptr< volume_type > x)
  {
    this->volume_.set (std::move (x));
  }

  const BibliographicReferenceType::issue_optional& BibliographicReferenceType::
  issue () const
  {
    return this->issue_;
  }

  BibliographicReferenceType::issue_optional& BibliographicReferenceType::
  issue ()
  {
    return this->issue_;
  }

  void BibliographicReferenceType::
  issue (const issue_type& x)
  {
    this->issue_.set (x);
  }

  void BibliographicReferenceType::
  issue (const issue_optional& x)
  {
    this->issue_ = x;
  }

  void BibliographicReferenceType::
  issue (::std::unique_ptr< issue_type > x)
  {
    this->issue_.set (std::move (x));
  }

  const BibliographicReferenceType::pages_optional& BibliographicReferenceType::
  pages () const
  {
    return this->pages_;
  }

  BibliographicReferenceType::pages_optional& BibliographicReferenceType::
  pages ()
  {
    return this->pages_;
  }

  void BibliographicReferenceType::
  pages (const pages_type& x)
  {
    this->pages_.set (x);
  }

  void BibliographicReferenceType::
  pages (const pages_optional& x)
  {
    this->pages_ = x;
  }

  void BibliographicReferenceType::
  pages (::std::unique_ptr< pages_type > x)
  {
    this->pages_.set (std::move (x));
  }

  const BibliographicReferenceType::title_optional& BibliographicReferenceType::
  title () const
  {
    return this->title_;
  }

  BibliographicReferenceType::title_optional& BibliographicReferenceType::
  title ()
  {
    return this->title_;
  }

  void BibliographicReferenceType::
  title (const title_type& x)
  {
    this->title_.set (x);
  }

  void BibliographicReferenceType::
  title (const title_optional& x)
  {
    this->title_ = x;
  }

  void BibliographicReferenceType::
  title (::std::unique_ptr< title_type > x)
  {
    this->title_.set (std::move (x));
  }

  const BibliographicReferenceType::doi_optional& BibliographicReferenceType::
  doi () const
  {
    return this->doi_;
  }

  BibliographicReferenceType::doi_optional& BibliographicReferenceType::
  doi ()
  {
    return this->doi_;
  }

  void BibliographicReferenceType::
  doi (const doi_type& x)
  {
    this->doi_.set (x);
  }

  void BibliographicReferenceType::
  doi (const doi_optional& x)
  {
    this->doi_ = x;
  }

  void BibliographicReferenceType::
  doi (::std::unique_ptr< doi_type > x)
  {
    this->doi_.set (std::move (x));
  }


  // AbstractParamType
  // 

  const AbstractParamType::name_type& AbstractParamType::
  name () const
  {
    return this->name_.get ();
  }

  AbstractParamType::name_type& AbstractParamType::
  name ()
  {
    return this->name_.get ();
  }

  void AbstractParamType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void AbstractParamType::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const AbstractParamType::value_optional& AbstractParamType::
  value () const
  {
    return this->value_;
  }

  AbstractParamType::value_optional& AbstractParamType::
  value ()
  {
    return this->value_;
  }

  void AbstractParamType::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void AbstractParamType::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void AbstractParamType::
  value (::std::unique_ptr< value_type > x)
  {
    this->value_.set (std::move (x));
  }

  const AbstractParamType::unitAccession_optional& AbstractParamType::
  unitAccession () const
  {
    return this->unitAccession_;
  }

  AbstractParamType::unitAccession_optional& AbstractParamType::
  unitAccession ()
  {
    return this->unitAccession_;
  }

  void AbstractParamType::
  unitAccession (const unitAccession_type& x)
  {
    this->unitAccession_.set (x);
  }

  void AbstractParamType::
  unitAccession (const unitAccession_optional& x)
  {
    this->unitAccession_ = x;
  }

  void AbstractParamType::
  unitAccession (::std::unique_ptr< unitAccession_type > x)
  {
    this->unitAccession_.set (std::move (x));
  }

  const AbstractParamType::unitName_optional& AbstractParamType::
  unitName () const
  {
    return this->unitName_;
  }

  AbstractParamType::unitName_optional& AbstractParamType::
  unitName ()
  {
    return this->unitName_;
  }

  void AbstractParamType::
  unitName (const unitName_type& x)
  {
    this->unitName_.set (x);
  }

  void AbstractParamType::
  unitName (const unitName_optional& x)
  {
    this->unitName_ = x;
  }

  void AbstractParamType::
  unitName (::std::unique_ptr< unitName_type > x)
  {
    this->unitName_.set (std::move (x));
  }

  const AbstractParamType::unitCvRef_optional& AbstractParamType::
  unitCvRef () const
  {
    return this->unitCvRef_;
  }

  AbstractParamType::unitCvRef_optional& AbstractParamType::
  unitCvRef ()
  {
    return this->unitCvRef_;
  }

  void AbstractParamType::
  unitCvRef (const unitCvRef_type& x)
  {
    this->unitCvRef_.set (x);
  }

  void AbstractParamType::
  unitCvRef (const unitCvRef_optional& x)
  {
    this->unitCvRef_ = x;
  }

  void AbstractParamType::
  unitCvRef (::std::unique_ptr< unitCvRef_type > x)
  {
    this->unitCvRef_.set (std::move (x));
  }


  // UserParamType
  // 

  const UserParamType::type_optional& UserParamType::
  type () const
  {
    return this->type_;
  }

  UserParamType::type_optional& UserParamType::
  type ()
  {
    return this->type_;
  }

  void UserParamType::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void UserParamType::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void UserParamType::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // CVParamType
  // 

  const CVParamType::cvRef_type& CVParamType::
  cvRef () const
  {
    return this->cvRef_.get ();
  }

  CVParamType::cvRef_type& CVParamType::
  cvRef ()
  {
    return this->cvRef_.get ();
  }

  void CVParamType::
  cvRef (const cvRef_type& x)
  {
    this->cvRef_.set (x);
  }

  void CVParamType::
  cvRef (::std::unique_ptr< cvRef_type > x)
  {
    this->cvRef_.set (std::move (x));
  }

  const CVParamType::accession_type& CVParamType::
  accession () const
  {
    return this->accession_.get ();
  }

  CVParamType::accession_type& CVParamType::
  accession ()
  {
    return this->accession_.get ();
  }

  void CVParamType::
  accession (const accession_type& x)
  {
    this->accession_.set (x);
  }

  void CVParamType::
  accession (::std::unique_ptr< accession_type > x)
  {
    this->accession_.set (std::move (x));
  }


  // cvType
  // 

  const cvType::fullName_type& cvType::
  fullName () const
  {
    return this->fullName_.get ();
  }

  cvType::fullName_type& cvType::
  fullName ()
  {
    return this->fullName_.get ();
  }

  void cvType::
  fullName (const fullName_type& x)
  {
    this->fullName_.set (x);
  }

  void cvType::
  fullName (::std::unique_ptr< fullName_type > x)
  {
    this->fullName_.set (std::move (x));
  }

  const cvType::version_optional& cvType::
  version () const
  {
    return this->version_;
  }

  cvType::version_optional& cvType::
  version ()
  {
    return this->version_;
  }

  void cvType::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void cvType::
  version (const version_optional& x)
  {
    this->version_ = x;
  }

  void cvType::
  version (::std::unique_ptr< version_type > x)
  {
    this->version_.set (std::move (x));
  }

  const cvType::uri_type& cvType::
  uri () const
  {
    return this->uri_.get ();
  }

  cvType::uri_type& cvType::
  uri ()
  {
    return this->uri_.get ();
  }

  void cvType::
  uri (const uri_type& x)
  {
    this->uri_.set (x);
  }

  void cvType::
  uri (::std::unique_ptr< uri_type > x)
  {
    this->uri_.set (std::move (x));
  }

  const cvType::id_type& cvType::
  id () const
  {
    return this->id_.get ();
  }

  cvType::id_type& cvType::
  id ()
  {
    return this->id_.get ();
  }

  void cvType::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void cvType::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // AuditCollectionType
  // 

  const AuditCollectionType::Person_sequence& AuditCollectionType::
  Person () const
  {
    return this->Person_;
  }

  AuditCollectionType::Person_sequence& AuditCollectionType::
  Person ()
  {
    return this->Person_;
  }

  void AuditCollectionType::
  Person (const Person_sequence& s)
  {
    this->Person_ = s;
  }

  const AuditCollectionType::Organization_sequence& AuditCollectionType::
  Organization () const
  {
    return this->Organization_;
  }

  AuditCollectionType::Organization_sequence& AuditCollectionType::
  Organization ()
  {
    return this->Organization_;
  }

  void AuditCollectionType::
  Organization (const Organization_sequence& s)
  {
    this->Organization_ = s;
  }


  // ProviderType
  // 

  const ProviderType::ContactRole_optional& ProviderType::
  ContactRole () const
  {
    return this->ContactRole_;
  }

  ProviderType::ContactRole_optional& ProviderType::
  ContactRole ()
  {
    return this->ContactRole_;
  }

  void ProviderType::
  ContactRole (const ContactRole_type& x)
  {
    this->ContactRole_.set (x);
  }

  void ProviderType::
  ContactRole (const ContactRole_optional& x)
  {
    this->ContactRole_ = x;
  }

  void ProviderType::
  ContactRole (::std::unique_ptr< ContactRole_type > x)
  {
    this->ContactRole_.set (std::move (x));
  }

  const ProviderType::analysisSoftware_ref_optional& ProviderType::
  analysisSoftware_ref () const
  {
    return this->analysisSoftware_ref_;
  }

  ProviderType::analysisSoftware_ref_optional& ProviderType::
  analysisSoftware_ref ()
  {
    return this->analysisSoftware_ref_;
  }

  void ProviderType::
  analysisSoftware_ref (const analysisSoftware_ref_type& x)
  {
    this->analysisSoftware_ref_.set (x);
  }

  void ProviderType::
  analysisSoftware_ref (const analysisSoftware_ref_optional& x)
  {
    this->analysisSoftware_ref_ = x;
  }

  void ProviderType::
  analysisSoftware_ref (::std::unique_ptr< analysisSoftware_ref_type > x)
  {
    this->analysisSoftware_ref_.set (std::move (x));
  }


  // ParamListType
  // 

  const ParamListType::cvParam_sequence& ParamListType::
  cvParam () const
  {
    return this->cvParam_;
  }

  ParamListType::cvParam_sequence& ParamListType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void ParamListType::
  cvParam (const cvParam_sequence& s)
  {
    this->cvParam_ = s;
  }

  const ParamListType::userParam_sequence& ParamListType::
  userParam () const
  {
    return this->userParam_;
  }

  ParamListType::userParam_sequence& ParamListType::
  userParam ()
  {
    return this->userParam_;
  }

  void ParamListType::
  userParam (const userParam_sequence& s)
  {
    this->userParam_ = s;
  }


  // ParamType
  // 

  const ParamType::cvParam_optional& ParamType::
  cvParam () const
  {
    return this->cvParam_;
  }

  ParamType::cvParam_optional& ParamType::
  cvParam ()
  {
    return this->cvParam_;
  }

  void ParamType::
  cvParam (const cvParam_type& x)
  {
    this->cvParam_.set (x);
  }

  void ParamType::
  cvParam (const cvParam_optional& x)
  {
    this->cvParam_ = x;
  }

  void ParamType::
  cvParam (::std::unique_ptr< cvParam_type > x)
  {
    this->cvParam_.set (std::move (x));
  }

  const ParamType::userParam_optional& ParamType::
  userParam () const
  {
    return this->userParam_;
  }

  ParamType::userParam_optional& ParamType::
  userParam ()
  {
    return this->userParam_;
  }

  void ParamType::
  userParam (const userParam_type& x)
  {
    this->userParam_.set (x);
  }

  void ParamType::
  userParam (const userParam_optional& x)
  {
    this->userParam_ = x;
  }

  void ParamType::
  userParam (::std::unique_ptr< userParam_type > x)
  {
    this->userParam_.set (std::move (x));
  }


  // originalResidue
  // 


  // replacementResidue
  // 


  // nTermGain
  // 


  // cTermGain
  // 


  // minDistance
  // 


  // pre
  // 


  // post
  // 


  // listOfCharsOrAny_member
  //

  listOfCharsOrAny_member::
  listOfCharsOrAny_member ()
  : ::xsd::cxx::tree::list< ::mzIdentML110::chars, char > (this)
  {
  }

  listOfCharsOrAny_member::
  listOfCharsOrAny_member (size_type n, const ::mzIdentML110::chars& x)
  : ::xsd::cxx::tree::list< ::mzIdentML110::chars, char > (n, x, this)
  {
  }

  listOfCharsOrAny_member::
  listOfCharsOrAny_member (const listOfCharsOrAny_member& o,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::mzIdentML110::chars, char > (o, f, this)
  {
  }

  // listOfCharsOrAny_member1
  // 

  listOfCharsOrAny_member1::
  listOfCharsOrAny_member1 ()
  : ::xml_schema::string ()
  {
  }

  listOfCharsOrAny_member1::
  listOfCharsOrAny_member1 (value v)
  : ::xml_schema::string (_xsd_listOfCharsOrAny_member1_literals_[v])
  {
  }

  listOfCharsOrAny_member1::
  listOfCharsOrAny_member1 (const char* v)
  : ::xml_schema::string (v)
  {
  }

  listOfCharsOrAny_member1::
  listOfCharsOrAny_member1 (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  listOfCharsOrAny_member1::
  listOfCharsOrAny_member1 (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  listOfCharsOrAny_member1::
  listOfCharsOrAny_member1 (const listOfCharsOrAny_member1& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  listOfCharsOrAny_member1& listOfCharsOrAny_member1::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_listOfCharsOrAny_member1_literals_[v]);

    return *this;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace mzIdentML110
{
  // CVListType
  //

  CVListType::
  CVListType ()
  : ::xml_schema::type (),
    cv_ (this)
  {
  }

  CVListType::
  CVListType (const CVListType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    cv_ (x.cv_, f, this)
  {
  }

  CVListType::
  CVListType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    cv_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CVListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // cv
      //
      if (n.name () == "cv" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cv_type > r (
          cv_traits::create (i, f, this));

        this->cv_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  CVListType* CVListType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CVListType (*this, f, c);
  }

  CVListType& CVListType::
  operator= (const CVListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->cv_ = x.cv_;
    }

    return *this;
  }

  CVListType::
  ~CVListType ()
  {
  }

  // AnalysisSoftwareListType
  //

  AnalysisSoftwareListType::
  AnalysisSoftwareListType ()
  : ::xml_schema::type (),
    AnalysisSoftware_ (this)
  {
  }

  AnalysisSoftwareListType::
  AnalysisSoftwareListType (const AnalysisSoftwareListType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    AnalysisSoftware_ (x.AnalysisSoftware_, f, this)
  {
  }

  AnalysisSoftwareListType::
  AnalysisSoftwareListType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    AnalysisSoftware_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AnalysisSoftwareListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AnalysisSoftware
      //
      if (n.name () == "AnalysisSoftware" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< AnalysisSoftware_type > r (
          AnalysisSoftware_traits::create (i, f, this));

        this->AnalysisSoftware_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AnalysisSoftwareListType* AnalysisSoftwareListType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AnalysisSoftwareListType (*this, f, c);
  }

  AnalysisSoftwareListType& AnalysisSoftwareListType::
  operator= (const AnalysisSoftwareListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->AnalysisSoftware_ = x.AnalysisSoftware_;
    }

    return *this;
  }

  AnalysisSoftwareListType::
  ~AnalysisSoftwareListType ()
  {
  }

  // AnalysisSampleCollectionType
  //

  AnalysisSampleCollectionType::
  AnalysisSampleCollectionType ()
  : ::xml_schema::type (),
    Sample_ (this)
  {
  }

  AnalysisSampleCollectionType::
  AnalysisSampleCollectionType (const AnalysisSampleCollectionType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Sample_ (x.Sample_, f, this)
  {
  }

  AnalysisSampleCollectionType::
  AnalysisSampleCollectionType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Sample_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AnalysisSampleCollectionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Sample
      //
      if (n.name () == "Sample" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Sample_type > r (
          Sample_traits::create (i, f, this));

        this->Sample_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AnalysisSampleCollectionType* AnalysisSampleCollectionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AnalysisSampleCollectionType (*this, f, c);
  }

  AnalysisSampleCollectionType& AnalysisSampleCollectionType::
  operator= (const AnalysisSampleCollectionType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Sample_ = x.Sample_;
    }

    return *this;
  }

  AnalysisSampleCollectionType::
  ~AnalysisSampleCollectionType ()
  {
  }

  // SequenceCollectionType
  //

  SequenceCollectionType::
  SequenceCollectionType ()
  : ::xml_schema::type (),
    DBSequence_ (this),
    Peptide_ (this),
    PeptideEvidence_ (this)
  {
  }

  SequenceCollectionType::
  SequenceCollectionType (const SequenceCollectionType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DBSequence_ (x.DBSequence_, f, this),
    Peptide_ (x.Peptide_, f, this),
    PeptideEvidence_ (x.PeptideEvidence_, f, this)
  {
  }

  SequenceCollectionType::
  SequenceCollectionType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DBSequence_ (this),
    Peptide_ (this),
    PeptideEvidence_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SequenceCollectionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DBSequence
      //
      if (n.name () == "DBSequence" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< DBSequence_type > r (
          DBSequence_traits::create (i, f, this));

        this->DBSequence_.push_back (::std::move (r));
        continue;
      }

      // Peptide
      //
      if (n.name () == "Peptide" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Peptide_type > r (
          Peptide_traits::create (i, f, this));

        this->Peptide_.push_back (::std::move (r));
        continue;
      }

      // PeptideEvidence
      //
      if (n.name () == "PeptideEvidence" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< PeptideEvidence_type > r (
          PeptideEvidence_traits::create (i, f, this));

        this->PeptideEvidence_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  SequenceCollectionType* SequenceCollectionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SequenceCollectionType (*this, f, c);
  }

  SequenceCollectionType& SequenceCollectionType::
  operator= (const SequenceCollectionType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->DBSequence_ = x.DBSequence_;
      this->Peptide_ = x.Peptide_;
      this->PeptideEvidence_ = x.PeptideEvidence_;
    }

    return *this;
  }

  SequenceCollectionType::
  ~SequenceCollectionType ()
  {
  }

  // AnalysisCollectionType
  //

  AnalysisCollectionType::
  AnalysisCollectionType ()
  : ::xml_schema::type (),
    SpectrumIdentification_ (this),
    ProteinDetection_ (this)
  {
  }

  AnalysisCollectionType::
  AnalysisCollectionType (const AnalysisCollectionType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    SpectrumIdentification_ (x.SpectrumIdentification_, f, this),
    ProteinDetection_ (x.ProteinDetection_, f, this)
  {
  }

  AnalysisCollectionType::
  AnalysisCollectionType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    SpectrumIdentification_ (this),
    ProteinDetection_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AnalysisCollectionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SpectrumIdentification
      //
      if (n.name () == "SpectrumIdentification" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< SpectrumIdentification_type > r (
          SpectrumIdentification_traits::create (i, f, this));

        this->SpectrumIdentification_.push_back (::std::move (r));
        continue;
      }

      // ProteinDetection
      //
      if (n.name () == "ProteinDetection" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< ProteinDetection_type > r (
          ProteinDetection_traits::create (i, f, this));

        if (!this->ProteinDetection_)
        {
          this->ProteinDetection_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  AnalysisCollectionType* AnalysisCollectionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AnalysisCollectionType (*this, f, c);
  }

  AnalysisCollectionType& AnalysisCollectionType::
  operator= (const AnalysisCollectionType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->SpectrumIdentification_ = x.SpectrumIdentification_;
      this->ProteinDetection_ = x.ProteinDetection_;
    }

    return *this;
  }

  AnalysisCollectionType::
  ~AnalysisCollectionType ()
  {
  }

  // AnalysisProtocolCollectionType
  //

  AnalysisProtocolCollectionType::
  AnalysisProtocolCollectionType ()
  : ::xml_schema::type (),
    SpectrumIdentificationProtocol_ (this),
    ProteinDetectionProtocol_ (this)
  {
  }

  AnalysisProtocolCollectionType::
  AnalysisProtocolCollectionType (const AnalysisProtocolCollectionType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    SpectrumIdentificationProtocol_ (x.SpectrumIdentificationProtocol_, f, this),
    ProteinDetectionProtocol_ (x.ProteinDetectionProtocol_, f, this)
  {
  }

  AnalysisProtocolCollectionType::
  AnalysisProtocolCollectionType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    SpectrumIdentificationProtocol_ (this),
    ProteinDetectionProtocol_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AnalysisProtocolCollectionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SpectrumIdentificationProtocol
      //
      if (n.name () == "SpectrumIdentificationProtocol" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< SpectrumIdentificationProtocol_type > r (
          SpectrumIdentificationProtocol_traits::create (i, f, this));

        this->SpectrumIdentificationProtocol_.push_back (::std::move (r));
        continue;
      }

      // ProteinDetectionProtocol
      //
      if (n.name () == "ProteinDetectionProtocol" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< ProteinDetectionProtocol_type > r (
          ProteinDetectionProtocol_traits::create (i, f, this));

        if (!this->ProteinDetectionProtocol_)
        {
          this->ProteinDetectionProtocol_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  AnalysisProtocolCollectionType* AnalysisProtocolCollectionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AnalysisProtocolCollectionType (*this, f, c);
  }

  AnalysisProtocolCollectionType& AnalysisProtocolCollectionType::
  operator= (const AnalysisProtocolCollectionType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->SpectrumIdentificationProtocol_ = x.SpectrumIdentificationProtocol_;
      this->ProteinDetectionProtocol_ = x.ProteinDetectionProtocol_;
    }

    return *this;
  }

  AnalysisProtocolCollectionType::
  ~AnalysisProtocolCollectionType ()
  {
  }

  // InputsType
  //

  InputsType::
  InputsType ()
  : ::xml_schema::type (),
    SourceFile_ (this),
    SearchDatabase_ (this),
    SpectraData_ (this)
  {
  }

  InputsType::
  InputsType (const InputsType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    SourceFile_ (x.SourceFile_, f, this),
    SearchDatabase_ (x.SearchDatabase_, f, this),
    SpectraData_ (x.SpectraData_, f, this)
  {
  }

  InputsType::
  InputsType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    SourceFile_ (this),
    SearchDatabase_ (this),
    SpectraData_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void InputsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SourceFile
      //
      if (n.name () == "SourceFile" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< SourceFile_type > r (
          SourceFile_traits::create (i, f, this));

        this->SourceFile_.push_back (::std::move (r));
        continue;
      }

      // SearchDatabase
      //
      if (n.name () == "SearchDatabase" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< SearchDatabase_type > r (
          SearchDatabase_traits::create (i, f, this));

        this->SearchDatabase_.push_back (::std::move (r));
        continue;
      }

      // SpectraData
      //
      if (n.name () == "SpectraData" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< SpectraData_type > r (
          SpectraData_traits::create (i, f, this));

        this->SpectraData_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  InputsType* InputsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InputsType (*this, f, c);
  }

  InputsType& InputsType::
  operator= (const InputsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->SourceFile_ = x.SourceFile_;
      this->SearchDatabase_ = x.SearchDatabase_;
      this->SpectraData_ = x.SpectraData_;
    }

    return *this;
  }

  InputsType::
  ~InputsType ()
  {
  }

  // AnalysisDataType
  //

  AnalysisDataType::
  AnalysisDataType ()
  : ::xml_schema::type (),
    SpectrumIdentificationList_ (this),
    ProteinDetectionList_ (this)
  {
  }

  AnalysisDataType::
  AnalysisDataType (const AnalysisDataType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    SpectrumIdentificationList_ (x.SpectrumIdentificationList_, f, this),
    ProteinDetectionList_ (x.ProteinDetectionList_, f, this)
  {
  }

  AnalysisDataType::
  AnalysisDataType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    SpectrumIdentificationList_ (this),
    ProteinDetectionList_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AnalysisDataType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SpectrumIdentificationList
      //
      if (n.name () == "SpectrumIdentificationList" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< SpectrumIdentificationList_type > r (
          SpectrumIdentificationList_traits::create (i, f, this));

        this->SpectrumIdentificationList_.push_back (::std::move (r));
        continue;
      }

      // ProteinDetectionList
      //
      if (n.name () == "ProteinDetectionList" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< ProteinDetectionList_type > r (
          ProteinDetectionList_traits::create (i, f, this));

        if (!this->ProteinDetectionList_)
        {
          this->ProteinDetectionList_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  AnalysisDataType* AnalysisDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AnalysisDataType (*this, f, c);
  }

  AnalysisDataType& AnalysisDataType::
  operator= (const AnalysisDataType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->SpectrumIdentificationList_ = x.SpectrumIdentificationList_;
      this->ProteinDetectionList_ = x.ProteinDetectionList_;
    }

    return *this;
  }

  AnalysisDataType::
  ~AnalysisDataType ()
  {
  }

  // DataCollectionType
  //

  DataCollectionType::
  DataCollectionType ()
  : ::xml_schema::type (),
    Inputs_ (this),
    AnalysisData_ (this)
  {
  }

  DataCollectionType::
  DataCollectionType (const Inputs_type& Inputs,
                      const AnalysisData_type& AnalysisData)
  : ::xml_schema::type (),
    Inputs_ (Inputs, this),
    AnalysisData_ (AnalysisData, this)
  {
  }

  DataCollectionType::
  DataCollectionType (::std::unique_ptr< Inputs_type > Inputs,
                      ::std::unique_ptr< AnalysisData_type > AnalysisData)
  : ::xml_schema::type (),
    Inputs_ (std::move (Inputs), this),
    AnalysisData_ (std::move (AnalysisData), this)
  {
  }

  DataCollectionType::
  DataCollectionType (const DataCollectionType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Inputs_ (x.Inputs_, f, this),
    AnalysisData_ (x.AnalysisData_, f, this)
  {
  }

  DataCollectionType::
  DataCollectionType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Inputs_ (this),
    AnalysisData_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DataCollectionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Inputs
      //
      if (n.name () == "Inputs" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Inputs_type > r (
          Inputs_traits::create (i, f, this));

        if (!Inputs_.present ())
        {
          this->Inputs_.set (::std::move (r));
          continue;
        }
      }

      // AnalysisData
      //
      if (n.name () == "AnalysisData" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< AnalysisData_type > r (
          AnalysisData_traits::create (i, f, this));

        if (!AnalysisData_.present ())
        {
          this->AnalysisData_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!Inputs_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Inputs",
        "http://psidev.info/psi/pi/mzIdentML/1.1");
    }

    if (!AnalysisData_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AnalysisData",
        "http://psidev.info/psi/pi/mzIdentML/1.1");
    }
  }

  DataCollectionType* DataCollectionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataCollectionType (*this, f, c);
  }

  DataCollectionType& DataCollectionType::
  operator= (const DataCollectionType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Inputs_ = x.Inputs_;
      this->AnalysisData_ = x.AnalysisData_;
    }

    return *this;
  }

  DataCollectionType::
  ~DataCollectionType ()
  {
  }

  // IdentifiableType
  //

  IdentifiableType::
  IdentifiableType ()
  : ::xml_schema::type (),
    id_ (this),
    name_ (this)
  {
  }

  IdentifiableType::
  IdentifiableType (const id_type& id)
  : ::xml_schema::type (),
    id_ (id, this),
    name_ (this)
  {
  }

  IdentifiableType::
  IdentifiableType (const IdentifiableType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  IdentifiableType::
  IdentifiableType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void IdentifiableType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  IdentifiableType* IdentifiableType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IdentifiableType (*this, f, c);
  }

  IdentifiableType& IdentifiableType::
  operator= (const IdentifiableType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->id_ = x.id_;
      this->name_ = x.name_;
    }

    return *this;
  }

  IdentifiableType::
  ~IdentifiableType ()
  {
  }

  // MzIdentMLType
  //

  MzIdentMLType::
  MzIdentMLType ()
  : ::mzIdentML110::IdentifiableType (),
    cvList_ (this),
    AnalysisSoftwareList_ (this),
    Provider_ (this),
    AuditCollection_ (this),
    AnalysisSampleCollection_ (this),
    SequenceCollection_ (this),
    AnalysisCollection_ (this),
    AnalysisProtocolCollection_ (this),
    DataCollection_ (this),
    BibliographicReference_ (this),
    creationDate_ (this),
    version_ (this)
  {
  }

  MzIdentMLType::
  MzIdentMLType (const id_type& id,
                 const cvList_type& cvList,
                 const AnalysisCollection_type& AnalysisCollection,
                 const AnalysisProtocolCollection_type& AnalysisProtocolCollection,
                 const DataCollection_type& DataCollection,
                 const version_type& version)
  : ::mzIdentML110::IdentifiableType (id),
    cvList_ (cvList, this),
    AnalysisSoftwareList_ (this),
    Provider_ (this),
    AuditCollection_ (this),
    AnalysisSampleCollection_ (this),
    SequenceCollection_ (this),
    AnalysisCollection_ (AnalysisCollection, this),
    AnalysisProtocolCollection_ (AnalysisProtocolCollection, this),
    DataCollection_ (DataCollection, this),
    BibliographicReference_ (this),
    creationDate_ (this),
    version_ (version, this)
  {
  }

  MzIdentMLType::
  MzIdentMLType (const id_type& id,
                 ::std::unique_ptr< cvList_type > cvList,
                 ::std::unique_ptr< AnalysisCollection_type > AnalysisCollection,
                 ::std::unique_ptr< AnalysisProtocolCollection_type > AnalysisProtocolCollection,
                 ::std::unique_ptr< DataCollection_type > DataCollection,
                 const version_type& version)
  : ::mzIdentML110::IdentifiableType (id),
    cvList_ (std::move (cvList), this),
    AnalysisSoftwareList_ (this),
    Provider_ (this),
    AuditCollection_ (this),
    AnalysisSampleCollection_ (this),
    SequenceCollection_ (this),
    AnalysisCollection_ (std::move (AnalysisCollection), this),
    AnalysisProtocolCollection_ (std::move (AnalysisProtocolCollection), this),
    DataCollection_ (std::move (DataCollection), this),
    BibliographicReference_ (this),
    creationDate_ (this),
    version_ (version, this)
  {
  }

  MzIdentMLType::
  MzIdentMLType (const MzIdentMLType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    cvList_ (x.cvList_, f, this),
    AnalysisSoftwareList_ (x.AnalysisSoftwareList_, f, this),
    Provider_ (x.Provider_, f, this),
    AuditCollection_ (x.AuditCollection_, f, this),
    AnalysisSampleCollection_ (x.AnalysisSampleCollection_, f, this),
    SequenceCollection_ (x.SequenceCollection_, f, this),
    AnalysisCollection_ (x.AnalysisCollection_, f, this),
    AnalysisProtocolCollection_ (x.AnalysisProtocolCollection_, f, this),
    DataCollection_ (x.DataCollection_, f, this),
    BibliographicReference_ (x.BibliographicReference_, f, this),
    creationDate_ (x.creationDate_, f, this),
    version_ (x.version_, f, this)
  {
  }

  MzIdentMLType::
  MzIdentMLType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    cvList_ (this),
    AnalysisSoftwareList_ (this),
    Provider_ (this),
    AuditCollection_ (this),
    AnalysisSampleCollection_ (this),
    SequenceCollection_ (this),
    AnalysisCollection_ (this),
    AnalysisProtocolCollection_ (this),
    DataCollection_ (this),
    BibliographicReference_ (this),
    creationDate_ (this),
    version_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MzIdentMLType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // cvList
      //
      if (n.name () == "cvList" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvList_type > r (
          cvList_traits::create (i, f, this));

        if (!cvList_.present ())
        {
          this->cvList_.set (::std::move (r));
          continue;
        }
      }

      // AnalysisSoftwareList
      //
      if (n.name () == "AnalysisSoftwareList" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< AnalysisSoftwareList_type > r (
          AnalysisSoftwareList_traits::create (i, f, this));

        if (!this->AnalysisSoftwareList_)
        {
          this->AnalysisSoftwareList_.set (::std::move (r));
          continue;
        }
      }

      // Provider
      //
      if (n.name () == "Provider" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Provider_type > r (
          Provider_traits::create (i, f, this));

        if (!this->Provider_)
        {
          this->Provider_.set (::std::move (r));
          continue;
        }
      }

      // AuditCollection
      //
      if (n.name () == "AuditCollection" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< AuditCollection_type > r (
          AuditCollection_traits::create (i, f, this));

        if (!this->AuditCollection_)
        {
          this->AuditCollection_.set (::std::move (r));
          continue;
        }
      }

      // AnalysisSampleCollection
      //
      if (n.name () == "AnalysisSampleCollection" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< AnalysisSampleCollection_type > r (
          AnalysisSampleCollection_traits::create (i, f, this));

        if (!this->AnalysisSampleCollection_)
        {
          this->AnalysisSampleCollection_.set (::std::move (r));
          continue;
        }
      }

      // SequenceCollection
      //
      if (n.name () == "SequenceCollection" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< SequenceCollection_type > r (
          SequenceCollection_traits::create (i, f, this));

        if (!this->SequenceCollection_)
        {
          this->SequenceCollection_.set (::std::move (r));
          continue;
        }
      }

      // AnalysisCollection
      //
      if (n.name () == "AnalysisCollection" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< AnalysisCollection_type > r (
          AnalysisCollection_traits::create (i, f, this));

        if (!AnalysisCollection_.present ())
        {
          this->AnalysisCollection_.set (::std::move (r));
          continue;
        }
      }

      // AnalysisProtocolCollection
      //
      if (n.name () == "AnalysisProtocolCollection" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< AnalysisProtocolCollection_type > r (
          AnalysisProtocolCollection_traits::create (i, f, this));

        if (!AnalysisProtocolCollection_.present ())
        {
          this->AnalysisProtocolCollection_.set (::std::move (r));
          continue;
        }
      }

      // DataCollection
      //
      if (n.name () == "DataCollection" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< DataCollection_type > r (
          DataCollection_traits::create (i, f, this));

        if (!DataCollection_.present ())
        {
          this->DataCollection_.set (::std::move (r));
          continue;
        }
      }

      // BibliographicReference
      //
      if (n.name () == "BibliographicReference" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< BibliographicReference_type > r (
          BibliographicReference_traits::create (i, f, this));

        this->BibliographicReference_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!cvList_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "cvList",
        "http://psidev.info/psi/pi/mzIdentML/1.1");
    }

    if (!AnalysisCollection_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AnalysisCollection",
        "http://psidev.info/psi/pi/mzIdentML/1.1");
    }

    if (!AnalysisProtocolCollection_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AnalysisProtocolCollection",
        "http://psidev.info/psi/pi/mzIdentML/1.1");
    }

    if (!DataCollection_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DataCollection",
        "http://psidev.info/psi/pi/mzIdentML/1.1");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "creationDate" && n.namespace_ ().empty ())
      {
        this->creationDate_.set (creationDate_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        this->version_.set (version_traits::create (i, f, this));
        continue;
      }
    }

    if (!version_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "version",
        "");
    }
  }

  MzIdentMLType* MzIdentMLType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MzIdentMLType (*this, f, c);
  }

  MzIdentMLType& MzIdentMLType::
  operator= (const MzIdentMLType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->cvList_ = x.cvList_;
      this->AnalysisSoftwareList_ = x.AnalysisSoftwareList_;
      this->Provider_ = x.Provider_;
      this->AuditCollection_ = x.AuditCollection_;
      this->AnalysisSampleCollection_ = x.AnalysisSampleCollection_;
      this->SequenceCollection_ = x.SequenceCollection_;
      this->AnalysisCollection_ = x.AnalysisCollection_;
      this->AnalysisProtocolCollection_ = x.AnalysisProtocolCollection_;
      this->DataCollection_ = x.DataCollection_;
      this->BibliographicReference_ = x.BibliographicReference_;
      this->creationDate_ = x.creationDate_;
      this->version_ = x.version_;
    }

    return *this;
  }

  MzIdentMLType::
  ~MzIdentMLType ()
  {
  }

  // ExternalDataType
  //

  ExternalDataType::
  ExternalDataType ()
  : ::mzIdentML110::IdentifiableType (),
    ExternalFormatDocumentation_ (this),
    FileFormat_ (this),
    location_ (this)
  {
  }

  ExternalDataType::
  ExternalDataType (const id_type& id,
                    const location_type& location)
  : ::mzIdentML110::IdentifiableType (id),
    ExternalFormatDocumentation_ (this),
    FileFormat_ (this),
    location_ (location, this)
  {
  }

  ExternalDataType::
  ExternalDataType (const ExternalDataType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    ExternalFormatDocumentation_ (x.ExternalFormatDocumentation_, f, this),
    FileFormat_ (x.FileFormat_, f, this),
    location_ (x.location_, f, this)
  {
  }

  ExternalDataType::
  ExternalDataType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    ExternalFormatDocumentation_ (this),
    FileFormat_ (this),
    location_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ExternalDataType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ExternalFormatDocumentation
      //
      if (n.name () == "ExternalFormatDocumentation" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< ExternalFormatDocumentation_type > r (
          ExternalFormatDocumentation_traits::create (i, f, this));

        if (!this->ExternalFormatDocumentation_)
        {
          this->ExternalFormatDocumentation_.set (::std::move (r));
          continue;
        }
      }

      // FileFormat
      //
      if (n.name () == "FileFormat" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< FileFormat_type > r (
          FileFormat_traits::create (i, f, this));

        if (!this->FileFormat_)
        {
          this->FileFormat_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "location" && n.namespace_ ().empty ())
      {
        this->location_.set (location_traits::create (i, f, this));
        continue;
      }
    }

    if (!location_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "location",
        "");
    }
  }

  ExternalDataType* ExternalDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ExternalDataType (*this, f, c);
  }

  ExternalDataType& ExternalDataType::
  operator= (const ExternalDataType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->ExternalFormatDocumentation_ = x.ExternalFormatDocumentation_;
      this->FileFormat_ = x.FileFormat_;
      this->location_ = x.location_;
    }

    return *this;
  }

  ExternalDataType::
  ~ExternalDataType ()
  {
  }

  // SearchDatabaseType
  //

  SearchDatabaseType::
  SearchDatabaseType ()
  : ::mzIdentML110::ExternalDataType (),
    DatabaseName_ (this),
    cvParam_ (this),
    version_ (this),
    releaseDate_ (this),
    numDatabaseSequences_ (this),
    numResidues_ (this)
  {
  }

  SearchDatabaseType::
  SearchDatabaseType (const id_type& id,
                      const location_type& location,
                      const DatabaseName_type& DatabaseName)
  : ::mzIdentML110::ExternalDataType (id,
                                      location),
    DatabaseName_ (DatabaseName, this),
    cvParam_ (this),
    version_ (this),
    releaseDate_ (this),
    numDatabaseSequences_ (this),
    numResidues_ (this)
  {
  }

  SearchDatabaseType::
  SearchDatabaseType (const id_type& id,
                      const location_type& location,
                      ::std::unique_ptr< DatabaseName_type > DatabaseName)
  : ::mzIdentML110::ExternalDataType (id,
                                      location),
    DatabaseName_ (std::move (DatabaseName), this),
    cvParam_ (this),
    version_ (this),
    releaseDate_ (this),
    numDatabaseSequences_ (this),
    numResidues_ (this)
  {
  }

  SearchDatabaseType::
  SearchDatabaseType (const SearchDatabaseType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::mzIdentML110::ExternalDataType (x, f, c),
    DatabaseName_ (x.DatabaseName_, f, this),
    cvParam_ (x.cvParam_, f, this),
    version_ (x.version_, f, this),
    releaseDate_ (x.releaseDate_, f, this),
    numDatabaseSequences_ (x.numDatabaseSequences_, f, this),
    numResidues_ (x.numResidues_, f, this)
  {
  }

  SearchDatabaseType::
  SearchDatabaseType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::mzIdentML110::ExternalDataType (e, f | ::xml_schema::flags::base, c),
    DatabaseName_ (this),
    cvParam_ (this),
    version_ (this),
    releaseDate_ (this),
    numDatabaseSequences_ (this),
    numResidues_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SearchDatabaseType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::ExternalDataType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DatabaseName
      //
      if (n.name () == "DatabaseName" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< DatabaseName_type > r (
          DatabaseName_traits::create (i, f, this));

        if (!DatabaseName_.present ())
        {
          this->DatabaseName_.set (::std::move (r));
          continue;
        }
      }

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!DatabaseName_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DatabaseName",
        "http://psidev.info/psi/pi/mzIdentML/1.1");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        this->version_.set (version_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "releaseDate" && n.namespace_ ().empty ())
      {
        this->releaseDate_.set (releaseDate_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "numDatabaseSequences" && n.namespace_ ().empty ())
      {
        this->numDatabaseSequences_.set (numDatabaseSequences_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "numResidues" && n.namespace_ ().empty ())
      {
        this->numResidues_.set (numResidues_traits::create (i, f, this));
        continue;
      }
    }
  }

  SearchDatabaseType* SearchDatabaseType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SearchDatabaseType (*this, f, c);
  }

  SearchDatabaseType& SearchDatabaseType::
  operator= (const SearchDatabaseType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::ExternalDataType& > (*this) = x;
      this->DatabaseName_ = x.DatabaseName_;
      this->cvParam_ = x.cvParam_;
      this->version_ = x.version_;
      this->releaseDate_ = x.releaseDate_;
      this->numDatabaseSequences_ = x.numDatabaseSequences_;
      this->numResidues_ = x.numResidues_;
    }

    return *this;
  }

  SearchDatabaseType::
  ~SearchDatabaseType ()
  {
  }

  // SourceFileType
  //

  SourceFileType::
  SourceFileType ()
  : ::mzIdentML110::ExternalDataType (),
    cvParam_ (this),
    userParam_ (this)
  {
  }

  SourceFileType::
  SourceFileType (const id_type& id,
                  const location_type& location)
  : ::mzIdentML110::ExternalDataType (id,
                                      location),
    cvParam_ (this),
    userParam_ (this)
  {
  }

  SourceFileType::
  SourceFileType (const SourceFileType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::mzIdentML110::ExternalDataType (x, f, c),
    cvParam_ (x.cvParam_, f, this),
    userParam_ (x.userParam_, f, this)
  {
  }

  SourceFileType::
  SourceFileType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::mzIdentML110::ExternalDataType (e, f | ::xml_schema::flags::base, c),
    cvParam_ (this),
    userParam_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SourceFileType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::ExternalDataType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      // userParam
      //
      if (n.name () == "userParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< userParam_type > r (
          userParam_traits::create (i, f, this));

        this->userParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  SourceFileType* SourceFileType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SourceFileType (*this, f, c);
  }

  SourceFileType& SourceFileType::
  operator= (const SourceFileType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::ExternalDataType& > (*this) = x;
      this->cvParam_ = x.cvParam_;
      this->userParam_ = x.userParam_;
    }

    return *this;
  }

  SourceFileType::
  ~SourceFileType ()
  {
  }

  // ModificationParamsType
  //

  ModificationParamsType::
  ModificationParamsType ()
  : ::xml_schema::type (),
    SearchModification_ (this)
  {
  }

  ModificationParamsType::
  ModificationParamsType (const ModificationParamsType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    SearchModification_ (x.SearchModification_, f, this)
  {
  }

  ModificationParamsType::
  ModificationParamsType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    SearchModification_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ModificationParamsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SearchModification
      //
      if (n.name () == "SearchModification" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< SearchModification_type > r (
          SearchModification_traits::create (i, f, this));

        this->SearchModification_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ModificationParamsType* ModificationParamsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ModificationParamsType (*this, f, c);
  }

  ModificationParamsType& ModificationParamsType::
  operator= (const ModificationParamsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->SearchModification_ = x.SearchModification_;
    }

    return *this;
  }

  ModificationParamsType::
  ~ModificationParamsType ()
  {
  }

  // FilterType
  //

  FilterType::
  FilterType ()
  : ::xml_schema::type (),
    FilterType1_ (this),
    Include_ (this),
    Exclude_ (this)
  {
  }

  FilterType::
  FilterType (const FilterType1_type& FilterType1)
  : ::xml_schema::type (),
    FilterType1_ (FilterType1, this),
    Include_ (this),
    Exclude_ (this)
  {
  }

  FilterType::
  FilterType (::std::unique_ptr< FilterType1_type > FilterType1)
  : ::xml_schema::type (),
    FilterType1_ (std::move (FilterType1), this),
    Include_ (this),
    Exclude_ (this)
  {
  }

  FilterType::
  FilterType (const FilterType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    FilterType1_ (x.FilterType1_, f, this),
    Include_ (x.Include_, f, this),
    Exclude_ (x.Exclude_, f, this)
  {
  }

  FilterType::
  FilterType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    FilterType1_ (this),
    Include_ (this),
    Exclude_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FilterType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FilterType
      //
      if (n.name () == "FilterType" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< FilterType1_type > r (
          FilterType1_traits::create (i, f, this));

        if (!FilterType1_.present ())
        {
          this->FilterType1_.set (::std::move (r));
          continue;
        }
      }

      // Include
      //
      if (n.name () == "Include" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Include_type > r (
          Include_traits::create (i, f, this));

        if (!this->Include_)
        {
          this->Include_.set (::std::move (r));
          continue;
        }
      }

      // Exclude
      //
      if (n.name () == "Exclude" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Exclude_type > r (
          Exclude_traits::create (i, f, this));

        if (!this->Exclude_)
        {
          this->Exclude_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!FilterType1_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "FilterType",
        "http://psidev.info/psi/pi/mzIdentML/1.1");
    }
  }

  FilterType* FilterType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FilterType (*this, f, c);
  }

  FilterType& FilterType::
  operator= (const FilterType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->FilterType1_ = x.FilterType1_;
      this->Include_ = x.Include_;
      this->Exclude_ = x.Exclude_;
    }

    return *this;
  }

  FilterType::
  ~FilterType ()
  {
  }

  // DatabaseFiltersType
  //

  DatabaseFiltersType::
  DatabaseFiltersType ()
  : ::xml_schema::type (),
    Filter_ (this)
  {
  }

  DatabaseFiltersType::
  DatabaseFiltersType (const DatabaseFiltersType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Filter_ (x.Filter_, f, this)
  {
  }

  DatabaseFiltersType::
  DatabaseFiltersType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Filter_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DatabaseFiltersType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Filter
      //
      if (n.name () == "Filter" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Filter_type > r (
          Filter_traits::create (i, f, this));

        this->Filter_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  DatabaseFiltersType* DatabaseFiltersType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DatabaseFiltersType (*this, f, c);
  }

  DatabaseFiltersType& DatabaseFiltersType::
  operator= (const DatabaseFiltersType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Filter_ = x.Filter_;
    }

    return *this;
  }

  DatabaseFiltersType::
  ~DatabaseFiltersType ()
  {
  }

  // TranslationTableType
  //

  TranslationTableType::
  TranslationTableType ()
  : ::mzIdentML110::IdentifiableType (),
    cvParam_ (this)
  {
  }

  TranslationTableType::
  TranslationTableType (const id_type& id)
  : ::mzIdentML110::IdentifiableType (id),
    cvParam_ (this)
  {
  }

  TranslationTableType::
  TranslationTableType (const TranslationTableType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    cvParam_ (x.cvParam_, f, this)
  {
  }

  TranslationTableType::
  TranslationTableType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    cvParam_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void TranslationTableType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  TranslationTableType* TranslationTableType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TranslationTableType (*this, f, c);
  }

  TranslationTableType& TranslationTableType::
  operator= (const TranslationTableType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->cvParam_ = x.cvParam_;
    }

    return *this;
  }

  TranslationTableType::
  ~TranslationTableType ()
  {
  }

  // DatabaseTranslationType
  //

  DatabaseTranslationType::
  DatabaseTranslationType ()
  : ::xml_schema::type (),
    TranslationTable_ (this),
    frames_ (this)
  {
  }

  DatabaseTranslationType::
  DatabaseTranslationType (const DatabaseTranslationType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    TranslationTable_ (x.TranslationTable_, f, this),
    frames_ (x.frames_, f, this)
  {
  }

  DatabaseTranslationType::
  DatabaseTranslationType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    TranslationTable_ (this),
    frames_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DatabaseTranslationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TranslationTable
      //
      if (n.name () == "TranslationTable" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< TranslationTable_type > r (
          TranslationTable_traits::create (i, f, this));

        this->TranslationTable_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "frames" && n.namespace_ ().empty ())
      {
        this->frames_.set (frames_traits::create (i, f, this));
        continue;
      }
    }
  }

  DatabaseTranslationType* DatabaseTranslationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DatabaseTranslationType (*this, f, c);
  }

  DatabaseTranslationType& DatabaseTranslationType::
  operator= (const DatabaseTranslationType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->TranslationTable_ = x.TranslationTable_;
      this->frames_ = x.frames_;
    }

    return *this;
  }

  DatabaseTranslationType::
  ~DatabaseTranslationType ()
  {
  }

  // SpectrumIdentificationProtocolType
  //

  SpectrumIdentificationProtocolType::
  SpectrumIdentificationProtocolType ()
  : ::mzIdentML110::IdentifiableType (),
    SearchType_ (this),
    AdditionalSearchParams_ (this),
    ModificationParams_ (this),
    Enzymes_ (this),
    MassTable_ (this),
    FragmentTolerance_ (this),
    ParentTolerance_ (this),
    Threshold_ (this),
    DatabaseFilters_ (this),
    DatabaseTranslation_ (this),
    analysisSoftware_ref_ (this)
  {
  }

  SpectrumIdentificationProtocolType::
  SpectrumIdentificationProtocolType (const id_type& id,
                                      const SearchType_type& SearchType,
                                      const Threshold_type& Threshold,
                                      const analysisSoftware_ref_type& analysisSoftware_ref)
  : ::mzIdentML110::IdentifiableType (id),
    SearchType_ (SearchType, this),
    AdditionalSearchParams_ (this),
    ModificationParams_ (this),
    Enzymes_ (this),
    MassTable_ (this),
    FragmentTolerance_ (this),
    ParentTolerance_ (this),
    Threshold_ (Threshold, this),
    DatabaseFilters_ (this),
    DatabaseTranslation_ (this),
    analysisSoftware_ref_ (analysisSoftware_ref, this)
  {
  }

  SpectrumIdentificationProtocolType::
  SpectrumIdentificationProtocolType (const id_type& id,
                                      ::std::unique_ptr< SearchType_type > SearchType,
                                      ::std::unique_ptr< Threshold_type > Threshold,
                                      const analysisSoftware_ref_type& analysisSoftware_ref)
  : ::mzIdentML110::IdentifiableType (id),
    SearchType_ (std::move (SearchType), this),
    AdditionalSearchParams_ (this),
    ModificationParams_ (this),
    Enzymes_ (this),
    MassTable_ (this),
    FragmentTolerance_ (this),
    ParentTolerance_ (this),
    Threshold_ (std::move (Threshold), this),
    DatabaseFilters_ (this),
    DatabaseTranslation_ (this),
    analysisSoftware_ref_ (analysisSoftware_ref, this)
  {
  }

  SpectrumIdentificationProtocolType::
  SpectrumIdentificationProtocolType (const SpectrumIdentificationProtocolType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    SearchType_ (x.SearchType_, f, this),
    AdditionalSearchParams_ (x.AdditionalSearchParams_, f, this),
    ModificationParams_ (x.ModificationParams_, f, this),
    Enzymes_ (x.Enzymes_, f, this),
    MassTable_ (x.MassTable_, f, this),
    FragmentTolerance_ (x.FragmentTolerance_, f, this),
    ParentTolerance_ (x.ParentTolerance_, f, this),
    Threshold_ (x.Threshold_, f, this),
    DatabaseFilters_ (x.DatabaseFilters_, f, this),
    DatabaseTranslation_ (x.DatabaseTranslation_, f, this),
    analysisSoftware_ref_ (x.analysisSoftware_ref_, f, this)
  {
  }

  SpectrumIdentificationProtocolType::
  SpectrumIdentificationProtocolType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    SearchType_ (this),
    AdditionalSearchParams_ (this),
    ModificationParams_ (this),
    Enzymes_ (this),
    MassTable_ (this),
    FragmentTolerance_ (this),
    ParentTolerance_ (this),
    Threshold_ (this),
    DatabaseFilters_ (this),
    DatabaseTranslation_ (this),
    analysisSoftware_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SpectrumIdentificationProtocolType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SearchType
      //
      if (n.name () == "SearchType" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< SearchType_type > r (
          SearchType_traits::create (i, f, this));

        if (!SearchType_.present ())
        {
          this->SearchType_.set (::std::move (r));
          continue;
        }
      }

      // AdditionalSearchParams
      //
      if (n.name () == "AdditionalSearchParams" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< AdditionalSearchParams_type > r (
          AdditionalSearchParams_traits::create (i, f, this));

        if (!this->AdditionalSearchParams_)
        {
          this->AdditionalSearchParams_.set (::std::move (r));
          continue;
        }
      }

      // ModificationParams
      //
      if (n.name () == "ModificationParams" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< ModificationParams_type > r (
          ModificationParams_traits::create (i, f, this));

        if (!this->ModificationParams_)
        {
          this->ModificationParams_.set (::std::move (r));
          continue;
        }
      }

      // Enzymes
      //
      if (n.name () == "Enzymes" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Enzymes_type > r (
          Enzymes_traits::create (i, f, this));

        if (!this->Enzymes_)
        {
          this->Enzymes_.set (::std::move (r));
          continue;
        }
      }

      // MassTable
      //
      if (n.name () == "MassTable" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< MassTable_type > r (
          MassTable_traits::create (i, f, this));

        this->MassTable_.push_back (::std::move (r));
        continue;
      }

      // FragmentTolerance
      //
      if (n.name () == "FragmentTolerance" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< FragmentTolerance_type > r (
          FragmentTolerance_traits::create (i, f, this));

        if (!this->FragmentTolerance_)
        {
          this->FragmentTolerance_.set (::std::move (r));
          continue;
        }
      }

      // ParentTolerance
      //
      if (n.name () == "ParentTolerance" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< ParentTolerance_type > r (
          ParentTolerance_traits::create (i, f, this));

        if (!this->ParentTolerance_)
        {
          this->ParentTolerance_.set (::std::move (r));
          continue;
        }
      }

      // Threshold
      //
      if (n.name () == "Threshold" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Threshold_type > r (
          Threshold_traits::create (i, f, this));

        if (!Threshold_.present ())
        {
          this->Threshold_.set (::std::move (r));
          continue;
        }
      }

      // DatabaseFilters
      //
      if (n.name () == "DatabaseFilters" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< DatabaseFilters_type > r (
          DatabaseFilters_traits::create (i, f, this));

        if (!this->DatabaseFilters_)
        {
          this->DatabaseFilters_.set (::std::move (r));
          continue;
        }
      }

      // DatabaseTranslation
      //
      if (n.name () == "DatabaseTranslation" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< DatabaseTranslation_type > r (
          DatabaseTranslation_traits::create (i, f, this));

        if (!this->DatabaseTranslation_)
        {
          this->DatabaseTranslation_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!SearchType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SearchType",
        "http://psidev.info/psi/pi/mzIdentML/1.1");
    }

    if (!Threshold_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Threshold",
        "http://psidev.info/psi/pi/mzIdentML/1.1");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "analysisSoftware_ref" && n.namespace_ ().empty ())
      {
        this->analysisSoftware_ref_.set (analysisSoftware_ref_traits::create (i, f, this));
        continue;
      }
    }

    if (!analysisSoftware_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "analysisSoftware_ref",
        "");
    }
  }

  SpectrumIdentificationProtocolType* SpectrumIdentificationProtocolType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpectrumIdentificationProtocolType (*this, f, c);
  }

  SpectrumIdentificationProtocolType& SpectrumIdentificationProtocolType::
  operator= (const SpectrumIdentificationProtocolType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->SearchType_ = x.SearchType_;
      this->AdditionalSearchParams_ = x.AdditionalSearchParams_;
      this->ModificationParams_ = x.ModificationParams_;
      this->Enzymes_ = x.Enzymes_;
      this->MassTable_ = x.MassTable_;
      this->FragmentTolerance_ = x.FragmentTolerance_;
      this->ParentTolerance_ = x.ParentTolerance_;
      this->Threshold_ = x.Threshold_;
      this->DatabaseFilters_ = x.DatabaseFilters_;
      this->DatabaseTranslation_ = x.DatabaseTranslation_;
      this->analysisSoftware_ref_ = x.analysisSoftware_ref_;
    }

    return *this;
  }

  SpectrumIdentificationProtocolType::
  ~SpectrumIdentificationProtocolType ()
  {
  }

  // InputSpectraType
  //

  InputSpectraType::
  InputSpectraType ()
  : ::xml_schema::type (),
    spectraData_ref_ (this)
  {
  }

  InputSpectraType::
  InputSpectraType (const InputSpectraType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    spectraData_ref_ (x.spectraData_ref_, f, this)
  {
  }

  InputSpectraType::
  InputSpectraType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    spectraData_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void InputSpectraType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "spectraData_ref" && n.namespace_ ().empty ())
      {
        this->spectraData_ref_.set (spectraData_ref_traits::create (i, f, this));
        continue;
      }
    }
  }

  InputSpectraType* InputSpectraType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InputSpectraType (*this, f, c);
  }

  InputSpectraType& InputSpectraType::
  operator= (const InputSpectraType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->spectraData_ref_ = x.spectraData_ref_;
    }

    return *this;
  }

  InputSpectraType::
  ~InputSpectraType ()
  {
  }

  // SearchDatabaseRefType
  //

  SearchDatabaseRefType::
  SearchDatabaseRefType ()
  : ::xml_schema::type (),
    searchDatabase_ref_ (this)
  {
  }

  SearchDatabaseRefType::
  SearchDatabaseRefType (const SearchDatabaseRefType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    searchDatabase_ref_ (x.searchDatabase_ref_, f, this)
  {
  }

  SearchDatabaseRefType::
  SearchDatabaseRefType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    searchDatabase_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void SearchDatabaseRefType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "searchDatabase_ref" && n.namespace_ ().empty ())
      {
        this->searchDatabase_ref_.set (searchDatabase_ref_traits::create (i, f, this));
        continue;
      }
    }
  }

  SearchDatabaseRefType* SearchDatabaseRefType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SearchDatabaseRefType (*this, f, c);
  }

  SearchDatabaseRefType& SearchDatabaseRefType::
  operator= (const SearchDatabaseRefType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->searchDatabase_ref_ = x.searchDatabase_ref_;
    }

    return *this;
  }

  SearchDatabaseRefType::
  ~SearchDatabaseRefType ()
  {
  }

  // ProtocolApplicationType
  //

  ProtocolApplicationType::
  ProtocolApplicationType ()
  : ::mzIdentML110::IdentifiableType (),
    activityDate_ (this)
  {
  }

  ProtocolApplicationType::
  ProtocolApplicationType (const id_type& id)
  : ::mzIdentML110::IdentifiableType (id),
    activityDate_ (this)
  {
  }

  ProtocolApplicationType::
  ProtocolApplicationType (const ProtocolApplicationType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    activityDate_ (x.activityDate_, f, this)
  {
  }

  ProtocolApplicationType::
  ProtocolApplicationType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    activityDate_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ProtocolApplicationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "activityDate" && n.namespace_ ().empty ())
      {
        this->activityDate_.set (activityDate_traits::create (i, f, this));
        continue;
      }
    }
  }

  ProtocolApplicationType* ProtocolApplicationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ProtocolApplicationType (*this, f, c);
  }

  ProtocolApplicationType& ProtocolApplicationType::
  operator= (const ProtocolApplicationType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->activityDate_ = x.activityDate_;
    }

    return *this;
  }

  ProtocolApplicationType::
  ~ProtocolApplicationType ()
  {
  }

  // SpectrumIdentificationType
  //

  SpectrumIdentificationType::
  SpectrumIdentificationType ()
  : ::mzIdentML110::ProtocolApplicationType (),
    InputSpectra_ (this),
    SearchDatabaseRef_ (this),
    spectrumIdentificationProtocol_ref_ (this),
    spectrumIdentificationList_ref_ (this)
  {
  }

  SpectrumIdentificationType::
  SpectrumIdentificationType (const id_type& id,
                              const spectrumIdentificationProtocol_ref_type& spectrumIdentificationProtocol_ref,
                              const spectrumIdentificationList_ref_type& spectrumIdentificationList_ref)
  : ::mzIdentML110::ProtocolApplicationType (id),
    InputSpectra_ (this),
    SearchDatabaseRef_ (this),
    spectrumIdentificationProtocol_ref_ (spectrumIdentificationProtocol_ref, this),
    spectrumIdentificationList_ref_ (spectrumIdentificationList_ref, this)
  {
  }

  SpectrumIdentificationType::
  SpectrumIdentificationType (const SpectrumIdentificationType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::mzIdentML110::ProtocolApplicationType (x, f, c),
    InputSpectra_ (x.InputSpectra_, f, this),
    SearchDatabaseRef_ (x.SearchDatabaseRef_, f, this),
    spectrumIdentificationProtocol_ref_ (x.spectrumIdentificationProtocol_ref_, f, this),
    spectrumIdentificationList_ref_ (x.spectrumIdentificationList_ref_, f, this)
  {
  }

  SpectrumIdentificationType::
  SpectrumIdentificationType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::mzIdentML110::ProtocolApplicationType (e, f | ::xml_schema::flags::base, c),
    InputSpectra_ (this),
    SearchDatabaseRef_ (this),
    spectrumIdentificationProtocol_ref_ (this),
    spectrumIdentificationList_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SpectrumIdentificationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::ProtocolApplicationType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // InputSpectra
      //
      if (n.name () == "InputSpectra" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< InputSpectra_type > r (
          InputSpectra_traits::create (i, f, this));

        this->InputSpectra_.push_back (::std::move (r));
        continue;
      }

      // SearchDatabaseRef
      //
      if (n.name () == "SearchDatabaseRef" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< SearchDatabaseRef_type > r (
          SearchDatabaseRef_traits::create (i, f, this));

        this->SearchDatabaseRef_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "spectrumIdentificationProtocol_ref" && n.namespace_ ().empty ())
      {
        this->spectrumIdentificationProtocol_ref_.set (spectrumIdentificationProtocol_ref_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "spectrumIdentificationList_ref" && n.namespace_ ().empty ())
      {
        this->spectrumIdentificationList_ref_.set (spectrumIdentificationList_ref_traits::create (i, f, this));
        continue;
      }
    }

    if (!spectrumIdentificationProtocol_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "spectrumIdentificationProtocol_ref",
        "");
    }

    if (!spectrumIdentificationList_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "spectrumIdentificationList_ref",
        "");
    }
  }

  SpectrumIdentificationType* SpectrumIdentificationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpectrumIdentificationType (*this, f, c);
  }

  SpectrumIdentificationType& SpectrumIdentificationType::
  operator= (const SpectrumIdentificationType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::ProtocolApplicationType& > (*this) = x;
      this->InputSpectra_ = x.InputSpectra_;
      this->SearchDatabaseRef_ = x.SearchDatabaseRef_;
      this->spectrumIdentificationProtocol_ref_ = x.spectrumIdentificationProtocol_ref_;
      this->spectrumIdentificationList_ref_ = x.spectrumIdentificationList_ref_;
    }

    return *this;
  }

  SpectrumIdentificationType::
  ~SpectrumIdentificationType ()
  {
  }

  // MeasureType
  //

  MeasureType::
  MeasureType ()
  : ::mzIdentML110::IdentifiableType (),
    cvParam_ (this)
  {
  }

  MeasureType::
  MeasureType (const id_type& id)
  : ::mzIdentML110::IdentifiableType (id),
    cvParam_ (this)
  {
  }

  MeasureType::
  MeasureType (const MeasureType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    cvParam_ (x.cvParam_, f, this)
  {
  }

  MeasureType::
  MeasureType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    cvParam_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MeasureType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  MeasureType* MeasureType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MeasureType (*this, f, c);
  }

  MeasureType& MeasureType::
  operator= (const MeasureType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->cvParam_ = x.cvParam_;
    }

    return *this;
  }

  MeasureType::
  ~MeasureType ()
  {
  }

  // FragmentationTableType
  //

  FragmentationTableType::
  FragmentationTableType ()
  : ::xml_schema::type (),
    Measure_ (this)
  {
  }

  FragmentationTableType::
  FragmentationTableType (const FragmentationTableType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Measure_ (x.Measure_, f, this)
  {
  }

  FragmentationTableType::
  FragmentationTableType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Measure_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FragmentationTableType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Measure
      //
      if (n.name () == "Measure" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Measure_type > r (
          Measure_traits::create (i, f, this));

        this->Measure_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  FragmentationTableType* FragmentationTableType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FragmentationTableType (*this, f, c);
  }

  FragmentationTableType& FragmentationTableType::
  operator= (const FragmentationTableType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Measure_ = x.Measure_;
    }

    return *this;
  }

  FragmentationTableType::
  ~FragmentationTableType ()
  {
  }

  // SpectrumIdentificationListType
  //

  SpectrumIdentificationListType::
  SpectrumIdentificationListType ()
  : ::mzIdentML110::IdentifiableType (),
    FragmentationTable_ (this),
    SpectrumIdentificationResult_ (this),
    cvParam_ (this),
    userParam_ (this),
    numSequencesSearched_ (this)
  {
  }

  SpectrumIdentificationListType::
  SpectrumIdentificationListType (const id_type& id)
  : ::mzIdentML110::IdentifiableType (id),
    FragmentationTable_ (this),
    SpectrumIdentificationResult_ (this),
    cvParam_ (this),
    userParam_ (this),
    numSequencesSearched_ (this)
  {
  }

  SpectrumIdentificationListType::
  SpectrumIdentificationListType (const SpectrumIdentificationListType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    FragmentationTable_ (x.FragmentationTable_, f, this),
    SpectrumIdentificationResult_ (x.SpectrumIdentificationResult_, f, this),
    cvParam_ (x.cvParam_, f, this),
    userParam_ (x.userParam_, f, this),
    numSequencesSearched_ (x.numSequencesSearched_, f, this)
  {
  }

  SpectrumIdentificationListType::
  SpectrumIdentificationListType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    FragmentationTable_ (this),
    SpectrumIdentificationResult_ (this),
    cvParam_ (this),
    userParam_ (this),
    numSequencesSearched_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SpectrumIdentificationListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FragmentationTable
      //
      if (n.name () == "FragmentationTable" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< FragmentationTable_type > r (
          FragmentationTable_traits::create (i, f, this));

        if (!this->FragmentationTable_)
        {
          this->FragmentationTable_.set (::std::move (r));
          continue;
        }
      }

      // SpectrumIdentificationResult
      //
      if (n.name () == "SpectrumIdentificationResult" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< SpectrumIdentificationResult_type > r (
          SpectrumIdentificationResult_traits::create (i, f, this));

        this->SpectrumIdentificationResult_.push_back (::std::move (r));
        continue;
      }

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      // userParam
      //
      if (n.name () == "userParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< userParam_type > r (
          userParam_traits::create (i, f, this));

        this->userParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "numSequencesSearched" && n.namespace_ ().empty ())
      {
        this->numSequencesSearched_.set (numSequencesSearched_traits::create (i, f, this));
        continue;
      }
    }
  }

  SpectrumIdentificationListType* SpectrumIdentificationListType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpectrumIdentificationListType (*this, f, c);
  }

  SpectrumIdentificationListType& SpectrumIdentificationListType::
  operator= (const SpectrumIdentificationListType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->FragmentationTable_ = x.FragmentationTable_;
      this->SpectrumIdentificationResult_ = x.SpectrumIdentificationResult_;
      this->cvParam_ = x.cvParam_;
      this->userParam_ = x.userParam_;
      this->numSequencesSearched_ = x.numSequencesSearched_;
    }

    return *this;
  }

  SpectrumIdentificationListType::
  ~SpectrumIdentificationListType ()
  {
  }

  // SpecificityRulesType
  //

  SpecificityRulesType::
  SpecificityRulesType ()
  : ::xml_schema::type (),
    cvParam_ (this)
  {
  }

  SpecificityRulesType::
  SpecificityRulesType (const SpecificityRulesType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    cvParam_ (x.cvParam_, f, this)
  {
  }

  SpecificityRulesType::
  SpecificityRulesType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    cvParam_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SpecificityRulesType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  SpecificityRulesType* SpecificityRulesType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpecificityRulesType (*this, f, c);
  }

  SpecificityRulesType& SpecificityRulesType::
  operator= (const SpecificityRulesType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->cvParam_ = x.cvParam_;
    }

    return *this;
  }

  SpecificityRulesType::
  ~SpecificityRulesType ()
  {
  }

  // SearchModificationType
  //

  SearchModificationType::
  SearchModificationType ()
  : ::xml_schema::type (),
    SpecificityRules_ (this),
    cvParam_ (this),
    fixedMod_ (this),
    massDelta_ (this),
    residues_ (this)
  {
  }

  SearchModificationType::
  SearchModificationType (const fixedMod_type& fixedMod,
                          const massDelta_type& massDelta,
                          const residues_type& residues)
  : ::xml_schema::type (),
    SpecificityRules_ (this),
    cvParam_ (this),
    fixedMod_ (fixedMod, this),
    massDelta_ (massDelta, this),
    residues_ (residues, this)
  {
  }

  SearchModificationType::
  SearchModificationType (const SearchModificationType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    SpecificityRules_ (x.SpecificityRules_, f, this),
    cvParam_ (x.cvParam_, f, this),
    fixedMod_ (x.fixedMod_, f, this),
    massDelta_ (x.massDelta_, f, this),
    residues_ (x.residues_, f, this)
  {
  }

  SearchModificationType::
  SearchModificationType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    SpecificityRules_ (this),
    cvParam_ (this),
    fixedMod_ (this),
    massDelta_ (this),
    residues_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SearchModificationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SpecificityRules
      //
      if (n.name () == "SpecificityRules" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< SpecificityRules_type > r (
          SpecificityRules_traits::create (i, f, this));

        this->SpecificityRules_.push_back (::std::move (r));
        continue;
      }

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "fixedMod" && n.namespace_ ().empty ())
      {
        this->fixedMod_.set (fixedMod_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "massDelta" && n.namespace_ ().empty ())
      {
        this->massDelta_.set (massDelta_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "residues" && n.namespace_ ().empty ())
      {
        this->residues_.set (residues_traits::create (i, f, this));
        continue;
      }
    }

    if (!fixedMod_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "fixedMod",
        "");
    }

    if (!massDelta_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "massDelta",
        "");
    }

    if (!residues_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "residues",
        "");
    }
  }

  SearchModificationType* SearchModificationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SearchModificationType (*this, f, c);
  }

  SearchModificationType& SearchModificationType::
  operator= (const SearchModificationType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->SpecificityRules_ = x.SpecificityRules_;
      this->cvParam_ = x.cvParam_;
      this->fixedMod_ = x.fixedMod_;
      this->massDelta_ = x.massDelta_;
      this->residues_ = x.residues_;
    }

    return *this;
  }

  SearchModificationType::
  ~SearchModificationType ()
  {
  }

  // FragmentArrayType
  //

  FragmentArrayType::
  FragmentArrayType ()
  : ::xml_schema::type (),
    values_ (this),
    measure_ref_ (this)
  {
  }

  FragmentArrayType::
  FragmentArrayType (const values_type& values,
                     const measure_ref_type& measure_ref)
  : ::xml_schema::type (),
    values_ (values, this),
    measure_ref_ (measure_ref, this)
  {
  }

  FragmentArrayType::
  FragmentArrayType (const FragmentArrayType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    values_ (x.values_, f, this),
    measure_ref_ (x.measure_ref_, f, this)
  {
  }

  FragmentArrayType::
  FragmentArrayType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    values_ (this),
    measure_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void FragmentArrayType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "values" && n.namespace_ ().empty ())
      {
        this->values_.set (values_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "measure_ref" && n.namespace_ ().empty ())
      {
        this->measure_ref_.set (measure_ref_traits::create (i, f, this));
        continue;
      }
    }

    if (!values_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "values",
        "");
    }

    if (!measure_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "measure_ref",
        "");
    }
  }

  FragmentArrayType* FragmentArrayType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FragmentArrayType (*this, f, c);
  }

  FragmentArrayType& FragmentArrayType::
  operator= (const FragmentArrayType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->values_ = x.values_;
      this->measure_ref_ = x.measure_ref_;
    }

    return *this;
  }

  FragmentArrayType::
  ~FragmentArrayType ()
  {
  }

  // IonTypeType
  //

  IonTypeType::
  IonTypeType ()
  : ::xml_schema::type (),
    FragmentArray_ (this),
    cvParam_ (this),
    index_ (this),
    charge_ (this)
  {
  }

  IonTypeType::
  IonTypeType (const cvParam_type& cvParam,
               const charge_type& charge)
  : ::xml_schema::type (),
    FragmentArray_ (this),
    cvParam_ (cvParam, this),
    index_ (this),
    charge_ (charge, this)
  {
  }

  IonTypeType::
  IonTypeType (::std::unique_ptr< cvParam_type > cvParam,
               const charge_type& charge)
  : ::xml_schema::type (),
    FragmentArray_ (this),
    cvParam_ (std::move (cvParam), this),
    index_ (this),
    charge_ (charge, this)
  {
  }

  IonTypeType::
  IonTypeType (const IonTypeType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    FragmentArray_ (x.FragmentArray_, f, this),
    cvParam_ (x.cvParam_, f, this),
    index_ (x.index_, f, this),
    charge_ (x.charge_, f, this)
  {
  }

  IonTypeType::
  IonTypeType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    FragmentArray_ (this),
    cvParam_ (this),
    index_ (this),
    charge_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void IonTypeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FragmentArray
      //
      if (n.name () == "FragmentArray" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< FragmentArray_type > r (
          FragmentArray_traits::create (i, f, this));

        this->FragmentArray_.push_back (::std::move (r));
        continue;
      }

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        if (!cvParam_.present ())
        {
          this->cvParam_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!cvParam_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "cvParam",
        "http://psidev.info/psi/pi/mzIdentML/1.1");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "index" && n.namespace_ ().empty ())
      {
        this->index_.set (index_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "charge" && n.namespace_ ().empty ())
      {
        this->charge_.set (charge_traits::create (i, f, this));
        continue;
      }
    }

    if (!charge_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "charge",
        "");
    }
  }

  IonTypeType* IonTypeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IonTypeType (*this, f, c);
  }

  IonTypeType& IonTypeType::
  operator= (const IonTypeType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->FragmentArray_ = x.FragmentArray_;
      this->cvParam_ = x.cvParam_;
      this->index_ = x.index_;
      this->charge_ = x.charge_;
    }

    return *this;
  }

  IonTypeType::
  ~IonTypeType ()
  {
  }

  // FragmentationType
  //

  FragmentationType::
  FragmentationType ()
  : ::xml_schema::type (),
    IonType_ (this)
  {
  }

  FragmentationType::
  FragmentationType (const FragmentationType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    IonType_ (x.IonType_, f, this)
  {
  }

  FragmentationType::
  FragmentationType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    IonType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FragmentationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // IonType
      //
      if (n.name () == "IonType" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< IonType_type > r (
          IonType_traits::create (i, f, this));

        this->IonType_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  FragmentationType* FragmentationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FragmentationType (*this, f, c);
  }

  FragmentationType& FragmentationType::
  operator= (const FragmentationType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->IonType_ = x.IonType_;
    }

    return *this;
  }

  FragmentationType::
  ~FragmentationType ()
  {
  }

  // PeptideEvidenceRefType
  //

  PeptideEvidenceRefType::
  PeptideEvidenceRefType ()
  : ::xml_schema::type (),
    peptideEvidence_ref_ (this)
  {
  }

  PeptideEvidenceRefType::
  PeptideEvidenceRefType (const peptideEvidence_ref_type& peptideEvidence_ref)
  : ::xml_schema::type (),
    peptideEvidence_ref_ (peptideEvidence_ref, this)
  {
  }

  PeptideEvidenceRefType::
  PeptideEvidenceRefType (const PeptideEvidenceRefType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    peptideEvidence_ref_ (x.peptideEvidence_ref_, f, this)
  {
  }

  PeptideEvidenceRefType::
  PeptideEvidenceRefType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    peptideEvidence_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void PeptideEvidenceRefType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "peptideEvidence_ref" && n.namespace_ ().empty ())
      {
        this->peptideEvidence_ref_.set (peptideEvidence_ref_traits::create (i, f, this));
        continue;
      }
    }

    if (!peptideEvidence_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "peptideEvidence_ref",
        "");
    }
  }

  PeptideEvidenceRefType* PeptideEvidenceRefType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PeptideEvidenceRefType (*this, f, c);
  }

  PeptideEvidenceRefType& PeptideEvidenceRefType::
  operator= (const PeptideEvidenceRefType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->peptideEvidence_ref_ = x.peptideEvidence_ref_;
    }

    return *this;
  }

  PeptideEvidenceRefType::
  ~PeptideEvidenceRefType ()
  {
  }

  // SpectrumIdentificationItemType
  //

  SpectrumIdentificationItemType::
  SpectrumIdentificationItemType ()
  : ::mzIdentML110::IdentifiableType (),
    PeptideEvidenceRef_ (this),
    Fragmentation_ (this),
    cvParam_ (this),
    userParam_ (this),
    chargeState_ (this),
    experimentalMassToCharge_ (this),
    calculatedMassToCharge_ (this),
    calculatedPI_ (this),
    peptide_ref_ (this),
    rank_ (this),
    passThreshold_ (this),
    massTable_ref_ (this),
    sample_ref_ (this)
  {
  }

  SpectrumIdentificationItemType::
  SpectrumIdentificationItemType (const id_type& id,
                                  const chargeState_type& chargeState,
                                  const experimentalMassToCharge_type& experimentalMassToCharge,
                                  const rank_type& rank,
                                  const passThreshold_type& passThreshold)
  : ::mzIdentML110::IdentifiableType (id),
    PeptideEvidenceRef_ (this),
    Fragmentation_ (this),
    cvParam_ (this),
    userParam_ (this),
    chargeState_ (chargeState, this),
    experimentalMassToCharge_ (experimentalMassToCharge, this),
    calculatedMassToCharge_ (this),
    calculatedPI_ (this),
    peptide_ref_ (this),
    rank_ (rank, this),
    passThreshold_ (passThreshold, this),
    massTable_ref_ (this),
    sample_ref_ (this)
  {
  }

  SpectrumIdentificationItemType::
  SpectrumIdentificationItemType (const SpectrumIdentificationItemType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    PeptideEvidenceRef_ (x.PeptideEvidenceRef_, f, this),
    Fragmentation_ (x.Fragmentation_, f, this),
    cvParam_ (x.cvParam_, f, this),
    userParam_ (x.userParam_, f, this),
    chargeState_ (x.chargeState_, f, this),
    experimentalMassToCharge_ (x.experimentalMassToCharge_, f, this),
    calculatedMassToCharge_ (x.calculatedMassToCharge_, f, this),
    calculatedPI_ (x.calculatedPI_, f, this),
    peptide_ref_ (x.peptide_ref_, f, this),
    rank_ (x.rank_, f, this),
    passThreshold_ (x.passThreshold_, f, this),
    massTable_ref_ (x.massTable_ref_, f, this),
    sample_ref_ (x.sample_ref_, f, this)
  {
  }

  SpectrumIdentificationItemType::
  SpectrumIdentificationItemType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    PeptideEvidenceRef_ (this),
    Fragmentation_ (this),
    cvParam_ (this),
    userParam_ (this),
    chargeState_ (this),
    experimentalMassToCharge_ (this),
    calculatedMassToCharge_ (this),
    calculatedPI_ (this),
    peptide_ref_ (this),
    rank_ (this),
    passThreshold_ (this),
    massTable_ref_ (this),
    sample_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SpectrumIdentificationItemType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PeptideEvidenceRef
      //
      if (n.name () == "PeptideEvidenceRef" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< PeptideEvidenceRef_type > r (
          PeptideEvidenceRef_traits::create (i, f, this));

        this->PeptideEvidenceRef_.push_back (::std::move (r));
        continue;
      }

      // Fragmentation
      //
      if (n.name () == "Fragmentation" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Fragmentation_type > r (
          Fragmentation_traits::create (i, f, this));

        if (!this->Fragmentation_)
        {
          this->Fragmentation_.set (::std::move (r));
          continue;
        }
      }

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      // userParam
      //
      if (n.name () == "userParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< userParam_type > r (
          userParam_traits::create (i, f, this));

        this->userParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "chargeState" && n.namespace_ ().empty ())
      {
        this->chargeState_.set (chargeState_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "experimentalMassToCharge" && n.namespace_ ().empty ())
      {
        this->experimentalMassToCharge_.set (experimentalMassToCharge_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "calculatedMassToCharge" && n.namespace_ ().empty ())
      {
        this->calculatedMassToCharge_.set (calculatedMassToCharge_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "calculatedPI" && n.namespace_ ().empty ())
      {
        this->calculatedPI_.set (calculatedPI_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "peptide_ref" && n.namespace_ ().empty ())
      {
        this->peptide_ref_.set (peptide_ref_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "rank" && n.namespace_ ().empty ())
      {
        this->rank_.set (rank_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "passThreshold" && n.namespace_ ().empty ())
      {
        this->passThreshold_.set (passThreshold_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "massTable_ref" && n.namespace_ ().empty ())
      {
        this->massTable_ref_.set (massTable_ref_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sample_ref" && n.namespace_ ().empty ())
      {
        this->sample_ref_.set (sample_ref_traits::create (i, f, this));
        continue;
      }
    }

    if (!chargeState_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "chargeState",
        "");
    }

    if (!experimentalMassToCharge_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "experimentalMassToCharge",
        "");
    }

    if (!rank_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "rank",
        "");
    }

    if (!passThreshold_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "passThreshold",
        "");
    }
  }

  SpectrumIdentificationItemType* SpectrumIdentificationItemType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpectrumIdentificationItemType (*this, f, c);
  }

  SpectrumIdentificationItemType& SpectrumIdentificationItemType::
  operator= (const SpectrumIdentificationItemType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->PeptideEvidenceRef_ = x.PeptideEvidenceRef_;
      this->Fragmentation_ = x.Fragmentation_;
      this->cvParam_ = x.cvParam_;
      this->userParam_ = x.userParam_;
      this->chargeState_ = x.chargeState_;
      this->experimentalMassToCharge_ = x.experimentalMassToCharge_;
      this->calculatedMassToCharge_ = x.calculatedMassToCharge_;
      this->calculatedPI_ = x.calculatedPI_;
      this->peptide_ref_ = x.peptide_ref_;
      this->rank_ = x.rank_;
      this->passThreshold_ = x.passThreshold_;
      this->massTable_ref_ = x.massTable_ref_;
      this->sample_ref_ = x.sample_ref_;
    }

    return *this;
  }

  SpectrumIdentificationItemType::
  ~SpectrumIdentificationItemType ()
  {
  }

  // SpectrumIdentificationResultType
  //

  SpectrumIdentificationResultType::
  SpectrumIdentificationResultType ()
  : ::mzIdentML110::IdentifiableType (),
    SpectrumIdentificationItem_ (this),
    cvParam_ (this),
    userParam_ (this),
    spectrumID_ (this),
    spectraData_ref_ (this)
  {
  }

  SpectrumIdentificationResultType::
  SpectrumIdentificationResultType (const id_type& id,
                                    const spectrumID_type& spectrumID,
                                    const spectraData_ref_type& spectraData_ref)
  : ::mzIdentML110::IdentifiableType (id),
    SpectrumIdentificationItem_ (this),
    cvParam_ (this),
    userParam_ (this),
    spectrumID_ (spectrumID, this),
    spectraData_ref_ (spectraData_ref, this)
  {
  }

  SpectrumIdentificationResultType::
  SpectrumIdentificationResultType (const SpectrumIdentificationResultType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    SpectrumIdentificationItem_ (x.SpectrumIdentificationItem_, f, this),
    cvParam_ (x.cvParam_, f, this),
    userParam_ (x.userParam_, f, this),
    spectrumID_ (x.spectrumID_, f, this),
    spectraData_ref_ (x.spectraData_ref_, f, this)
  {
  }

  SpectrumIdentificationResultType::
  SpectrumIdentificationResultType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    SpectrumIdentificationItem_ (this),
    cvParam_ (this),
    userParam_ (this),
    spectrumID_ (this),
    spectraData_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SpectrumIdentificationResultType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SpectrumIdentificationItem
      //
      if (n.name () == "SpectrumIdentificationItem" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< SpectrumIdentificationItem_type > r (
          SpectrumIdentificationItem_traits::create (i, f, this));

        this->SpectrumIdentificationItem_.push_back (::std::move (r));
        continue;
      }

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      // userParam
      //
      if (n.name () == "userParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< userParam_type > r (
          userParam_traits::create (i, f, this));

        this->userParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "spectrumID" && n.namespace_ ().empty ())
      {
        this->spectrumID_.set (spectrumID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "spectraData_ref" && n.namespace_ ().empty ())
      {
        this->spectraData_ref_.set (spectraData_ref_traits::create (i, f, this));
        continue;
      }
    }

    if (!spectrumID_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "spectrumID",
        "");
    }

    if (!spectraData_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "spectraData_ref",
        "");
    }
  }

  SpectrumIdentificationResultType* SpectrumIdentificationResultType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpectrumIdentificationResultType (*this, f, c);
  }

  SpectrumIdentificationResultType& SpectrumIdentificationResultType::
  operator= (const SpectrumIdentificationResultType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->SpectrumIdentificationItem_ = x.SpectrumIdentificationItem_;
      this->cvParam_ = x.cvParam_;
      this->userParam_ = x.userParam_;
      this->spectrumID_ = x.spectrumID_;
      this->spectraData_ref_ = x.spectraData_ref_;
    }

    return *this;
  }

  SpectrumIdentificationResultType::
  ~SpectrumIdentificationResultType ()
  {
  }

  // InputSpectrumIdentificationsType
  //

  InputSpectrumIdentificationsType::
  InputSpectrumIdentificationsType ()
  : ::xml_schema::type (),
    spectrumIdentificationList_ref_ (this)
  {
  }

  InputSpectrumIdentificationsType::
  InputSpectrumIdentificationsType (const spectrumIdentificationList_ref_type& spectrumIdentificationList_ref)
  : ::xml_schema::type (),
    spectrumIdentificationList_ref_ (spectrumIdentificationList_ref, this)
  {
  }

  InputSpectrumIdentificationsType::
  InputSpectrumIdentificationsType (const InputSpectrumIdentificationsType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    spectrumIdentificationList_ref_ (x.spectrumIdentificationList_ref_, f, this)
  {
  }

  InputSpectrumIdentificationsType::
  InputSpectrumIdentificationsType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    spectrumIdentificationList_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void InputSpectrumIdentificationsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "spectrumIdentificationList_ref" && n.namespace_ ().empty ())
      {
        this->spectrumIdentificationList_ref_.set (spectrumIdentificationList_ref_traits::create (i, f, this));
        continue;
      }
    }

    if (!spectrumIdentificationList_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "spectrumIdentificationList_ref",
        "");
    }
  }

  InputSpectrumIdentificationsType* InputSpectrumIdentificationsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InputSpectrumIdentificationsType (*this, f, c);
  }

  InputSpectrumIdentificationsType& InputSpectrumIdentificationsType::
  operator= (const InputSpectrumIdentificationsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->spectrumIdentificationList_ref_ = x.spectrumIdentificationList_ref_;
    }

    return *this;
  }

  InputSpectrumIdentificationsType::
  ~InputSpectrumIdentificationsType ()
  {
  }

  // ProteinDetectionType
  //

  ProteinDetectionType::
  ProteinDetectionType ()
  : ::mzIdentML110::ProtocolApplicationType (),
    InputSpectrumIdentifications_ (this),
    proteinDetectionList_ref_ (this),
    proteinDetectionProtocol_ref_ (this)
  {
  }

  ProteinDetectionType::
  ProteinDetectionType (const id_type& id,
                        const proteinDetectionList_ref_type& proteinDetectionList_ref,
                        const proteinDetectionProtocol_ref_type& proteinDetectionProtocol_ref)
  : ::mzIdentML110::ProtocolApplicationType (id),
    InputSpectrumIdentifications_ (this),
    proteinDetectionList_ref_ (proteinDetectionList_ref, this),
    proteinDetectionProtocol_ref_ (proteinDetectionProtocol_ref, this)
  {
  }

  ProteinDetectionType::
  ProteinDetectionType (const ProteinDetectionType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::mzIdentML110::ProtocolApplicationType (x, f, c),
    InputSpectrumIdentifications_ (x.InputSpectrumIdentifications_, f, this),
    proteinDetectionList_ref_ (x.proteinDetectionList_ref_, f, this),
    proteinDetectionProtocol_ref_ (x.proteinDetectionProtocol_ref_, f, this)
  {
  }

  ProteinDetectionType::
  ProteinDetectionType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::mzIdentML110::ProtocolApplicationType (e, f | ::xml_schema::flags::base, c),
    InputSpectrumIdentifications_ (this),
    proteinDetectionList_ref_ (this),
    proteinDetectionProtocol_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ProteinDetectionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::ProtocolApplicationType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // InputSpectrumIdentifications
      //
      if (n.name () == "InputSpectrumIdentifications" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< InputSpectrumIdentifications_type > r (
          InputSpectrumIdentifications_traits::create (i, f, this));

        this->InputSpectrumIdentifications_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "proteinDetectionList_ref" && n.namespace_ ().empty ())
      {
        this->proteinDetectionList_ref_.set (proteinDetectionList_ref_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "proteinDetectionProtocol_ref" && n.namespace_ ().empty ())
      {
        this->proteinDetectionProtocol_ref_.set (proteinDetectionProtocol_ref_traits::create (i, f, this));
        continue;
      }
    }

    if (!proteinDetectionList_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "proteinDetectionList_ref",
        "");
    }

    if (!proteinDetectionProtocol_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "proteinDetectionProtocol_ref",
        "");
    }
  }

  ProteinDetectionType* ProteinDetectionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ProteinDetectionType (*this, f, c);
  }

  ProteinDetectionType& ProteinDetectionType::
  operator= (const ProteinDetectionType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::ProtocolApplicationType& > (*this) = x;
      this->InputSpectrumIdentifications_ = x.InputSpectrumIdentifications_;
      this->proteinDetectionList_ref_ = x.proteinDetectionList_ref_;
      this->proteinDetectionProtocol_ref_ = x.proteinDetectionProtocol_ref_;
    }

    return *this;
  }

  ProteinDetectionType::
  ~ProteinDetectionType ()
  {
  }

  // ProteinDetectionProtocolType
  //

  ProteinDetectionProtocolType::
  ProteinDetectionProtocolType ()
  : ::mzIdentML110::IdentifiableType (),
    AnalysisParams_ (this),
    Threshold_ (this),
    analysisSoftware_ref_ (this)
  {
  }

  ProteinDetectionProtocolType::
  ProteinDetectionProtocolType (const id_type& id,
                                const Threshold_type& Threshold,
                                const analysisSoftware_ref_type& analysisSoftware_ref)
  : ::mzIdentML110::IdentifiableType (id),
    AnalysisParams_ (this),
    Threshold_ (Threshold, this),
    analysisSoftware_ref_ (analysisSoftware_ref, this)
  {
  }

  ProteinDetectionProtocolType::
  ProteinDetectionProtocolType (const id_type& id,
                                ::std::unique_ptr< Threshold_type > Threshold,
                                const analysisSoftware_ref_type& analysisSoftware_ref)
  : ::mzIdentML110::IdentifiableType (id),
    AnalysisParams_ (this),
    Threshold_ (std::move (Threshold), this),
    analysisSoftware_ref_ (analysisSoftware_ref, this)
  {
  }

  ProteinDetectionProtocolType::
  ProteinDetectionProtocolType (const ProteinDetectionProtocolType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    AnalysisParams_ (x.AnalysisParams_, f, this),
    Threshold_ (x.Threshold_, f, this),
    analysisSoftware_ref_ (x.analysisSoftware_ref_, f, this)
  {
  }

  ProteinDetectionProtocolType::
  ProteinDetectionProtocolType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    AnalysisParams_ (this),
    Threshold_ (this),
    analysisSoftware_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ProteinDetectionProtocolType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AnalysisParams
      //
      if (n.name () == "AnalysisParams" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< AnalysisParams_type > r (
          AnalysisParams_traits::create (i, f, this));

        if (!this->AnalysisParams_)
        {
          this->AnalysisParams_.set (::std::move (r));
          continue;
        }
      }

      // Threshold
      //
      if (n.name () == "Threshold" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Threshold_type > r (
          Threshold_traits::create (i, f, this));

        if (!Threshold_.present ())
        {
          this->Threshold_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!Threshold_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Threshold",
        "http://psidev.info/psi/pi/mzIdentML/1.1");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "analysisSoftware_ref" && n.namespace_ ().empty ())
      {
        this->analysisSoftware_ref_.set (analysisSoftware_ref_traits::create (i, f, this));
        continue;
      }
    }

    if (!analysisSoftware_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "analysisSoftware_ref",
        "");
    }
  }

  ProteinDetectionProtocolType* ProteinDetectionProtocolType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ProteinDetectionProtocolType (*this, f, c);
  }

  ProteinDetectionProtocolType& ProteinDetectionProtocolType::
  operator= (const ProteinDetectionProtocolType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->AnalysisParams_ = x.AnalysisParams_;
      this->Threshold_ = x.Threshold_;
      this->analysisSoftware_ref_ = x.analysisSoftware_ref_;
    }

    return *this;
  }

  ProteinDetectionProtocolType::
  ~ProteinDetectionProtocolType ()
  {
  }

  // ProteinDetectionListType
  //

  ProteinDetectionListType::
  ProteinDetectionListType ()
  : ::mzIdentML110::IdentifiableType (),
    ProteinAmbiguityGroup_ (this),
    cvParam_ (this),
    userParam_ (this)
  {
  }

  ProteinDetectionListType::
  ProteinDetectionListType (const id_type& id)
  : ::mzIdentML110::IdentifiableType (id),
    ProteinAmbiguityGroup_ (this),
    cvParam_ (this),
    userParam_ (this)
  {
  }

  ProteinDetectionListType::
  ProteinDetectionListType (const ProteinDetectionListType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    ProteinAmbiguityGroup_ (x.ProteinAmbiguityGroup_, f, this),
    cvParam_ (x.cvParam_, f, this),
    userParam_ (x.userParam_, f, this)
  {
  }

  ProteinDetectionListType::
  ProteinDetectionListType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    ProteinAmbiguityGroup_ (this),
    cvParam_ (this),
    userParam_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ProteinDetectionListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ProteinAmbiguityGroup
      //
      if (n.name () == "ProteinAmbiguityGroup" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< ProteinAmbiguityGroup_type > r (
          ProteinAmbiguityGroup_traits::create (i, f, this));

        this->ProteinAmbiguityGroup_.push_back (::std::move (r));
        continue;
      }

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      // userParam
      //
      if (n.name () == "userParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< userParam_type > r (
          userParam_traits::create (i, f, this));

        this->userParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ProteinDetectionListType* ProteinDetectionListType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ProteinDetectionListType (*this, f, c);
  }

  ProteinDetectionListType& ProteinDetectionListType::
  operator= (const ProteinDetectionListType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->ProteinAmbiguityGroup_ = x.ProteinAmbiguityGroup_;
      this->cvParam_ = x.cvParam_;
      this->userParam_ = x.userParam_;
    }

    return *this;
  }

  ProteinDetectionListType::
  ~ProteinDetectionListType ()
  {
  }

  // SpectrumIdentificationItemRefType
  //

  SpectrumIdentificationItemRefType::
  SpectrumIdentificationItemRefType ()
  : ::xml_schema::type (),
    spectrumIdentificationItem_ref_ (this)
  {
  }

  SpectrumIdentificationItemRefType::
  SpectrumIdentificationItemRefType (const spectrumIdentificationItem_ref_type& spectrumIdentificationItem_ref)
  : ::xml_schema::type (),
    spectrumIdentificationItem_ref_ (spectrumIdentificationItem_ref, this)
  {
  }

  SpectrumIdentificationItemRefType::
  SpectrumIdentificationItemRefType (const SpectrumIdentificationItemRefType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    spectrumIdentificationItem_ref_ (x.spectrumIdentificationItem_ref_, f, this)
  {
  }

  SpectrumIdentificationItemRefType::
  SpectrumIdentificationItemRefType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    spectrumIdentificationItem_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void SpectrumIdentificationItemRefType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "spectrumIdentificationItem_ref" && n.namespace_ ().empty ())
      {
        this->spectrumIdentificationItem_ref_.set (spectrumIdentificationItem_ref_traits::create (i, f, this));
        continue;
      }
    }

    if (!spectrumIdentificationItem_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "spectrumIdentificationItem_ref",
        "");
    }
  }

  SpectrumIdentificationItemRefType* SpectrumIdentificationItemRefType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpectrumIdentificationItemRefType (*this, f, c);
  }

  SpectrumIdentificationItemRefType& SpectrumIdentificationItemRefType::
  operator= (const SpectrumIdentificationItemRefType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->spectrumIdentificationItem_ref_ = x.spectrumIdentificationItem_ref_;
    }

    return *this;
  }

  SpectrumIdentificationItemRefType::
  ~SpectrumIdentificationItemRefType ()
  {
  }

  // PeptideHypothesisType
  //

  PeptideHypothesisType::
  PeptideHypothesisType ()
  : ::xml_schema::type (),
    SpectrumIdentificationItemRef_ (this),
    peptideEvidence_ref_ (this)
  {
  }

  PeptideHypothesisType::
  PeptideHypothesisType (const peptideEvidence_ref_type& peptideEvidence_ref)
  : ::xml_schema::type (),
    SpectrumIdentificationItemRef_ (this),
    peptideEvidence_ref_ (peptideEvidence_ref, this)
  {
  }

  PeptideHypothesisType::
  PeptideHypothesisType (const PeptideHypothesisType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    SpectrumIdentificationItemRef_ (x.SpectrumIdentificationItemRef_, f, this),
    peptideEvidence_ref_ (x.peptideEvidence_ref_, f, this)
  {
  }

  PeptideHypothesisType::
  PeptideHypothesisType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    SpectrumIdentificationItemRef_ (this),
    peptideEvidence_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void PeptideHypothesisType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SpectrumIdentificationItemRef
      //
      if (n.name () == "SpectrumIdentificationItemRef" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< SpectrumIdentificationItemRef_type > r (
          SpectrumIdentificationItemRef_traits::create (i, f, this));

        this->SpectrumIdentificationItemRef_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "peptideEvidence_ref" && n.namespace_ ().empty ())
      {
        this->peptideEvidence_ref_.set (peptideEvidence_ref_traits::create (i, f, this));
        continue;
      }
    }

    if (!peptideEvidence_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "peptideEvidence_ref",
        "");
    }
  }

  PeptideHypothesisType* PeptideHypothesisType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PeptideHypothesisType (*this, f, c);
  }

  PeptideHypothesisType& PeptideHypothesisType::
  operator= (const PeptideHypothesisType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->SpectrumIdentificationItemRef_ = x.SpectrumIdentificationItemRef_;
      this->peptideEvidence_ref_ = x.peptideEvidence_ref_;
    }

    return *this;
  }

  PeptideHypothesisType::
  ~PeptideHypothesisType ()
  {
  }

  // ProteinDetectionHypothesisType
  //

  ProteinDetectionHypothesisType::
  ProteinDetectionHypothesisType ()
  : ::mzIdentML110::IdentifiableType (),
    PeptideHypothesis_ (this),
    cvParam_ (this),
    userParam_ (this),
    dBSequence_ref_ (this),
    passThreshold_ (this)
  {
  }

  ProteinDetectionHypothesisType::
  ProteinDetectionHypothesisType (const id_type& id,
                                  const passThreshold_type& passThreshold)
  : ::mzIdentML110::IdentifiableType (id),
    PeptideHypothesis_ (this),
    cvParam_ (this),
    userParam_ (this),
    dBSequence_ref_ (this),
    passThreshold_ (passThreshold, this)
  {
  }

  ProteinDetectionHypothesisType::
  ProteinDetectionHypothesisType (const ProteinDetectionHypothesisType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    PeptideHypothesis_ (x.PeptideHypothesis_, f, this),
    cvParam_ (x.cvParam_, f, this),
    userParam_ (x.userParam_, f, this),
    dBSequence_ref_ (x.dBSequence_ref_, f, this),
    passThreshold_ (x.passThreshold_, f, this)
  {
  }

  ProteinDetectionHypothesisType::
  ProteinDetectionHypothesisType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    PeptideHypothesis_ (this),
    cvParam_ (this),
    userParam_ (this),
    dBSequence_ref_ (this),
    passThreshold_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ProteinDetectionHypothesisType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PeptideHypothesis
      //
      if (n.name () == "PeptideHypothesis" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< PeptideHypothesis_type > r (
          PeptideHypothesis_traits::create (i, f, this));

        this->PeptideHypothesis_.push_back (::std::move (r));
        continue;
      }

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      // userParam
      //
      if (n.name () == "userParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< userParam_type > r (
          userParam_traits::create (i, f, this));

        this->userParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "dBSequence_ref" && n.namespace_ ().empty ())
      {
        this->dBSequence_ref_.set (dBSequence_ref_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "passThreshold" && n.namespace_ ().empty ())
      {
        this->passThreshold_.set (passThreshold_traits::create (i, f, this));
        continue;
      }
    }

    if (!passThreshold_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "passThreshold",
        "");
    }
  }

  ProteinDetectionHypothesisType* ProteinDetectionHypothesisType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ProteinDetectionHypothesisType (*this, f, c);
  }

  ProteinDetectionHypothesisType& ProteinDetectionHypothesisType::
  operator= (const ProteinDetectionHypothesisType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->PeptideHypothesis_ = x.PeptideHypothesis_;
      this->cvParam_ = x.cvParam_;
      this->userParam_ = x.userParam_;
      this->dBSequence_ref_ = x.dBSequence_ref_;
      this->passThreshold_ = x.passThreshold_;
    }

    return *this;
  }

  ProteinDetectionHypothesisType::
  ~ProteinDetectionHypothesisType ()
  {
  }

  // ProteinAmbiguityGroupType
  //

  ProteinAmbiguityGroupType::
  ProteinAmbiguityGroupType ()
  : ::mzIdentML110::IdentifiableType (),
    ProteinDetectionHypothesis_ (this),
    cvParam_ (this),
    userParam_ (this)
  {
  }

  ProteinAmbiguityGroupType::
  ProteinAmbiguityGroupType (const id_type& id)
  : ::mzIdentML110::IdentifiableType (id),
    ProteinDetectionHypothesis_ (this),
    cvParam_ (this),
    userParam_ (this)
  {
  }

  ProteinAmbiguityGroupType::
  ProteinAmbiguityGroupType (const ProteinAmbiguityGroupType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    ProteinDetectionHypothesis_ (x.ProteinDetectionHypothesis_, f, this),
    cvParam_ (x.cvParam_, f, this),
    userParam_ (x.userParam_, f, this)
  {
  }

  ProteinAmbiguityGroupType::
  ProteinAmbiguityGroupType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    ProteinDetectionHypothesis_ (this),
    cvParam_ (this),
    userParam_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ProteinAmbiguityGroupType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ProteinDetectionHypothesis
      //
      if (n.name () == "ProteinDetectionHypothesis" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< ProteinDetectionHypothesis_type > r (
          ProteinDetectionHypothesis_traits::create (i, f, this));

        this->ProteinDetectionHypothesis_.push_back (::std::move (r));
        continue;
      }

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      // userParam
      //
      if (n.name () == "userParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< userParam_type > r (
          userParam_traits::create (i, f, this));

        this->userParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ProteinAmbiguityGroupType* ProteinAmbiguityGroupType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ProteinAmbiguityGroupType (*this, f, c);
  }

  ProteinAmbiguityGroupType& ProteinAmbiguityGroupType::
  operator= (const ProteinAmbiguityGroupType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->ProteinDetectionHypothesis_ = x.ProteinDetectionHypothesis_;
      this->cvParam_ = x.cvParam_;
      this->userParam_ = x.userParam_;
    }

    return *this;
  }

  ProteinAmbiguityGroupType::
  ~ProteinAmbiguityGroupType ()
  {
  }

  // ModificationType
  //

  ModificationType::
  ModificationType ()
  : ::xml_schema::type (),
    cvParam_ (this),
    location_ (this),
    residues_ (this),
    avgMassDelta_ (this),
    monoisotopicMassDelta_ (this)
  {
  }

  ModificationType::
  ModificationType (const ModificationType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    cvParam_ (x.cvParam_, f, this),
    location_ (x.location_, f, this),
    residues_ (x.residues_, f, this),
    avgMassDelta_ (x.avgMassDelta_, f, this),
    monoisotopicMassDelta_ (x.monoisotopicMassDelta_, f, this)
  {
  }

  ModificationType::
  ModificationType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    cvParam_ (this),
    location_ (this),
    residues_ (this),
    avgMassDelta_ (this),
    monoisotopicMassDelta_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ModificationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "location" && n.namespace_ ().empty ())
      {
        this->location_.set (location_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "residues" && n.namespace_ ().empty ())
      {
        this->residues_.set (residues_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "avgMassDelta" && n.namespace_ ().empty ())
      {
        this->avgMassDelta_.set (avgMassDelta_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "monoisotopicMassDelta" && n.namespace_ ().empty ())
      {
        this->monoisotopicMassDelta_.set (monoisotopicMassDelta_traits::create (i, f, this));
        continue;
      }
    }
  }

  ModificationType* ModificationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ModificationType (*this, f, c);
  }

  ModificationType& ModificationType::
  operator= (const ModificationType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->cvParam_ = x.cvParam_;
      this->location_ = x.location_;
      this->residues_ = x.residues_;
      this->avgMassDelta_ = x.avgMassDelta_;
      this->monoisotopicMassDelta_ = x.monoisotopicMassDelta_;
    }

    return *this;
  }

  ModificationType::
  ~ModificationType ()
  {
  }

  // PeptideType
  //

  PeptideType::
  PeptideType ()
  : ::mzIdentML110::IdentifiableType (),
    PeptideSequence_ (this),
    Modification_ (this),
    SubstitutionModification_ (this),
    cvParam_ (this),
    userParam_ (this)
  {
  }

  PeptideType::
  PeptideType (const id_type& id,
               const PeptideSequence_type& PeptideSequence)
  : ::mzIdentML110::IdentifiableType (id),
    PeptideSequence_ (PeptideSequence, this),
    Modification_ (this),
    SubstitutionModification_ (this),
    cvParam_ (this),
    userParam_ (this)
  {
  }

  PeptideType::
  PeptideType (const PeptideType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    PeptideSequence_ (x.PeptideSequence_, f, this),
    Modification_ (x.Modification_, f, this),
    SubstitutionModification_ (x.SubstitutionModification_, f, this),
    cvParam_ (x.cvParam_, f, this),
    userParam_ (x.userParam_, f, this)
  {
  }

  PeptideType::
  PeptideType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    PeptideSequence_ (this),
    Modification_ (this),
    SubstitutionModification_ (this),
    cvParam_ (this),
    userParam_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void PeptideType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PeptideSequence
      //
      if (n.name () == "PeptideSequence" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< PeptideSequence_type > r (
          PeptideSequence_traits::create (i, f, this));

        if (!PeptideSequence_.present ())
        {
          this->PeptideSequence_.set (::std::move (r));
          continue;
        }
      }

      // Modification
      //
      if (n.name () == "Modification" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Modification_type > r (
          Modification_traits::create (i, f, this));

        this->Modification_.push_back (::std::move (r));
        continue;
      }

      // SubstitutionModification
      //
      if (n.name () == "SubstitutionModification" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< SubstitutionModification_type > r (
          SubstitutionModification_traits::create (i, f, this));

        this->SubstitutionModification_.push_back (::std::move (r));
        continue;
      }

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      // userParam
      //
      if (n.name () == "userParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< userParam_type > r (
          userParam_traits::create (i, f, this));

        this->userParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!PeptideSequence_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "PeptideSequence",
        "http://psidev.info/psi/pi/mzIdentML/1.1");
    }
  }

  PeptideType* PeptideType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PeptideType (*this, f, c);
  }

  PeptideType& PeptideType::
  operator= (const PeptideType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->PeptideSequence_ = x.PeptideSequence_;
      this->Modification_ = x.Modification_;
      this->SubstitutionModification_ = x.SubstitutionModification_;
      this->cvParam_ = x.cvParam_;
      this->userParam_ = x.userParam_;
    }

    return *this;
  }

  PeptideType::
  ~PeptideType ()
  {
  }

  // SubstitutionModificationType
  //

  SubstitutionModificationType::
  SubstitutionModificationType ()
  : ::xml_schema::type (),
    originalResidue_ (this),
    replacementResidue_ (this),
    location_ (this),
    avgMassDelta_ (this),
    monoisotopicMassDelta_ (this)
  {
  }

  SubstitutionModificationType::
  SubstitutionModificationType (const originalResidue_type& originalResidue,
                                const replacementResidue_type& replacementResidue)
  : ::xml_schema::type (),
    originalResidue_ (originalResidue, this),
    replacementResidue_ (replacementResidue, this),
    location_ (this),
    avgMassDelta_ (this),
    monoisotopicMassDelta_ (this)
  {
  }

  SubstitutionModificationType::
  SubstitutionModificationType (const SubstitutionModificationType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    originalResidue_ (x.originalResidue_, f, this),
    replacementResidue_ (x.replacementResidue_, f, this),
    location_ (x.location_, f, this),
    avgMassDelta_ (x.avgMassDelta_, f, this),
    monoisotopicMassDelta_ (x.monoisotopicMassDelta_, f, this)
  {
  }

  SubstitutionModificationType::
  SubstitutionModificationType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    originalResidue_ (this),
    replacementResidue_ (this),
    location_ (this),
    avgMassDelta_ (this),
    monoisotopicMassDelta_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void SubstitutionModificationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "originalResidue" && n.namespace_ ().empty ())
      {
        this->originalResidue_.set (originalResidue_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "replacementResidue" && n.namespace_ ().empty ())
      {
        this->replacementResidue_.set (replacementResidue_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "location" && n.namespace_ ().empty ())
      {
        this->location_.set (location_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "avgMassDelta" && n.namespace_ ().empty ())
      {
        this->avgMassDelta_.set (avgMassDelta_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "monoisotopicMassDelta" && n.namespace_ ().empty ())
      {
        this->monoisotopicMassDelta_.set (monoisotopicMassDelta_traits::create (i, f, this));
        continue;
      }
    }

    if (!originalResidue_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "originalResidue",
        "");
    }

    if (!replacementResidue_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "replacementResidue",
        "");
    }
  }

  SubstitutionModificationType* SubstitutionModificationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SubstitutionModificationType (*this, f, c);
  }

  SubstitutionModificationType& SubstitutionModificationType::
  operator= (const SubstitutionModificationType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->originalResidue_ = x.originalResidue_;
      this->replacementResidue_ = x.replacementResidue_;
      this->location_ = x.location_;
      this->avgMassDelta_ = x.avgMassDelta_;
      this->monoisotopicMassDelta_ = x.monoisotopicMassDelta_;
    }

    return *this;
  }

  SubstitutionModificationType::
  ~SubstitutionModificationType ()
  {
  }

  // SpectraDataType
  //

  SpectraDataType::
  SpectraDataType ()
  : ::mzIdentML110::ExternalDataType (),
    SpectrumIDFormat_ (this)
  {
  }

  SpectraDataType::
  SpectraDataType (const id_type& id,
                   const location_type& location,
                   const SpectrumIDFormat_type& SpectrumIDFormat)
  : ::mzIdentML110::ExternalDataType (id,
                                      location),
    SpectrumIDFormat_ (SpectrumIDFormat, this)
  {
  }

  SpectraDataType::
  SpectraDataType (const id_type& id,
                   const location_type& location,
                   ::std::unique_ptr< SpectrumIDFormat_type > SpectrumIDFormat)
  : ::mzIdentML110::ExternalDataType (id,
                                      location),
    SpectrumIDFormat_ (std::move (SpectrumIDFormat), this)
  {
  }

  SpectraDataType::
  SpectraDataType (const SpectraDataType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::mzIdentML110::ExternalDataType (x, f, c),
    SpectrumIDFormat_ (x.SpectrumIDFormat_, f, this)
  {
  }

  SpectraDataType::
  SpectraDataType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::mzIdentML110::ExternalDataType (e, f | ::xml_schema::flags::base, c),
    SpectrumIDFormat_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SpectraDataType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::ExternalDataType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SpectrumIDFormat
      //
      if (n.name () == "SpectrumIDFormat" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< SpectrumIDFormat_type > r (
          SpectrumIDFormat_traits::create (i, f, this));

        if (!SpectrumIDFormat_.present ())
        {
          this->SpectrumIDFormat_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!SpectrumIDFormat_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SpectrumIDFormat",
        "http://psidev.info/psi/pi/mzIdentML/1.1");
    }
  }

  SpectraDataType* SpectraDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpectraDataType (*this, f, c);
  }

  SpectraDataType& SpectraDataType::
  operator= (const SpectraDataType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::ExternalDataType& > (*this) = x;
      this->SpectrumIDFormat_ = x.SpectrumIDFormat_;
    }

    return *this;
  }

  SpectraDataType::
  ~SpectraDataType ()
  {
  }

  // AnalysisSoftwareType
  //

  AnalysisSoftwareType::
  AnalysisSoftwareType ()
  : ::mzIdentML110::IdentifiableType (),
    ContactRole_ (this),
    SoftwareName_ (this),
    Customizations_ (this),
    version_ (this),
    uri_ (this)
  {
  }

  AnalysisSoftwareType::
  AnalysisSoftwareType (const id_type& id,
                        const SoftwareName_type& SoftwareName)
  : ::mzIdentML110::IdentifiableType (id),
    ContactRole_ (this),
    SoftwareName_ (SoftwareName, this),
    Customizations_ (this),
    version_ (this),
    uri_ (this)
  {
  }

  AnalysisSoftwareType::
  AnalysisSoftwareType (const id_type& id,
                        ::std::unique_ptr< SoftwareName_type > SoftwareName)
  : ::mzIdentML110::IdentifiableType (id),
    ContactRole_ (this),
    SoftwareName_ (std::move (SoftwareName), this),
    Customizations_ (this),
    version_ (this),
    uri_ (this)
  {
  }

  AnalysisSoftwareType::
  AnalysisSoftwareType (const AnalysisSoftwareType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    ContactRole_ (x.ContactRole_, f, this),
    SoftwareName_ (x.SoftwareName_, f, this),
    Customizations_ (x.Customizations_, f, this),
    version_ (x.version_, f, this),
    uri_ (x.uri_, f, this)
  {
  }

  AnalysisSoftwareType::
  AnalysisSoftwareType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    ContactRole_ (this),
    SoftwareName_ (this),
    Customizations_ (this),
    version_ (this),
    uri_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AnalysisSoftwareType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ContactRole
      //
      if (n.name () == "ContactRole" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< ContactRole_type > r (
          ContactRole_traits::create (i, f, this));

        if (!this->ContactRole_)
        {
          this->ContactRole_.set (::std::move (r));
          continue;
        }
      }

      // SoftwareName
      //
      if (n.name () == "SoftwareName" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< SoftwareName_type > r (
          SoftwareName_traits::create (i, f, this));

        if (!SoftwareName_.present ())
        {
          this->SoftwareName_.set (::std::move (r));
          continue;
        }
      }

      // Customizations
      //
      if (n.name () == "Customizations" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Customizations_type > r (
          Customizations_traits::create (i, f, this));

        if (!this->Customizations_)
        {
          this->Customizations_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!SoftwareName_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SoftwareName",
        "http://psidev.info/psi/pi/mzIdentML/1.1");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        this->version_.set (version_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "uri" && n.namespace_ ().empty ())
      {
        this->uri_.set (uri_traits::create (i, f, this));
        continue;
      }
    }
  }

  AnalysisSoftwareType* AnalysisSoftwareType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AnalysisSoftwareType (*this, f, c);
  }

  AnalysisSoftwareType& AnalysisSoftwareType::
  operator= (const AnalysisSoftwareType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->ContactRole_ = x.ContactRole_;
      this->SoftwareName_ = x.SoftwareName_;
      this->Customizations_ = x.Customizations_;
      this->version_ = x.version_;
      this->uri_ = x.uri_;
    }

    return *this;
  }

  AnalysisSoftwareType::
  ~AnalysisSoftwareType ()
  {
  }

  // EnzymeType
  //

  EnzymeType::
  EnzymeType ()
  : ::mzIdentML110::IdentifiableType (),
    SiteRegexp_ (this),
    EnzymeName_ (this),
    nTermGain_ (this),
    cTermGain_ (this),
    semiSpecific_ (this),
    missedCleavages_ (this),
    minDistance_ (this)
  {
  }

  EnzymeType::
  EnzymeType (const id_type& id)
  : ::mzIdentML110::IdentifiableType (id),
    SiteRegexp_ (this),
    EnzymeName_ (this),
    nTermGain_ (this),
    cTermGain_ (this),
    semiSpecific_ (this),
    missedCleavages_ (this),
    minDistance_ (this)
  {
  }

  EnzymeType::
  EnzymeType (const EnzymeType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    SiteRegexp_ (x.SiteRegexp_, f, this),
    EnzymeName_ (x.EnzymeName_, f, this),
    nTermGain_ (x.nTermGain_, f, this),
    cTermGain_ (x.cTermGain_, f, this),
    semiSpecific_ (x.semiSpecific_, f, this),
    missedCleavages_ (x.missedCleavages_, f, this),
    minDistance_ (x.minDistance_, f, this)
  {
  }

  EnzymeType::
  EnzymeType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    SiteRegexp_ (this),
    EnzymeName_ (this),
    nTermGain_ (this),
    cTermGain_ (this),
    semiSpecific_ (this),
    missedCleavages_ (this),
    minDistance_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void EnzymeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SiteRegexp
      //
      if (n.name () == "SiteRegexp" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< SiteRegexp_type > r (
          SiteRegexp_traits::create (i, f, this));

        if (!this->SiteRegexp_)
        {
          this->SiteRegexp_.set (::std::move (r));
          continue;
        }
      }

      // EnzymeName
      //
      if (n.name () == "EnzymeName" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< EnzymeName_type > r (
          EnzymeName_traits::create (i, f, this));

        if (!this->EnzymeName_)
        {
          this->EnzymeName_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "nTermGain" && n.namespace_ ().empty ())
      {
        this->nTermGain_.set (nTermGain_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "cTermGain" && n.namespace_ ().empty ())
      {
        this->cTermGain_.set (cTermGain_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "semiSpecific" && n.namespace_ ().empty ())
      {
        this->semiSpecific_.set (semiSpecific_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "missedCleavages" && n.namespace_ ().empty ())
      {
        this->missedCleavages_.set (missedCleavages_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "minDistance" && n.namespace_ ().empty ())
      {
        this->minDistance_.set (minDistance_traits::create (i, f, this));
        continue;
      }
    }
  }

  EnzymeType* EnzymeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EnzymeType (*this, f, c);
  }

  EnzymeType& EnzymeType::
  operator= (const EnzymeType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->SiteRegexp_ = x.SiteRegexp_;
      this->EnzymeName_ = x.EnzymeName_;
      this->nTermGain_ = x.nTermGain_;
      this->cTermGain_ = x.cTermGain_;
      this->semiSpecific_ = x.semiSpecific_;
      this->missedCleavages_ = x.missedCleavages_;
      this->minDistance_ = x.minDistance_;
    }

    return *this;
  }

  EnzymeType::
  ~EnzymeType ()
  {
  }

  // EnzymesType
  //

  EnzymesType::
  EnzymesType ()
  : ::xml_schema::type (),
    Enzyme_ (this),
    independent_ (this)
  {
  }

  EnzymesType::
  EnzymesType (const EnzymesType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Enzyme_ (x.Enzyme_, f, this),
    independent_ (x.independent_, f, this)
  {
  }

  EnzymesType::
  EnzymesType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Enzyme_ (this),
    independent_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void EnzymesType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Enzyme
      //
      if (n.name () == "Enzyme" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Enzyme_type > r (
          Enzyme_traits::create (i, f, this));

        this->Enzyme_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "independent" && n.namespace_ ().empty ())
      {
        this->independent_.set (independent_traits::create (i, f, this));
        continue;
      }
    }
  }

  EnzymesType* EnzymesType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EnzymesType (*this, f, c);
  }

  EnzymesType& EnzymesType::
  operator= (const EnzymesType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Enzyme_ = x.Enzyme_;
      this->independent_ = x.independent_;
    }

    return *this;
  }

  EnzymesType::
  ~EnzymesType ()
  {
  }

  // ResidueType
  //

  ResidueType::
  ResidueType ()
  : ::xml_schema::type (),
    code_ (this),
    mass_ (this)
  {
  }

  ResidueType::
  ResidueType (const code_type& code,
               const mass_type& mass)
  : ::xml_schema::type (),
    code_ (code, this),
    mass_ (mass, this)
  {
  }

  ResidueType::
  ResidueType (const ResidueType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    code_ (x.code_, f, this),
    mass_ (x.mass_, f, this)
  {
  }

  ResidueType::
  ResidueType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    code_ (this),
    mass_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ResidueType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "code" && n.namespace_ ().empty ())
      {
        this->code_.set (code_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "mass" && n.namespace_ ().empty ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    if (!code_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "code",
        "");
    }

    if (!mass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mass",
        "");
    }
  }

  ResidueType* ResidueType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ResidueType (*this, f, c);
  }

  ResidueType& ResidueType::
  operator= (const ResidueType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->code_ = x.code_;
      this->mass_ = x.mass_;
    }

    return *this;
  }

  ResidueType::
  ~ResidueType ()
  {
  }

  // AmbiguousResidueType
  //

  AmbiguousResidueType::
  AmbiguousResidueType ()
  : ::xml_schema::type (),
    cvParam_ (this),
    userParam_ (this),
    code_ (this)
  {
  }

  AmbiguousResidueType::
  AmbiguousResidueType (const code_type& code)
  : ::xml_schema::type (),
    cvParam_ (this),
    userParam_ (this),
    code_ (code, this)
  {
  }

  AmbiguousResidueType::
  AmbiguousResidueType (const AmbiguousResidueType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    cvParam_ (x.cvParam_, f, this),
    userParam_ (x.userParam_, f, this),
    code_ (x.code_, f, this)
  {
  }

  AmbiguousResidueType::
  AmbiguousResidueType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    cvParam_ (this),
    userParam_ (this),
    code_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AmbiguousResidueType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      // userParam
      //
      if (n.name () == "userParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< userParam_type > r (
          userParam_traits::create (i, f, this));

        this->userParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "code" && n.namespace_ ().empty ())
      {
        this->code_.set (code_traits::create (i, f, this));
        continue;
      }
    }

    if (!code_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "code",
        "");
    }
  }

  AmbiguousResidueType* AmbiguousResidueType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AmbiguousResidueType (*this, f, c);
  }

  AmbiguousResidueType& AmbiguousResidueType::
  operator= (const AmbiguousResidueType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->cvParam_ = x.cvParam_;
      this->userParam_ = x.userParam_;
      this->code_ = x.code_;
    }

    return *this;
  }

  AmbiguousResidueType::
  ~AmbiguousResidueType ()
  {
  }

  // MassTableType
  //

  MassTableType::
  MassTableType ()
  : ::mzIdentML110::IdentifiableType (),
    Residue_ (this),
    AmbiguousResidue_ (this),
    cvParam_ (this),
    userParam_ (this),
    msLevel_ (this)
  {
  }

  MassTableType::
  MassTableType (const id_type& id,
                 const msLevel_type& msLevel)
  : ::mzIdentML110::IdentifiableType (id),
    Residue_ (this),
    AmbiguousResidue_ (this),
    cvParam_ (this),
    userParam_ (this),
    msLevel_ (msLevel, this)
  {
  }

  MassTableType::
  MassTableType (const MassTableType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    Residue_ (x.Residue_, f, this),
    AmbiguousResidue_ (x.AmbiguousResidue_, f, this),
    cvParam_ (x.cvParam_, f, this),
    userParam_ (x.userParam_, f, this),
    msLevel_ (x.msLevel_, f, this)
  {
  }

  MassTableType::
  MassTableType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    Residue_ (this),
    AmbiguousResidue_ (this),
    cvParam_ (this),
    userParam_ (this),
    msLevel_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MassTableType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Residue
      //
      if (n.name () == "Residue" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Residue_type > r (
          Residue_traits::create (i, f, this));

        this->Residue_.push_back (::std::move (r));
        continue;
      }

      // AmbiguousResidue
      //
      if (n.name () == "AmbiguousResidue" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< AmbiguousResidue_type > r (
          AmbiguousResidue_traits::create (i, f, this));

        this->AmbiguousResidue_.push_back (::std::move (r));
        continue;
      }

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      // userParam
      //
      if (n.name () == "userParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< userParam_type > r (
          userParam_traits::create (i, f, this));

        this->userParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "msLevel" && n.namespace_ ().empty ())
      {
        this->msLevel_.set (msLevel_traits::create (i, f, this));
        continue;
      }
    }

    if (!msLevel_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "msLevel",
        "");
    }
  }

  MassTableType* MassTableType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MassTableType (*this, f, c);
  }

  MassTableType& MassTableType::
  operator= (const MassTableType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->Residue_ = x.Residue_;
      this->AmbiguousResidue_ = x.AmbiguousResidue_;
      this->cvParam_ = x.cvParam_;
      this->userParam_ = x.userParam_;
      this->msLevel_ = x.msLevel_;
    }

    return *this;
  }

  MassTableType::
  ~MassTableType ()
  {
  }

  // PeptideEvidenceType
  //

  PeptideEvidenceType::
  PeptideEvidenceType ()
  : ::mzIdentML110::IdentifiableType (),
    cvParam_ (this),
    userParam_ (this),
    dBSequence_ref_ (this),
    peptide_ref_ (this),
    start_ (this),
    end_ (this),
    pre_ (this),
    post_ (this),
    translationTable_ref_ (this),
    frame_ (this),
    isDecoy_ (isDecoy_default_value (), this)
  {
  }

  PeptideEvidenceType::
  PeptideEvidenceType (const id_type& id,
                       const dBSequence_ref_type& dBSequence_ref,
                       const peptide_ref_type& peptide_ref)
  : ::mzIdentML110::IdentifiableType (id),
    cvParam_ (this),
    userParam_ (this),
    dBSequence_ref_ (dBSequence_ref, this),
    peptide_ref_ (peptide_ref, this),
    start_ (this),
    end_ (this),
    pre_ (this),
    post_ (this),
    translationTable_ref_ (this),
    frame_ (this),
    isDecoy_ (isDecoy_default_value (), this)
  {
  }

  PeptideEvidenceType::
  PeptideEvidenceType (const PeptideEvidenceType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    cvParam_ (x.cvParam_, f, this),
    userParam_ (x.userParam_, f, this),
    dBSequence_ref_ (x.dBSequence_ref_, f, this),
    peptide_ref_ (x.peptide_ref_, f, this),
    start_ (x.start_, f, this),
    end_ (x.end_, f, this),
    pre_ (x.pre_, f, this),
    post_ (x.post_, f, this),
    translationTable_ref_ (x.translationTable_ref_, f, this),
    frame_ (x.frame_, f, this),
    isDecoy_ (x.isDecoy_, f, this)
  {
  }

  PeptideEvidenceType::
  PeptideEvidenceType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    cvParam_ (this),
    userParam_ (this),
    dBSequence_ref_ (this),
    peptide_ref_ (this),
    start_ (this),
    end_ (this),
    pre_ (this),
    post_ (this),
    translationTable_ref_ (this),
    frame_ (this),
    isDecoy_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void PeptideEvidenceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      // userParam
      //
      if (n.name () == "userParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< userParam_type > r (
          userParam_traits::create (i, f, this));

        this->userParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "dBSequence_ref" && n.namespace_ ().empty ())
      {
        this->dBSequence_ref_.set (dBSequence_ref_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "peptide_ref" && n.namespace_ ().empty ())
      {
        this->peptide_ref_.set (peptide_ref_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "start" && n.namespace_ ().empty ())
      {
        this->start_.set (start_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "end" && n.namespace_ ().empty ())
      {
        this->end_.set (end_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "pre" && n.namespace_ ().empty ())
      {
        this->pre_.set (pre_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "post" && n.namespace_ ().empty ())
      {
        this->post_.set (post_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "translationTable_ref" && n.namespace_ ().empty ())
      {
        this->translationTable_ref_.set (translationTable_ref_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "frame" && n.namespace_ ().empty ())
      {
        this->frame_.set (frame_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isDecoy" && n.namespace_ ().empty ())
      {
        this->isDecoy_.set (isDecoy_traits::create (i, f, this));
        continue;
      }
    }

    if (!dBSequence_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "dBSequence_ref",
        "");
    }

    if (!peptide_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "peptide_ref",
        "");
    }

    if (!isDecoy_.present ())
    {
      this->isDecoy_.set (isDecoy_default_value ());
    }
  }

  PeptideEvidenceType* PeptideEvidenceType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PeptideEvidenceType (*this, f, c);
  }

  PeptideEvidenceType& PeptideEvidenceType::
  operator= (const PeptideEvidenceType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->cvParam_ = x.cvParam_;
      this->userParam_ = x.userParam_;
      this->dBSequence_ref_ = x.dBSequence_ref_;
      this->peptide_ref_ = x.peptide_ref_;
      this->start_ = x.start_;
      this->end_ = x.end_;
      this->pre_ = x.pre_;
      this->post_ = x.post_;
      this->translationTable_ref_ = x.translationTable_ref_;
      this->frame_ = x.frame_;
      this->isDecoy_ = x.isDecoy_;
    }

    return *this;
  }

  PeptideEvidenceType::
  ~PeptideEvidenceType ()
  {
  }

  // ToleranceType
  //

  ToleranceType::
  ToleranceType ()
  : ::xml_schema::type (),
    cvParam_ (this)
  {
  }

  ToleranceType::
  ToleranceType (const ToleranceType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    cvParam_ (x.cvParam_, f, this)
  {
  }

  ToleranceType::
  ToleranceType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    cvParam_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ToleranceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ToleranceType* ToleranceType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ToleranceType (*this, f, c);
  }

  ToleranceType& ToleranceType::
  operator= (const ToleranceType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->cvParam_ = x.cvParam_;
    }

    return *this;
  }

  ToleranceType::
  ~ToleranceType ()
  {
  }

  // SpectrumIDFormatType
  //

  SpectrumIDFormatType::
  SpectrumIDFormatType ()
  : ::xml_schema::type (),
    cvParam_ (this)
  {
  }

  SpectrumIDFormatType::
  SpectrumIDFormatType (const cvParam_type& cvParam)
  : ::xml_schema::type (),
    cvParam_ (cvParam, this)
  {
  }

  SpectrumIDFormatType::
  SpectrumIDFormatType (::std::unique_ptr< cvParam_type > cvParam)
  : ::xml_schema::type (),
    cvParam_ (std::move (cvParam), this)
  {
  }

  SpectrumIDFormatType::
  SpectrumIDFormatType (const SpectrumIDFormatType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    cvParam_ (x.cvParam_, f, this)
  {
  }

  SpectrumIDFormatType::
  SpectrumIDFormatType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    cvParam_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SpectrumIDFormatType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        if (!cvParam_.present ())
        {
          this->cvParam_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!cvParam_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "cvParam",
        "http://psidev.info/psi/pi/mzIdentML/1.1");
    }
  }

  SpectrumIDFormatType* SpectrumIDFormatType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpectrumIDFormatType (*this, f, c);
  }

  SpectrumIDFormatType& SpectrumIDFormatType::
  operator= (const SpectrumIDFormatType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->cvParam_ = x.cvParam_;
    }

    return *this;
  }

  SpectrumIDFormatType::
  ~SpectrumIDFormatType ()
  {
  }

  // DBSequenceType
  //

  DBSequenceType::
  DBSequenceType ()
  : ::mzIdentML110::IdentifiableType (),
    Seq_ (this),
    cvParam_ (this),
    userParam_ (this),
    length_ (this),
    searchDatabase_ref_ (this),
    accession_ (this)
  {
  }

  DBSequenceType::
  DBSequenceType (const id_type& id,
                  const searchDatabase_ref_type& searchDatabase_ref,
                  const accession_type& accession)
  : ::mzIdentML110::IdentifiableType (id),
    Seq_ (this),
    cvParam_ (this),
    userParam_ (this),
    length_ (this),
    searchDatabase_ref_ (searchDatabase_ref, this),
    accession_ (accession, this)
  {
  }

  DBSequenceType::
  DBSequenceType (const DBSequenceType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    Seq_ (x.Seq_, f, this),
    cvParam_ (x.cvParam_, f, this),
    userParam_ (x.userParam_, f, this),
    length_ (x.length_, f, this),
    searchDatabase_ref_ (x.searchDatabase_ref_, f, this),
    accession_ (x.accession_, f, this)
  {
  }

  DBSequenceType::
  DBSequenceType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    Seq_ (this),
    cvParam_ (this),
    userParam_ (this),
    length_ (this),
    searchDatabase_ref_ (this),
    accession_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DBSequenceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Seq
      //
      if (n.name () == "Seq" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Seq_type > r (
          Seq_traits::create (i, f, this));

        if (!this->Seq_)
        {
          this->Seq_.set (::std::move (r));
          continue;
        }
      }

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      // userParam
      //
      if (n.name () == "userParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< userParam_type > r (
          userParam_traits::create (i, f, this));

        this->userParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "length" && n.namespace_ ().empty ())
      {
        this->length_.set (length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "searchDatabase_ref" && n.namespace_ ().empty ())
      {
        this->searchDatabase_ref_.set (searchDatabase_ref_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "accession" && n.namespace_ ().empty ())
      {
        this->accession_.set (accession_traits::create (i, f, this));
        continue;
      }
    }

    if (!searchDatabase_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "searchDatabase_ref",
        "");
    }

    if (!accession_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "accession",
        "");
    }
  }

  DBSequenceType* DBSequenceType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DBSequenceType (*this, f, c);
  }

  DBSequenceType& DBSequenceType::
  operator= (const DBSequenceType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->Seq_ = x.Seq_;
      this->cvParam_ = x.cvParam_;
      this->userParam_ = x.userParam_;
      this->length_ = x.length_;
      this->searchDatabase_ref_ = x.searchDatabase_ref_;
      this->accession_ = x.accession_;
    }

    return *this;
  }

  DBSequenceType::
  ~DBSequenceType ()
  {
  }

  // SampleType
  //

  SampleType::
  SampleType ()
  : ::mzIdentML110::IdentifiableType (),
    ContactRole_ (this),
    SubSample_ (this),
    cvParam_ (this),
    userParam_ (this)
  {
  }

  SampleType::
  SampleType (const id_type& id)
  : ::mzIdentML110::IdentifiableType (id),
    ContactRole_ (this),
    SubSample_ (this),
    cvParam_ (this),
    userParam_ (this)
  {
  }

  SampleType::
  SampleType (const SampleType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    ContactRole_ (x.ContactRole_, f, this),
    SubSample_ (x.SubSample_, f, this),
    cvParam_ (x.cvParam_, f, this),
    userParam_ (x.userParam_, f, this)
  {
  }

  SampleType::
  SampleType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    ContactRole_ (this),
    SubSample_ (this),
    cvParam_ (this),
    userParam_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SampleType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ContactRole
      //
      if (n.name () == "ContactRole" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< ContactRole_type > r (
          ContactRole_traits::create (i, f, this));

        this->ContactRole_.push_back (::std::move (r));
        continue;
      }

      // SubSample
      //
      if (n.name () == "SubSample" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< SubSample_type > r (
          SubSample_traits::create (i, f, this));

        this->SubSample_.push_back (::std::move (r));
        continue;
      }

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      // userParam
      //
      if (n.name () == "userParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< userParam_type > r (
          userParam_traits::create (i, f, this));

        this->userParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  SampleType* SampleType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SampleType (*this, f, c);
  }

  SampleType& SampleType::
  operator= (const SampleType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->ContactRole_ = x.ContactRole_;
      this->SubSample_ = x.SubSample_;
      this->cvParam_ = x.cvParam_;
      this->userParam_ = x.userParam_;
    }

    return *this;
  }

  SampleType::
  ~SampleType ()
  {
  }

  // SubSampleType
  //

  SubSampleType::
  SubSampleType ()
  : ::xml_schema::type (),
    sample_ref_ (this)
  {
  }

  SubSampleType::
  SubSampleType (const sample_ref_type& sample_ref)
  : ::xml_schema::type (),
    sample_ref_ (sample_ref, this)
  {
  }

  SubSampleType::
  SubSampleType (const SubSampleType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sample_ref_ (x.sample_ref_, f, this)
  {
  }

  SubSampleType::
  SubSampleType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sample_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void SubSampleType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "sample_ref" && n.namespace_ ().empty ())
      {
        this->sample_ref_.set (sample_ref_traits::create (i, f, this));
        continue;
      }
    }

    if (!sample_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "sample_ref",
        "");
    }
  }

  SubSampleType* SubSampleType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SubSampleType (*this, f, c);
  }

  SubSampleType& SubSampleType::
  operator= (const SubSampleType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->sample_ref_ = x.sample_ref_;
    }

    return *this;
  }

  SubSampleType::
  ~SubSampleType ()
  {
  }

  // listOfIntegers
  //

  listOfIntegers::
  listOfIntegers (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::integer, char > (e, f, this)
  {
  }

  listOfIntegers::
  listOfIntegers (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::integer, char > (a, f, this)
  {
  }

  listOfIntegers::
  listOfIntegers (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::integer, char > (s, e, f, this)
  {
  }

  listOfIntegers* listOfIntegers::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class listOfIntegers (*this, f, c);
  }

  listOfIntegers::
  ~listOfIntegers ()
  {
  }

  // listOfFloats
  //

  listOfFloats::
  listOfFloats (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::float_, char > (e, f, this)
  {
  }

  listOfFloats::
  listOfFloats (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::float_, char > (a, f, this)
  {
  }

  listOfFloats::
  listOfFloats (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::float_, char > (s, e, f, this)
  {
  }

  listOfFloats* listOfFloats::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class listOfFloats (*this, f, c);
  }

  listOfFloats::
  ~listOfFloats ()
  {
  }

  // listOfChars
  //

  listOfChars::
  listOfChars (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::mzIdentML110::chars, char > (e, f, this)
  {
  }

  listOfChars::
  listOfChars (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::mzIdentML110::chars, char > (a, f, this)
  {
  }

  listOfChars::
  listOfChars (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::mzIdentML110::chars, char > (s, e, f, this)
  {
  }

  listOfChars* listOfChars::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class listOfChars (*this, f, c);
  }

  listOfChars::
  ~listOfChars ()
  {
  }

  // listOfCharsOrAny
  //

  listOfCharsOrAny::
  listOfCharsOrAny (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  listOfCharsOrAny::
  listOfCharsOrAny (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  listOfCharsOrAny::
  listOfCharsOrAny (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  listOfCharsOrAny* listOfCharsOrAny::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class listOfCharsOrAny (*this, f, c);
  }

  // chars
  //

  chars::
  chars ()
  : ::xml_schema::string ()
  {
  }

  chars::
  chars (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  chars::
  chars (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  chars::
  chars (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  chars::
  chars (const chars& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  chars::
  chars (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  chars::
  chars (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  chars::
  chars (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  chars* chars::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class chars (*this, f, c);
  }

  chars::
  ~chars ()
  {
  }

  // sequence
  //

  sequence::
  sequence ()
  : ::xml_schema::string ()
  {
  }

  sequence::
  sequence (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  sequence::
  sequence (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  sequence::
  sequence (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  sequence::
  sequence (const sequence& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  sequence::
  sequence (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  sequence::
  sequence (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  sequence::
  sequence (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  sequence* sequence::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class sequence (*this, f, c);
  }

  sequence::
  ~sequence ()
  {
  }

  // allowed_frames
  //

  allowed_frames::
  allowed_frames (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  allowed_frames::
  allowed_frames (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  allowed_frames::
  allowed_frames (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  allowed_frames* allowed_frames::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class allowed_frames (*this, f, c);
  }

  // listOfAllowedFrames
  //

  listOfAllowedFrames::
  listOfAllowedFrames (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::mzIdentML110::allowed_frames, char > (e, f, this)
  {
  }

  listOfAllowedFrames::
  listOfAllowedFrames (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::mzIdentML110::allowed_frames, char > (a, f, this)
  {
  }

  listOfAllowedFrames::
  listOfAllowedFrames (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::mzIdentML110::allowed_frames, char > (s, e, f, this)
  {
  }

  listOfAllowedFrames* listOfAllowedFrames::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class listOfAllowedFrames (*this, f, c);
  }

  listOfAllowedFrames::
  ~listOfAllowedFrames ()
  {
  }

  // versionRegex
  //

  versionRegex::
  versionRegex ()
  : ::xml_schema::string ()
  {
  }

  versionRegex::
  versionRegex (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  versionRegex::
  versionRegex (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  versionRegex::
  versionRegex (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  versionRegex::
  versionRegex (const versionRegex& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  versionRegex::
  versionRegex (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  versionRegex::
  versionRegex (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  versionRegex::
  versionRegex (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  versionRegex* versionRegex::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class versionRegex (*this, f, c);
  }

  versionRegex::
  ~versionRegex ()
  {
  }

  // FileFormatType
  //

  FileFormatType::
  FileFormatType ()
  : ::xml_schema::type (),
    cvParam_ (this)
  {
  }

  FileFormatType::
  FileFormatType (const cvParam_type& cvParam)
  : ::xml_schema::type (),
    cvParam_ (cvParam, this)
  {
  }

  FileFormatType::
  FileFormatType (::std::unique_ptr< cvParam_type > cvParam)
  : ::xml_schema::type (),
    cvParam_ (std::move (cvParam), this)
  {
  }

  FileFormatType::
  FileFormatType (const FileFormatType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    cvParam_ (x.cvParam_, f, this)
  {
  }

  FileFormatType::
  FileFormatType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    cvParam_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FileFormatType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        if (!cvParam_.present ())
        {
          this->cvParam_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!cvParam_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "cvParam",
        "http://psidev.info/psi/pi/mzIdentML/1.1");
    }
  }

  FileFormatType* FileFormatType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FileFormatType (*this, f, c);
  }

  FileFormatType& FileFormatType::
  operator= (const FileFormatType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->cvParam_ = x.cvParam_;
    }

    return *this;
  }

  FileFormatType::
  ~FileFormatType ()
  {
  }

  // AbstractContactType
  //

  AbstractContactType::
  AbstractContactType ()
  : ::mzIdentML110::IdentifiableType (),
    cvParam_ (this),
    userParam_ (this)
  {
  }

  AbstractContactType::
  AbstractContactType (const id_type& id)
  : ::mzIdentML110::IdentifiableType (id),
    cvParam_ (this),
    userParam_ (this)
  {
  }

  AbstractContactType::
  AbstractContactType (const AbstractContactType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    cvParam_ (x.cvParam_, f, this),
    userParam_ (x.userParam_, f, this)
  {
  }

  AbstractContactType::
  AbstractContactType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    cvParam_ (this),
    userParam_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractContactType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      // userParam
      //
      if (n.name () == "userParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< userParam_type > r (
          userParam_traits::create (i, f, this));

        this->userParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AbstractContactType* AbstractContactType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AbstractContactType (*this, f, c);
  }

  AbstractContactType& AbstractContactType::
  operator= (const AbstractContactType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->cvParam_ = x.cvParam_;
      this->userParam_ = x.userParam_;
    }

    return *this;
  }

  AbstractContactType::
  ~AbstractContactType ()
  {
  }

  // PersonType
  //

  PersonType::
  PersonType ()
  : ::mzIdentML110::AbstractContactType (),
    Affiliation_ (this),
    lastName_ (this),
    firstName_ (this),
    midInitials_ (this)
  {
  }

  PersonType::
  PersonType (const id_type& id)
  : ::mzIdentML110::AbstractContactType (id),
    Affiliation_ (this),
    lastName_ (this),
    firstName_ (this),
    midInitials_ (this)
  {
  }

  PersonType::
  PersonType (const PersonType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::mzIdentML110::AbstractContactType (x, f, c),
    Affiliation_ (x.Affiliation_, f, this),
    lastName_ (x.lastName_, f, this),
    firstName_ (x.firstName_, f, this),
    midInitials_ (x.midInitials_, f, this)
  {
  }

  PersonType::
  PersonType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::mzIdentML110::AbstractContactType (e, f | ::xml_schema::flags::base, c),
    Affiliation_ (this),
    lastName_ (this),
    firstName_ (this),
    midInitials_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void PersonType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::AbstractContactType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Affiliation
      //
      if (n.name () == "Affiliation" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Affiliation_type > r (
          Affiliation_traits::create (i, f, this));

        this->Affiliation_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lastName" && n.namespace_ ().empty ())
      {
        this->lastName_.set (lastName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "firstName" && n.namespace_ ().empty ())
      {
        this->firstName_.set (firstName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "midInitials" && n.namespace_ ().empty ())
      {
        this->midInitials_.set (midInitials_traits::create (i, f, this));
        continue;
      }
    }
  }

  PersonType* PersonType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PersonType (*this, f, c);
  }

  PersonType& PersonType::
  operator= (const PersonType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::AbstractContactType& > (*this) = x;
      this->Affiliation_ = x.Affiliation_;
      this->lastName_ = x.lastName_;
      this->firstName_ = x.firstName_;
      this->midInitials_ = x.midInitials_;
    }

    return *this;
  }

  PersonType::
  ~PersonType ()
  {
  }

  // AffiliationType
  //

  AffiliationType::
  AffiliationType ()
  : ::xml_schema::type (),
    organization_ref_ (this)
  {
  }

  AffiliationType::
  AffiliationType (const organization_ref_type& organization_ref)
  : ::xml_schema::type (),
    organization_ref_ (organization_ref, this)
  {
  }

  AffiliationType::
  AffiliationType (const AffiliationType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    organization_ref_ (x.organization_ref_, f, this)
  {
  }

  AffiliationType::
  AffiliationType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    organization_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void AffiliationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "organization_ref" && n.namespace_ ().empty ())
      {
        this->organization_ref_.set (organization_ref_traits::create (i, f, this));
        continue;
      }
    }

    if (!organization_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "organization_ref",
        "");
    }
  }

  AffiliationType* AffiliationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AffiliationType (*this, f, c);
  }

  AffiliationType& AffiliationType::
  operator= (const AffiliationType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->organization_ref_ = x.organization_ref_;
    }

    return *this;
  }

  AffiliationType::
  ~AffiliationType ()
  {
  }

  // OrganizationType
  //

  OrganizationType::
  OrganizationType ()
  : ::mzIdentML110::AbstractContactType (),
    Parent_ (this)
  {
  }

  OrganizationType::
  OrganizationType (const id_type& id)
  : ::mzIdentML110::AbstractContactType (id),
    Parent_ (this)
  {
  }

  OrganizationType::
  OrganizationType (const OrganizationType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::mzIdentML110::AbstractContactType (x, f, c),
    Parent_ (x.Parent_, f, this)
  {
  }

  OrganizationType::
  OrganizationType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::mzIdentML110::AbstractContactType (e, f | ::xml_schema::flags::base, c),
    Parent_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void OrganizationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::AbstractContactType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Parent
      //
      if (n.name () == "Parent" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Parent_type > r (
          Parent_traits::create (i, f, this));

        if (!this->Parent_)
        {
          this->Parent_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  OrganizationType* OrganizationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OrganizationType (*this, f, c);
  }

  OrganizationType& OrganizationType::
  operator= (const OrganizationType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::AbstractContactType& > (*this) = x;
      this->Parent_ = x.Parent_;
    }

    return *this;
  }

  OrganizationType::
  ~OrganizationType ()
  {
  }

  // ParentOrganizationType
  //

  ParentOrganizationType::
  ParentOrganizationType ()
  : ::xml_schema::type (),
    organization_ref_ (this)
  {
  }

  ParentOrganizationType::
  ParentOrganizationType (const organization_ref_type& organization_ref)
  : ::xml_schema::type (),
    organization_ref_ (organization_ref, this)
  {
  }

  ParentOrganizationType::
  ParentOrganizationType (const ParentOrganizationType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    organization_ref_ (x.organization_ref_, f, this)
  {
  }

  ParentOrganizationType::
  ParentOrganizationType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    organization_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ParentOrganizationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "organization_ref" && n.namespace_ ().empty ())
      {
        this->organization_ref_.set (organization_ref_traits::create (i, f, this));
        continue;
      }
    }

    if (!organization_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "organization_ref",
        "");
    }
  }

  ParentOrganizationType* ParentOrganizationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ParentOrganizationType (*this, f, c);
  }

  ParentOrganizationType& ParentOrganizationType::
  operator= (const ParentOrganizationType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->organization_ref_ = x.organization_ref_;
    }

    return *this;
  }

  ParentOrganizationType::
  ~ParentOrganizationType ()
  {
  }

  // ContactRoleType
  //

  ContactRoleType::
  ContactRoleType ()
  : ::xml_schema::type (),
    Role_ (this),
    contact_ref_ (this)
  {
  }

  ContactRoleType::
  ContactRoleType (const Role_type& Role,
                   const contact_ref_type& contact_ref)
  : ::xml_schema::type (),
    Role_ (Role, this),
    contact_ref_ (contact_ref, this)
  {
  }

  ContactRoleType::
  ContactRoleType (::std::unique_ptr< Role_type > Role,
                   const contact_ref_type& contact_ref)
  : ::xml_schema::type (),
    Role_ (std::move (Role), this),
    contact_ref_ (contact_ref, this)
  {
  }

  ContactRoleType::
  ContactRoleType (const ContactRoleType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Role_ (x.Role_, f, this),
    contact_ref_ (x.contact_ref_, f, this)
  {
  }

  ContactRoleType::
  ContactRoleType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Role_ (this),
    contact_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ContactRoleType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Role
      //
      if (n.name () == "Role" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Role_type > r (
          Role_traits::create (i, f, this));

        if (!Role_.present ())
        {
          this->Role_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!Role_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Role",
        "http://psidev.info/psi/pi/mzIdentML/1.1");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "contact_ref" && n.namespace_ ().empty ())
      {
        this->contact_ref_.set (contact_ref_traits::create (i, f, this));
        continue;
      }
    }

    if (!contact_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "contact_ref",
        "");
    }
  }

  ContactRoleType* ContactRoleType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ContactRoleType (*this, f, c);
  }

  ContactRoleType& ContactRoleType::
  operator= (const ContactRoleType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Role_ = x.Role_;
      this->contact_ref_ = x.contact_ref_;
    }

    return *this;
  }

  ContactRoleType::
  ~ContactRoleType ()
  {
  }

  // RoleType
  //

  RoleType::
  RoleType ()
  : ::xml_schema::type (),
    cvParam_ (this)
  {
  }

  RoleType::
  RoleType (const cvParam_type& cvParam)
  : ::xml_schema::type (),
    cvParam_ (cvParam, this)
  {
  }

  RoleType::
  RoleType (::std::unique_ptr< cvParam_type > cvParam)
  : ::xml_schema::type (),
    cvParam_ (std::move (cvParam), this)
  {
  }

  RoleType::
  RoleType (const RoleType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    cvParam_ (x.cvParam_, f, this)
  {
  }

  RoleType::
  RoleType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    cvParam_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void RoleType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        if (!cvParam_.present ())
        {
          this->cvParam_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!cvParam_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "cvParam",
        "http://psidev.info/psi/pi/mzIdentML/1.1");
    }
  }

  RoleType* RoleType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RoleType (*this, f, c);
  }

  RoleType& RoleType::
  operator= (const RoleType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->cvParam_ = x.cvParam_;
    }

    return *this;
  }

  RoleType::
  ~RoleType ()
  {
  }

  // BibliographicReferenceType
  //

  BibliographicReferenceType::
  BibliographicReferenceType ()
  : ::mzIdentML110::IdentifiableType (),
    authors_ (this),
    publication_ (this),
    publisher_ (this),
    editor_ (this),
    year_ (this),
    volume_ (this),
    issue_ (this),
    pages_ (this),
    title_ (this),
    doi_ (this)
  {
  }

  BibliographicReferenceType::
  BibliographicReferenceType (const id_type& id)
  : ::mzIdentML110::IdentifiableType (id),
    authors_ (this),
    publication_ (this),
    publisher_ (this),
    editor_ (this),
    year_ (this),
    volume_ (this),
    issue_ (this),
    pages_ (this),
    title_ (this),
    doi_ (this)
  {
  }

  BibliographicReferenceType::
  BibliographicReferenceType (const BibliographicReferenceType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    authors_ (x.authors_, f, this),
    publication_ (x.publication_, f, this),
    publisher_ (x.publisher_, f, this),
    editor_ (x.editor_, f, this),
    year_ (x.year_, f, this),
    volume_ (x.volume_, f, this),
    issue_ (x.issue_, f, this),
    pages_ (x.pages_, f, this),
    title_ (x.title_, f, this),
    doi_ (x.doi_, f, this)
  {
  }

  BibliographicReferenceType::
  BibliographicReferenceType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    authors_ (this),
    publication_ (this),
    publisher_ (this),
    editor_ (this),
    year_ (this),
    volume_ (this),
    issue_ (this),
    pages_ (this),
    title_ (this),
    doi_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void BibliographicReferenceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "authors" && n.namespace_ ().empty ())
      {
        this->authors_.set (authors_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "publication" && n.namespace_ ().empty ())
      {
        this->publication_.set (publication_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "publisher" && n.namespace_ ().empty ())
      {
        this->publisher_.set (publisher_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "editor" && n.namespace_ ().empty ())
      {
        this->editor_.set (editor_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "year" && n.namespace_ ().empty ())
      {
        this->year_.set (year_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "volume" && n.namespace_ ().empty ())
      {
        this->volume_.set (volume_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "issue" && n.namespace_ ().empty ())
      {
        this->issue_.set (issue_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "pages" && n.namespace_ ().empty ())
      {
        this->pages_.set (pages_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "title" && n.namespace_ ().empty ())
      {
        this->title_.set (title_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "doi" && n.namespace_ ().empty ())
      {
        this->doi_.set (doi_traits::create (i, f, this));
        continue;
      }
    }
  }

  BibliographicReferenceType* BibliographicReferenceType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BibliographicReferenceType (*this, f, c);
  }

  BibliographicReferenceType& BibliographicReferenceType::
  operator= (const BibliographicReferenceType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->authors_ = x.authors_;
      this->publication_ = x.publication_;
      this->publisher_ = x.publisher_;
      this->editor_ = x.editor_;
      this->year_ = x.year_;
      this->volume_ = x.volume_;
      this->issue_ = x.issue_;
      this->pages_ = x.pages_;
      this->title_ = x.title_;
      this->doi_ = x.doi_;
    }

    return *this;
  }

  BibliographicReferenceType::
  ~BibliographicReferenceType ()
  {
  }

  // AbstractParamType
  //

  AbstractParamType::
  AbstractParamType ()
  : ::xml_schema::type (),
    name_ (this),
    value_ (this),
    unitAccession_ (this),
    unitName_ (this),
    unitCvRef_ (this)
  {
  }

  AbstractParamType::
  AbstractParamType (const name_type& name)
  : ::xml_schema::type (),
    name_ (name, this),
    value_ (this),
    unitAccession_ (this),
    unitName_ (this),
    unitCvRef_ (this)
  {
  }

  AbstractParamType::
  AbstractParamType (const AbstractParamType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    value_ (x.value_, f, this),
    unitAccession_ (x.unitAccession_, f, this),
    unitName_ (x.unitName_, f, this),
    unitCvRef_ (x.unitCvRef_, f, this)
  {
  }

  AbstractParamType::
  AbstractParamType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    value_ (this),
    unitAccession_ (this),
    unitName_ (this),
    unitCvRef_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void AbstractParamType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "unitAccession" && n.namespace_ ().empty ())
      {
        this->unitAccession_.set (unitAccession_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "unitName" && n.namespace_ ().empty ())
      {
        this->unitName_.set (unitName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "unitCvRef" && n.namespace_ ().empty ())
      {
        this->unitCvRef_.set (unitCvRef_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  AbstractParamType* AbstractParamType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AbstractParamType (*this, f, c);
  }

  AbstractParamType& AbstractParamType::
  operator= (const AbstractParamType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->name_ = x.name_;
      this->value_ = x.value_;
      this->unitAccession_ = x.unitAccession_;
      this->unitName_ = x.unitName_;
      this->unitCvRef_ = x.unitCvRef_;
    }

    return *this;
  }

  AbstractParamType::
  ~AbstractParamType ()
  {
  }

  // UserParamType
  //

  UserParamType::
  UserParamType ()
  : ::mzIdentML110::AbstractParamType (),
    type_ (this)
  {
  }

  UserParamType::
  UserParamType (const name_type& name)
  : ::mzIdentML110::AbstractParamType (name),
    type_ (this)
  {
  }

  UserParamType::
  UserParamType (const UserParamType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::mzIdentML110::AbstractParamType (x, f, c),
    type_ (x.type_, f, this)
  {
  }

  UserParamType::
  UserParamType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::mzIdentML110::AbstractParamType (e, f | ::xml_schema::flags::base, c),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void UserParamType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::AbstractParamType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }
  }

  UserParamType* UserParamType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UserParamType (*this, f, c);
  }

  UserParamType& UserParamType::
  operator= (const UserParamType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::AbstractParamType& > (*this) = x;
      this->type_ = x.type_;
    }

    return *this;
  }

  UserParamType::
  ~UserParamType ()
  {
  }

  // CVParamType
  //

  CVParamType::
  CVParamType ()
  : ::mzIdentML110::AbstractParamType (),
    cvRef_ (this),
    accession_ (this)
  {
  }

  CVParamType::
  CVParamType (const name_type& name,
               const cvRef_type& cvRef,
               const accession_type& accession)
  : ::mzIdentML110::AbstractParamType (name),
    cvRef_ (cvRef, this),
    accession_ (accession, this)
  {
  }

  CVParamType::
  CVParamType (const CVParamType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::mzIdentML110::AbstractParamType (x, f, c),
    cvRef_ (x.cvRef_, f, this),
    accession_ (x.accession_, f, this)
  {
  }

  CVParamType::
  CVParamType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::mzIdentML110::AbstractParamType (e, f | ::xml_schema::flags::base, c),
    cvRef_ (this),
    accession_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CVParamType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::AbstractParamType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "cvRef" && n.namespace_ ().empty ())
      {
        this->cvRef_.set (cvRef_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "accession" && n.namespace_ ().empty ())
      {
        this->accession_.set (accession_traits::create (i, f, this));
        continue;
      }
    }

    if (!cvRef_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "cvRef",
        "");
    }

    if (!accession_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "accession",
        "");
    }
  }

  CVParamType* CVParamType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CVParamType (*this, f, c);
  }

  CVParamType& CVParamType::
  operator= (const CVParamType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::AbstractParamType& > (*this) = x;
      this->cvRef_ = x.cvRef_;
      this->accession_ = x.accession_;
    }

    return *this;
  }

  CVParamType::
  ~CVParamType ()
  {
  }

  // cvType
  //

  cvType::
  cvType ()
  : ::xml_schema::type (),
    fullName_ (this),
    version_ (this),
    uri_ (this),
    id_ (this)
  {
  }

  cvType::
  cvType (const fullName_type& fullName,
          const uri_type& uri,
          const id_type& id)
  : ::xml_schema::type (),
    fullName_ (fullName, this),
    version_ (this),
    uri_ (uri, this),
    id_ (id, this)
  {
  }

  cvType::
  cvType (const cvType& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    fullName_ (x.fullName_, f, this),
    version_ (x.version_, f, this),
    uri_ (x.uri_, f, this),
    id_ (x.id_, f, this)
  {
  }

  cvType::
  cvType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    fullName_ (this),
    version_ (this),
    uri_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void cvType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "fullName" && n.namespace_ ().empty ())
      {
        this->fullName_.set (fullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        this->version_.set (version_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "uri" && n.namespace_ ().empty ())
      {
        this->uri_.set (uri_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!fullName_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "fullName",
        "");
    }

    if (!uri_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "uri",
        "");
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  cvType* cvType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class cvType (*this, f, c);
  }

  cvType& cvType::
  operator= (const cvType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->fullName_ = x.fullName_;
      this->version_ = x.version_;
      this->uri_ = x.uri_;
      this->id_ = x.id_;
    }

    return *this;
  }

  cvType::
  ~cvType ()
  {
  }

  // AuditCollectionType
  //

  AuditCollectionType::
  AuditCollectionType ()
  : ::xml_schema::type (),
    Person_ (this),
    Organization_ (this)
  {
  }

  AuditCollectionType::
  AuditCollectionType (const AuditCollectionType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Person_ (x.Person_, f, this),
    Organization_ (x.Organization_, f, this)
  {
  }

  AuditCollectionType::
  AuditCollectionType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Person_ (this),
    Organization_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AuditCollectionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Person
      //
      if (n.name () == "Person" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Person_type > r (
          Person_traits::create (i, f, this));

        this->Person_.push_back (::std::move (r));
        continue;
      }

      // Organization
      //
      if (n.name () == "Organization" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< Organization_type > r (
          Organization_traits::create (i, f, this));

        this->Organization_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AuditCollectionType* AuditCollectionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AuditCollectionType (*this, f, c);
  }

  AuditCollectionType& AuditCollectionType::
  operator= (const AuditCollectionType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Person_ = x.Person_;
      this->Organization_ = x.Organization_;
    }

    return *this;
  }

  AuditCollectionType::
  ~AuditCollectionType ()
  {
  }

  // ProviderType
  //

  ProviderType::
  ProviderType ()
  : ::mzIdentML110::IdentifiableType (),
    ContactRole_ (this),
    analysisSoftware_ref_ (this)
  {
  }

  ProviderType::
  ProviderType (const id_type& id)
  : ::mzIdentML110::IdentifiableType (id),
    ContactRole_ (this),
    analysisSoftware_ref_ (this)
  {
  }

  ProviderType::
  ProviderType (const ProviderType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (x, f, c),
    ContactRole_ (x.ContactRole_, f, this),
    analysisSoftware_ref_ (x.analysisSoftware_ref_, f, this)
  {
  }

  ProviderType::
  ProviderType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::mzIdentML110::IdentifiableType (e, f | ::xml_schema::flags::base, c),
    ContactRole_ (this),
    analysisSoftware_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ProviderType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::mzIdentML110::IdentifiableType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ContactRole
      //
      if (n.name () == "ContactRole" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< ContactRole_type > r (
          ContactRole_traits::create (i, f, this));

        if (!this->ContactRole_)
        {
          this->ContactRole_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "analysisSoftware_ref" && n.namespace_ ().empty ())
      {
        this->analysisSoftware_ref_.set (analysisSoftware_ref_traits::create (i, f, this));
        continue;
      }
    }
  }

  ProviderType* ProviderType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ProviderType (*this, f, c);
  }

  ProviderType& ProviderType::
  operator= (const ProviderType& x)
  {
    if (this != &x)
    {
      static_cast< ::mzIdentML110::IdentifiableType& > (*this) = x;
      this->ContactRole_ = x.ContactRole_;
      this->analysisSoftware_ref_ = x.analysisSoftware_ref_;
    }

    return *this;
  }

  ProviderType::
  ~ProviderType ()
  {
  }

  // ParamListType
  //

  ParamListType::
  ParamListType ()
  : ::xml_schema::type (),
    cvParam_ (this),
    userParam_ (this)
  {
  }

  ParamListType::
  ParamListType (const ParamListType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    cvParam_ (x.cvParam_, f, this),
    userParam_ (x.userParam_, f, this)
  {
  }

  ParamListType::
  ParamListType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    cvParam_ (this),
    userParam_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ParamListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        this->cvParam_.push_back (::std::move (r));
        continue;
      }

      // userParam
      //
      if (n.name () == "userParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< userParam_type > r (
          userParam_traits::create (i, f, this));

        this->userParam_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ParamListType* ParamListType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ParamListType (*this, f, c);
  }

  ParamListType& ParamListType::
  operator= (const ParamListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->cvParam_ = x.cvParam_;
      this->userParam_ = x.userParam_;
    }

    return *this;
  }

  ParamListType::
  ~ParamListType ()
  {
  }

  // ParamType
  //

  ParamType::
  ParamType ()
  : ::xml_schema::type (),
    cvParam_ (this),
    userParam_ (this)
  {
  }

  ParamType::
  ParamType (const ParamType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    cvParam_ (x.cvParam_, f, this),
    userParam_ (x.userParam_, f, this)
  {
  }

  ParamType::
  ParamType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    cvParam_ (this),
    userParam_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ParamType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // cvParam
      //
      if (n.name () == "cvParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< cvParam_type > r (
          cvParam_traits::create (i, f, this));

        if (!this->cvParam_)
        {
          this->cvParam_.set (::std::move (r));
          continue;
        }
      }

      // userParam
      //
      if (n.name () == "userParam" && n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
      {
        ::std::unique_ptr< userParam_type > r (
          userParam_traits::create (i, f, this));

        if (!this->userParam_)
        {
          this->userParam_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ParamType* ParamType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ParamType (*this, f, c);
  }

  ParamType& ParamType::
  operator= (const ParamType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->cvParam_ = x.cvParam_;
      this->userParam_ = x.userParam_;
    }

    return *this;
  }

  ParamType::
  ~ParamType ()
  {
  }

  // originalResidue
  //

  originalResidue::
  originalResidue ()
  : ::xml_schema::string ()
  {
  }

  originalResidue::
  originalResidue (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  originalResidue::
  originalResidue (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  originalResidue::
  originalResidue (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  originalResidue::
  originalResidue (const originalResidue& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  originalResidue::
  originalResidue (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  originalResidue::
  originalResidue (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  originalResidue::
  originalResidue (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  originalResidue* originalResidue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class originalResidue (*this, f, c);
  }

  originalResidue::
  ~originalResidue ()
  {
  }

  // replacementResidue
  //

  replacementResidue::
  replacementResidue ()
  : ::xml_schema::string ()
  {
  }

  replacementResidue::
  replacementResidue (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  replacementResidue::
  replacementResidue (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  replacementResidue::
  replacementResidue (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  replacementResidue::
  replacementResidue (const replacementResidue& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  replacementResidue::
  replacementResidue (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  replacementResidue::
  replacementResidue (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  replacementResidue::
  replacementResidue (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  replacementResidue* replacementResidue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class replacementResidue (*this, f, c);
  }

  replacementResidue::
  ~replacementResidue ()
  {
  }

  // nTermGain
  //

  nTermGain::
  nTermGain ()
  : ::xml_schema::string ()
  {
  }

  nTermGain::
  nTermGain (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  nTermGain::
  nTermGain (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  nTermGain::
  nTermGain (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  nTermGain::
  nTermGain (const nTermGain& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  nTermGain::
  nTermGain (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  nTermGain::
  nTermGain (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  nTermGain::
  nTermGain (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  nTermGain* nTermGain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class nTermGain (*this, f, c);
  }

  nTermGain::
  ~nTermGain ()
  {
  }

  // cTermGain
  //

  cTermGain::
  cTermGain ()
  : ::xml_schema::string ()
  {
  }

  cTermGain::
  cTermGain (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  cTermGain::
  cTermGain (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  cTermGain::
  cTermGain (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  cTermGain::
  cTermGain (const cTermGain& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  cTermGain::
  cTermGain (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  cTermGain::
  cTermGain (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  cTermGain::
  cTermGain (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  cTermGain* cTermGain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class cTermGain (*this, f, c);
  }

  cTermGain::
  ~cTermGain ()
  {
  }

  // minDistance
  //

  minDistance::
  minDistance ()
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > ()
  {
  }

  minDistance::
  minDistance (const ::xml_schema::int_& _xsd_int__base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (_xsd_int__base)
  {
  }

  minDistance::
  minDistance (const minDistance& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  minDistance::
  minDistance (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  minDistance::
  minDistance (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  minDistance::
  minDistance (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  minDistance* minDistance::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class minDistance (*this, f, c);
  }

  minDistance::
  ~minDistance ()
  {
  }

  // pre
  //

  pre::
  pre ()
  : ::xml_schema::string ()
  {
  }

  pre::
  pre (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  pre::
  pre (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  pre::
  pre (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  pre::
  pre (const pre& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  pre::
  pre (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  pre::
  pre (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  pre::
  pre (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  pre* pre::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class pre (*this, f, c);
  }

  pre::
  ~pre ()
  {
  }

  // post
  //

  post::
  post ()
  : ::xml_schema::string ()
  {
  }

  post::
  post (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  post::
  post (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  post::
  post (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  post::
  post (const post& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  post::
  post (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  post::
  post (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  post::
  post (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  post* post::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class post (*this, f, c);
  }

  post::
  ~post ()
  {
  }

  // listOfCharsOrAny_member
  //

  listOfCharsOrAny_member::
  listOfCharsOrAny_member (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::mzIdentML110::chars, char > (e, f, this)
  {
  }

  listOfCharsOrAny_member::
  listOfCharsOrAny_member (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::mzIdentML110::chars, char > (a, f, this)
  {
  }

  listOfCharsOrAny_member::
  listOfCharsOrAny_member (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::mzIdentML110::chars, char > (s, e, f, this)
  {
  }

  listOfCharsOrAny_member* listOfCharsOrAny_member::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class listOfCharsOrAny_member (*this, f, c);
  }

  listOfCharsOrAny_member::
  ~listOfCharsOrAny_member ()
  {
  }

  // listOfCharsOrAny_member1
  //

  listOfCharsOrAny_member1::
  listOfCharsOrAny_member1 (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_listOfCharsOrAny_member1_convert ();
  }

  listOfCharsOrAny_member1::
  listOfCharsOrAny_member1 (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_listOfCharsOrAny_member1_convert ();
  }

  listOfCharsOrAny_member1::
  listOfCharsOrAny_member1 (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_listOfCharsOrAny_member1_convert ();
  }

  listOfCharsOrAny_member1* listOfCharsOrAny_member1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class listOfCharsOrAny_member1 (*this, f, c);
  }

  listOfCharsOrAny_member1::value listOfCharsOrAny_member1::
  _xsd_listOfCharsOrAny_member1_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_listOfCharsOrAny_member1_literals_);
    const value* i (::std::lower_bound (
                      _xsd_listOfCharsOrAny_member1_indexes_,
                      _xsd_listOfCharsOrAny_member1_indexes_ + 1,
                      *this,
                      c));

    if (i == _xsd_listOfCharsOrAny_member1_indexes_ + 1 || _xsd_listOfCharsOrAny_member1_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const listOfCharsOrAny_member1::
  _xsd_listOfCharsOrAny_member1_literals_[1] =
  {
    "."
  };

  const listOfCharsOrAny_member1::value listOfCharsOrAny_member1::
  _xsd_listOfCharsOrAny_member1_indexes_[1] =
  {
    ::mzIdentML110::listOfCharsOrAny_member1::cxx_
  };
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace mzIdentML110
{
  ::std::unique_ptr< ::mzIdentML110::MzIdentMLType >
  MzIdentML (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::mzIdentML110::MzIdentMLType > (
      ::mzIdentML110::MzIdentML (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::mzIdentML110::MzIdentMLType >
  MzIdentML (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::mzIdentML110::MzIdentMLType > (
      ::mzIdentML110::MzIdentML (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::mzIdentML110::MzIdentMLType >
  MzIdentML (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::mzIdentML110::MzIdentMLType > (
      ::mzIdentML110::MzIdentML (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::mzIdentML110::MzIdentMLType >
  MzIdentML (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::mzIdentML110::MzIdentML (isrc, f, p);
  }

  ::std::unique_ptr< ::mzIdentML110::MzIdentMLType >
  MzIdentML (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::mzIdentML110::MzIdentML (isrc, h, f, p);
  }

  ::std::unique_ptr< ::mzIdentML110::MzIdentMLType >
  MzIdentML (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::mzIdentML110::MzIdentML (isrc, h, f, p);
  }

  ::std::unique_ptr< ::mzIdentML110::MzIdentMLType >
  MzIdentML (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::mzIdentML110::MzIdentML (isrc, f, p);
  }

  ::std::unique_ptr< ::mzIdentML110::MzIdentMLType >
  MzIdentML (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::mzIdentML110::MzIdentML (isrc, h, f, p);
  }

  ::std::unique_ptr< ::mzIdentML110::MzIdentMLType >
  MzIdentML (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::mzIdentML110::MzIdentML (isrc, h, f, p);
  }

  ::std::unique_ptr< ::mzIdentML110::MzIdentMLType >
  MzIdentML (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::mzIdentML110::MzIdentMLType > (
      ::mzIdentML110::MzIdentML (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::mzIdentML110::MzIdentMLType >
  MzIdentML (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::mzIdentML110::MzIdentMLType > (
      ::mzIdentML110::MzIdentML (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::mzIdentML110::MzIdentMLType >
  MzIdentML (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::mzIdentML110::MzIdentMLType > (
      ::mzIdentML110::MzIdentML (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::mzIdentML110::MzIdentMLType >
  MzIdentML (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::mzIdentML110::MzIdentMLType > (
        ::mzIdentML110::MzIdentML (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "MzIdentML" &&
        n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
    {
      ::std::unique_ptr< ::mzIdentML110::MzIdentMLType > r (
        ::xsd::cxx::tree::traits< ::mzIdentML110::MzIdentMLType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MzIdentML",
      "http://psidev.info/psi/pi/mzIdentML/1.1");
  }

  ::std::unique_ptr< ::mzIdentML110::MzIdentMLType >
  MzIdentML (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "MzIdentML" &&
        n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
    {
      ::std::unique_ptr< ::mzIdentML110::MzIdentMLType > r (
        ::xsd::cxx::tree::traits< ::mzIdentML110::MzIdentMLType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MzIdentML",
      "http://psidev.info/psi/pi/mzIdentML/1.1");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace mzIdentML110
{
  void
  MzIdentML (::std::ostream& o,
             const ::mzIdentML110::MzIdentMLType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::mzIdentML110::MzIdentML (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  MzIdentML (::std::ostream& o,
             const ::mzIdentML110::MzIdentMLType& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::mzIdentML110::MzIdentML (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  MzIdentML (::std::ostream& o,
             const ::mzIdentML110::MzIdentMLType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::mzIdentML110::MzIdentML (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  MzIdentML (::xercesc::XMLFormatTarget& t,
             const ::mzIdentML110::MzIdentMLType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::mzIdentML110::MzIdentML (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  MzIdentML (::xercesc::XMLFormatTarget& t,
             const ::mzIdentML110::MzIdentMLType& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::mzIdentML110::MzIdentML (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  MzIdentML (::xercesc::XMLFormatTarget& t,
             const ::mzIdentML110::MzIdentMLType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::mzIdentML110::MzIdentML (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  MzIdentML (::xercesc::DOMDocument& d,
             const ::mzIdentML110::MzIdentMLType& s,
             ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "MzIdentML" &&
        n.namespace_ () == "http://psidev.info/psi/pi/mzIdentML/1.1")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "MzIdentML",
        "http://psidev.info/psi/pi/mzIdentML/1.1");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  MzIdentML (const ::mzIdentML110::MzIdentMLType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "MzIdentML",
        "http://psidev.info/psi/pi/mzIdentML/1.1",
        m, f));

    ::mzIdentML110::MzIdentML (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const CVListType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // cv
    //
    for (CVListType::cv_const_iterator
         b (i.cv ().begin ()), n (i.cv ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cv",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AnalysisSoftwareListType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // AnalysisSoftware
    //
    for (AnalysisSoftwareListType::AnalysisSoftware_const_iterator
         b (i.AnalysisSoftware ().begin ()), n (i.AnalysisSoftware ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AnalysisSoftware",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AnalysisSampleCollectionType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Sample
    //
    for (AnalysisSampleCollectionType::Sample_const_iterator
         b (i.Sample ().begin ()), n (i.Sample ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Sample",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SequenceCollectionType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // DBSequence
    //
    for (SequenceCollectionType::DBSequence_const_iterator
         b (i.DBSequence ().begin ()), n (i.DBSequence ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DBSequence",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // Peptide
    //
    for (SequenceCollectionType::Peptide_const_iterator
         b (i.Peptide ().begin ()), n (i.Peptide ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Peptide",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // PeptideEvidence
    //
    for (SequenceCollectionType::PeptideEvidence_const_iterator
         b (i.PeptideEvidence ().begin ()), n (i.PeptideEvidence ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PeptideEvidence",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AnalysisCollectionType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // SpectrumIdentification
    //
    for (AnalysisCollectionType::SpectrumIdentification_const_iterator
         b (i.SpectrumIdentification ().begin ()), n (i.SpectrumIdentification ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SpectrumIdentification",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // ProteinDetection
    //
    if (i.ProteinDetection ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ProteinDetection",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.ProteinDetection ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AnalysisProtocolCollectionType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // SpectrumIdentificationProtocol
    //
    for (AnalysisProtocolCollectionType::SpectrumIdentificationProtocol_const_iterator
         b (i.SpectrumIdentificationProtocol ().begin ()), n (i.SpectrumIdentificationProtocol ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SpectrumIdentificationProtocol",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // ProteinDetectionProtocol
    //
    if (i.ProteinDetectionProtocol ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ProteinDetectionProtocol",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.ProteinDetectionProtocol ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // SourceFile
    //
    for (InputsType::SourceFile_const_iterator
         b (i.SourceFile ().begin ()), n (i.SourceFile ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SourceFile",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // SearchDatabase
    //
    for (InputsType::SearchDatabase_const_iterator
         b (i.SearchDatabase ().begin ()), n (i.SearchDatabase ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SearchDatabase",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // SpectraData
    //
    for (InputsType::SpectraData_const_iterator
         b (i.SpectraData ().begin ()), n (i.SpectraData ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SpectraData",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AnalysisDataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // SpectrumIdentificationList
    //
    for (AnalysisDataType::SpectrumIdentificationList_const_iterator
         b (i.SpectrumIdentificationList ().begin ()), n (i.SpectrumIdentificationList ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SpectrumIdentificationList",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // ProteinDetectionList
    //
    if (i.ProteinDetectionList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ProteinDetectionList",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.ProteinDetectionList ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DataCollectionType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Inputs
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Inputs",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << i.Inputs ();
    }

    // AnalysisData
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AnalysisData",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << i.AnalysisData ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const IdentifiableType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    if (i.name ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MzIdentMLType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // cvList
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvList",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << i.cvList ();
    }

    // AnalysisSoftwareList
    //
    if (i.AnalysisSoftwareList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AnalysisSoftwareList",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.AnalysisSoftwareList ();
    }

    // Provider
    //
    if (i.Provider ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Provider",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.Provider ();
    }

    // AuditCollection
    //
    if (i.AuditCollection ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AuditCollection",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.AuditCollection ();
    }

    // AnalysisSampleCollection
    //
    if (i.AnalysisSampleCollection ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AnalysisSampleCollection",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.AnalysisSampleCollection ();
    }

    // SequenceCollection
    //
    if (i.SequenceCollection ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SequenceCollection",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.SequenceCollection ();
    }

    // AnalysisCollection
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AnalysisCollection",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << i.AnalysisCollection ();
    }

    // AnalysisProtocolCollection
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AnalysisProtocolCollection",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << i.AnalysisProtocolCollection ();
    }

    // DataCollection
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DataCollection",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << i.DataCollection ();
    }

    // BibliographicReference
    //
    for (MzIdentMLType::BibliographicReference_const_iterator
         b (i.BibliographicReference ().begin ()), n (i.BibliographicReference ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "BibliographicReference",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // creationDate
    //
    if (i.creationDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "creationDate",
          e));

      a << *i.creationDate ();
    }

    // version
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "version",
          e));

      a << i.version ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ExternalDataType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // ExternalFormatDocumentation
    //
    if (i.ExternalFormatDocumentation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ExternalFormatDocumentation",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.ExternalFormatDocumentation ();
    }

    // FileFormat
    //
    if (i.FileFormat ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FileFormat",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.FileFormat ();
    }

    // location
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "location",
          e));

      a << i.location ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SearchDatabaseType& i)
  {
    e << static_cast< const ::mzIdentML110::ExternalDataType& > (i);

    // DatabaseName
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DatabaseName",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << i.DatabaseName ();
    }

    // cvParam
    //
    for (SearchDatabaseType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // version
    //
    if (i.version ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "version",
          e));

      a << *i.version ();
    }

    // releaseDate
    //
    if (i.releaseDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "releaseDate",
          e));

      a << *i.releaseDate ();
    }

    // numDatabaseSequences
    //
    if (i.numDatabaseSequences ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "numDatabaseSequences",
          e));

      a << *i.numDatabaseSequences ();
    }

    // numResidues
    //
    if (i.numResidues ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "numResidues",
          e));

      a << *i.numResidues ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SourceFileType& i)
  {
    e << static_cast< const ::mzIdentML110::ExternalDataType& > (i);

    // cvParam
    //
    for (SourceFileType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // userParam
    //
    for (SourceFileType::userParam_const_iterator
         b (i.userParam ().begin ()), n (i.userParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ModificationParamsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // SearchModification
    //
    for (ModificationParamsType::SearchModification_const_iterator
         b (i.SearchModification ().begin ()), n (i.SearchModification ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SearchModification",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const FilterType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // FilterType
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FilterType",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << i.FilterType1 ();
    }

    // Include
    //
    if (i.Include ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Include",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.Include ();
    }

    // Exclude
    //
    if (i.Exclude ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Exclude",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.Exclude ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DatabaseFiltersType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Filter
    //
    for (DatabaseFiltersType::Filter_const_iterator
         b (i.Filter ().begin ()), n (i.Filter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Filter",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TranslationTableType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // cvParam
    //
    for (TranslationTableType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DatabaseTranslationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // TranslationTable
    //
    for (DatabaseTranslationType::TranslationTable_const_iterator
         b (i.TranslationTable ().begin ()), n (i.TranslationTable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TranslationTable",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // frames
    //
    if (i.frames ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "frames",
          e));

      a << *i.frames ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpectrumIdentificationProtocolType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // SearchType
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SearchType",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << i.SearchType ();
    }

    // AdditionalSearchParams
    //
    if (i.AdditionalSearchParams ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AdditionalSearchParams",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.AdditionalSearchParams ();
    }

    // ModificationParams
    //
    if (i.ModificationParams ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ModificationParams",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.ModificationParams ();
    }

    // Enzymes
    //
    if (i.Enzymes ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Enzymes",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.Enzymes ();
    }

    // MassTable
    //
    for (SpectrumIdentificationProtocolType::MassTable_const_iterator
         b (i.MassTable ().begin ()), n (i.MassTable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MassTable",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // FragmentTolerance
    //
    if (i.FragmentTolerance ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FragmentTolerance",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.FragmentTolerance ();
    }

    // ParentTolerance
    //
    if (i.ParentTolerance ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ParentTolerance",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.ParentTolerance ();
    }

    // Threshold
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Threshold",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << i.Threshold ();
    }

    // DatabaseFilters
    //
    if (i.DatabaseFilters ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DatabaseFilters",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.DatabaseFilters ();
    }

    // DatabaseTranslation
    //
    if (i.DatabaseTranslation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DatabaseTranslation",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.DatabaseTranslation ();
    }

    // analysisSoftware_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "analysisSoftware_ref",
          e));

      a << i.analysisSoftware_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputSpectraType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // spectraData_ref
    //
    if (i.spectraData_ref ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "spectraData_ref",
          e));

      a << *i.spectraData_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SearchDatabaseRefType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // searchDatabase_ref
    //
    if (i.searchDatabase_ref ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "searchDatabase_ref",
          e));

      a << *i.searchDatabase_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ProtocolApplicationType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // activityDate
    //
    if (i.activityDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "activityDate",
          e));

      a << *i.activityDate ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpectrumIdentificationType& i)
  {
    e << static_cast< const ::mzIdentML110::ProtocolApplicationType& > (i);

    // InputSpectra
    //
    for (SpectrumIdentificationType::InputSpectra_const_iterator
         b (i.InputSpectra ().begin ()), n (i.InputSpectra ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "InputSpectra",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // SearchDatabaseRef
    //
    for (SpectrumIdentificationType::SearchDatabaseRef_const_iterator
         b (i.SearchDatabaseRef ().begin ()), n (i.SearchDatabaseRef ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SearchDatabaseRef",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // spectrumIdentificationProtocol_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "spectrumIdentificationProtocol_ref",
          e));

      a << i.spectrumIdentificationProtocol_ref ();
    }

    // spectrumIdentificationList_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "spectrumIdentificationList_ref",
          e));

      a << i.spectrumIdentificationList_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MeasureType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // cvParam
    //
    for (MeasureType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const FragmentationTableType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Measure
    //
    for (FragmentationTableType::Measure_const_iterator
         b (i.Measure ().begin ()), n (i.Measure ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Measure",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpectrumIdentificationListType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // FragmentationTable
    //
    if (i.FragmentationTable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FragmentationTable",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.FragmentationTable ();
    }

    // SpectrumIdentificationResult
    //
    for (SpectrumIdentificationListType::SpectrumIdentificationResult_const_iterator
         b (i.SpectrumIdentificationResult ().begin ()), n (i.SpectrumIdentificationResult ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SpectrumIdentificationResult",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // cvParam
    //
    for (SpectrumIdentificationListType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // userParam
    //
    for (SpectrumIdentificationListType::userParam_const_iterator
         b (i.userParam ().begin ()), n (i.userParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // numSequencesSearched
    //
    if (i.numSequencesSearched ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "numSequencesSearched",
          e));

      a << *i.numSequencesSearched ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpecificityRulesType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // cvParam
    //
    for (SpecificityRulesType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SearchModificationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // SpecificityRules
    //
    for (SearchModificationType::SpecificityRules_const_iterator
         b (i.SpecificityRules ().begin ()), n (i.SpecificityRules ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SpecificityRules",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // cvParam
    //
    for (SearchModificationType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // fixedMod
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "fixedMod",
          e));

      a << i.fixedMod ();
    }

    // massDelta
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "massDelta",
          e));

      a << i.massDelta ();
    }

    // residues
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "residues",
          e));

      a << i.residues ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const FragmentArrayType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // values
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "values",
          e));

      a << i.values ();
    }

    // measure_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "measure_ref",
          e));

      a << i.measure_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const IonTypeType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // FragmentArray
    //
    for (IonTypeType::FragmentArray_const_iterator
         b (i.FragmentArray ().begin ()), n (i.FragmentArray ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FragmentArray",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // cvParam
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << i.cvParam ();
    }

    // index
    //
    if (i.index ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "index",
          e));

      a << *i.index ();
    }

    // charge
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "charge",
          e));

      a << i.charge ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const FragmentationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // IonType
    //
    for (FragmentationType::IonType_const_iterator
         b (i.IonType ().begin ()), n (i.IonType ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "IonType",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PeptideEvidenceRefType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // peptideEvidence_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "peptideEvidence_ref",
          e));

      a << i.peptideEvidence_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpectrumIdentificationItemType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // PeptideEvidenceRef
    //
    for (SpectrumIdentificationItemType::PeptideEvidenceRef_const_iterator
         b (i.PeptideEvidenceRef ().begin ()), n (i.PeptideEvidenceRef ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PeptideEvidenceRef",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // Fragmentation
    //
    if (i.Fragmentation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Fragmentation",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.Fragmentation ();
    }

    // cvParam
    //
    for (SpectrumIdentificationItemType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // userParam
    //
    for (SpectrumIdentificationItemType::userParam_const_iterator
         b (i.userParam ().begin ()), n (i.userParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // chargeState
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "chargeState",
          e));

      a << i.chargeState ();
    }

    // experimentalMassToCharge
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "experimentalMassToCharge",
          e));

      a << ::xml_schema::as_double(i.experimentalMassToCharge ());
    }

    // calculatedMassToCharge
    //
    if (i.calculatedMassToCharge ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "calculatedMassToCharge",
          e));

      a << ::xml_schema::as_double(*i.calculatedMassToCharge ());
    }

    // calculatedPI
    //
    if (i.calculatedPI ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "calculatedPI",
          e));

      a << *i.calculatedPI ();
    }

    // peptide_ref
    //
    if (i.peptide_ref ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "peptide_ref",
          e));

      a << *i.peptide_ref ();
    }

    // rank
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "rank",
          e));

      a << i.rank ();
    }

    // passThreshold
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "passThreshold",
          e));

      a << i.passThreshold ();
    }

    // massTable_ref
    //
    if (i.massTable_ref ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "massTable_ref",
          e));

      a << *i.massTable_ref ();
    }

    // sample_ref
    //
    if (i.sample_ref ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sample_ref",
          e));

      a << *i.sample_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpectrumIdentificationResultType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // SpectrumIdentificationItem
    //
    for (SpectrumIdentificationResultType::SpectrumIdentificationItem_const_iterator
         b (i.SpectrumIdentificationItem ().begin ()), n (i.SpectrumIdentificationItem ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SpectrumIdentificationItem",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // cvParam
    //
    for (SpectrumIdentificationResultType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // userParam
    //
    for (SpectrumIdentificationResultType::userParam_const_iterator
         b (i.userParam ().begin ()), n (i.userParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // spectrumID
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "spectrumID",
          e));

      a << i.spectrumID ();
    }

    // spectraData_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "spectraData_ref",
          e));

      a << i.spectraData_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputSpectrumIdentificationsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // spectrumIdentificationList_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "spectrumIdentificationList_ref",
          e));

      a << i.spectrumIdentificationList_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ProteinDetectionType& i)
  {
    e << static_cast< const ::mzIdentML110::ProtocolApplicationType& > (i);

    // InputSpectrumIdentifications
    //
    for (ProteinDetectionType::InputSpectrumIdentifications_const_iterator
         b (i.InputSpectrumIdentifications ().begin ()), n (i.InputSpectrumIdentifications ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "InputSpectrumIdentifications",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // proteinDetectionList_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "proteinDetectionList_ref",
          e));

      a << i.proteinDetectionList_ref ();
    }

    // proteinDetectionProtocol_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "proteinDetectionProtocol_ref",
          e));

      a << i.proteinDetectionProtocol_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ProteinDetectionProtocolType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // AnalysisParams
    //
    if (i.AnalysisParams ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AnalysisParams",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.AnalysisParams ();
    }

    // Threshold
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Threshold",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << i.Threshold ();
    }

    // analysisSoftware_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "analysisSoftware_ref",
          e));

      a << i.analysisSoftware_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ProteinDetectionListType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // ProteinAmbiguityGroup
    //
    for (ProteinDetectionListType::ProteinAmbiguityGroup_const_iterator
         b (i.ProteinAmbiguityGroup ().begin ()), n (i.ProteinAmbiguityGroup ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ProteinAmbiguityGroup",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // cvParam
    //
    for (ProteinDetectionListType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // userParam
    //
    for (ProteinDetectionListType::userParam_const_iterator
         b (i.userParam ().begin ()), n (i.userParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpectrumIdentificationItemRefType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // spectrumIdentificationItem_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "spectrumIdentificationItem_ref",
          e));

      a << i.spectrumIdentificationItem_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PeptideHypothesisType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // SpectrumIdentificationItemRef
    //
    for (PeptideHypothesisType::SpectrumIdentificationItemRef_const_iterator
         b (i.SpectrumIdentificationItemRef ().begin ()), n (i.SpectrumIdentificationItemRef ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SpectrumIdentificationItemRef",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // peptideEvidence_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "peptideEvidence_ref",
          e));

      a << i.peptideEvidence_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ProteinDetectionHypothesisType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // PeptideHypothesis
    //
    for (ProteinDetectionHypothesisType::PeptideHypothesis_const_iterator
         b (i.PeptideHypothesis ().begin ()), n (i.PeptideHypothesis ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PeptideHypothesis",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // cvParam
    //
    for (ProteinDetectionHypothesisType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // userParam
    //
    for (ProteinDetectionHypothesisType::userParam_const_iterator
         b (i.userParam ().begin ()), n (i.userParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // dBSequence_ref
    //
    if (i.dBSequence_ref ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dBSequence_ref",
          e));

      a << *i.dBSequence_ref ();
    }

    // passThreshold
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "passThreshold",
          e));

      a << i.passThreshold ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ProteinAmbiguityGroupType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // ProteinDetectionHypothesis
    //
    for (ProteinAmbiguityGroupType::ProteinDetectionHypothesis_const_iterator
         b (i.ProteinDetectionHypothesis ().begin ()), n (i.ProteinDetectionHypothesis ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ProteinDetectionHypothesis",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // cvParam
    //
    for (ProteinAmbiguityGroupType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // userParam
    //
    for (ProteinAmbiguityGroupType::userParam_const_iterator
         b (i.userParam ().begin ()), n (i.userParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ModificationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // cvParam
    //
    for (ModificationType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // location
    //
    if (i.location ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "location",
          e));

      a << *i.location ();
    }

    // residues
    //
    if (i.residues ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "residues",
          e));

      a << *i.residues ();
    }

    // avgMassDelta
    //
    if (i.avgMassDelta ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "avgMassDelta",
          e));

      a << ::xml_schema::as_double(*i.avgMassDelta ());
    }

    // monoisotopicMassDelta
    //
    if (i.monoisotopicMassDelta ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "monoisotopicMassDelta",
          e));

      a << ::xml_schema::as_double(*i.monoisotopicMassDelta ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PeptideType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // PeptideSequence
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PeptideSequence",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << i.PeptideSequence ();
    }

    // Modification
    //
    for (PeptideType::Modification_const_iterator
         b (i.Modification ().begin ()), n (i.Modification ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Modification",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // SubstitutionModification
    //
    for (PeptideType::SubstitutionModification_const_iterator
         b (i.SubstitutionModification ().begin ()), n (i.SubstitutionModification ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SubstitutionModification",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // cvParam
    //
    for (PeptideType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // userParam
    //
    for (PeptideType::userParam_const_iterator
         b (i.userParam ().begin ()), n (i.userParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SubstitutionModificationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // originalResidue
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalResidue",
          e));

      a << i.originalResidue ();
    }

    // replacementResidue
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "replacementResidue",
          e));

      a << i.replacementResidue ();
    }

    // location
    //
    if (i.location ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "location",
          e));

      a << *i.location ();
    }

    // avgMassDelta
    //
    if (i.avgMassDelta ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "avgMassDelta",
          e));

      a << ::xml_schema::as_double(*i.avgMassDelta ());
    }

    // monoisotopicMassDelta
    //
    if (i.monoisotopicMassDelta ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "monoisotopicMassDelta",
          e));

      a << ::xml_schema::as_double(*i.monoisotopicMassDelta ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpectraDataType& i)
  {
    e << static_cast< const ::mzIdentML110::ExternalDataType& > (i);

    // SpectrumIDFormat
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SpectrumIDFormat",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << i.SpectrumIDFormat ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AnalysisSoftwareType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // ContactRole
    //
    if (i.ContactRole ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ContactRole",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.ContactRole ();
    }

    // SoftwareName
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SoftwareName",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << i.SoftwareName ();
    }

    // Customizations
    //
    if (i.Customizations ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Customizations",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.Customizations ();
    }

    // version
    //
    if (i.version ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "version",
          e));

      a << *i.version ();
    }

    // uri
    //
    if (i.uri ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "uri",
          e));

      a << *i.uri ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EnzymeType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // SiteRegexp
    //
    if (i.SiteRegexp ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SiteRegexp",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.SiteRegexp ();
    }

    // EnzymeName
    //
    if (i.EnzymeName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EnzymeName",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.EnzymeName ();
    }

    // nTermGain
    //
    if (i.nTermGain ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "nTermGain",
          e));

      a << *i.nTermGain ();
    }

    // cTermGain
    //
    if (i.cTermGain ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "cTermGain",
          e));

      a << *i.cTermGain ();
    }

    // semiSpecific
    //
    if (i.semiSpecific ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "semiSpecific",
          e));

      a << *i.semiSpecific ();
    }

    // missedCleavages
    //
    if (i.missedCleavages ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "missedCleavages",
          e));

      a << *i.missedCleavages ();
    }

    // minDistance
    //
    if (i.minDistance ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "minDistance",
          e));

      a << *i.minDistance ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EnzymesType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Enzyme
    //
    for (EnzymesType::Enzyme_const_iterator
         b (i.Enzyme ().begin ()), n (i.Enzyme ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Enzyme",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // independent
    //
    if (i.independent ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "independent",
          e));

      a << *i.independent ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ResidueType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // code
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "code",
          e));

      a << i.code ();
    }

    // mass
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "mass",
          e));

      a << i.mass ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AmbiguousResidueType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // cvParam
    //
    for (AmbiguousResidueType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // userParam
    //
    for (AmbiguousResidueType::userParam_const_iterator
         b (i.userParam ().begin ()), n (i.userParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // code
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "code",
          e));

      a << i.code ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MassTableType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // Residue
    //
    for (MassTableType::Residue_const_iterator
         b (i.Residue ().begin ()), n (i.Residue ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Residue",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // AmbiguousResidue
    //
    for (MassTableType::AmbiguousResidue_const_iterator
         b (i.AmbiguousResidue ().begin ()), n (i.AmbiguousResidue ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AmbiguousResidue",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // cvParam
    //
    for (MassTableType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // userParam
    //
    for (MassTableType::userParam_const_iterator
         b (i.userParam ().begin ()), n (i.userParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // msLevel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "msLevel",
          e));

      a << i.msLevel ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PeptideEvidenceType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // cvParam
    //
    for (PeptideEvidenceType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // userParam
    //
    for (PeptideEvidenceType::userParam_const_iterator
         b (i.userParam ().begin ()), n (i.userParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // dBSequence_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dBSequence_ref",
          e));

      a << i.dBSequence_ref ();
    }

    // peptide_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "peptide_ref",
          e));

      a << i.peptide_ref ();
    }

    // start
    //
    if (i.start ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "start",
          e));

      a << *i.start ();
    }

    // end
    //
    if (i.end ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "end",
          e));

      a << *i.end ();
    }

    // pre
    //
    if (i.pre ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "pre",
          e));

      a << *i.pre ();
    }

    // post
    //
    if (i.post ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "post",
          e));

      a << *i.post ();
    }

    // translationTable_ref
    //
    if (i.translationTable_ref ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "translationTable_ref",
          e));

      a << *i.translationTable_ref ();
    }

    // frame
    //
    if (i.frame ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "frame",
          e));

      a << *i.frame ();
    }

    // isDecoy
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isDecoy",
          e));

      a << i.isDecoy ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ToleranceType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // cvParam
    //
    for (ToleranceType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpectrumIDFormatType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // cvParam
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << i.cvParam ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DBSequenceType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // Seq
    //
    if (i.Seq ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Seq",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.Seq ();
    }

    // cvParam
    //
    for (DBSequenceType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // userParam
    //
    for (DBSequenceType::userParam_const_iterator
         b (i.userParam ().begin ()), n (i.userParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // length
    //
    if (i.length ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "length",
          e));

      a << *i.length ();
    }

    // searchDatabase_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "searchDatabase_ref",
          e));

      a << i.searchDatabase_ref ();
    }

    // accession
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "accession",
          e));

      a << i.accession ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SampleType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // ContactRole
    //
    for (SampleType::ContactRole_const_iterator
         b (i.ContactRole ().begin ()), n (i.ContactRole ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ContactRole",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // SubSample
    //
    for (SampleType::SubSample_const_iterator
         b (i.SubSample ().begin ()), n (i.SubSample ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SubSample",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // cvParam
    //
    for (SampleType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // userParam
    //
    for (SampleType::userParam_const_iterator
         b (i.userParam ().begin ()), n (i.userParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SubSampleType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // sample_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sample_ref",
          e));

      a << i.sample_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const listOfIntegers& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::integer, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const listOfIntegers& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::integer, char >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const listOfIntegers& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::integer, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const listOfFloats& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::float_, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const listOfFloats& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::float_, char >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const listOfFloats& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::float_, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const listOfChars& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::mzIdentML110::chars, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const listOfChars& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::mzIdentML110::chars, char >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const listOfChars& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::mzIdentML110::chars, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const listOfCharsOrAny& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const listOfCharsOrAny& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const listOfCharsOrAny& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const chars& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const chars& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const chars& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const sequence& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const sequence& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const sequence& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const allowed_frames& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const allowed_frames& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const allowed_frames& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const listOfAllowedFrames& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::mzIdentML110::allowed_frames, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const listOfAllowedFrames& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::mzIdentML110::allowed_frames, char >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const listOfAllowedFrames& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::mzIdentML110::allowed_frames, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const versionRegex& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const versionRegex& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const versionRegex& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const FileFormatType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // cvParam
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << i.cvParam ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AbstractContactType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // cvParam
    //
    for (AbstractContactType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // userParam
    //
    for (AbstractContactType::userParam_const_iterator
         b (i.userParam ().begin ()), n (i.userParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PersonType& i)
  {
    e << static_cast< const ::mzIdentML110::AbstractContactType& > (i);

    // Affiliation
    //
    for (PersonType::Affiliation_const_iterator
         b (i.Affiliation ().begin ()), n (i.Affiliation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Affiliation",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // lastName
    //
    if (i.lastName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "lastName",
          e));

      a << *i.lastName ();
    }

    // firstName
    //
    if (i.firstName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "firstName",
          e));

      a << *i.firstName ();
    }

    // midInitials
    //
    if (i.midInitials ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "midInitials",
          e));

      a << *i.midInitials ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AffiliationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // organization_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "organization_ref",
          e));

      a << i.organization_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const OrganizationType& i)
  {
    e << static_cast< const ::mzIdentML110::AbstractContactType& > (i);

    // Parent
    //
    if (i.Parent ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Parent",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.Parent ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParentOrganizationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // organization_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "organization_ref",
          e));

      a << i.organization_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ContactRoleType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Role
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Role",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << i.Role ();
    }

    // contact_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "contact_ref",
          e));

      a << i.contact_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RoleType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // cvParam
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << i.cvParam ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BibliographicReferenceType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // authors
    //
    if (i.authors ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "authors",
          e));

      a << *i.authors ();
    }

    // publication
    //
    if (i.publication ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "publication",
          e));

      a << *i.publication ();
    }

    // publisher
    //
    if (i.publisher ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "publisher",
          e));

      a << *i.publisher ();
    }

    // editor
    //
    if (i.editor ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "editor",
          e));

      a << *i.editor ();
    }

    // year
    //
    if (i.year ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "year",
          e));

      a << *i.year ();
    }

    // volume
    //
    if (i.volume ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "volume",
          e));

      a << *i.volume ();
    }

    // issue
    //
    if (i.issue ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "issue",
          e));

      a << *i.issue ();
    }

    // pages
    //
    if (i.pages ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "pages",
          e));

      a << *i.pages ();
    }

    // title
    //
    if (i.title ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "title",
          e));

      a << *i.title ();
    }

    // doi
    //
    if (i.doi ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "doi",
          e));

      a << *i.doi ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AbstractParamType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // value
    //
    if (i.value ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << *i.value ();
    }

    // unitAccession
    //
    if (i.unitAccession ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unitAccession",
          e));

      a << *i.unitAccession ();
    }

    // unitName
    //
    if (i.unitName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unitName",
          e));

      a << *i.unitName ();
    }

    // unitCvRef
    //
    if (i.unitCvRef ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unitCvRef",
          e));

      a << *i.unitCvRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UserParamType& i)
  {
    e << static_cast< const ::mzIdentML110::AbstractParamType& > (i);

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << *i.type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CVParamType& i)
  {
    e << static_cast< const ::mzIdentML110::AbstractParamType& > (i);

    // cvRef
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "cvRef",
          e));

      a << i.cvRef ();
    }

    // accession
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "accession",
          e));

      a << i.accession ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const cvType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // fullName
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "fullName",
          e));

      a << i.fullName ();
    }

    // version
    //
    if (i.version ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "version",
          e));

      a << *i.version ();
    }

    // uri
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "uri",
          e));

      a << i.uri ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AuditCollectionType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Person
    //
    for (AuditCollectionType::Person_const_iterator
         b (i.Person ().begin ()), n (i.Person ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Person",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // Organization
    //
    for (AuditCollectionType::Organization_const_iterator
         b (i.Organization ().begin ()), n (i.Organization ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Organization",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ProviderType& i)
  {
    e << static_cast< const ::mzIdentML110::IdentifiableType& > (i);

    // ContactRole
    //
    if (i.ContactRole ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ContactRole",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.ContactRole ();
    }

    // analysisSoftware_ref
    //
    if (i.analysisSoftware_ref ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "analysisSoftware_ref",
          e));

      a << *i.analysisSoftware_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParamListType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // cvParam
    //
    for (ParamListType::cvParam_const_iterator
         b (i.cvParam ().begin ()), n (i.cvParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }

    // userParam
    //
    for (ParamListType::userParam_const_iterator
         b (i.userParam ().begin ()), n (i.userParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParamType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // cvParam
    //
    if (i.cvParam ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cvParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.cvParam ();
    }

    // userParam
    //
    if (i.userParam ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParam",
          "http://psidev.info/psi/pi/mzIdentML/1.1",
          e));

      s << *i.userParam ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const originalResidue& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const originalResidue& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const originalResidue& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const replacementResidue& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const replacementResidue& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const replacementResidue& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const nTermGain& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const nTermGain& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const nTermGain& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const cTermGain& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const cTermGain& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const cTermGain& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const minDistance& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const minDistance& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const minDistance& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const pre& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const pre& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const pre& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const post& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const post& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const post& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const listOfCharsOrAny_member& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::mzIdentML110::chars, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const listOfCharsOrAny_member& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::mzIdentML110::chars, char >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const listOfCharsOrAny_member& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::mzIdentML110::chars, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const listOfCharsOrAny_member1& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const listOfCharsOrAny_member1& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const listOfCharsOrAny_member1& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

