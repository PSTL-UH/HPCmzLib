// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef MZ_IDENT_ML120_H
#define MZ_IDENT_ML120_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace mzIdentML120
{
  class CVListType;
  class AnalysisSoftwareListType;
  class AnalysisSampleCollectionType;
  class SequenceCollectionType;
  class AnalysisCollectionType;
  class AnalysisProtocolCollectionType;
  class InputsType;
  class AnalysisDataType;
  class DataCollectionType;
  class IdentifiableType;
  class MzIdentMLType;
  class ExternalDataType;
  class SearchDatabaseType;
  class SourceFileType;
  class ModificationParamsType;
  class FilterType;
  class DatabaseFiltersType;
  class TranslationTableType;
  class DatabaseTranslationType;
  class SpectrumIdentificationProtocolType;
  class InputSpectraType;
  class SearchDatabaseRefType;
  class ProtocolApplicationType;
  class SpectrumIdentificationType;
  class MeasureType;
  class FragmentationTableType;
  class SpectrumIdentificationListType;
  class SpecificityRulesType;
  class SearchModificationType;
  class FragmentArrayType;
  class IonTypeType;
  class FragmentationType;
  class PeptideEvidenceRefType;
  class SpectrumIdentificationItemType;
  class SpectrumIdentificationResultType;
  class InputSpectrumIdentificationsType;
  class ProteinDetectionType;
  class ProteinDetectionProtocolType;
  class ProteinDetectionListType;
  class SpectrumIdentificationItemRefType;
  class PeptideHypothesisType;
  class ProteinDetectionHypothesisType;
  class ProteinAmbiguityGroupType;
  class ModificationType;
  class PeptideType;
  class SubstitutionModificationType;
  class SpectraDataType;
  class AnalysisSoftwareType;
  class EnzymeType;
  class EnzymesType;
  class ResidueType;
  class AmbiguousResidueType;
  class MassTableType;
  class PeptideEvidenceType;
  class ToleranceType;
  class SpectrumIDFormatType;
  class DBSequenceType;
  class SampleType;
  class SubSampleType;
  class listOfIntegers;
  class listOfFloats;
  class listOfChars;
  class listOfCharsOrAny;
  class chars;
  class sequence;
  class allowed_frames;
  class listOfAllowedFrames;
  class versionRegex;
  class FileFormatType;
  class AbstractContactType;
  class PersonType;
  class AffiliationType;
  class OrganizationType;
  class ParentOrganizationType;
  class ContactRoleType;
  class RoleType;
  class BibliographicReferenceType;
  class AbstractParamType;
  class UserParamType;
  class CVParamType;
  class cvType;
  class AuditCollectionType;
  class ProviderType;
  class ParamListType;
  class ParamType;
  class originalResidue;
  class replacementResidue;
  class nTermGain;
  class cTermGain;
  class minDistance;
  class pre;
  class post;
  class listOfCharsOrAny_member;
  class listOfCharsOrAny_member1;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

namespace mzIdentML120
{
  class CVListType: public ::xml_schema::type
  {
    public:
    // cv
    //
    typedef ::mzIdentML120::cvType cv_type;
    typedef ::xsd::cxx::tree::sequence< cv_type > cv_sequence;
    typedef cv_sequence::iterator cv_iterator;
    typedef cv_sequence::const_iterator cv_const_iterator;
    typedef ::xsd::cxx::tree::traits< cv_type, char > cv_traits;

    const cv_sequence&
    cv () const;

    cv_sequence&
    cv ();

    void
    cv (const cv_sequence& s);

    // Constructors.
    //
    CVListType ();

    CVListType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    CVListType (const CVListType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual CVListType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CVListType&
    operator= (const CVListType& x);

    virtual 
    ~CVListType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    cv_sequence cv_;
  };

  class AnalysisSoftwareListType: public ::xml_schema::type
  {
    public:
    // AnalysisSoftware
    //
    typedef ::mzIdentML120::AnalysisSoftwareType AnalysisSoftware_type;
    typedef ::xsd::cxx::tree::sequence< AnalysisSoftware_type > AnalysisSoftware_sequence;
    typedef AnalysisSoftware_sequence::iterator AnalysisSoftware_iterator;
    typedef AnalysisSoftware_sequence::const_iterator AnalysisSoftware_const_iterator;
    typedef ::xsd::cxx::tree::traits< AnalysisSoftware_type, char > AnalysisSoftware_traits;

    const AnalysisSoftware_sequence&
    AnalysisSoftware () const;

    AnalysisSoftware_sequence&
    AnalysisSoftware ();

    void
    AnalysisSoftware (const AnalysisSoftware_sequence& s);

    // Constructors.
    //
    AnalysisSoftwareListType ();

    AnalysisSoftwareListType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    AnalysisSoftwareListType (const AnalysisSoftwareListType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual AnalysisSoftwareListType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AnalysisSoftwareListType&
    operator= (const AnalysisSoftwareListType& x);

    virtual 
    ~AnalysisSoftwareListType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    AnalysisSoftware_sequence AnalysisSoftware_;
  };

  class AnalysisSampleCollectionType: public ::xml_schema::type
  {
    public:
    // Sample
    //
    typedef ::mzIdentML120::SampleType Sample_type;
    typedef ::xsd::cxx::tree::sequence< Sample_type > Sample_sequence;
    typedef Sample_sequence::iterator Sample_iterator;
    typedef Sample_sequence::const_iterator Sample_const_iterator;
    typedef ::xsd::cxx::tree::traits< Sample_type, char > Sample_traits;

    const Sample_sequence&
    Sample () const;

    Sample_sequence&
    Sample ();

    void
    Sample (const Sample_sequence& s);

    // Constructors.
    //
    AnalysisSampleCollectionType ();

    AnalysisSampleCollectionType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    AnalysisSampleCollectionType (const AnalysisSampleCollectionType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual AnalysisSampleCollectionType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AnalysisSampleCollectionType&
    operator= (const AnalysisSampleCollectionType& x);

    virtual 
    ~AnalysisSampleCollectionType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Sample_sequence Sample_;
  };

  class SequenceCollectionType: public ::xml_schema::type
  {
    public:
    // DBSequence
    //
    typedef ::mzIdentML120::DBSequenceType DBSequence_type;
    typedef ::xsd::cxx::tree::sequence< DBSequence_type > DBSequence_sequence;
    typedef DBSequence_sequence::iterator DBSequence_iterator;
    typedef DBSequence_sequence::const_iterator DBSequence_const_iterator;
    typedef ::xsd::cxx::tree::traits< DBSequence_type, char > DBSequence_traits;

    const DBSequence_sequence&
    DBSequence () const;

    DBSequence_sequence&
    DBSequence ();

    void
    DBSequence (const DBSequence_sequence& s);

    // Peptide
    //
    typedef ::mzIdentML120::PeptideType Peptide_type;
    typedef ::xsd::cxx::tree::sequence< Peptide_type > Peptide_sequence;
    typedef Peptide_sequence::iterator Peptide_iterator;
    typedef Peptide_sequence::const_iterator Peptide_const_iterator;
    typedef ::xsd::cxx::tree::traits< Peptide_type, char > Peptide_traits;

    const Peptide_sequence&
    Peptide () const;

    Peptide_sequence&
    Peptide ();

    void
    Peptide (const Peptide_sequence& s);

    // PeptideEvidence
    //
    typedef ::mzIdentML120::PeptideEvidenceType PeptideEvidence_type;
    typedef ::xsd::cxx::tree::sequence< PeptideEvidence_type > PeptideEvidence_sequence;
    typedef PeptideEvidence_sequence::iterator PeptideEvidence_iterator;
    typedef PeptideEvidence_sequence::const_iterator PeptideEvidence_const_iterator;
    typedef ::xsd::cxx::tree::traits< PeptideEvidence_type, char > PeptideEvidence_traits;

    const PeptideEvidence_sequence&
    PeptideEvidence () const;

    PeptideEvidence_sequence&
    PeptideEvidence ();

    void
    PeptideEvidence (const PeptideEvidence_sequence& s);

    // Constructors.
    //
    SequenceCollectionType ();

    SequenceCollectionType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    SequenceCollectionType (const SequenceCollectionType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual SequenceCollectionType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SequenceCollectionType&
    operator= (const SequenceCollectionType& x);

    virtual 
    ~SequenceCollectionType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    DBSequence_sequence DBSequence_;
    Peptide_sequence Peptide_;
    PeptideEvidence_sequence PeptideEvidence_;
  };

  class AnalysisCollectionType: public ::xml_schema::type
  {
    public:
    // SpectrumIdentification
    //
    typedef ::mzIdentML120::SpectrumIdentificationType SpectrumIdentification_type;
    typedef ::xsd::cxx::tree::sequence< SpectrumIdentification_type > SpectrumIdentification_sequence;
    typedef SpectrumIdentification_sequence::iterator SpectrumIdentification_iterator;
    typedef SpectrumIdentification_sequence::const_iterator SpectrumIdentification_const_iterator;
    typedef ::xsd::cxx::tree::traits< SpectrumIdentification_type, char > SpectrumIdentification_traits;

    const SpectrumIdentification_sequence&
    SpectrumIdentification () const;

    SpectrumIdentification_sequence&
    SpectrumIdentification ();

    void
    SpectrumIdentification (const SpectrumIdentification_sequence& s);

    // ProteinDetection
    //
    typedef ::mzIdentML120::ProteinDetectionType ProteinDetection_type;
    typedef ::xsd::cxx::tree::optional< ProteinDetection_type > ProteinDetection_optional;
    typedef ::xsd::cxx::tree::traits< ProteinDetection_type, char > ProteinDetection_traits;

    const ProteinDetection_optional&
    ProteinDetection () const;

    ProteinDetection_optional&
    ProteinDetection ();

    void
    ProteinDetection (const ProteinDetection_type& x);

    void
    ProteinDetection (const ProteinDetection_optional& x);

    void
    ProteinDetection (::std::unique_ptr< ProteinDetection_type > p);

    // Constructors.
    //
    AnalysisCollectionType ();

    AnalysisCollectionType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    AnalysisCollectionType (const AnalysisCollectionType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual AnalysisCollectionType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AnalysisCollectionType&
    operator= (const AnalysisCollectionType& x);

    virtual 
    ~AnalysisCollectionType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    SpectrumIdentification_sequence SpectrumIdentification_;
    ProteinDetection_optional ProteinDetection_;
  };

  class AnalysisProtocolCollectionType: public ::xml_schema::type
  {
    public:
    // SpectrumIdentificationProtocol
    //
    typedef ::mzIdentML120::SpectrumIdentificationProtocolType SpectrumIdentificationProtocol_type;
    typedef ::xsd::cxx::tree::sequence< SpectrumIdentificationProtocol_type > SpectrumIdentificationProtocol_sequence;
    typedef SpectrumIdentificationProtocol_sequence::iterator SpectrumIdentificationProtocol_iterator;
    typedef SpectrumIdentificationProtocol_sequence::const_iterator SpectrumIdentificationProtocol_const_iterator;
    typedef ::xsd::cxx::tree::traits< SpectrumIdentificationProtocol_type, char > SpectrumIdentificationProtocol_traits;

    const SpectrumIdentificationProtocol_sequence&
    SpectrumIdentificationProtocol () const;

    SpectrumIdentificationProtocol_sequence&
    SpectrumIdentificationProtocol ();

    void
    SpectrumIdentificationProtocol (const SpectrumIdentificationProtocol_sequence& s);

    // ProteinDetectionProtocol
    //
    typedef ::mzIdentML120::ProteinDetectionProtocolType ProteinDetectionProtocol_type;
    typedef ::xsd::cxx::tree::optional< ProteinDetectionProtocol_type > ProteinDetectionProtocol_optional;
    typedef ::xsd::cxx::tree::traits< ProteinDetectionProtocol_type, char > ProteinDetectionProtocol_traits;

    const ProteinDetectionProtocol_optional&
    ProteinDetectionProtocol () const;

    ProteinDetectionProtocol_optional&
    ProteinDetectionProtocol ();

    void
    ProteinDetectionProtocol (const ProteinDetectionProtocol_type& x);

    void
    ProteinDetectionProtocol (const ProteinDetectionProtocol_optional& x);

    void
    ProteinDetectionProtocol (::std::unique_ptr< ProteinDetectionProtocol_type > p);

    // Constructors.
    //
    AnalysisProtocolCollectionType ();

    AnalysisProtocolCollectionType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    AnalysisProtocolCollectionType (const AnalysisProtocolCollectionType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual AnalysisProtocolCollectionType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AnalysisProtocolCollectionType&
    operator= (const AnalysisProtocolCollectionType& x);

    virtual 
    ~AnalysisProtocolCollectionType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    SpectrumIdentificationProtocol_sequence SpectrumIdentificationProtocol_;
    ProteinDetectionProtocol_optional ProteinDetectionProtocol_;
  };

  class InputsType: public ::xml_schema::type
  {
    public:
    // SourceFile
    //
    typedef ::mzIdentML120::SourceFileType SourceFile_type;
    typedef ::xsd::cxx::tree::sequence< SourceFile_type > SourceFile_sequence;
    typedef SourceFile_sequence::iterator SourceFile_iterator;
    typedef SourceFile_sequence::const_iterator SourceFile_const_iterator;
    typedef ::xsd::cxx::tree::traits< SourceFile_type, char > SourceFile_traits;

    const SourceFile_sequence&
    SourceFile () const;

    SourceFile_sequence&
    SourceFile ();

    void
    SourceFile (const SourceFile_sequence& s);

    // SearchDatabase
    //
    typedef ::mzIdentML120::SearchDatabaseType SearchDatabase_type;
    typedef ::xsd::cxx::tree::sequence< SearchDatabase_type > SearchDatabase_sequence;
    typedef SearchDatabase_sequence::iterator SearchDatabase_iterator;
    typedef SearchDatabase_sequence::const_iterator SearchDatabase_const_iterator;
    typedef ::xsd::cxx::tree::traits< SearchDatabase_type, char > SearchDatabase_traits;

    const SearchDatabase_sequence&
    SearchDatabase () const;

    SearchDatabase_sequence&
    SearchDatabase ();

    void
    SearchDatabase (const SearchDatabase_sequence& s);

    // SpectraData
    //
    typedef ::mzIdentML120::SpectraDataType SpectraData_type;
    typedef ::xsd::cxx::tree::sequence< SpectraData_type > SpectraData_sequence;
    typedef SpectraData_sequence::iterator SpectraData_iterator;
    typedef SpectraData_sequence::const_iterator SpectraData_const_iterator;
    typedef ::xsd::cxx::tree::traits< SpectraData_type, char > SpectraData_traits;

    const SpectraData_sequence&
    SpectraData () const;

    SpectraData_sequence&
    SpectraData ();

    void
    SpectraData (const SpectraData_sequence& s);

    // Constructors.
    //
    InputsType ();

    InputsType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    InputsType (const InputsType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual InputsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    InputsType&
    operator= (const InputsType& x);

    virtual 
    ~InputsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    SourceFile_sequence SourceFile_;
    SearchDatabase_sequence SearchDatabase_;
    SpectraData_sequence SpectraData_;
  };

  class AnalysisDataType: public ::xml_schema::type
  {
    public:
    // SpectrumIdentificationList
    //
    typedef ::mzIdentML120::SpectrumIdentificationListType SpectrumIdentificationList_type;
    typedef ::xsd::cxx::tree::sequence< SpectrumIdentificationList_type > SpectrumIdentificationList_sequence;
    typedef SpectrumIdentificationList_sequence::iterator SpectrumIdentificationList_iterator;
    typedef SpectrumIdentificationList_sequence::const_iterator SpectrumIdentificationList_const_iterator;
    typedef ::xsd::cxx::tree::traits< SpectrumIdentificationList_type, char > SpectrumIdentificationList_traits;

    const SpectrumIdentificationList_sequence&
    SpectrumIdentificationList () const;

    SpectrumIdentificationList_sequence&
    SpectrumIdentificationList ();

    void
    SpectrumIdentificationList (const SpectrumIdentificationList_sequence& s);

    // ProteinDetectionList
    //
    typedef ::mzIdentML120::ProteinDetectionListType ProteinDetectionList_type;
    typedef ::xsd::cxx::tree::optional< ProteinDetectionList_type > ProteinDetectionList_optional;
    typedef ::xsd::cxx::tree::traits< ProteinDetectionList_type, char > ProteinDetectionList_traits;

    const ProteinDetectionList_optional&
    ProteinDetectionList () const;

    ProteinDetectionList_optional&
    ProteinDetectionList ();

    void
    ProteinDetectionList (const ProteinDetectionList_type& x);

    void
    ProteinDetectionList (const ProteinDetectionList_optional& x);

    void
    ProteinDetectionList (::std::unique_ptr< ProteinDetectionList_type > p);

    // Constructors.
    //
    AnalysisDataType ();

    AnalysisDataType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    AnalysisDataType (const AnalysisDataType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual AnalysisDataType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AnalysisDataType&
    operator= (const AnalysisDataType& x);

    virtual 
    ~AnalysisDataType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    SpectrumIdentificationList_sequence SpectrumIdentificationList_;
    ProteinDetectionList_optional ProteinDetectionList_;
  };

  class DataCollectionType: public ::xml_schema::type
  {
    public:
    // Inputs
    //
    typedef ::mzIdentML120::InputsType Inputs_type;
    typedef ::xsd::cxx::tree::traits< Inputs_type, char > Inputs_traits;

    const Inputs_type&
    Inputs () const;

    Inputs_type&
    Inputs ();

    void
    Inputs (const Inputs_type& x);

    void
    Inputs (::std::unique_ptr< Inputs_type > p);

    // AnalysisData
    //
    typedef ::mzIdentML120::AnalysisDataType AnalysisData_type;
    typedef ::xsd::cxx::tree::traits< AnalysisData_type, char > AnalysisData_traits;

    const AnalysisData_type&
    AnalysisData () const;

    AnalysisData_type&
    AnalysisData ();

    void
    AnalysisData (const AnalysisData_type& x);

    void
    AnalysisData (::std::unique_ptr< AnalysisData_type > p);

    // Constructors.
    //
    DataCollectionType ();

    DataCollectionType (const Inputs_type&,
                        const AnalysisData_type&);

    DataCollectionType (::std::unique_ptr< Inputs_type >,
                        ::std::unique_ptr< AnalysisData_type >);

    DataCollectionType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    DataCollectionType (const DataCollectionType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual DataCollectionType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DataCollectionType&
    operator= (const DataCollectionType& x);

    virtual 
    ~DataCollectionType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< Inputs_type > Inputs_;
    ::xsd::cxx::tree::one< AnalysisData_type > AnalysisData_;
  };

  class IdentifiableType: public ::xml_schema::type
  {
    public:
    // id
    //
    typedef ::xml_schema::string id_type;
    typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

    const id_type&
    id () const;

    id_type&
    id ();

    void
    id (const id_type& x);

    void
    id (::std::unique_ptr< id_type > p);

    // name
    //
    typedef ::xml_schema::string name_type;
    typedef ::xsd::cxx::tree::optional< name_type > name_optional;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_optional&
    name () const;

    name_optional&
    name ();

    void
    name (const name_type& x);

    void
    name (const name_optional& x);

    void
    name (::std::unique_ptr< name_type > p);

    // Constructors.
    //
    IdentifiableType ();

    IdentifiableType (const id_type&);

    IdentifiableType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    IdentifiableType (const IdentifiableType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual IdentifiableType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    IdentifiableType&
    operator= (const IdentifiableType& x);

    virtual 
    ~IdentifiableType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< id_type > id_;
    name_optional name_;
  };

  class MzIdentMLType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // cvList
    //
    typedef ::mzIdentML120::CVListType cvList_type;
    typedef ::xsd::cxx::tree::traits< cvList_type, char > cvList_traits;

    const cvList_type&
    cvList () const;

    cvList_type&
    cvList ();

    void
    cvList (const cvList_type& x);

    void
    cvList (::std::unique_ptr< cvList_type > p);

    // AnalysisSoftwareList
    //
    typedef ::mzIdentML120::AnalysisSoftwareListType AnalysisSoftwareList_type;
    typedef ::xsd::cxx::tree::optional< AnalysisSoftwareList_type > AnalysisSoftwareList_optional;
    typedef ::xsd::cxx::tree::traits< AnalysisSoftwareList_type, char > AnalysisSoftwareList_traits;

    const AnalysisSoftwareList_optional&
    AnalysisSoftwareList () const;

    AnalysisSoftwareList_optional&
    AnalysisSoftwareList ();

    void
    AnalysisSoftwareList (const AnalysisSoftwareList_type& x);

    void
    AnalysisSoftwareList (const AnalysisSoftwareList_optional& x);

    void
    AnalysisSoftwareList (::std::unique_ptr< AnalysisSoftwareList_type > p);

    // Provider
    //
    typedef ::mzIdentML120::ProviderType Provider_type;
    typedef ::xsd::cxx::tree::optional< Provider_type > Provider_optional;
    typedef ::xsd::cxx::tree::traits< Provider_type, char > Provider_traits;

    const Provider_optional&
    Provider () const;

    Provider_optional&
    Provider ();

    void
    Provider (const Provider_type& x);

    void
    Provider (const Provider_optional& x);

    void
    Provider (::std::unique_ptr< Provider_type > p);

    // AuditCollection
    //
    typedef ::mzIdentML120::AuditCollectionType AuditCollection_type;
    typedef ::xsd::cxx::tree::optional< AuditCollection_type > AuditCollection_optional;
    typedef ::xsd::cxx::tree::traits< AuditCollection_type, char > AuditCollection_traits;

    const AuditCollection_optional&
    AuditCollection () const;

    AuditCollection_optional&
    AuditCollection ();

    void
    AuditCollection (const AuditCollection_type& x);

    void
    AuditCollection (const AuditCollection_optional& x);

    void
    AuditCollection (::std::unique_ptr< AuditCollection_type > p);

    // AnalysisSampleCollection
    //
    typedef ::mzIdentML120::AnalysisSampleCollectionType AnalysisSampleCollection_type;
    typedef ::xsd::cxx::tree::optional< AnalysisSampleCollection_type > AnalysisSampleCollection_optional;
    typedef ::xsd::cxx::tree::traits< AnalysisSampleCollection_type, char > AnalysisSampleCollection_traits;

    const AnalysisSampleCollection_optional&
    AnalysisSampleCollection () const;

    AnalysisSampleCollection_optional&
    AnalysisSampleCollection ();

    void
    AnalysisSampleCollection (const AnalysisSampleCollection_type& x);

    void
    AnalysisSampleCollection (const AnalysisSampleCollection_optional& x);

    void
    AnalysisSampleCollection (::std::unique_ptr< AnalysisSampleCollection_type > p);

    // SequenceCollection
    //
    typedef ::mzIdentML120::SequenceCollectionType SequenceCollection_type;
    typedef ::xsd::cxx::tree::optional< SequenceCollection_type > SequenceCollection_optional;
    typedef ::xsd::cxx::tree::traits< SequenceCollection_type, char > SequenceCollection_traits;

    const SequenceCollection_optional&
    SequenceCollection () const;

    SequenceCollection_optional&
    SequenceCollection ();

    void
    SequenceCollection (const SequenceCollection_type& x);

    void
    SequenceCollection (const SequenceCollection_optional& x);

    void
    SequenceCollection (::std::unique_ptr< SequenceCollection_type > p);

    // AnalysisCollection
    //
    typedef ::mzIdentML120::AnalysisCollectionType AnalysisCollection_type;
    typedef ::xsd::cxx::tree::traits< AnalysisCollection_type, char > AnalysisCollection_traits;

    const AnalysisCollection_type&
    AnalysisCollection () const;

    AnalysisCollection_type&
    AnalysisCollection ();

    void
    AnalysisCollection (const AnalysisCollection_type& x);

    void
    AnalysisCollection (::std::unique_ptr< AnalysisCollection_type > p);

    // AnalysisProtocolCollection
    //
    typedef ::mzIdentML120::AnalysisProtocolCollectionType AnalysisProtocolCollection_type;
    typedef ::xsd::cxx::tree::traits< AnalysisProtocolCollection_type, char > AnalysisProtocolCollection_traits;

    const AnalysisProtocolCollection_type&
    AnalysisProtocolCollection () const;

    AnalysisProtocolCollection_type&
    AnalysisProtocolCollection ();

    void
    AnalysisProtocolCollection (const AnalysisProtocolCollection_type& x);

    void
    AnalysisProtocolCollection (::std::unique_ptr< AnalysisProtocolCollection_type > p);

    // DataCollection
    //
    typedef ::mzIdentML120::DataCollectionType DataCollection_type;
    typedef ::xsd::cxx::tree::traits< DataCollection_type, char > DataCollection_traits;

    const DataCollection_type&
    DataCollection () const;

    DataCollection_type&
    DataCollection ();

    void
    DataCollection (const DataCollection_type& x);

    void
    DataCollection (::std::unique_ptr< DataCollection_type > p);

    // BibliographicReference
    //
    typedef ::mzIdentML120::BibliographicReferenceType BibliographicReference_type;
    typedef ::xsd::cxx::tree::sequence< BibliographicReference_type > BibliographicReference_sequence;
    typedef BibliographicReference_sequence::iterator BibliographicReference_iterator;
    typedef BibliographicReference_sequence::const_iterator BibliographicReference_const_iterator;
    typedef ::xsd::cxx::tree::traits< BibliographicReference_type, char > BibliographicReference_traits;

    const BibliographicReference_sequence&
    BibliographicReference () const;

    BibliographicReference_sequence&
    BibliographicReference ();

    void
    BibliographicReference (const BibliographicReference_sequence& s);

    // creationDate
    //
    typedef ::xml_schema::date_time creationDate_type;
    typedef ::xsd::cxx::tree::optional< creationDate_type > creationDate_optional;
    typedef ::xsd::cxx::tree::traits< creationDate_type, char > creationDate_traits;

    const creationDate_optional&
    creationDate () const;

    creationDate_optional&
    creationDate ();

    void
    creationDate (const creationDate_type& x);

    void
    creationDate (const creationDate_optional& x);

    void
    creationDate (::std::unique_ptr< creationDate_type > p);

    // version
    //
    typedef ::mzIdentML120::versionRegex version_type;
    typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

    const version_type&
    version () const;

    version_type&
    version ();

    void
    version (const version_type& x);

    void
    version (::std::unique_ptr< version_type > p);

    // Constructors.
    //
    MzIdentMLType ();

    MzIdentMLType (const id_type&,
                   const cvList_type&,
                   const AnalysisCollection_type&,
                   const AnalysisProtocolCollection_type&,
                   const DataCollection_type&,
                   const version_type&);

    MzIdentMLType (const id_type&,
                   ::std::unique_ptr< cvList_type >,
                   ::std::unique_ptr< AnalysisCollection_type >,
                   ::std::unique_ptr< AnalysisProtocolCollection_type >,
                   ::std::unique_ptr< DataCollection_type >,
                   const version_type&);

    MzIdentMLType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    MzIdentMLType (const MzIdentMLType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual MzIdentMLType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MzIdentMLType&
    operator= (const MzIdentMLType& x);

    virtual 
    ~MzIdentMLType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< cvList_type > cvList_;
    AnalysisSoftwareList_optional AnalysisSoftwareList_;
    Provider_optional Provider_;
    AuditCollection_optional AuditCollection_;
    AnalysisSampleCollection_optional AnalysisSampleCollection_;
    SequenceCollection_optional SequenceCollection_;
    ::xsd::cxx::tree::one< AnalysisCollection_type > AnalysisCollection_;
    ::xsd::cxx::tree::one< AnalysisProtocolCollection_type > AnalysisProtocolCollection_;
    ::xsd::cxx::tree::one< DataCollection_type > DataCollection_;
    BibliographicReference_sequence BibliographicReference_;
    creationDate_optional creationDate_;
    ::xsd::cxx::tree::one< version_type > version_;
  };

  class ExternalDataType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // ExternalFormatDocumentation
    //
    typedef ::xml_schema::uri ExternalFormatDocumentation_type;
    typedef ::xsd::cxx::tree::optional< ExternalFormatDocumentation_type > ExternalFormatDocumentation_optional;
    typedef ::xsd::cxx::tree::traits< ExternalFormatDocumentation_type, char > ExternalFormatDocumentation_traits;

    const ExternalFormatDocumentation_optional&
    ExternalFormatDocumentation () const;

    ExternalFormatDocumentation_optional&
    ExternalFormatDocumentation ();

    void
    ExternalFormatDocumentation (const ExternalFormatDocumentation_type& x);

    void
    ExternalFormatDocumentation (const ExternalFormatDocumentation_optional& x);

    void
    ExternalFormatDocumentation (::std::unique_ptr< ExternalFormatDocumentation_type > p);

    // FileFormat
    //
    typedef ::mzIdentML120::FileFormatType FileFormat_type;
    typedef ::xsd::cxx::tree::traits< FileFormat_type, char > FileFormat_traits;

    const FileFormat_type&
    FileFormat () const;

    FileFormat_type&
    FileFormat ();

    void
    FileFormat (const FileFormat_type& x);

    void
    FileFormat (::std::unique_ptr< FileFormat_type > p);

    // location
    //
    typedef ::xml_schema::uri location_type;
    typedef ::xsd::cxx::tree::traits< location_type, char > location_traits;

    const location_type&
    location () const;

    location_type&
    location ();

    void
    location (const location_type& x);

    void
    location (::std::unique_ptr< location_type > p);

    // Constructors.
    //
    ExternalDataType ();

    ExternalDataType (const id_type&,
                      const FileFormat_type&,
                      const location_type&);

    ExternalDataType (const id_type&,
                      ::std::unique_ptr< FileFormat_type >,
                      const location_type&);

    ExternalDataType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    ExternalDataType (const ExternalDataType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual ExternalDataType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ExternalDataType&
    operator= (const ExternalDataType& x);

    virtual 
    ~ExternalDataType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ExternalFormatDocumentation_optional ExternalFormatDocumentation_;
    ::xsd::cxx::tree::one< FileFormat_type > FileFormat_;
    ::xsd::cxx::tree::one< location_type > location_;
  };

  class SearchDatabaseType: public ::mzIdentML120::ExternalDataType
  {
    public:
    // DatabaseName
    //
    typedef ::mzIdentML120::ParamType DatabaseName_type;
    typedef ::xsd::cxx::tree::traits< DatabaseName_type, char > DatabaseName_traits;

    const DatabaseName_type&
    DatabaseName () const;

    DatabaseName_type&
    DatabaseName ();

    void
    DatabaseName (const DatabaseName_type& x);

    void
    DatabaseName (::std::unique_ptr< DatabaseName_type > p);

    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // version
    //
    typedef ::xml_schema::string version_type;
    typedef ::xsd::cxx::tree::optional< version_type > version_optional;
    typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

    const version_optional&
    version () const;

    version_optional&
    version ();

    void
    version (const version_type& x);

    void
    version (const version_optional& x);

    void
    version (::std::unique_ptr< version_type > p);

    // releaseDate
    //
    typedef ::xml_schema::date_time releaseDate_type;
    typedef ::xsd::cxx::tree::optional< releaseDate_type > releaseDate_optional;
    typedef ::xsd::cxx::tree::traits< releaseDate_type, char > releaseDate_traits;

    const releaseDate_optional&
    releaseDate () const;

    releaseDate_optional&
    releaseDate ();

    void
    releaseDate (const releaseDate_type& x);

    void
    releaseDate (const releaseDate_optional& x);

    void
    releaseDate (::std::unique_ptr< releaseDate_type > p);

    // numDatabaseSequences
    //
    typedef ::xml_schema::long_ numDatabaseSequences_type;
    typedef ::xsd::cxx::tree::optional< numDatabaseSequences_type > numDatabaseSequences_optional;
    typedef ::xsd::cxx::tree::traits< numDatabaseSequences_type, char > numDatabaseSequences_traits;

    const numDatabaseSequences_optional&
    numDatabaseSequences () const;

    numDatabaseSequences_optional&
    numDatabaseSequences ();

    void
    numDatabaseSequences (const numDatabaseSequences_type& x);

    void
    numDatabaseSequences (const numDatabaseSequences_optional& x);

    // numResidues
    //
    typedef ::xml_schema::long_ numResidues_type;
    typedef ::xsd::cxx::tree::optional< numResidues_type > numResidues_optional;
    typedef ::xsd::cxx::tree::traits< numResidues_type, char > numResidues_traits;

    const numResidues_optional&
    numResidues () const;

    numResidues_optional&
    numResidues ();

    void
    numResidues (const numResidues_type& x);

    void
    numResidues (const numResidues_optional& x);

    // Constructors.
    //
    SearchDatabaseType ();

    SearchDatabaseType (const id_type&,
                        const FileFormat_type&,
                        const location_type&,
                        const DatabaseName_type&);

    SearchDatabaseType (const id_type&,
                        ::std::unique_ptr< FileFormat_type >,
                        const location_type&,
                        ::std::unique_ptr< DatabaseName_type >);

    SearchDatabaseType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    SearchDatabaseType (const SearchDatabaseType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual SearchDatabaseType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SearchDatabaseType&
    operator= (const SearchDatabaseType& x);

    virtual 
    ~SearchDatabaseType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< DatabaseName_type > DatabaseName_;
    cvParam_sequence cvParam_;
    version_optional version_;
    releaseDate_optional releaseDate_;
    numDatabaseSequences_optional numDatabaseSequences_;
    numResidues_optional numResidues_;
  };

  class SourceFileType: public ::mzIdentML120::ExternalDataType
  {
    public:
    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // userParam
    //
    typedef ::mzIdentML120::UserParamType userParam_type;
    typedef ::xsd::cxx::tree::sequence< userParam_type > userParam_sequence;
    typedef userParam_sequence::iterator userParam_iterator;
    typedef userParam_sequence::const_iterator userParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< userParam_type, char > userParam_traits;

    const userParam_sequence&
    userParam () const;

    userParam_sequence&
    userParam ();

    void
    userParam (const userParam_sequence& s);

    // Constructors.
    //
    SourceFileType ();

    SourceFileType (const id_type&,
                    const FileFormat_type&,
                    const location_type&);

    SourceFileType (const id_type&,
                    ::std::unique_ptr< FileFormat_type >,
                    const location_type&);

    SourceFileType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    SourceFileType (const SourceFileType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual SourceFileType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SourceFileType&
    operator= (const SourceFileType& x);

    virtual 
    ~SourceFileType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    cvParam_sequence cvParam_;
    userParam_sequence userParam_;
  };

  class ModificationParamsType: public ::xml_schema::type
  {
    public:
    // SearchModification
    //
    typedef ::mzIdentML120::SearchModificationType SearchModification_type;
    typedef ::xsd::cxx::tree::sequence< SearchModification_type > SearchModification_sequence;
    typedef SearchModification_sequence::iterator SearchModification_iterator;
    typedef SearchModification_sequence::const_iterator SearchModification_const_iterator;
    typedef ::xsd::cxx::tree::traits< SearchModification_type, char > SearchModification_traits;

    const SearchModification_sequence&
    SearchModification () const;

    SearchModification_sequence&
    SearchModification ();

    void
    SearchModification (const SearchModification_sequence& s);

    // Constructors.
    //
    ModificationParamsType ();

    ModificationParamsType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ModificationParamsType (const ModificationParamsType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual ModificationParamsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ModificationParamsType&
    operator= (const ModificationParamsType& x);

    virtual 
    ~ModificationParamsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    SearchModification_sequence SearchModification_;
  };

  class FilterType: public ::xml_schema::type
  {
    public:
    // FilterType
    //
    typedef ::mzIdentML120::ParamType FilterType1_type;
    typedef ::xsd::cxx::tree::traits< FilterType1_type, char > FilterType1_traits;

    const FilterType1_type&
    FilterType1 () const;

    FilterType1_type&
    FilterType1 ();

    void
    FilterType1 (const FilterType1_type& x);

    void
    FilterType1 (::std::unique_ptr< FilterType1_type > p);

    // Include
    //
    typedef ::mzIdentML120::ParamListType Include_type;
    typedef ::xsd::cxx::tree::optional< Include_type > Include_optional;
    typedef ::xsd::cxx::tree::traits< Include_type, char > Include_traits;

    const Include_optional&
    Include () const;

    Include_optional&
    Include ();

    void
    Include (const Include_type& x);

    void
    Include (const Include_optional& x);

    void
    Include (::std::unique_ptr< Include_type > p);

    // Exclude
    //
    typedef ::mzIdentML120::ParamListType Exclude_type;
    typedef ::xsd::cxx::tree::optional< Exclude_type > Exclude_optional;
    typedef ::xsd::cxx::tree::traits< Exclude_type, char > Exclude_traits;

    const Exclude_optional&
    Exclude () const;

    Exclude_optional&
    Exclude ();

    void
    Exclude (const Exclude_type& x);

    void
    Exclude (const Exclude_optional& x);

    void
    Exclude (::std::unique_ptr< Exclude_type > p);

    // Constructors.
    //
    FilterType ();

    FilterType (const FilterType1_type&);

    FilterType (::std::unique_ptr< FilterType1_type >);

    FilterType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    FilterType (const FilterType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual FilterType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FilterType&
    operator= (const FilterType& x);

    virtual 
    ~FilterType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< FilterType1_type > FilterType1_;
    Include_optional Include_;
    Exclude_optional Exclude_;
  };

  class DatabaseFiltersType: public ::xml_schema::type
  {
    public:
    // Filter
    //
    typedef ::mzIdentML120::FilterType Filter_type;
    typedef ::xsd::cxx::tree::sequence< Filter_type > Filter_sequence;
    typedef Filter_sequence::iterator Filter_iterator;
    typedef Filter_sequence::const_iterator Filter_const_iterator;
    typedef ::xsd::cxx::tree::traits< Filter_type, char > Filter_traits;

    const Filter_sequence&
    Filter () const;

    Filter_sequence&
    Filter ();

    void
    Filter (const Filter_sequence& s);

    // Constructors.
    //
    DatabaseFiltersType ();

    DatabaseFiltersType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    DatabaseFiltersType (const DatabaseFiltersType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual DatabaseFiltersType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DatabaseFiltersType&
    operator= (const DatabaseFiltersType& x);

    virtual 
    ~DatabaseFiltersType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Filter_sequence Filter_;
  };

  class TranslationTableType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // Constructors.
    //
    TranslationTableType ();

    TranslationTableType (const id_type&);

    TranslationTableType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    TranslationTableType (const TranslationTableType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual TranslationTableType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    TranslationTableType&
    operator= (const TranslationTableType& x);

    virtual 
    ~TranslationTableType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    cvParam_sequence cvParam_;
  };

  class DatabaseTranslationType: public ::xml_schema::type
  {
    public:
    // TranslationTable
    //
    typedef ::mzIdentML120::TranslationTableType TranslationTable_type;
    typedef ::xsd::cxx::tree::sequence< TranslationTable_type > TranslationTable_sequence;
    typedef TranslationTable_sequence::iterator TranslationTable_iterator;
    typedef TranslationTable_sequence::const_iterator TranslationTable_const_iterator;
    typedef ::xsd::cxx::tree::traits< TranslationTable_type, char > TranslationTable_traits;

    const TranslationTable_sequence&
    TranslationTable () const;

    TranslationTable_sequence&
    TranslationTable ();

    void
    TranslationTable (const TranslationTable_sequence& s);

    // frames
    //
    typedef ::mzIdentML120::listOfAllowedFrames frames_type;
    typedef ::xsd::cxx::tree::optional< frames_type > frames_optional;
    typedef ::xsd::cxx::tree::traits< frames_type, char > frames_traits;

    const frames_optional&
    frames () const;

    frames_optional&
    frames ();

    void
    frames (const frames_type& x);

    void
    frames (const frames_optional& x);

    void
    frames (::std::unique_ptr< frames_type > p);

    // Constructors.
    //
    DatabaseTranslationType ();

    DatabaseTranslationType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    DatabaseTranslationType (const DatabaseTranslationType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual DatabaseTranslationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DatabaseTranslationType&
    operator= (const DatabaseTranslationType& x);

    virtual 
    ~DatabaseTranslationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    TranslationTable_sequence TranslationTable_;
    frames_optional frames_;
  };

  class SpectrumIdentificationProtocolType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // SearchType
    //
    typedef ::mzIdentML120::ParamType SearchType_type;
    typedef ::xsd::cxx::tree::traits< SearchType_type, char > SearchType_traits;

    const SearchType_type&
    SearchType () const;

    SearchType_type&
    SearchType ();

    void
    SearchType (const SearchType_type& x);

    void
    SearchType (::std::unique_ptr< SearchType_type > p);

    // AdditionalSearchParams
    //
    typedef ::mzIdentML120::ParamListType AdditionalSearchParams_type;
    typedef ::xsd::cxx::tree::optional< AdditionalSearchParams_type > AdditionalSearchParams_optional;
    typedef ::xsd::cxx::tree::traits< AdditionalSearchParams_type, char > AdditionalSearchParams_traits;

    const AdditionalSearchParams_optional&
    AdditionalSearchParams () const;

    AdditionalSearchParams_optional&
    AdditionalSearchParams ();

    void
    AdditionalSearchParams (const AdditionalSearchParams_type& x);

    void
    AdditionalSearchParams (const AdditionalSearchParams_optional& x);

    void
    AdditionalSearchParams (::std::unique_ptr< AdditionalSearchParams_type > p);

    // ModificationParams
    //
    typedef ::mzIdentML120::ModificationParamsType ModificationParams_type;
    typedef ::xsd::cxx::tree::optional< ModificationParams_type > ModificationParams_optional;
    typedef ::xsd::cxx::tree::traits< ModificationParams_type, char > ModificationParams_traits;

    const ModificationParams_optional&
    ModificationParams () const;

    ModificationParams_optional&
    ModificationParams ();

    void
    ModificationParams (const ModificationParams_type& x);

    void
    ModificationParams (const ModificationParams_optional& x);

    void
    ModificationParams (::std::unique_ptr< ModificationParams_type > p);

    // Enzymes
    //
    typedef ::mzIdentML120::EnzymesType Enzymes_type;
    typedef ::xsd::cxx::tree::optional< Enzymes_type > Enzymes_optional;
    typedef ::xsd::cxx::tree::traits< Enzymes_type, char > Enzymes_traits;

    const Enzymes_optional&
    Enzymes () const;

    Enzymes_optional&
    Enzymes ();

    void
    Enzymes (const Enzymes_type& x);

    void
    Enzymes (const Enzymes_optional& x);

    void
    Enzymes (::std::unique_ptr< Enzymes_type > p);

    // MassTable
    //
    typedef ::mzIdentML120::MassTableType MassTable_type;
    typedef ::xsd::cxx::tree::sequence< MassTable_type > MassTable_sequence;
    typedef MassTable_sequence::iterator MassTable_iterator;
    typedef MassTable_sequence::const_iterator MassTable_const_iterator;
    typedef ::xsd::cxx::tree::traits< MassTable_type, char > MassTable_traits;

    const MassTable_sequence&
    MassTable () const;

    MassTable_sequence&
    MassTable ();

    void
    MassTable (const MassTable_sequence& s);

    // FragmentTolerance
    //
    typedef ::mzIdentML120::ToleranceType FragmentTolerance_type;
    typedef ::xsd::cxx::tree::optional< FragmentTolerance_type > FragmentTolerance_optional;
    typedef ::xsd::cxx::tree::traits< FragmentTolerance_type, char > FragmentTolerance_traits;

    const FragmentTolerance_optional&
    FragmentTolerance () const;

    FragmentTolerance_optional&
    FragmentTolerance ();

    void
    FragmentTolerance (const FragmentTolerance_type& x);

    void
    FragmentTolerance (const FragmentTolerance_optional& x);

    void
    FragmentTolerance (::std::unique_ptr< FragmentTolerance_type > p);

    // ParentTolerance
    //
    typedef ::mzIdentML120::ToleranceType ParentTolerance_type;
    typedef ::xsd::cxx::tree::optional< ParentTolerance_type > ParentTolerance_optional;
    typedef ::xsd::cxx::tree::traits< ParentTolerance_type, char > ParentTolerance_traits;

    const ParentTolerance_optional&
    ParentTolerance () const;

    ParentTolerance_optional&
    ParentTolerance ();

    void
    ParentTolerance (const ParentTolerance_type& x);

    void
    ParentTolerance (const ParentTolerance_optional& x);

    void
    ParentTolerance (::std::unique_ptr< ParentTolerance_type > p);

    // Threshold
    //
    typedef ::mzIdentML120::ParamListType Threshold_type;
    typedef ::xsd::cxx::tree::traits< Threshold_type, char > Threshold_traits;

    const Threshold_type&
    Threshold () const;

    Threshold_type&
    Threshold ();

    void
    Threshold (const Threshold_type& x);

    void
    Threshold (::std::unique_ptr< Threshold_type > p);

    // DatabaseFilters
    //
    typedef ::mzIdentML120::DatabaseFiltersType DatabaseFilters_type;
    typedef ::xsd::cxx::tree::optional< DatabaseFilters_type > DatabaseFilters_optional;
    typedef ::xsd::cxx::tree::traits< DatabaseFilters_type, char > DatabaseFilters_traits;

    const DatabaseFilters_optional&
    DatabaseFilters () const;

    DatabaseFilters_optional&
    DatabaseFilters ();

    void
    DatabaseFilters (const DatabaseFilters_type& x);

    void
    DatabaseFilters (const DatabaseFilters_optional& x);

    void
    DatabaseFilters (::std::unique_ptr< DatabaseFilters_type > p);

    // DatabaseTranslation
    //
    typedef ::mzIdentML120::DatabaseTranslationType DatabaseTranslation_type;
    typedef ::xsd::cxx::tree::optional< DatabaseTranslation_type > DatabaseTranslation_optional;
    typedef ::xsd::cxx::tree::traits< DatabaseTranslation_type, char > DatabaseTranslation_traits;

    const DatabaseTranslation_optional&
    DatabaseTranslation () const;

    DatabaseTranslation_optional&
    DatabaseTranslation ();

    void
    DatabaseTranslation (const DatabaseTranslation_type& x);

    void
    DatabaseTranslation (const DatabaseTranslation_optional& x);

    void
    DatabaseTranslation (::std::unique_ptr< DatabaseTranslation_type > p);

    // analysisSoftware_ref
    //
    typedef ::xml_schema::string analysisSoftware_ref_type;
    typedef ::xsd::cxx::tree::traits< analysisSoftware_ref_type, char > analysisSoftware_ref_traits;

    const analysisSoftware_ref_type&
    analysisSoftware_ref () const;

    analysisSoftware_ref_type&
    analysisSoftware_ref ();

    void
    analysisSoftware_ref (const analysisSoftware_ref_type& x);

    void
    analysisSoftware_ref (::std::unique_ptr< analysisSoftware_ref_type > p);

    // Constructors.
    //
    SpectrumIdentificationProtocolType ();

    SpectrumIdentificationProtocolType (const id_type&,
                                        const SearchType_type&,
                                        const Threshold_type&,
                                        const analysisSoftware_ref_type&);

    SpectrumIdentificationProtocolType (const id_type&,
                                        ::std::unique_ptr< SearchType_type >,
                                        ::std::unique_ptr< Threshold_type >,
                                        const analysisSoftware_ref_type&);

    SpectrumIdentificationProtocolType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    SpectrumIdentificationProtocolType (const SpectrumIdentificationProtocolType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual SpectrumIdentificationProtocolType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SpectrumIdentificationProtocolType&
    operator= (const SpectrumIdentificationProtocolType& x);

    virtual 
    ~SpectrumIdentificationProtocolType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< SearchType_type > SearchType_;
    AdditionalSearchParams_optional AdditionalSearchParams_;
    ModificationParams_optional ModificationParams_;
    Enzymes_optional Enzymes_;
    MassTable_sequence MassTable_;
    FragmentTolerance_optional FragmentTolerance_;
    ParentTolerance_optional ParentTolerance_;
    ::xsd::cxx::tree::one< Threshold_type > Threshold_;
    DatabaseFilters_optional DatabaseFilters_;
    DatabaseTranslation_optional DatabaseTranslation_;
    ::xsd::cxx::tree::one< analysisSoftware_ref_type > analysisSoftware_ref_;
  };

  class InputSpectraType: public ::xml_schema::type
  {
    public:
    // spectraData_ref
    //
    typedef ::xml_schema::string spectraData_ref_type;
    typedef ::xsd::cxx::tree::optional< spectraData_ref_type > spectraData_ref_optional;
    typedef ::xsd::cxx::tree::traits< spectraData_ref_type, char > spectraData_ref_traits;

    const spectraData_ref_optional&
    spectraData_ref () const;

    spectraData_ref_optional&
    spectraData_ref ();

    void
    spectraData_ref (const spectraData_ref_type& x);

    void
    spectraData_ref (const spectraData_ref_optional& x);

    void
    spectraData_ref (::std::unique_ptr< spectraData_ref_type > p);

    // Constructors.
    //
    InputSpectraType ();

    InputSpectraType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    InputSpectraType (const InputSpectraType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual InputSpectraType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    InputSpectraType&
    operator= (const InputSpectraType& x);

    virtual 
    ~InputSpectraType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    spectraData_ref_optional spectraData_ref_;
  };

  class SearchDatabaseRefType: public ::xml_schema::type
  {
    public:
    // searchDatabase_ref
    //
    typedef ::xml_schema::string searchDatabase_ref_type;
    typedef ::xsd::cxx::tree::optional< searchDatabase_ref_type > searchDatabase_ref_optional;
    typedef ::xsd::cxx::tree::traits< searchDatabase_ref_type, char > searchDatabase_ref_traits;

    const searchDatabase_ref_optional&
    searchDatabase_ref () const;

    searchDatabase_ref_optional&
    searchDatabase_ref ();

    void
    searchDatabase_ref (const searchDatabase_ref_type& x);

    void
    searchDatabase_ref (const searchDatabase_ref_optional& x);

    void
    searchDatabase_ref (::std::unique_ptr< searchDatabase_ref_type > p);

    // Constructors.
    //
    SearchDatabaseRefType ();

    SearchDatabaseRefType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    SearchDatabaseRefType (const SearchDatabaseRefType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual SearchDatabaseRefType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SearchDatabaseRefType&
    operator= (const SearchDatabaseRefType& x);

    virtual 
    ~SearchDatabaseRefType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    searchDatabase_ref_optional searchDatabase_ref_;
  };

  class ProtocolApplicationType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // activityDate
    //
    typedef ::xml_schema::date_time activityDate_type;
    typedef ::xsd::cxx::tree::optional< activityDate_type > activityDate_optional;
    typedef ::xsd::cxx::tree::traits< activityDate_type, char > activityDate_traits;

    const activityDate_optional&
    activityDate () const;

    activityDate_optional&
    activityDate ();

    void
    activityDate (const activityDate_type& x);

    void
    activityDate (const activityDate_optional& x);

    void
    activityDate (::std::unique_ptr< activityDate_type > p);

    // Constructors.
    //
    ProtocolApplicationType ();

    ProtocolApplicationType (const id_type&);

    ProtocolApplicationType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    ProtocolApplicationType (const ProtocolApplicationType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual ProtocolApplicationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ProtocolApplicationType&
    operator= (const ProtocolApplicationType& x);

    virtual 
    ~ProtocolApplicationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    activityDate_optional activityDate_;
  };

  class SpectrumIdentificationType: public ::mzIdentML120::ProtocolApplicationType
  {
    public:
    // InputSpectra
    //
    typedef ::mzIdentML120::InputSpectraType InputSpectra_type;
    typedef ::xsd::cxx::tree::sequence< InputSpectra_type > InputSpectra_sequence;
    typedef InputSpectra_sequence::iterator InputSpectra_iterator;
    typedef InputSpectra_sequence::const_iterator InputSpectra_const_iterator;
    typedef ::xsd::cxx::tree::traits< InputSpectra_type, char > InputSpectra_traits;

    const InputSpectra_sequence&
    InputSpectra () const;

    InputSpectra_sequence&
    InputSpectra ();

    void
    InputSpectra (const InputSpectra_sequence& s);

    // SearchDatabaseRef
    //
    typedef ::mzIdentML120::SearchDatabaseRefType SearchDatabaseRef_type;
    typedef ::xsd::cxx::tree::sequence< SearchDatabaseRef_type > SearchDatabaseRef_sequence;
    typedef SearchDatabaseRef_sequence::iterator SearchDatabaseRef_iterator;
    typedef SearchDatabaseRef_sequence::const_iterator SearchDatabaseRef_const_iterator;
    typedef ::xsd::cxx::tree::traits< SearchDatabaseRef_type, char > SearchDatabaseRef_traits;

    const SearchDatabaseRef_sequence&
    SearchDatabaseRef () const;

    SearchDatabaseRef_sequence&
    SearchDatabaseRef ();

    void
    SearchDatabaseRef (const SearchDatabaseRef_sequence& s);

    // spectrumIdentificationProtocol_ref
    //
    typedef ::xml_schema::string spectrumIdentificationProtocol_ref_type;
    typedef ::xsd::cxx::tree::traits< spectrumIdentificationProtocol_ref_type, char > spectrumIdentificationProtocol_ref_traits;

    const spectrumIdentificationProtocol_ref_type&
    spectrumIdentificationProtocol_ref () const;

    spectrumIdentificationProtocol_ref_type&
    spectrumIdentificationProtocol_ref ();

    void
    spectrumIdentificationProtocol_ref (const spectrumIdentificationProtocol_ref_type& x);

    void
    spectrumIdentificationProtocol_ref (::std::unique_ptr< spectrumIdentificationProtocol_ref_type > p);

    // spectrumIdentificationList_ref
    //
    typedef ::xml_schema::string spectrumIdentificationList_ref_type;
    typedef ::xsd::cxx::tree::traits< spectrumIdentificationList_ref_type, char > spectrumIdentificationList_ref_traits;

    const spectrumIdentificationList_ref_type&
    spectrumIdentificationList_ref () const;

    spectrumIdentificationList_ref_type&
    spectrumIdentificationList_ref ();

    void
    spectrumIdentificationList_ref (const spectrumIdentificationList_ref_type& x);

    void
    spectrumIdentificationList_ref (::std::unique_ptr< spectrumIdentificationList_ref_type > p);

    // Constructors.
    //
    SpectrumIdentificationType ();

    SpectrumIdentificationType (const id_type&,
                                const spectrumIdentificationProtocol_ref_type&,
                                const spectrumIdentificationList_ref_type&);

    SpectrumIdentificationType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    SpectrumIdentificationType (const SpectrumIdentificationType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual SpectrumIdentificationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SpectrumIdentificationType&
    operator= (const SpectrumIdentificationType& x);

    virtual 
    ~SpectrumIdentificationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    InputSpectra_sequence InputSpectra_;
    SearchDatabaseRef_sequence SearchDatabaseRef_;
    ::xsd::cxx::tree::one< spectrumIdentificationProtocol_ref_type > spectrumIdentificationProtocol_ref_;
    ::xsd::cxx::tree::one< spectrumIdentificationList_ref_type > spectrumIdentificationList_ref_;
  };

  class MeasureType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // Constructors.
    //
    MeasureType ();

    MeasureType (const id_type&);

    MeasureType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    MeasureType (const MeasureType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual MeasureType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MeasureType&
    operator= (const MeasureType& x);

    virtual 
    ~MeasureType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    cvParam_sequence cvParam_;
  };

  class FragmentationTableType: public ::xml_schema::type
  {
    public:
    // Measure
    //
    typedef ::mzIdentML120::MeasureType Measure_type;
    typedef ::xsd::cxx::tree::sequence< Measure_type > Measure_sequence;
    typedef Measure_sequence::iterator Measure_iterator;
    typedef Measure_sequence::const_iterator Measure_const_iterator;
    typedef ::xsd::cxx::tree::traits< Measure_type, char > Measure_traits;

    const Measure_sequence&
    Measure () const;

    Measure_sequence&
    Measure ();

    void
    Measure (const Measure_sequence& s);

    // Constructors.
    //
    FragmentationTableType ();

    FragmentationTableType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    FragmentationTableType (const FragmentationTableType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual FragmentationTableType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FragmentationTableType&
    operator= (const FragmentationTableType& x);

    virtual 
    ~FragmentationTableType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Measure_sequence Measure_;
  };

  class SpectrumIdentificationListType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // FragmentationTable
    //
    typedef ::mzIdentML120::FragmentationTableType FragmentationTable_type;
    typedef ::xsd::cxx::tree::optional< FragmentationTable_type > FragmentationTable_optional;
    typedef ::xsd::cxx::tree::traits< FragmentationTable_type, char > FragmentationTable_traits;

    const FragmentationTable_optional&
    FragmentationTable () const;

    FragmentationTable_optional&
    FragmentationTable ();

    void
    FragmentationTable (const FragmentationTable_type& x);

    void
    FragmentationTable (const FragmentationTable_optional& x);

    void
    FragmentationTable (::std::unique_ptr< FragmentationTable_type > p);

    // SpectrumIdentificationResult
    //
    typedef ::mzIdentML120::SpectrumIdentificationResultType SpectrumIdentificationResult_type;
    typedef ::xsd::cxx::tree::sequence< SpectrumIdentificationResult_type > SpectrumIdentificationResult_sequence;
    typedef SpectrumIdentificationResult_sequence::iterator SpectrumIdentificationResult_iterator;
    typedef SpectrumIdentificationResult_sequence::const_iterator SpectrumIdentificationResult_const_iterator;
    typedef ::xsd::cxx::tree::traits< SpectrumIdentificationResult_type, char > SpectrumIdentificationResult_traits;

    const SpectrumIdentificationResult_sequence&
    SpectrumIdentificationResult () const;

    SpectrumIdentificationResult_sequence&
    SpectrumIdentificationResult ();

    void
    SpectrumIdentificationResult (const SpectrumIdentificationResult_sequence& s);

    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // userParam
    //
    typedef ::mzIdentML120::UserParamType userParam_type;
    typedef ::xsd::cxx::tree::sequence< userParam_type > userParam_sequence;
    typedef userParam_sequence::iterator userParam_iterator;
    typedef userParam_sequence::const_iterator userParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< userParam_type, char > userParam_traits;

    const userParam_sequence&
    userParam () const;

    userParam_sequence&
    userParam ();

    void
    userParam (const userParam_sequence& s);

    // numSequencesSearched
    //
    typedef ::xml_schema::long_ numSequencesSearched_type;
    typedef ::xsd::cxx::tree::optional< numSequencesSearched_type > numSequencesSearched_optional;
    typedef ::xsd::cxx::tree::traits< numSequencesSearched_type, char > numSequencesSearched_traits;

    const numSequencesSearched_optional&
    numSequencesSearched () const;

    numSequencesSearched_optional&
    numSequencesSearched ();

    void
    numSequencesSearched (const numSequencesSearched_type& x);

    void
    numSequencesSearched (const numSequencesSearched_optional& x);

    // Constructors.
    //
    SpectrumIdentificationListType ();

    SpectrumIdentificationListType (const id_type&);

    SpectrumIdentificationListType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    SpectrumIdentificationListType (const SpectrumIdentificationListType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual SpectrumIdentificationListType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SpectrumIdentificationListType&
    operator= (const SpectrumIdentificationListType& x);

    virtual 
    ~SpectrumIdentificationListType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    FragmentationTable_optional FragmentationTable_;
    SpectrumIdentificationResult_sequence SpectrumIdentificationResult_;
    cvParam_sequence cvParam_;
    userParam_sequence userParam_;
    numSequencesSearched_optional numSequencesSearched_;
  };

  class SpecificityRulesType: public ::xml_schema::type
  {
    public:
    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // Constructors.
    //
    SpecificityRulesType ();

    SpecificityRulesType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    SpecificityRulesType (const SpecificityRulesType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual SpecificityRulesType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SpecificityRulesType&
    operator= (const SpecificityRulesType& x);

    virtual 
    ~SpecificityRulesType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    cvParam_sequence cvParam_;
  };

  class SearchModificationType: public ::xml_schema::type
  {
    public:
    // SpecificityRules
    //
    typedef ::mzIdentML120::SpecificityRulesType SpecificityRules_type;
    typedef ::xsd::cxx::tree::sequence< SpecificityRules_type > SpecificityRules_sequence;
    typedef SpecificityRules_sequence::iterator SpecificityRules_iterator;
    typedef SpecificityRules_sequence::const_iterator SpecificityRules_const_iterator;
    typedef ::xsd::cxx::tree::traits< SpecificityRules_type, char > SpecificityRules_traits;

    const SpecificityRules_sequence&
    SpecificityRules () const;

    SpecificityRules_sequence&
    SpecificityRules ();

    void
    SpecificityRules (const SpecificityRules_sequence& s);

    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // fixedMod
    //
    typedef ::xml_schema::boolean fixedMod_type;
    typedef ::xsd::cxx::tree::traits< fixedMod_type, char > fixedMod_traits;

    const fixedMod_type&
    fixedMod () const;

    fixedMod_type&
    fixedMod ();

    void
    fixedMod (const fixedMod_type& x);

    // massDelta
    //
    typedef ::xml_schema::float_ massDelta_type;
    typedef ::xsd::cxx::tree::traits< massDelta_type, char > massDelta_traits;

    const massDelta_type&
    massDelta () const;

    massDelta_type&
    massDelta ();

    void
    massDelta (const massDelta_type& x);

    // residues
    //
    typedef ::mzIdentML120::listOfCharsOrAny residues_type;
    typedef ::xsd::cxx::tree::traits< residues_type, char > residues_traits;

    const residues_type&
    residues () const;

    residues_type&
    residues ();

    void
    residues (const residues_type& x);

    void
    residues (::std::unique_ptr< residues_type > p);

    // Constructors.
    //
    SearchModificationType ();

    SearchModificationType (const fixedMod_type&,
                            const massDelta_type&,
                            const residues_type&);

    SearchModificationType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    SearchModificationType (const SearchModificationType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual SearchModificationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SearchModificationType&
    operator= (const SearchModificationType& x);

    virtual 
    ~SearchModificationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    SpecificityRules_sequence SpecificityRules_;
    cvParam_sequence cvParam_;
    ::xsd::cxx::tree::one< fixedMod_type > fixedMod_;
    ::xsd::cxx::tree::one< massDelta_type > massDelta_;
    ::xsd::cxx::tree::one< residues_type > residues_;
  };

  class FragmentArrayType: public ::xml_schema::type
  {
    public:
    // values
    //
    typedef ::mzIdentML120::listOfFloats values_type;
    typedef ::xsd::cxx::tree::traits< values_type, char > values_traits;

    const values_type&
    values () const;

    values_type&
    values ();

    void
    values (const values_type& x);

    void
    values (::std::unique_ptr< values_type > p);

    // measure_ref
    //
    typedef ::xml_schema::string measure_ref_type;
    typedef ::xsd::cxx::tree::traits< measure_ref_type, char > measure_ref_traits;

    const measure_ref_type&
    measure_ref () const;

    measure_ref_type&
    measure_ref ();

    void
    measure_ref (const measure_ref_type& x);

    void
    measure_ref (::std::unique_ptr< measure_ref_type > p);

    // Constructors.
    //
    FragmentArrayType ();

    FragmentArrayType (const values_type&,
                       const measure_ref_type&);

    FragmentArrayType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    FragmentArrayType (const FragmentArrayType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual FragmentArrayType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FragmentArrayType&
    operator= (const FragmentArrayType& x);

    virtual 
    ~FragmentArrayType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< values_type > values_;
    ::xsd::cxx::tree::one< measure_ref_type > measure_ref_;
  };

  class IonTypeType: public ::xml_schema::type
  {
    public:
    // FragmentArray
    //
    typedef ::mzIdentML120::FragmentArrayType FragmentArray_type;
    typedef ::xsd::cxx::tree::sequence< FragmentArray_type > FragmentArray_sequence;
    typedef FragmentArray_sequence::iterator FragmentArray_iterator;
    typedef FragmentArray_sequence::const_iterator FragmentArray_const_iterator;
    typedef ::xsd::cxx::tree::traits< FragmentArray_type, char > FragmentArray_traits;

    const FragmentArray_sequence&
    FragmentArray () const;

    FragmentArray_sequence&
    FragmentArray ();

    void
    FragmentArray (const FragmentArray_sequence& s);

    // userParam
    //
    typedef ::mzIdentML120::UserParamType userParam_type;
    typedef ::xsd::cxx::tree::sequence< userParam_type > userParam_sequence;
    typedef userParam_sequence::iterator userParam_iterator;
    typedef userParam_sequence::const_iterator userParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< userParam_type, char > userParam_traits;

    const userParam_sequence&
    userParam () const;

    userParam_sequence&
    userParam ();

    void
    userParam (const userParam_sequence& s);

    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // index
    //
    typedef ::mzIdentML120::listOfIntegers index_type;
    typedef ::xsd::cxx::tree::optional< index_type > index_optional;
    typedef ::xsd::cxx::tree::traits< index_type, char > index_traits;

    const index_optional&
    index () const;

    index_optional&
    index ();

    void
    index (const index_type& x);

    void
    index (const index_optional& x);

    void
    index (::std::unique_ptr< index_type > p);

    // charge
    //
    typedef ::xml_schema::int_ charge_type;
    typedef ::xsd::cxx::tree::traits< charge_type, char > charge_traits;

    const charge_type&
    charge () const;

    charge_type&
    charge ();

    void
    charge (const charge_type& x);

    // Constructors.
    //
    IonTypeType ();

    IonTypeType (const charge_type&);

    IonTypeType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    IonTypeType (const IonTypeType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual IonTypeType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    IonTypeType&
    operator= (const IonTypeType& x);

    virtual 
    ~IonTypeType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    FragmentArray_sequence FragmentArray_;
    userParam_sequence userParam_;
    cvParam_sequence cvParam_;
    index_optional index_;
    ::xsd::cxx::tree::one< charge_type > charge_;
  };

  class FragmentationType: public ::xml_schema::type
  {
    public:
    // IonType
    //
    typedef ::mzIdentML120::IonTypeType IonType_type;
    typedef ::xsd::cxx::tree::sequence< IonType_type > IonType_sequence;
    typedef IonType_sequence::iterator IonType_iterator;
    typedef IonType_sequence::const_iterator IonType_const_iterator;
    typedef ::xsd::cxx::tree::traits< IonType_type, char > IonType_traits;

    const IonType_sequence&
    IonType () const;

    IonType_sequence&
    IonType ();

    void
    IonType (const IonType_sequence& s);

    // Constructors.
    //
    FragmentationType ();

    FragmentationType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    FragmentationType (const FragmentationType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual FragmentationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FragmentationType&
    operator= (const FragmentationType& x);

    virtual 
    ~FragmentationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    IonType_sequence IonType_;
  };

  class PeptideEvidenceRefType: public ::xml_schema::type
  {
    public:
    // peptideEvidence_ref
    //
    typedef ::xml_schema::string peptideEvidence_ref_type;
    typedef ::xsd::cxx::tree::traits< peptideEvidence_ref_type, char > peptideEvidence_ref_traits;

    const peptideEvidence_ref_type&
    peptideEvidence_ref () const;

    peptideEvidence_ref_type&
    peptideEvidence_ref ();

    void
    peptideEvidence_ref (const peptideEvidence_ref_type& x);

    void
    peptideEvidence_ref (::std::unique_ptr< peptideEvidence_ref_type > p);

    // Constructors.
    //
    PeptideEvidenceRefType ();

    PeptideEvidenceRefType (const peptideEvidence_ref_type&);

    PeptideEvidenceRefType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    PeptideEvidenceRefType (const PeptideEvidenceRefType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual PeptideEvidenceRefType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PeptideEvidenceRefType&
    operator= (const PeptideEvidenceRefType& x);

    virtual 
    ~PeptideEvidenceRefType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< peptideEvidence_ref_type > peptideEvidence_ref_;
  };

  class SpectrumIdentificationItemType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // PeptideEvidenceRef
    //
    typedef ::mzIdentML120::PeptideEvidenceRefType PeptideEvidenceRef_type;
    typedef ::xsd::cxx::tree::sequence< PeptideEvidenceRef_type > PeptideEvidenceRef_sequence;
    typedef PeptideEvidenceRef_sequence::iterator PeptideEvidenceRef_iterator;
    typedef PeptideEvidenceRef_sequence::const_iterator PeptideEvidenceRef_const_iterator;
    typedef ::xsd::cxx::tree::traits< PeptideEvidenceRef_type, char > PeptideEvidenceRef_traits;

    const PeptideEvidenceRef_sequence&
    PeptideEvidenceRef () const;

    PeptideEvidenceRef_sequence&
    PeptideEvidenceRef ();

    void
    PeptideEvidenceRef (const PeptideEvidenceRef_sequence& s);

    // Fragmentation
    //
    typedef ::mzIdentML120::FragmentationType Fragmentation_type;
    typedef ::xsd::cxx::tree::optional< Fragmentation_type > Fragmentation_optional;
    typedef ::xsd::cxx::tree::traits< Fragmentation_type, char > Fragmentation_traits;

    const Fragmentation_optional&
    Fragmentation () const;

    Fragmentation_optional&
    Fragmentation ();

    void
    Fragmentation (const Fragmentation_type& x);

    void
    Fragmentation (const Fragmentation_optional& x);

    void
    Fragmentation (::std::unique_ptr< Fragmentation_type > p);

    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // userParam
    //
    typedef ::mzIdentML120::UserParamType userParam_type;
    typedef ::xsd::cxx::tree::sequence< userParam_type > userParam_sequence;
    typedef userParam_sequence::iterator userParam_iterator;
    typedef userParam_sequence::const_iterator userParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< userParam_type, char > userParam_traits;

    const userParam_sequence&
    userParam () const;

    userParam_sequence&
    userParam ();

    void
    userParam (const userParam_sequence& s);

    // chargeState
    //
    typedef ::xml_schema::int_ chargeState_type;
    typedef ::xsd::cxx::tree::traits< chargeState_type, char > chargeState_traits;

    const chargeState_type&
    chargeState () const;

    chargeState_type&
    chargeState ();

    void
    chargeState (const chargeState_type& x);

    // experimentalMassToCharge
    //
    typedef ::xml_schema::double_ experimentalMassToCharge_type;
    typedef ::xsd::cxx::tree::traits< experimentalMassToCharge_type, char, ::xsd::cxx::tree::schema_type::double_ > experimentalMassToCharge_traits;

    const experimentalMassToCharge_type&
    experimentalMassToCharge () const;

    experimentalMassToCharge_type&
    experimentalMassToCharge ();

    void
    experimentalMassToCharge (const experimentalMassToCharge_type& x);

    // calculatedMassToCharge
    //
    typedef ::xml_schema::double_ calculatedMassToCharge_type;
    typedef ::xsd::cxx::tree::optional< calculatedMassToCharge_type > calculatedMassToCharge_optional;
    typedef ::xsd::cxx::tree::traits< calculatedMassToCharge_type, char, ::xsd::cxx::tree::schema_type::double_ > calculatedMassToCharge_traits;

    const calculatedMassToCharge_optional&
    calculatedMassToCharge () const;

    calculatedMassToCharge_optional&
    calculatedMassToCharge ();

    void
    calculatedMassToCharge (const calculatedMassToCharge_type& x);

    void
    calculatedMassToCharge (const calculatedMassToCharge_optional& x);

    // calculatedPI
    //
    typedef ::xml_schema::float_ calculatedPI_type;
    typedef ::xsd::cxx::tree::optional< calculatedPI_type > calculatedPI_optional;
    typedef ::xsd::cxx::tree::traits< calculatedPI_type, char > calculatedPI_traits;

    const calculatedPI_optional&
    calculatedPI () const;

    calculatedPI_optional&
    calculatedPI ();

    void
    calculatedPI (const calculatedPI_type& x);

    void
    calculatedPI (const calculatedPI_optional& x);

    // peptide_ref
    //
    typedef ::xml_schema::string peptide_ref_type;
    typedef ::xsd::cxx::tree::traits< peptide_ref_type, char > peptide_ref_traits;

    const peptide_ref_type&
    peptide_ref () const;

    peptide_ref_type&
    peptide_ref ();

    void
    peptide_ref (const peptide_ref_type& x);

    void
    peptide_ref (::std::unique_ptr< peptide_ref_type > p);

    // rank
    //
    typedef ::xml_schema::int_ rank_type;
    typedef ::xsd::cxx::tree::traits< rank_type, char > rank_traits;

    const rank_type&
    rank () const;

    rank_type&
    rank ();

    void
    rank (const rank_type& x);

    // passThreshold
    //
    typedef ::xml_schema::boolean passThreshold_type;
    typedef ::xsd::cxx::tree::traits< passThreshold_type, char > passThreshold_traits;

    const passThreshold_type&
    passThreshold () const;

    passThreshold_type&
    passThreshold ();

    void
    passThreshold (const passThreshold_type& x);

    // massTable_ref
    //
    typedef ::xml_schema::string massTable_ref_type;
    typedef ::xsd::cxx::tree::optional< massTable_ref_type > massTable_ref_optional;
    typedef ::xsd::cxx::tree::traits< massTable_ref_type, char > massTable_ref_traits;

    const massTable_ref_optional&
    massTable_ref () const;

    massTable_ref_optional&
    massTable_ref ();

    void
    massTable_ref (const massTable_ref_type& x);

    void
    massTable_ref (const massTable_ref_optional& x);

    void
    massTable_ref (::std::unique_ptr< massTable_ref_type > p);

    // sample_ref
    //
    typedef ::xml_schema::string sample_ref_type;
    typedef ::xsd::cxx::tree::optional< sample_ref_type > sample_ref_optional;
    typedef ::xsd::cxx::tree::traits< sample_ref_type, char > sample_ref_traits;

    const sample_ref_optional&
    sample_ref () const;

    sample_ref_optional&
    sample_ref ();

    void
    sample_ref (const sample_ref_type& x);

    void
    sample_ref (const sample_ref_optional& x);

    void
    sample_ref (::std::unique_ptr< sample_ref_type > p);

    // Constructors.
    //
    SpectrumIdentificationItemType ();

    SpectrumIdentificationItemType (const id_type&,
                                    const chargeState_type&,
                                    const experimentalMassToCharge_type&,
                                    const peptide_ref_type&,
                                    const rank_type&,
                                    const passThreshold_type&);

    SpectrumIdentificationItemType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    SpectrumIdentificationItemType (const SpectrumIdentificationItemType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual SpectrumIdentificationItemType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SpectrumIdentificationItemType&
    operator= (const SpectrumIdentificationItemType& x);

    virtual 
    ~SpectrumIdentificationItemType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    PeptideEvidenceRef_sequence PeptideEvidenceRef_;
    Fragmentation_optional Fragmentation_;
    cvParam_sequence cvParam_;
    userParam_sequence userParam_;
    ::xsd::cxx::tree::one< chargeState_type > chargeState_;
    ::xsd::cxx::tree::one< experimentalMassToCharge_type > experimentalMassToCharge_;
    calculatedMassToCharge_optional calculatedMassToCharge_;
    calculatedPI_optional calculatedPI_;
    ::xsd::cxx::tree::one< peptide_ref_type > peptide_ref_;
    ::xsd::cxx::tree::one< rank_type > rank_;
    ::xsd::cxx::tree::one< passThreshold_type > passThreshold_;
    massTable_ref_optional massTable_ref_;
    sample_ref_optional sample_ref_;
  };

  class SpectrumIdentificationResultType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // SpectrumIdentificationItem
    //
    typedef ::mzIdentML120::SpectrumIdentificationItemType SpectrumIdentificationItem_type;
    typedef ::xsd::cxx::tree::sequence< SpectrumIdentificationItem_type > SpectrumIdentificationItem_sequence;
    typedef SpectrumIdentificationItem_sequence::iterator SpectrumIdentificationItem_iterator;
    typedef SpectrumIdentificationItem_sequence::const_iterator SpectrumIdentificationItem_const_iterator;
    typedef ::xsd::cxx::tree::traits< SpectrumIdentificationItem_type, char > SpectrumIdentificationItem_traits;

    const SpectrumIdentificationItem_sequence&
    SpectrumIdentificationItem () const;

    SpectrumIdentificationItem_sequence&
    SpectrumIdentificationItem ();

    void
    SpectrumIdentificationItem (const SpectrumIdentificationItem_sequence& s);

    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // userParam
    //
    typedef ::mzIdentML120::UserParamType userParam_type;
    typedef ::xsd::cxx::tree::sequence< userParam_type > userParam_sequence;
    typedef userParam_sequence::iterator userParam_iterator;
    typedef userParam_sequence::const_iterator userParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< userParam_type, char > userParam_traits;

    const userParam_sequence&
    userParam () const;

    userParam_sequence&
    userParam ();

    void
    userParam (const userParam_sequence& s);

    // spectrumID
    //
    typedef ::xml_schema::string spectrumID_type;
    typedef ::xsd::cxx::tree::traits< spectrumID_type, char > spectrumID_traits;

    const spectrumID_type&
    spectrumID () const;

    spectrumID_type&
    spectrumID ();

    void
    spectrumID (const spectrumID_type& x);

    void
    spectrumID (::std::unique_ptr< spectrumID_type > p);

    // spectraData_ref
    //
    typedef ::xml_schema::string spectraData_ref_type;
    typedef ::xsd::cxx::tree::traits< spectraData_ref_type, char > spectraData_ref_traits;

    const spectraData_ref_type&
    spectraData_ref () const;

    spectraData_ref_type&
    spectraData_ref ();

    void
    spectraData_ref (const spectraData_ref_type& x);

    void
    spectraData_ref (::std::unique_ptr< spectraData_ref_type > p);

    // Constructors.
    //
    SpectrumIdentificationResultType ();

    SpectrumIdentificationResultType (const id_type&,
                                      const spectrumID_type&,
                                      const spectraData_ref_type&);

    SpectrumIdentificationResultType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    SpectrumIdentificationResultType (const SpectrumIdentificationResultType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual SpectrumIdentificationResultType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SpectrumIdentificationResultType&
    operator= (const SpectrumIdentificationResultType& x);

    virtual 
    ~SpectrumIdentificationResultType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    SpectrumIdentificationItem_sequence SpectrumIdentificationItem_;
    cvParam_sequence cvParam_;
    userParam_sequence userParam_;
    ::xsd::cxx::tree::one< spectrumID_type > spectrumID_;
    ::xsd::cxx::tree::one< spectraData_ref_type > spectraData_ref_;
  };

  class InputSpectrumIdentificationsType: public ::xml_schema::type
  {
    public:
    // spectrumIdentificationList_ref
    //
    typedef ::xml_schema::string spectrumIdentificationList_ref_type;
    typedef ::xsd::cxx::tree::traits< spectrumIdentificationList_ref_type, char > spectrumIdentificationList_ref_traits;

    const spectrumIdentificationList_ref_type&
    spectrumIdentificationList_ref () const;

    spectrumIdentificationList_ref_type&
    spectrumIdentificationList_ref ();

    void
    spectrumIdentificationList_ref (const spectrumIdentificationList_ref_type& x);

    void
    spectrumIdentificationList_ref (::std::unique_ptr< spectrumIdentificationList_ref_type > p);

    // Constructors.
    //
    InputSpectrumIdentificationsType ();

    InputSpectrumIdentificationsType (const spectrumIdentificationList_ref_type&);

    InputSpectrumIdentificationsType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    InputSpectrumIdentificationsType (const InputSpectrumIdentificationsType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual InputSpectrumIdentificationsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    InputSpectrumIdentificationsType&
    operator= (const InputSpectrumIdentificationsType& x);

    virtual 
    ~InputSpectrumIdentificationsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< spectrumIdentificationList_ref_type > spectrumIdentificationList_ref_;
  };

  class ProteinDetectionType: public ::mzIdentML120::ProtocolApplicationType
  {
    public:
    // InputSpectrumIdentifications
    //
    typedef ::mzIdentML120::InputSpectrumIdentificationsType InputSpectrumIdentifications_type;
    typedef ::xsd::cxx::tree::sequence< InputSpectrumIdentifications_type > InputSpectrumIdentifications_sequence;
    typedef InputSpectrumIdentifications_sequence::iterator InputSpectrumIdentifications_iterator;
    typedef InputSpectrumIdentifications_sequence::const_iterator InputSpectrumIdentifications_const_iterator;
    typedef ::xsd::cxx::tree::traits< InputSpectrumIdentifications_type, char > InputSpectrumIdentifications_traits;

    const InputSpectrumIdentifications_sequence&
    InputSpectrumIdentifications () const;

    InputSpectrumIdentifications_sequence&
    InputSpectrumIdentifications ();

    void
    InputSpectrumIdentifications (const InputSpectrumIdentifications_sequence& s);

    // proteinDetectionList_ref
    //
    typedef ::xml_schema::string proteinDetectionList_ref_type;
    typedef ::xsd::cxx::tree::traits< proteinDetectionList_ref_type, char > proteinDetectionList_ref_traits;

    const proteinDetectionList_ref_type&
    proteinDetectionList_ref () const;

    proteinDetectionList_ref_type&
    proteinDetectionList_ref ();

    void
    proteinDetectionList_ref (const proteinDetectionList_ref_type& x);

    void
    proteinDetectionList_ref (::std::unique_ptr< proteinDetectionList_ref_type > p);

    // proteinDetectionProtocol_ref
    //
    typedef ::xml_schema::string proteinDetectionProtocol_ref_type;
    typedef ::xsd::cxx::tree::traits< proteinDetectionProtocol_ref_type, char > proteinDetectionProtocol_ref_traits;

    const proteinDetectionProtocol_ref_type&
    proteinDetectionProtocol_ref () const;

    proteinDetectionProtocol_ref_type&
    proteinDetectionProtocol_ref ();

    void
    proteinDetectionProtocol_ref (const proteinDetectionProtocol_ref_type& x);

    void
    proteinDetectionProtocol_ref (::std::unique_ptr< proteinDetectionProtocol_ref_type > p);

    // Constructors.
    //
    ProteinDetectionType ();

    ProteinDetectionType (const id_type&,
                          const proteinDetectionList_ref_type&,
                          const proteinDetectionProtocol_ref_type&);

    ProteinDetectionType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    ProteinDetectionType (const ProteinDetectionType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual ProteinDetectionType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ProteinDetectionType&
    operator= (const ProteinDetectionType& x);

    virtual 
    ~ProteinDetectionType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    InputSpectrumIdentifications_sequence InputSpectrumIdentifications_;
    ::xsd::cxx::tree::one< proteinDetectionList_ref_type > proteinDetectionList_ref_;
    ::xsd::cxx::tree::one< proteinDetectionProtocol_ref_type > proteinDetectionProtocol_ref_;
  };

  class ProteinDetectionProtocolType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // AnalysisParams
    //
    typedef ::mzIdentML120::ParamListType AnalysisParams_type;
    typedef ::xsd::cxx::tree::optional< AnalysisParams_type > AnalysisParams_optional;
    typedef ::xsd::cxx::tree::traits< AnalysisParams_type, char > AnalysisParams_traits;

    const AnalysisParams_optional&
    AnalysisParams () const;

    AnalysisParams_optional&
    AnalysisParams ();

    void
    AnalysisParams (const AnalysisParams_type& x);

    void
    AnalysisParams (const AnalysisParams_optional& x);

    void
    AnalysisParams (::std::unique_ptr< AnalysisParams_type > p);

    // Threshold
    //
    typedef ::mzIdentML120::ParamListType Threshold_type;
    typedef ::xsd::cxx::tree::traits< Threshold_type, char > Threshold_traits;

    const Threshold_type&
    Threshold () const;

    Threshold_type&
    Threshold ();

    void
    Threshold (const Threshold_type& x);

    void
    Threshold (::std::unique_ptr< Threshold_type > p);

    // analysisSoftware_ref
    //
    typedef ::xml_schema::string analysisSoftware_ref_type;
    typedef ::xsd::cxx::tree::traits< analysisSoftware_ref_type, char > analysisSoftware_ref_traits;

    const analysisSoftware_ref_type&
    analysisSoftware_ref () const;

    analysisSoftware_ref_type&
    analysisSoftware_ref ();

    void
    analysisSoftware_ref (const analysisSoftware_ref_type& x);

    void
    analysisSoftware_ref (::std::unique_ptr< analysisSoftware_ref_type > p);

    // Constructors.
    //
    ProteinDetectionProtocolType ();

    ProteinDetectionProtocolType (const id_type&,
                                  const Threshold_type&,
                                  const analysisSoftware_ref_type&);

    ProteinDetectionProtocolType (const id_type&,
                                  ::std::unique_ptr< Threshold_type >,
                                  const analysisSoftware_ref_type&);

    ProteinDetectionProtocolType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ProteinDetectionProtocolType (const ProteinDetectionProtocolType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual ProteinDetectionProtocolType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ProteinDetectionProtocolType&
    operator= (const ProteinDetectionProtocolType& x);

    virtual 
    ~ProteinDetectionProtocolType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    AnalysisParams_optional AnalysisParams_;
    ::xsd::cxx::tree::one< Threshold_type > Threshold_;
    ::xsd::cxx::tree::one< analysisSoftware_ref_type > analysisSoftware_ref_;
  };

  class ProteinDetectionListType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // ProteinAmbiguityGroup
    //
    typedef ::mzIdentML120::ProteinAmbiguityGroupType ProteinAmbiguityGroup_type;
    typedef ::xsd::cxx::tree::sequence< ProteinAmbiguityGroup_type > ProteinAmbiguityGroup_sequence;
    typedef ProteinAmbiguityGroup_sequence::iterator ProteinAmbiguityGroup_iterator;
    typedef ProteinAmbiguityGroup_sequence::const_iterator ProteinAmbiguityGroup_const_iterator;
    typedef ::xsd::cxx::tree::traits< ProteinAmbiguityGroup_type, char > ProteinAmbiguityGroup_traits;

    const ProteinAmbiguityGroup_sequence&
    ProteinAmbiguityGroup () const;

    ProteinAmbiguityGroup_sequence&
    ProteinAmbiguityGroup ();

    void
    ProteinAmbiguityGroup (const ProteinAmbiguityGroup_sequence& s);

    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // userParam
    //
    typedef ::mzIdentML120::UserParamType userParam_type;
    typedef ::xsd::cxx::tree::sequence< userParam_type > userParam_sequence;
    typedef userParam_sequence::iterator userParam_iterator;
    typedef userParam_sequence::const_iterator userParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< userParam_type, char > userParam_traits;

    const userParam_sequence&
    userParam () const;

    userParam_sequence&
    userParam ();

    void
    userParam (const userParam_sequence& s);

    // Constructors.
    //
    ProteinDetectionListType ();

    ProteinDetectionListType (const id_type&);

    ProteinDetectionListType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    ProteinDetectionListType (const ProteinDetectionListType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual ProteinDetectionListType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ProteinDetectionListType&
    operator= (const ProteinDetectionListType& x);

    virtual 
    ~ProteinDetectionListType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ProteinAmbiguityGroup_sequence ProteinAmbiguityGroup_;
    cvParam_sequence cvParam_;
    userParam_sequence userParam_;
  };

  class SpectrumIdentificationItemRefType: public ::xml_schema::type
  {
    public:
    // spectrumIdentificationItem_ref
    //
    typedef ::xml_schema::string spectrumIdentificationItem_ref_type;
    typedef ::xsd::cxx::tree::traits< spectrumIdentificationItem_ref_type, char > spectrumIdentificationItem_ref_traits;

    const spectrumIdentificationItem_ref_type&
    spectrumIdentificationItem_ref () const;

    spectrumIdentificationItem_ref_type&
    spectrumIdentificationItem_ref ();

    void
    spectrumIdentificationItem_ref (const spectrumIdentificationItem_ref_type& x);

    void
    spectrumIdentificationItem_ref (::std::unique_ptr< spectrumIdentificationItem_ref_type > p);

    // Constructors.
    //
    SpectrumIdentificationItemRefType ();

    SpectrumIdentificationItemRefType (const spectrumIdentificationItem_ref_type&);

    SpectrumIdentificationItemRefType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    SpectrumIdentificationItemRefType (const SpectrumIdentificationItemRefType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual SpectrumIdentificationItemRefType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SpectrumIdentificationItemRefType&
    operator= (const SpectrumIdentificationItemRefType& x);

    virtual 
    ~SpectrumIdentificationItemRefType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< spectrumIdentificationItem_ref_type > spectrumIdentificationItem_ref_;
  };

  class PeptideHypothesisType: public ::xml_schema::type
  {
    public:
    // SpectrumIdentificationItemRef
    //
    typedef ::mzIdentML120::SpectrumIdentificationItemRefType SpectrumIdentificationItemRef_type;
    typedef ::xsd::cxx::tree::sequence< SpectrumIdentificationItemRef_type > SpectrumIdentificationItemRef_sequence;
    typedef SpectrumIdentificationItemRef_sequence::iterator SpectrumIdentificationItemRef_iterator;
    typedef SpectrumIdentificationItemRef_sequence::const_iterator SpectrumIdentificationItemRef_const_iterator;
    typedef ::xsd::cxx::tree::traits< SpectrumIdentificationItemRef_type, char > SpectrumIdentificationItemRef_traits;

    const SpectrumIdentificationItemRef_sequence&
    SpectrumIdentificationItemRef () const;

    SpectrumIdentificationItemRef_sequence&
    SpectrumIdentificationItemRef ();

    void
    SpectrumIdentificationItemRef (const SpectrumIdentificationItemRef_sequence& s);

    // peptideEvidence_ref
    //
    typedef ::xml_schema::string peptideEvidence_ref_type;
    typedef ::xsd::cxx::tree::traits< peptideEvidence_ref_type, char > peptideEvidence_ref_traits;

    const peptideEvidence_ref_type&
    peptideEvidence_ref () const;

    peptideEvidence_ref_type&
    peptideEvidence_ref ();

    void
    peptideEvidence_ref (const peptideEvidence_ref_type& x);

    void
    peptideEvidence_ref (::std::unique_ptr< peptideEvidence_ref_type > p);

    // Constructors.
    //
    PeptideHypothesisType ();

    PeptideHypothesisType (const peptideEvidence_ref_type&);

    PeptideHypothesisType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    PeptideHypothesisType (const PeptideHypothesisType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual PeptideHypothesisType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PeptideHypothesisType&
    operator= (const PeptideHypothesisType& x);

    virtual 
    ~PeptideHypothesisType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    SpectrumIdentificationItemRef_sequence SpectrumIdentificationItemRef_;
    ::xsd::cxx::tree::one< peptideEvidence_ref_type > peptideEvidence_ref_;
  };

  class ProteinDetectionHypothesisType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // PeptideHypothesis
    //
    typedef ::mzIdentML120::PeptideHypothesisType PeptideHypothesis_type;
    typedef ::xsd::cxx::tree::sequence< PeptideHypothesis_type > PeptideHypothesis_sequence;
    typedef PeptideHypothesis_sequence::iterator PeptideHypothesis_iterator;
    typedef PeptideHypothesis_sequence::const_iterator PeptideHypothesis_const_iterator;
    typedef ::xsd::cxx::tree::traits< PeptideHypothesis_type, char > PeptideHypothesis_traits;

    const PeptideHypothesis_sequence&
    PeptideHypothesis () const;

    PeptideHypothesis_sequence&
    PeptideHypothesis ();

    void
    PeptideHypothesis (const PeptideHypothesis_sequence& s);

    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // userParam
    //
    typedef ::mzIdentML120::UserParamType userParam_type;
    typedef ::xsd::cxx::tree::sequence< userParam_type > userParam_sequence;
    typedef userParam_sequence::iterator userParam_iterator;
    typedef userParam_sequence::const_iterator userParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< userParam_type, char > userParam_traits;

    const userParam_sequence&
    userParam () const;

    userParam_sequence&
    userParam ();

    void
    userParam (const userParam_sequence& s);

    // dBSequence_ref
    //
    typedef ::xml_schema::string dBSequence_ref_type;
    typedef ::xsd::cxx::tree::traits< dBSequence_ref_type, char > dBSequence_ref_traits;

    const dBSequence_ref_type&
    dBSequence_ref () const;

    dBSequence_ref_type&
    dBSequence_ref ();

    void
    dBSequence_ref (const dBSequence_ref_type& x);

    void
    dBSequence_ref (::std::unique_ptr< dBSequence_ref_type > p);

    // passThreshold
    //
    typedef ::xml_schema::boolean passThreshold_type;
    typedef ::xsd::cxx::tree::traits< passThreshold_type, char > passThreshold_traits;

    const passThreshold_type&
    passThreshold () const;

    passThreshold_type&
    passThreshold ();

    void
    passThreshold (const passThreshold_type& x);

    // Constructors.
    //
    ProteinDetectionHypothesisType ();

    ProteinDetectionHypothesisType (const id_type&,
                                    const dBSequence_ref_type&,
                                    const passThreshold_type&);

    ProteinDetectionHypothesisType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    ProteinDetectionHypothesisType (const ProteinDetectionHypothesisType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual ProteinDetectionHypothesisType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ProteinDetectionHypothesisType&
    operator= (const ProteinDetectionHypothesisType& x);

    virtual 
    ~ProteinDetectionHypothesisType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    PeptideHypothesis_sequence PeptideHypothesis_;
    cvParam_sequence cvParam_;
    userParam_sequence userParam_;
    ::xsd::cxx::tree::one< dBSequence_ref_type > dBSequence_ref_;
    ::xsd::cxx::tree::one< passThreshold_type > passThreshold_;
  };

  class ProteinAmbiguityGroupType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // ProteinDetectionHypothesis
    //
    typedef ::mzIdentML120::ProteinDetectionHypothesisType ProteinDetectionHypothesis_type;
    typedef ::xsd::cxx::tree::sequence< ProteinDetectionHypothesis_type > ProteinDetectionHypothesis_sequence;
    typedef ProteinDetectionHypothesis_sequence::iterator ProteinDetectionHypothesis_iterator;
    typedef ProteinDetectionHypothesis_sequence::const_iterator ProteinDetectionHypothesis_const_iterator;
    typedef ::xsd::cxx::tree::traits< ProteinDetectionHypothesis_type, char > ProteinDetectionHypothesis_traits;

    const ProteinDetectionHypothesis_sequence&
    ProteinDetectionHypothesis () const;

    ProteinDetectionHypothesis_sequence&
    ProteinDetectionHypothesis ();

    void
    ProteinDetectionHypothesis (const ProteinDetectionHypothesis_sequence& s);

    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // userParam
    //
    typedef ::mzIdentML120::UserParamType userParam_type;
    typedef ::xsd::cxx::tree::sequence< userParam_type > userParam_sequence;
    typedef userParam_sequence::iterator userParam_iterator;
    typedef userParam_sequence::const_iterator userParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< userParam_type, char > userParam_traits;

    const userParam_sequence&
    userParam () const;

    userParam_sequence&
    userParam ();

    void
    userParam (const userParam_sequence& s);

    // Constructors.
    //
    ProteinAmbiguityGroupType ();

    ProteinAmbiguityGroupType (const id_type&);

    ProteinAmbiguityGroupType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    ProteinAmbiguityGroupType (const ProteinAmbiguityGroupType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual ProteinAmbiguityGroupType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ProteinAmbiguityGroupType&
    operator= (const ProteinAmbiguityGroupType& x);

    virtual 
    ~ProteinAmbiguityGroupType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ProteinDetectionHypothesis_sequence ProteinDetectionHypothesis_;
    cvParam_sequence cvParam_;
    userParam_sequence userParam_;
  };

  class ModificationType: public ::xml_schema::type
  {
    public:
    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // location
    //
    typedef ::xml_schema::int_ location_type;
    typedef ::xsd::cxx::tree::optional< location_type > location_optional;
    typedef ::xsd::cxx::tree::traits< location_type, char > location_traits;

    const location_optional&
    location () const;

    location_optional&
    location ();

    void
    location (const location_type& x);

    void
    location (const location_optional& x);

    // residues
    //
    typedef ::mzIdentML120::listOfChars residues_type;
    typedef ::xsd::cxx::tree::optional< residues_type > residues_optional;
    typedef ::xsd::cxx::tree::traits< residues_type, char > residues_traits;

    const residues_optional&
    residues () const;

    residues_optional&
    residues ();

    void
    residues (const residues_type& x);

    void
    residues (const residues_optional& x);

    void
    residues (::std::unique_ptr< residues_type > p);

    // avgMassDelta
    //
    typedef ::xml_schema::double_ avgMassDelta_type;
    typedef ::xsd::cxx::tree::optional< avgMassDelta_type > avgMassDelta_optional;
    typedef ::xsd::cxx::tree::traits< avgMassDelta_type, char, ::xsd::cxx::tree::schema_type::double_ > avgMassDelta_traits;

    const avgMassDelta_optional&
    avgMassDelta () const;

    avgMassDelta_optional&
    avgMassDelta ();

    void
    avgMassDelta (const avgMassDelta_type& x);

    void
    avgMassDelta (const avgMassDelta_optional& x);

    // monoisotopicMassDelta
    //
    typedef ::xml_schema::double_ monoisotopicMassDelta_type;
    typedef ::xsd::cxx::tree::optional< monoisotopicMassDelta_type > monoisotopicMassDelta_optional;
    typedef ::xsd::cxx::tree::traits< monoisotopicMassDelta_type, char, ::xsd::cxx::tree::schema_type::double_ > monoisotopicMassDelta_traits;

    const monoisotopicMassDelta_optional&
    monoisotopicMassDelta () const;

    monoisotopicMassDelta_optional&
    monoisotopicMassDelta ();

    void
    monoisotopicMassDelta (const monoisotopicMassDelta_type& x);

    void
    monoisotopicMassDelta (const monoisotopicMassDelta_optional& x);

    // Constructors.
    //
    ModificationType ();

    ModificationType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    ModificationType (const ModificationType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual ModificationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ModificationType&
    operator= (const ModificationType& x);

    virtual 
    ~ModificationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    cvParam_sequence cvParam_;
    location_optional location_;
    residues_optional residues_;
    avgMassDelta_optional avgMassDelta_;
    monoisotopicMassDelta_optional monoisotopicMassDelta_;
  };

  class PeptideType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // PeptideSequence
    //
    typedef ::mzIdentML120::sequence PeptideSequence_type;
    typedef ::xsd::cxx::tree::traits< PeptideSequence_type, char > PeptideSequence_traits;

    const PeptideSequence_type&
    PeptideSequence () const;

    PeptideSequence_type&
    PeptideSequence ();

    void
    PeptideSequence (const PeptideSequence_type& x);

    void
    PeptideSequence (::std::unique_ptr< PeptideSequence_type > p);

    // Modification
    //
    typedef ::mzIdentML120::ModificationType Modification_type;
    typedef ::xsd::cxx::tree::sequence< Modification_type > Modification_sequence;
    typedef Modification_sequence::iterator Modification_iterator;
    typedef Modification_sequence::const_iterator Modification_const_iterator;
    typedef ::xsd::cxx::tree::traits< Modification_type, char > Modification_traits;

    const Modification_sequence&
    Modification () const;

    Modification_sequence&
    Modification ();

    void
    Modification (const Modification_sequence& s);

    // SubstitutionModification
    //
    typedef ::mzIdentML120::SubstitutionModificationType SubstitutionModification_type;
    typedef ::xsd::cxx::tree::sequence< SubstitutionModification_type > SubstitutionModification_sequence;
    typedef SubstitutionModification_sequence::iterator SubstitutionModification_iterator;
    typedef SubstitutionModification_sequence::const_iterator SubstitutionModification_const_iterator;
    typedef ::xsd::cxx::tree::traits< SubstitutionModification_type, char > SubstitutionModification_traits;

    const SubstitutionModification_sequence&
    SubstitutionModification () const;

    SubstitutionModification_sequence&
    SubstitutionModification ();

    void
    SubstitutionModification (const SubstitutionModification_sequence& s);

    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // userParam
    //
    typedef ::mzIdentML120::UserParamType userParam_type;
    typedef ::xsd::cxx::tree::sequence< userParam_type > userParam_sequence;
    typedef userParam_sequence::iterator userParam_iterator;
    typedef userParam_sequence::const_iterator userParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< userParam_type, char > userParam_traits;

    const userParam_sequence&
    userParam () const;

    userParam_sequence&
    userParam ();

    void
    userParam (const userParam_sequence& s);

    // Constructors.
    //
    PeptideType ();

    PeptideType (const id_type&,
                 const PeptideSequence_type&);

    PeptideType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    PeptideType (const PeptideType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual PeptideType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PeptideType&
    operator= (const PeptideType& x);

    virtual 
    ~PeptideType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< PeptideSequence_type > PeptideSequence_;
    Modification_sequence Modification_;
    SubstitutionModification_sequence SubstitutionModification_;
    cvParam_sequence cvParam_;
    userParam_sequence userParam_;
  };

  class SubstitutionModificationType: public ::xml_schema::type
  {
    public:
    // originalResidue
    //
    typedef ::mzIdentML120::originalResidue originalResidue_type;
    typedef ::xsd::cxx::tree::traits< originalResidue_type, char > originalResidue_traits;

    const originalResidue_type&
    originalResidue () const;

    originalResidue_type&
    originalResidue ();

    void
    originalResidue (const originalResidue_type& x);

    void
    originalResidue (::std::unique_ptr< originalResidue_type > p);

    // replacementResidue
    //
    typedef ::mzIdentML120::replacementResidue replacementResidue_type;
    typedef ::xsd::cxx::tree::traits< replacementResidue_type, char > replacementResidue_traits;

    const replacementResidue_type&
    replacementResidue () const;

    replacementResidue_type&
    replacementResidue ();

    void
    replacementResidue (const replacementResidue_type& x);

    void
    replacementResidue (::std::unique_ptr< replacementResidue_type > p);

    // location
    //
    typedef ::xml_schema::int_ location_type;
    typedef ::xsd::cxx::tree::optional< location_type > location_optional;
    typedef ::xsd::cxx::tree::traits< location_type, char > location_traits;

    const location_optional&
    location () const;

    location_optional&
    location ();

    void
    location (const location_type& x);

    void
    location (const location_optional& x);

    // avgMassDelta
    //
    typedef ::xml_schema::double_ avgMassDelta_type;
    typedef ::xsd::cxx::tree::optional< avgMassDelta_type > avgMassDelta_optional;
    typedef ::xsd::cxx::tree::traits< avgMassDelta_type, char, ::xsd::cxx::tree::schema_type::double_ > avgMassDelta_traits;

    const avgMassDelta_optional&
    avgMassDelta () const;

    avgMassDelta_optional&
    avgMassDelta ();

    void
    avgMassDelta (const avgMassDelta_type& x);

    void
    avgMassDelta (const avgMassDelta_optional& x);

    // monoisotopicMassDelta
    //
    typedef ::xml_schema::double_ monoisotopicMassDelta_type;
    typedef ::xsd::cxx::tree::optional< monoisotopicMassDelta_type > monoisotopicMassDelta_optional;
    typedef ::xsd::cxx::tree::traits< monoisotopicMassDelta_type, char, ::xsd::cxx::tree::schema_type::double_ > monoisotopicMassDelta_traits;

    const monoisotopicMassDelta_optional&
    monoisotopicMassDelta () const;

    monoisotopicMassDelta_optional&
    monoisotopicMassDelta ();

    void
    monoisotopicMassDelta (const monoisotopicMassDelta_type& x);

    void
    monoisotopicMassDelta (const monoisotopicMassDelta_optional& x);

    // Constructors.
    //
    SubstitutionModificationType ();

    SubstitutionModificationType (const originalResidue_type&,
                                  const replacementResidue_type&);

    SubstitutionModificationType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    SubstitutionModificationType (const SubstitutionModificationType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual SubstitutionModificationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SubstitutionModificationType&
    operator= (const SubstitutionModificationType& x);

    virtual 
    ~SubstitutionModificationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< originalResidue_type > originalResidue_;
    ::xsd::cxx::tree::one< replacementResidue_type > replacementResidue_;
    location_optional location_;
    avgMassDelta_optional avgMassDelta_;
    monoisotopicMassDelta_optional monoisotopicMassDelta_;
  };

  class SpectraDataType: public ::mzIdentML120::ExternalDataType
  {
    public:
    // SpectrumIDFormat
    //
    typedef ::mzIdentML120::SpectrumIDFormatType SpectrumIDFormat_type;
    typedef ::xsd::cxx::tree::traits< SpectrumIDFormat_type, char > SpectrumIDFormat_traits;

    const SpectrumIDFormat_type&
    SpectrumIDFormat () const;

    SpectrumIDFormat_type&
    SpectrumIDFormat ();

    void
    SpectrumIDFormat (const SpectrumIDFormat_type& x);

    void
    SpectrumIDFormat (::std::unique_ptr< SpectrumIDFormat_type > p);

    // Constructors.
    //
    SpectraDataType ();

    SpectraDataType (const id_type&,
                     const FileFormat_type&,
                     const location_type&,
                     const SpectrumIDFormat_type&);

    SpectraDataType (const id_type&,
                     ::std::unique_ptr< FileFormat_type >,
                     const location_type&,
                     ::std::unique_ptr< SpectrumIDFormat_type >);

    SpectraDataType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    SpectraDataType (const SpectraDataType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual SpectraDataType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SpectraDataType&
    operator= (const SpectraDataType& x);

    virtual 
    ~SpectraDataType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< SpectrumIDFormat_type > SpectrumIDFormat_;
  };

  class AnalysisSoftwareType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // ContactRole
    //
    typedef ::mzIdentML120::ContactRoleType ContactRole_type;
    typedef ::xsd::cxx::tree::optional< ContactRole_type > ContactRole_optional;
    typedef ::xsd::cxx::tree::traits< ContactRole_type, char > ContactRole_traits;

    const ContactRole_optional&
    ContactRole () const;

    ContactRole_optional&
    ContactRole ();

    void
    ContactRole (const ContactRole_type& x);

    void
    ContactRole (const ContactRole_optional& x);

    void
    ContactRole (::std::unique_ptr< ContactRole_type > p);

    // SoftwareName
    //
    typedef ::mzIdentML120::ParamType SoftwareName_type;
    typedef ::xsd::cxx::tree::traits< SoftwareName_type, char > SoftwareName_traits;

    const SoftwareName_type&
    SoftwareName () const;

    SoftwareName_type&
    SoftwareName ();

    void
    SoftwareName (const SoftwareName_type& x);

    void
    SoftwareName (::std::unique_ptr< SoftwareName_type > p);

    // Customizations
    //
    typedef ::xml_schema::string Customizations_type;
    typedef ::xsd::cxx::tree::optional< Customizations_type > Customizations_optional;
    typedef ::xsd::cxx::tree::traits< Customizations_type, char > Customizations_traits;

    const Customizations_optional&
    Customizations () const;

    Customizations_optional&
    Customizations ();

    void
    Customizations (const Customizations_type& x);

    void
    Customizations (const Customizations_optional& x);

    void
    Customizations (::std::unique_ptr< Customizations_type > p);

    // version
    //
    typedef ::xml_schema::string version_type;
    typedef ::xsd::cxx::tree::optional< version_type > version_optional;
    typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

    const version_optional&
    version () const;

    version_optional&
    version ();

    void
    version (const version_type& x);

    void
    version (const version_optional& x);

    void
    version (::std::unique_ptr< version_type > p);

    // uri
    //
    typedef ::xml_schema::uri uri_type;
    typedef ::xsd::cxx::tree::optional< uri_type > uri_optional;
    typedef ::xsd::cxx::tree::traits< uri_type, char > uri_traits;

    const uri_optional&
    uri () const;

    uri_optional&
    uri ();

    void
    uri (const uri_type& x);

    void
    uri (const uri_optional& x);

    void
    uri (::std::unique_ptr< uri_type > p);

    // Constructors.
    //
    AnalysisSoftwareType ();

    AnalysisSoftwareType (const id_type&,
                          const SoftwareName_type&);

    AnalysisSoftwareType (const id_type&,
                          ::std::unique_ptr< SoftwareName_type >);

    AnalysisSoftwareType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    AnalysisSoftwareType (const AnalysisSoftwareType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual AnalysisSoftwareType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AnalysisSoftwareType&
    operator= (const AnalysisSoftwareType& x);

    virtual 
    ~AnalysisSoftwareType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ContactRole_optional ContactRole_;
    ::xsd::cxx::tree::one< SoftwareName_type > SoftwareName_;
    Customizations_optional Customizations_;
    version_optional version_;
    uri_optional uri_;
  };

  class EnzymeType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // SiteRegexp
    //
    typedef ::xml_schema::string SiteRegexp_type;
    typedef ::xsd::cxx::tree::optional< SiteRegexp_type > SiteRegexp_optional;
    typedef ::xsd::cxx::tree::traits< SiteRegexp_type, char > SiteRegexp_traits;

    const SiteRegexp_optional&
    SiteRegexp () const;

    SiteRegexp_optional&
    SiteRegexp ();

    void
    SiteRegexp (const SiteRegexp_type& x);

    void
    SiteRegexp (const SiteRegexp_optional& x);

    void
    SiteRegexp (::std::unique_ptr< SiteRegexp_type > p);

    // EnzymeName
    //
    typedef ::mzIdentML120::ParamListType EnzymeName_type;
    typedef ::xsd::cxx::tree::optional< EnzymeName_type > EnzymeName_optional;
    typedef ::xsd::cxx::tree::traits< EnzymeName_type, char > EnzymeName_traits;

    const EnzymeName_optional&
    EnzymeName () const;

    EnzymeName_optional&
    EnzymeName ();

    void
    EnzymeName (const EnzymeName_type& x);

    void
    EnzymeName (const EnzymeName_optional& x);

    void
    EnzymeName (::std::unique_ptr< EnzymeName_type > p);

    // nTermGain
    //
    typedef ::mzIdentML120::nTermGain nTermGain_type;
    typedef ::xsd::cxx::tree::optional< nTermGain_type > nTermGain_optional;
    typedef ::xsd::cxx::tree::traits< nTermGain_type, char > nTermGain_traits;

    const nTermGain_optional&
    nTermGain () const;

    nTermGain_optional&
    nTermGain ();

    void
    nTermGain (const nTermGain_type& x);

    void
    nTermGain (const nTermGain_optional& x);

    void
    nTermGain (::std::unique_ptr< nTermGain_type > p);

    // cTermGain
    //
    typedef ::mzIdentML120::cTermGain cTermGain_type;
    typedef ::xsd::cxx::tree::optional< cTermGain_type > cTermGain_optional;
    typedef ::xsd::cxx::tree::traits< cTermGain_type, char > cTermGain_traits;

    const cTermGain_optional&
    cTermGain () const;

    cTermGain_optional&
    cTermGain ();

    void
    cTermGain (const cTermGain_type& x);

    void
    cTermGain (const cTermGain_optional& x);

    void
    cTermGain (::std::unique_ptr< cTermGain_type > p);

    // semiSpecific
    //
    typedef ::xml_schema::boolean semiSpecific_type;
    typedef ::xsd::cxx::tree::optional< semiSpecific_type > semiSpecific_optional;
    typedef ::xsd::cxx::tree::traits< semiSpecific_type, char > semiSpecific_traits;

    const semiSpecific_optional&
    semiSpecific () const;

    semiSpecific_optional&
    semiSpecific ();

    void
    semiSpecific (const semiSpecific_type& x);

    void
    semiSpecific (const semiSpecific_optional& x);

    // missedCleavages
    //
    typedef ::xml_schema::int_ missedCleavages_type;
    typedef ::xsd::cxx::tree::optional< missedCleavages_type > missedCleavages_optional;
    typedef ::xsd::cxx::tree::traits< missedCleavages_type, char > missedCleavages_traits;

    const missedCleavages_optional&
    missedCleavages () const;

    missedCleavages_optional&
    missedCleavages ();

    void
    missedCleavages (const missedCleavages_type& x);

    void
    missedCleavages (const missedCleavages_optional& x);

    // minDistance
    //
    typedef ::mzIdentML120::minDistance minDistance_type;
    typedef ::xsd::cxx::tree::optional< minDistance_type > minDistance_optional;
    typedef ::xsd::cxx::tree::traits< minDistance_type, char > minDistance_traits;

    const minDistance_optional&
    minDistance () const;

    minDistance_optional&
    minDistance ();

    void
    minDistance (const minDistance_type& x);

    void
    minDistance (const minDistance_optional& x);

    void
    minDistance (::std::unique_ptr< minDistance_type > p);

    // Constructors.
    //
    EnzymeType ();

    EnzymeType (const id_type&);

    EnzymeType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    EnzymeType (const EnzymeType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual EnzymeType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    EnzymeType&
    operator= (const EnzymeType& x);

    virtual 
    ~EnzymeType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    SiteRegexp_optional SiteRegexp_;
    EnzymeName_optional EnzymeName_;
    nTermGain_optional nTermGain_;
    cTermGain_optional cTermGain_;
    semiSpecific_optional semiSpecific_;
    missedCleavages_optional missedCleavages_;
    minDistance_optional minDistance_;
  };

  class EnzymesType: public ::xml_schema::type
  {
    public:
    // Enzyme
    //
    typedef ::mzIdentML120::EnzymeType Enzyme_type;
    typedef ::xsd::cxx::tree::sequence< Enzyme_type > Enzyme_sequence;
    typedef Enzyme_sequence::iterator Enzyme_iterator;
    typedef Enzyme_sequence::const_iterator Enzyme_const_iterator;
    typedef ::xsd::cxx::tree::traits< Enzyme_type, char > Enzyme_traits;

    const Enzyme_sequence&
    Enzyme () const;

    Enzyme_sequence&
    Enzyme ();

    void
    Enzyme (const Enzyme_sequence& s);

    // independent
    //
    typedef ::xml_schema::boolean independent_type;
    typedef ::xsd::cxx::tree::optional< independent_type > independent_optional;
    typedef ::xsd::cxx::tree::traits< independent_type, char > independent_traits;

    const independent_optional&
    independent () const;

    independent_optional&
    independent ();

    void
    independent (const independent_type& x);

    void
    independent (const independent_optional& x);

    // Constructors.
    //
    EnzymesType ();

    EnzymesType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    EnzymesType (const EnzymesType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual EnzymesType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    EnzymesType&
    operator= (const EnzymesType& x);

    virtual 
    ~EnzymesType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Enzyme_sequence Enzyme_;
    independent_optional independent_;
  };

  class ResidueType: public ::xml_schema::type
  {
    public:
    // code
    //
    typedef ::mzIdentML120::chars code_type;
    typedef ::xsd::cxx::tree::traits< code_type, char > code_traits;

    const code_type&
    code () const;

    code_type&
    code ();

    void
    code (const code_type& x);

    void
    code (::std::unique_ptr< code_type > p);

    // mass
    //
    typedef ::xml_schema::float_ mass_type;
    typedef ::xsd::cxx::tree::traits< mass_type, char > mass_traits;

    const mass_type&
    mass () const;

    mass_type&
    mass ();

    void
    mass (const mass_type& x);

    // Constructors.
    //
    ResidueType ();

    ResidueType (const code_type&,
                 const mass_type&);

    ResidueType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    ResidueType (const ResidueType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual ResidueType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ResidueType&
    operator= (const ResidueType& x);

    virtual 
    ~ResidueType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< code_type > code_;
    ::xsd::cxx::tree::one< mass_type > mass_;
  };

  class AmbiguousResidueType: public ::xml_schema::type
  {
    public:
    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // userParam
    //
    typedef ::mzIdentML120::UserParamType userParam_type;
    typedef ::xsd::cxx::tree::sequence< userParam_type > userParam_sequence;
    typedef userParam_sequence::iterator userParam_iterator;
    typedef userParam_sequence::const_iterator userParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< userParam_type, char > userParam_traits;

    const userParam_sequence&
    userParam () const;

    userParam_sequence&
    userParam ();

    void
    userParam (const userParam_sequence& s);

    // code
    //
    typedef ::mzIdentML120::chars code_type;
    typedef ::xsd::cxx::tree::traits< code_type, char > code_traits;

    const code_type&
    code () const;

    code_type&
    code ();

    void
    code (const code_type& x);

    void
    code (::std::unique_ptr< code_type > p);

    // Constructors.
    //
    AmbiguousResidueType ();

    AmbiguousResidueType (const code_type&);

    AmbiguousResidueType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    AmbiguousResidueType (const AmbiguousResidueType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual AmbiguousResidueType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AmbiguousResidueType&
    operator= (const AmbiguousResidueType& x);

    virtual 
    ~AmbiguousResidueType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    cvParam_sequence cvParam_;
    userParam_sequence userParam_;
    ::xsd::cxx::tree::one< code_type > code_;
  };

  class MassTableType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // Residue
    //
    typedef ::mzIdentML120::ResidueType Residue_type;
    typedef ::xsd::cxx::tree::sequence< Residue_type > Residue_sequence;
    typedef Residue_sequence::iterator Residue_iterator;
    typedef Residue_sequence::const_iterator Residue_const_iterator;
    typedef ::xsd::cxx::tree::traits< Residue_type, char > Residue_traits;

    const Residue_sequence&
    Residue () const;

    Residue_sequence&
    Residue ();

    void
    Residue (const Residue_sequence& s);

    // AmbiguousResidue
    //
    typedef ::mzIdentML120::AmbiguousResidueType AmbiguousResidue_type;
    typedef ::xsd::cxx::tree::sequence< AmbiguousResidue_type > AmbiguousResidue_sequence;
    typedef AmbiguousResidue_sequence::iterator AmbiguousResidue_iterator;
    typedef AmbiguousResidue_sequence::const_iterator AmbiguousResidue_const_iterator;
    typedef ::xsd::cxx::tree::traits< AmbiguousResidue_type, char > AmbiguousResidue_traits;

    const AmbiguousResidue_sequence&
    AmbiguousResidue () const;

    AmbiguousResidue_sequence&
    AmbiguousResidue ();

    void
    AmbiguousResidue (const AmbiguousResidue_sequence& s);

    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // userParam
    //
    typedef ::mzIdentML120::UserParamType userParam_type;
    typedef ::xsd::cxx::tree::sequence< userParam_type > userParam_sequence;
    typedef userParam_sequence::iterator userParam_iterator;
    typedef userParam_sequence::const_iterator userParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< userParam_type, char > userParam_traits;

    const userParam_sequence&
    userParam () const;

    userParam_sequence&
    userParam ();

    void
    userParam (const userParam_sequence& s);

    // msLevel
    //
    typedef ::mzIdentML120::listOfIntegers msLevel_type;
    typedef ::xsd::cxx::tree::traits< msLevel_type, char > msLevel_traits;

    const msLevel_type&
    msLevel () const;

    msLevel_type&
    msLevel ();

    void
    msLevel (const msLevel_type& x);

    void
    msLevel (::std::unique_ptr< msLevel_type > p);

    // Constructors.
    //
    MassTableType ();

    MassTableType (const id_type&,
                   const msLevel_type&);

    MassTableType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    MassTableType (const MassTableType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual MassTableType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MassTableType&
    operator= (const MassTableType& x);

    virtual 
    ~MassTableType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Residue_sequence Residue_;
    AmbiguousResidue_sequence AmbiguousResidue_;
    cvParam_sequence cvParam_;
    userParam_sequence userParam_;
    ::xsd::cxx::tree::one< msLevel_type > msLevel_;
  };

  class PeptideEvidenceType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // userParam
    //
    typedef ::mzIdentML120::UserParamType userParam_type;
    typedef ::xsd::cxx::tree::sequence< userParam_type > userParam_sequence;
    typedef userParam_sequence::iterator userParam_iterator;
    typedef userParam_sequence::const_iterator userParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< userParam_type, char > userParam_traits;

    const userParam_sequence&
    userParam () const;

    userParam_sequence&
    userParam ();

    void
    userParam (const userParam_sequence& s);

    // dBSequence_ref
    //
    typedef ::xml_schema::string dBSequence_ref_type;
    typedef ::xsd::cxx::tree::traits< dBSequence_ref_type, char > dBSequence_ref_traits;

    const dBSequence_ref_type&
    dBSequence_ref () const;

    dBSequence_ref_type&
    dBSequence_ref ();

    void
    dBSequence_ref (const dBSequence_ref_type& x);

    void
    dBSequence_ref (::std::unique_ptr< dBSequence_ref_type > p);

    // peptide_ref
    //
    typedef ::xml_schema::string peptide_ref_type;
    typedef ::xsd::cxx::tree::traits< peptide_ref_type, char > peptide_ref_traits;

    const peptide_ref_type&
    peptide_ref () const;

    peptide_ref_type&
    peptide_ref ();

    void
    peptide_ref (const peptide_ref_type& x);

    void
    peptide_ref (::std::unique_ptr< peptide_ref_type > p);

    // start
    //
    typedef ::xml_schema::int_ start_type;
    typedef ::xsd::cxx::tree::optional< start_type > start_optional;
    typedef ::xsd::cxx::tree::traits< start_type, char > start_traits;

    const start_optional&
    start () const;

    start_optional&
    start ();

    void
    start (const start_type& x);

    void
    start (const start_optional& x);

    // end
    //
    typedef ::xml_schema::int_ end_type;
    typedef ::xsd::cxx::tree::optional< end_type > end_optional;
    typedef ::xsd::cxx::tree::traits< end_type, char > end_traits;

    const end_optional&
    end () const;

    end_optional&
    end ();

    void
    end (const end_type& x);

    void
    end (const end_optional& x);

    // pre
    //
    typedef ::mzIdentML120::pre pre_type;
    typedef ::xsd::cxx::tree::optional< pre_type > pre_optional;
    typedef ::xsd::cxx::tree::traits< pre_type, char > pre_traits;

    const pre_optional&
    pre () const;

    pre_optional&
    pre ();

    void
    pre (const pre_type& x);

    void
    pre (const pre_optional& x);

    void
    pre (::std::unique_ptr< pre_type > p);

    // post
    //
    typedef ::mzIdentML120::post post_type;
    typedef ::xsd::cxx::tree::optional< post_type > post_optional;
    typedef ::xsd::cxx::tree::traits< post_type, char > post_traits;

    const post_optional&
    post () const;

    post_optional&
    post ();

    void
    post (const post_type& x);

    void
    post (const post_optional& x);

    void
    post (::std::unique_ptr< post_type > p);

    // translationTable_ref
    //
    typedef ::xml_schema::string translationTable_ref_type;
    typedef ::xsd::cxx::tree::optional< translationTable_ref_type > translationTable_ref_optional;
    typedef ::xsd::cxx::tree::traits< translationTable_ref_type, char > translationTable_ref_traits;

    const translationTable_ref_optional&
    translationTable_ref () const;

    translationTable_ref_optional&
    translationTable_ref ();

    void
    translationTable_ref (const translationTable_ref_type& x);

    void
    translationTable_ref (const translationTable_ref_optional& x);

    void
    translationTable_ref (::std::unique_ptr< translationTable_ref_type > p);

    // frame
    //
    typedef ::mzIdentML120::allowed_frames frame_type;
    typedef ::xsd::cxx::tree::optional< frame_type > frame_optional;
    typedef ::xsd::cxx::tree::traits< frame_type, char > frame_traits;

    const frame_optional&
    frame () const;

    frame_optional&
    frame ();

    void
    frame (const frame_type& x);

    void
    frame (const frame_optional& x);

    void
    frame (::std::unique_ptr< frame_type > p);

    // isDecoy
    //
    typedef ::xml_schema::boolean isDecoy_type;
    typedef ::xsd::cxx::tree::traits< isDecoy_type, char > isDecoy_traits;

    const isDecoy_type&
    isDecoy () const;

    isDecoy_type&
    isDecoy ();

    void
    isDecoy (const isDecoy_type& x);

    static isDecoy_type
    isDecoy_default_value ();

    // Constructors.
    //
    PeptideEvidenceType ();

    PeptideEvidenceType (const id_type&,
                         const dBSequence_ref_type&,
                         const peptide_ref_type&);

    PeptideEvidenceType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    PeptideEvidenceType (const PeptideEvidenceType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual PeptideEvidenceType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PeptideEvidenceType&
    operator= (const PeptideEvidenceType& x);

    virtual 
    ~PeptideEvidenceType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    cvParam_sequence cvParam_;
    userParam_sequence userParam_;
    ::xsd::cxx::tree::one< dBSequence_ref_type > dBSequence_ref_;
    ::xsd::cxx::tree::one< peptide_ref_type > peptide_ref_;
    start_optional start_;
    end_optional end_;
    pre_optional pre_;
    post_optional post_;
    translationTable_ref_optional translationTable_ref_;
    frame_optional frame_;
    ::xsd::cxx::tree::one< isDecoy_type > isDecoy_;
  };

  class ToleranceType: public ::xml_schema::type
  {
    public:
    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // Constructors.
    //
    ToleranceType ();

    ToleranceType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    ToleranceType (const ToleranceType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual ToleranceType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ToleranceType&
    operator= (const ToleranceType& x);

    virtual 
    ~ToleranceType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    cvParam_sequence cvParam_;
  };

  class SpectrumIDFormatType: public ::xml_schema::type
  {
    public:
    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_type&
    cvParam () const;

    cvParam_type&
    cvParam ();

    void
    cvParam (const cvParam_type& x);

    void
    cvParam (::std::unique_ptr< cvParam_type > p);

    // Constructors.
    //
    SpectrumIDFormatType ();

    SpectrumIDFormatType (const cvParam_type&);

    SpectrumIDFormatType (::std::unique_ptr< cvParam_type >);

    SpectrumIDFormatType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    SpectrumIDFormatType (const SpectrumIDFormatType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual SpectrumIDFormatType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SpectrumIDFormatType&
    operator= (const SpectrumIDFormatType& x);

    virtual 
    ~SpectrumIDFormatType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< cvParam_type > cvParam_;
  };

  class DBSequenceType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // Seq
    //
    typedef ::mzIdentML120::sequence Seq_type;
    typedef ::xsd::cxx::tree::optional< Seq_type > Seq_optional;
    typedef ::xsd::cxx::tree::traits< Seq_type, char > Seq_traits;

    const Seq_optional&
    Seq () const;

    Seq_optional&
    Seq ();

    void
    Seq (const Seq_type& x);

    void
    Seq (const Seq_optional& x);

    void
    Seq (::std::unique_ptr< Seq_type > p);

    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // userParam
    //
    typedef ::mzIdentML120::UserParamType userParam_type;
    typedef ::xsd::cxx::tree::sequence< userParam_type > userParam_sequence;
    typedef userParam_sequence::iterator userParam_iterator;
    typedef userParam_sequence::const_iterator userParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< userParam_type, char > userParam_traits;

    const userParam_sequence&
    userParam () const;

    userParam_sequence&
    userParam ();

    void
    userParam (const userParam_sequence& s);

    // length
    //
    typedef ::xml_schema::int_ length_type;
    typedef ::xsd::cxx::tree::optional< length_type > length_optional;
    typedef ::xsd::cxx::tree::traits< length_type, char > length_traits;

    const length_optional&
    length () const;

    length_optional&
    length ();

    void
    length (const length_type& x);

    void
    length (const length_optional& x);

    // searchDatabase_ref
    //
    typedef ::xml_schema::string searchDatabase_ref_type;
    typedef ::xsd::cxx::tree::traits< searchDatabase_ref_type, char > searchDatabase_ref_traits;

    const searchDatabase_ref_type&
    searchDatabase_ref () const;

    searchDatabase_ref_type&
    searchDatabase_ref ();

    void
    searchDatabase_ref (const searchDatabase_ref_type& x);

    void
    searchDatabase_ref (::std::unique_ptr< searchDatabase_ref_type > p);

    // accession
    //
    typedef ::xml_schema::string accession_type;
    typedef ::xsd::cxx::tree::traits< accession_type, char > accession_traits;

    const accession_type&
    accession () const;

    accession_type&
    accession ();

    void
    accession (const accession_type& x);

    void
    accession (::std::unique_ptr< accession_type > p);

    // Constructors.
    //
    DBSequenceType ();

    DBSequenceType (const id_type&,
                    const searchDatabase_ref_type&,
                    const accession_type&);

    DBSequenceType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    DBSequenceType (const DBSequenceType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual DBSequenceType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DBSequenceType&
    operator= (const DBSequenceType& x);

    virtual 
    ~DBSequenceType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Seq_optional Seq_;
    cvParam_sequence cvParam_;
    userParam_sequence userParam_;
    length_optional length_;
    ::xsd::cxx::tree::one< searchDatabase_ref_type > searchDatabase_ref_;
    ::xsd::cxx::tree::one< accession_type > accession_;
  };

  class SampleType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // ContactRole
    //
    typedef ::mzIdentML120::ContactRoleType ContactRole_type;
    typedef ::xsd::cxx::tree::sequence< ContactRole_type > ContactRole_sequence;
    typedef ContactRole_sequence::iterator ContactRole_iterator;
    typedef ContactRole_sequence::const_iterator ContactRole_const_iterator;
    typedef ::xsd::cxx::tree::traits< ContactRole_type, char > ContactRole_traits;

    const ContactRole_sequence&
    ContactRole () const;

    ContactRole_sequence&
    ContactRole ();

    void
    ContactRole (const ContactRole_sequence& s);

    // SubSample
    //
    typedef ::mzIdentML120::SubSampleType SubSample_type;
    typedef ::xsd::cxx::tree::sequence< SubSample_type > SubSample_sequence;
    typedef SubSample_sequence::iterator SubSample_iterator;
    typedef SubSample_sequence::const_iterator SubSample_const_iterator;
    typedef ::xsd::cxx::tree::traits< SubSample_type, char > SubSample_traits;

    const SubSample_sequence&
    SubSample () const;

    SubSample_sequence&
    SubSample ();

    void
    SubSample (const SubSample_sequence& s);

    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // userParam
    //
    typedef ::mzIdentML120::UserParamType userParam_type;
    typedef ::xsd::cxx::tree::sequence< userParam_type > userParam_sequence;
    typedef userParam_sequence::iterator userParam_iterator;
    typedef userParam_sequence::const_iterator userParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< userParam_type, char > userParam_traits;

    const userParam_sequence&
    userParam () const;

    userParam_sequence&
    userParam ();

    void
    userParam (const userParam_sequence& s);

    // Constructors.
    //
    SampleType ();

    SampleType (const id_type&);

    SampleType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    SampleType (const SampleType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual SampleType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SampleType&
    operator= (const SampleType& x);

    virtual 
    ~SampleType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ContactRole_sequence ContactRole_;
    SubSample_sequence SubSample_;
    cvParam_sequence cvParam_;
    userParam_sequence userParam_;
  };

  class SubSampleType: public ::xml_schema::type
  {
    public:
    // sample_ref
    //
    typedef ::xml_schema::string sample_ref_type;
    typedef ::xsd::cxx::tree::traits< sample_ref_type, char > sample_ref_traits;

    const sample_ref_type&
    sample_ref () const;

    sample_ref_type&
    sample_ref ();

    void
    sample_ref (const sample_ref_type& x);

    void
    sample_ref (::std::unique_ptr< sample_ref_type > p);

    // Constructors.
    //
    SubSampleType ();

    SubSampleType (const sample_ref_type&);

    SubSampleType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    SubSampleType (const SubSampleType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual SubSampleType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SubSampleType&
    operator= (const SubSampleType& x);

    virtual 
    ~SubSampleType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< sample_ref_type > sample_ref_;
  };

  class listOfIntegers: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::xml_schema::integer, char >
  {
    public:
    listOfIntegers ();

    listOfIntegers (size_type n, const ::xml_schema::integer& x);

    template < typename I >
    listOfIntegers (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::xml_schema::integer, char > (begin, end, this)
    {
    }

    listOfIntegers (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    listOfIntegers (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    listOfIntegers (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    listOfIntegers (const listOfIntegers& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual listOfIntegers*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~listOfIntegers ();
  };

  class listOfFloats: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::xml_schema::float_, char >
  {
    public:
    listOfFloats ();

    listOfFloats (size_type n, const ::xml_schema::float_& x);

    template < typename I >
    listOfFloats (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::xml_schema::float_, char > (begin, end, this)
    {
    }

    listOfFloats (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    listOfFloats (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    listOfFloats (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    listOfFloats (const listOfFloats& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual listOfFloats*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~listOfFloats ();
  };

  class listOfChars: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::mzIdentML120::chars, char >
  {
    public:
    listOfChars ();

    listOfChars (size_type n, const ::mzIdentML120::chars& x);

    template < typename I >
    listOfChars (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::mzIdentML120::chars, char > (begin, end, this)
    {
    }

    listOfChars (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    listOfChars (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    listOfChars (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    listOfChars (const listOfChars& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual listOfChars*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~listOfChars ();
  };

  class listOfCharsOrAny: public ::xml_schema::string
  {
    public:

    listOfCharsOrAny ();

    listOfCharsOrAny (const char* v);

    listOfCharsOrAny (const ::std::string& v);

    listOfCharsOrAny (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    listOfCharsOrAny (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    listOfCharsOrAny (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    listOfCharsOrAny (const listOfCharsOrAny& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual listOfCharsOrAny*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;
  };

  class chars: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    chars ();

    chars (const char*);

    chars (const ::std::string&);

    chars (const ::xml_schema::string&);

    chars (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    chars (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    chars (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    chars (const chars& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual chars*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~chars ();
  };

  class sequence: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    sequence ();

    sequence (const char*);

    sequence (const ::std::string&);

    sequence (const ::xml_schema::string&);

    sequence (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    sequence (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    sequence (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    sequence (const sequence& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual sequence*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~sequence ();
  };

  class allowed_frames: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >
  {
    public:
    allowed_frames ();

    allowed_frames (::xml_schema::int_ v);

    allowed_frames (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    allowed_frames (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    allowed_frames (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    allowed_frames (const allowed_frames& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual allowed_frames*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;
  };

  class listOfAllowedFrames: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::mzIdentML120::allowed_frames, char >
  {
    public:
    listOfAllowedFrames ();

    listOfAllowedFrames (size_type n, const ::mzIdentML120::allowed_frames& x);

    template < typename I >
    listOfAllowedFrames (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::mzIdentML120::allowed_frames, char > (begin, end, this)
    {
    }

    listOfAllowedFrames (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    listOfAllowedFrames (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    listOfAllowedFrames (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    listOfAllowedFrames (const listOfAllowedFrames& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual listOfAllowedFrames*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~listOfAllowedFrames ();
  };

  class versionRegex: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    versionRegex ();

    versionRegex (const char*);

    versionRegex (const ::std::string&);

    versionRegex (const ::xml_schema::string&);

    versionRegex (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    versionRegex (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    versionRegex (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    versionRegex (const versionRegex& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual versionRegex*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~versionRegex ();
  };

  class FileFormatType: public ::xml_schema::type
  {
    public:
    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_type&
    cvParam () const;

    cvParam_type&
    cvParam ();

    void
    cvParam (const cvParam_type& x);

    void
    cvParam (::std::unique_ptr< cvParam_type > p);

    // Constructors.
    //
    FileFormatType ();

    FileFormatType (const cvParam_type&);

    FileFormatType (::std::unique_ptr< cvParam_type >);

    FileFormatType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    FileFormatType (const FileFormatType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual FileFormatType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FileFormatType&
    operator= (const FileFormatType& x);

    virtual 
    ~FileFormatType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< cvParam_type > cvParam_;
  };

  class AbstractContactType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // userParam
    //
    typedef ::mzIdentML120::UserParamType userParam_type;
    typedef ::xsd::cxx::tree::sequence< userParam_type > userParam_sequence;
    typedef userParam_sequence::iterator userParam_iterator;
    typedef userParam_sequence::const_iterator userParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< userParam_type, char > userParam_traits;

    const userParam_sequence&
    userParam () const;

    userParam_sequence&
    userParam ();

    void
    userParam (const userParam_sequence& s);

    // Constructors.
    //
    AbstractContactType ();

    AbstractContactType (const id_type&);

    AbstractContactType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    AbstractContactType (const AbstractContactType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual AbstractContactType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AbstractContactType&
    operator= (const AbstractContactType& x);

    virtual 
    ~AbstractContactType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    cvParam_sequence cvParam_;
    userParam_sequence userParam_;
  };

  class PersonType: public ::mzIdentML120::AbstractContactType
  {
    public:
    // Affiliation
    //
    typedef ::mzIdentML120::AffiliationType Affiliation_type;
    typedef ::xsd::cxx::tree::sequence< Affiliation_type > Affiliation_sequence;
    typedef Affiliation_sequence::iterator Affiliation_iterator;
    typedef Affiliation_sequence::const_iterator Affiliation_const_iterator;
    typedef ::xsd::cxx::tree::traits< Affiliation_type, char > Affiliation_traits;

    const Affiliation_sequence&
    Affiliation () const;

    Affiliation_sequence&
    Affiliation ();

    void
    Affiliation (const Affiliation_sequence& s);

    // lastName
    //
    typedef ::xml_schema::string lastName_type;
    typedef ::xsd::cxx::tree::optional< lastName_type > lastName_optional;
    typedef ::xsd::cxx::tree::traits< lastName_type, char > lastName_traits;

    const lastName_optional&
    lastName () const;

    lastName_optional&
    lastName ();

    void
    lastName (const lastName_type& x);

    void
    lastName (const lastName_optional& x);

    void
    lastName (::std::unique_ptr< lastName_type > p);

    // firstName
    //
    typedef ::xml_schema::string firstName_type;
    typedef ::xsd::cxx::tree::optional< firstName_type > firstName_optional;
    typedef ::xsd::cxx::tree::traits< firstName_type, char > firstName_traits;

    const firstName_optional&
    firstName () const;

    firstName_optional&
    firstName ();

    void
    firstName (const firstName_type& x);

    void
    firstName (const firstName_optional& x);

    void
    firstName (::std::unique_ptr< firstName_type > p);

    // midInitials
    //
    typedef ::xml_schema::string midInitials_type;
    typedef ::xsd::cxx::tree::optional< midInitials_type > midInitials_optional;
    typedef ::xsd::cxx::tree::traits< midInitials_type, char > midInitials_traits;

    const midInitials_optional&
    midInitials () const;

    midInitials_optional&
    midInitials ();

    void
    midInitials (const midInitials_type& x);

    void
    midInitials (const midInitials_optional& x);

    void
    midInitials (::std::unique_ptr< midInitials_type > p);

    // Constructors.
    //
    PersonType ();

    PersonType (const id_type&);

    PersonType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    PersonType (const PersonType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual PersonType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PersonType&
    operator= (const PersonType& x);

    virtual 
    ~PersonType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Affiliation_sequence Affiliation_;
    lastName_optional lastName_;
    firstName_optional firstName_;
    midInitials_optional midInitials_;
  };

  class AffiliationType: public ::xml_schema::type
  {
    public:
    // organization_ref
    //
    typedef ::xml_schema::string organization_ref_type;
    typedef ::xsd::cxx::tree::traits< organization_ref_type, char > organization_ref_traits;

    const organization_ref_type&
    organization_ref () const;

    organization_ref_type&
    organization_ref ();

    void
    organization_ref (const organization_ref_type& x);

    void
    organization_ref (::std::unique_ptr< organization_ref_type > p);

    // Constructors.
    //
    AffiliationType ();

    AffiliationType (const organization_ref_type&);

    AffiliationType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    AffiliationType (const AffiliationType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual AffiliationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AffiliationType&
    operator= (const AffiliationType& x);

    virtual 
    ~AffiliationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< organization_ref_type > organization_ref_;
  };

  class OrganizationType: public ::mzIdentML120::AbstractContactType
  {
    public:
    // Parent
    //
    typedef ::mzIdentML120::ParentOrganizationType Parent_type;
    typedef ::xsd::cxx::tree::optional< Parent_type > Parent_optional;
    typedef ::xsd::cxx::tree::traits< Parent_type, char > Parent_traits;

    const Parent_optional&
    Parent () const;

    Parent_optional&
    Parent ();

    void
    Parent (const Parent_type& x);

    void
    Parent (const Parent_optional& x);

    void
    Parent (::std::unique_ptr< Parent_type > p);

    // Constructors.
    //
    OrganizationType ();

    OrganizationType (const id_type&);

    OrganizationType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    OrganizationType (const OrganizationType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual OrganizationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganizationType&
    operator= (const OrganizationType& x);

    virtual 
    ~OrganizationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Parent_optional Parent_;
  };

  class ParentOrganizationType: public ::xml_schema::type
  {
    public:
    // organization_ref
    //
    typedef ::xml_schema::string organization_ref_type;
    typedef ::xsd::cxx::tree::traits< organization_ref_type, char > organization_ref_traits;

    const organization_ref_type&
    organization_ref () const;

    organization_ref_type&
    organization_ref ();

    void
    organization_ref (const organization_ref_type& x);

    void
    organization_ref (::std::unique_ptr< organization_ref_type > p);

    // Constructors.
    //
    ParentOrganizationType ();

    ParentOrganizationType (const organization_ref_type&);

    ParentOrganizationType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ParentOrganizationType (const ParentOrganizationType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual ParentOrganizationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ParentOrganizationType&
    operator= (const ParentOrganizationType& x);

    virtual 
    ~ParentOrganizationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< organization_ref_type > organization_ref_;
  };

  class ContactRoleType: public ::xml_schema::type
  {
    public:
    // Role
    //
    typedef ::mzIdentML120::RoleType Role_type;
    typedef ::xsd::cxx::tree::traits< Role_type, char > Role_traits;

    const Role_type&
    Role () const;

    Role_type&
    Role ();

    void
    Role (const Role_type& x);

    void
    Role (::std::unique_ptr< Role_type > p);

    // contact_ref
    //
    typedef ::xml_schema::string contact_ref_type;
    typedef ::xsd::cxx::tree::traits< contact_ref_type, char > contact_ref_traits;

    const contact_ref_type&
    contact_ref () const;

    contact_ref_type&
    contact_ref ();

    void
    contact_ref (const contact_ref_type& x);

    void
    contact_ref (::std::unique_ptr< contact_ref_type > p);

    // Constructors.
    //
    ContactRoleType ();

    ContactRoleType (const Role_type&,
                     const contact_ref_type&);

    ContactRoleType (::std::unique_ptr< Role_type >,
                     const contact_ref_type&);

    ContactRoleType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    ContactRoleType (const ContactRoleType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual ContactRoleType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ContactRoleType&
    operator= (const ContactRoleType& x);

    virtual 
    ~ContactRoleType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< Role_type > Role_;
    ::xsd::cxx::tree::one< contact_ref_type > contact_ref_;
  };

  class RoleType: public ::xml_schema::type
  {
    public:
    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_type&
    cvParam () const;

    cvParam_type&
    cvParam ();

    void
    cvParam (const cvParam_type& x);

    void
    cvParam (::std::unique_ptr< cvParam_type > p);

    // Constructors.
    //
    RoleType ();

    RoleType (const cvParam_type&);

    RoleType (::std::unique_ptr< cvParam_type >);

    RoleType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    RoleType (const RoleType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual RoleType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RoleType&
    operator= (const RoleType& x);

    virtual 
    ~RoleType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< cvParam_type > cvParam_;
  };

  class BibliographicReferenceType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // authors
    //
    typedef ::xml_schema::string authors_type;
    typedef ::xsd::cxx::tree::optional< authors_type > authors_optional;
    typedef ::xsd::cxx::tree::traits< authors_type, char > authors_traits;

    const authors_optional&
    authors () const;

    authors_optional&
    authors ();

    void
    authors (const authors_type& x);

    void
    authors (const authors_optional& x);

    void
    authors (::std::unique_ptr< authors_type > p);

    // publication
    //
    typedef ::xml_schema::string publication_type;
    typedef ::xsd::cxx::tree::optional< publication_type > publication_optional;
    typedef ::xsd::cxx::tree::traits< publication_type, char > publication_traits;

    const publication_optional&
    publication () const;

    publication_optional&
    publication ();

    void
    publication (const publication_type& x);

    void
    publication (const publication_optional& x);

    void
    publication (::std::unique_ptr< publication_type > p);

    // publisher
    //
    typedef ::xml_schema::string publisher_type;
    typedef ::xsd::cxx::tree::optional< publisher_type > publisher_optional;
    typedef ::xsd::cxx::tree::traits< publisher_type, char > publisher_traits;

    const publisher_optional&
    publisher () const;

    publisher_optional&
    publisher ();

    void
    publisher (const publisher_type& x);

    void
    publisher (const publisher_optional& x);

    void
    publisher (::std::unique_ptr< publisher_type > p);

    // editor
    //
    typedef ::xml_schema::string editor_type;
    typedef ::xsd::cxx::tree::optional< editor_type > editor_optional;
    typedef ::xsd::cxx::tree::traits< editor_type, char > editor_traits;

    const editor_optional&
    editor () const;

    editor_optional&
    editor ();

    void
    editor (const editor_type& x);

    void
    editor (const editor_optional& x);

    void
    editor (::std::unique_ptr< editor_type > p);

    // year
    //
    typedef ::xml_schema::int_ year_type;
    typedef ::xsd::cxx::tree::optional< year_type > year_optional;
    typedef ::xsd::cxx::tree::traits< year_type, char > year_traits;

    const year_optional&
    year () const;

    year_optional&
    year ();

    void
    year (const year_type& x);

    void
    year (const year_optional& x);

    // volume
    //
    typedef ::xml_schema::string volume_type;
    typedef ::xsd::cxx::tree::optional< volume_type > volume_optional;
    typedef ::xsd::cxx::tree::traits< volume_type, char > volume_traits;

    const volume_optional&
    volume () const;

    volume_optional&
    volume ();

    void
    volume (const volume_type& x);

    void
    volume (const volume_optional& x);

    void
    volume (::std::unique_ptr< volume_type > p);

    // issue
    //
    typedef ::xml_schema::string issue_type;
    typedef ::xsd::cxx::tree::optional< issue_type > issue_optional;
    typedef ::xsd::cxx::tree::traits< issue_type, char > issue_traits;

    const issue_optional&
    issue () const;

    issue_optional&
    issue ();

    void
    issue (const issue_type& x);

    void
    issue (const issue_optional& x);

    void
    issue (::std::unique_ptr< issue_type > p);

    // pages
    //
    typedef ::xml_schema::string pages_type;
    typedef ::xsd::cxx::tree::optional< pages_type > pages_optional;
    typedef ::xsd::cxx::tree::traits< pages_type, char > pages_traits;

    const pages_optional&
    pages () const;

    pages_optional&
    pages ();

    void
    pages (const pages_type& x);

    void
    pages (const pages_optional& x);

    void
    pages (::std::unique_ptr< pages_type > p);

    // title
    //
    typedef ::xml_schema::string title_type;
    typedef ::xsd::cxx::tree::optional< title_type > title_optional;
    typedef ::xsd::cxx::tree::traits< title_type, char > title_traits;

    const title_optional&
    title () const;

    title_optional&
    title ();

    void
    title (const title_type& x);

    void
    title (const title_optional& x);

    void
    title (::std::unique_ptr< title_type > p);

    // doi
    //
    typedef ::xml_schema::string doi_type;
    typedef ::xsd::cxx::tree::optional< doi_type > doi_optional;
    typedef ::xsd::cxx::tree::traits< doi_type, char > doi_traits;

    const doi_optional&
    doi () const;

    doi_optional&
    doi ();

    void
    doi (const doi_type& x);

    void
    doi (const doi_optional& x);

    void
    doi (::std::unique_ptr< doi_type > p);

    // Constructors.
    //
    BibliographicReferenceType ();

    BibliographicReferenceType (const id_type&);

    BibliographicReferenceType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    BibliographicReferenceType (const BibliographicReferenceType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual BibliographicReferenceType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    BibliographicReferenceType&
    operator= (const BibliographicReferenceType& x);

    virtual 
    ~BibliographicReferenceType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    authors_optional authors_;
    publication_optional publication_;
    publisher_optional publisher_;
    editor_optional editor_;
    year_optional year_;
    volume_optional volume_;
    issue_optional issue_;
    pages_optional pages_;
    title_optional title_;
    doi_optional doi_;
  };

  class AbstractParamType: public ::xml_schema::type
  {
    public:
    // name
    //
    typedef ::xml_schema::string name_type;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_type&
    name () const;

    name_type&
    name ();

    void
    name (const name_type& x);

    void
    name (::std::unique_ptr< name_type > p);

    // value
    //
    typedef ::xml_schema::string value_type;
    typedef ::xsd::cxx::tree::optional< value_type > value_optional;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_optional&
    value () const;

    value_optional&
    value ();

    void
    value (const value_type& x);

    void
    value (const value_optional& x);

    void
    value (::std::unique_ptr< value_type > p);

    // unitAccession
    //
    typedef ::xml_schema::string unitAccession_type;
    typedef ::xsd::cxx::tree::optional< unitAccession_type > unitAccession_optional;
    typedef ::xsd::cxx::tree::traits< unitAccession_type, char > unitAccession_traits;

    const unitAccession_optional&
    unitAccession () const;

    unitAccession_optional&
    unitAccession ();

    void
    unitAccession (const unitAccession_type& x);

    void
    unitAccession (const unitAccession_optional& x);

    void
    unitAccession (::std::unique_ptr< unitAccession_type > p);

    // unitName
    //
    typedef ::xml_schema::string unitName_type;
    typedef ::xsd::cxx::tree::optional< unitName_type > unitName_optional;
    typedef ::xsd::cxx::tree::traits< unitName_type, char > unitName_traits;

    const unitName_optional&
    unitName () const;

    unitName_optional&
    unitName ();

    void
    unitName (const unitName_type& x);

    void
    unitName (const unitName_optional& x);

    void
    unitName (::std::unique_ptr< unitName_type > p);

    // unitCvRef
    //
    typedef ::xml_schema::string unitCvRef_type;
    typedef ::xsd::cxx::tree::optional< unitCvRef_type > unitCvRef_optional;
    typedef ::xsd::cxx::tree::traits< unitCvRef_type, char > unitCvRef_traits;

    const unitCvRef_optional&
    unitCvRef () const;

    unitCvRef_optional&
    unitCvRef ();

    void
    unitCvRef (const unitCvRef_type& x);

    void
    unitCvRef (const unitCvRef_optional& x);

    void
    unitCvRef (::std::unique_ptr< unitCvRef_type > p);

    // Constructors.
    //
    AbstractParamType ();

    AbstractParamType (const name_type&);

    AbstractParamType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    AbstractParamType (const AbstractParamType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual AbstractParamType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AbstractParamType&
    operator= (const AbstractParamType& x);

    virtual 
    ~AbstractParamType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< name_type > name_;
    value_optional value_;
    unitAccession_optional unitAccession_;
    unitName_optional unitName_;
    unitCvRef_optional unitCvRef_;
  };

  class UserParamType: public ::mzIdentML120::AbstractParamType
  {
    public:
    // type
    //
    typedef ::xml_schema::string type_type;
    typedef ::xsd::cxx::tree::optional< type_type > type_optional;
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    const type_optional&
    type () const;

    type_optional&
    type ();

    void
    type (const type_type& x);

    void
    type (const type_optional& x);

    void
    type (::std::unique_ptr< type_type > p);

    // Constructors.
    //
    UserParamType ();

    UserParamType (const name_type&);

    UserParamType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    UserParamType (const UserParamType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual UserParamType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    UserParamType&
    operator= (const UserParamType& x);

    virtual 
    ~UserParamType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    type_optional type_;
  };

  class CVParamType: public ::mzIdentML120::AbstractParamType
  {
    public:
    // cvRef
    //
    typedef ::xml_schema::string cvRef_type;
    typedef ::xsd::cxx::tree::traits< cvRef_type, char > cvRef_traits;

    const cvRef_type&
    cvRef () const;

    cvRef_type&
    cvRef ();

    void
    cvRef (const cvRef_type& x);

    void
    cvRef (::std::unique_ptr< cvRef_type > p);

    // accession
    //
    typedef ::xml_schema::string accession_type;
    typedef ::xsd::cxx::tree::traits< accession_type, char > accession_traits;

    const accession_type&
    accession () const;

    accession_type&
    accession ();

    void
    accession (const accession_type& x);

    void
    accession (::std::unique_ptr< accession_type > p);

    // Constructors.
    //
    CVParamType ();

    CVParamType (const name_type&,
                 const cvRef_type&,
                 const accession_type&);

    CVParamType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    CVParamType (const CVParamType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual CVParamType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CVParamType&
    operator= (const CVParamType& x);

    virtual 
    ~CVParamType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< cvRef_type > cvRef_;
    ::xsd::cxx::tree::one< accession_type > accession_;
  };

  class cvType: public ::xml_schema::type
  {
    public:
    // fullName
    //
    typedef ::xml_schema::string fullName_type;
    typedef ::xsd::cxx::tree::traits< fullName_type, char > fullName_traits;

    const fullName_type&
    fullName () const;

    fullName_type&
    fullName ();

    void
    fullName (const fullName_type& x);

    void
    fullName (::std::unique_ptr< fullName_type > p);

    // version
    //
    typedef ::xml_schema::string version_type;
    typedef ::xsd::cxx::tree::optional< version_type > version_optional;
    typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

    const version_optional&
    version () const;

    version_optional&
    version ();

    void
    version (const version_type& x);

    void
    version (const version_optional& x);

    void
    version (::std::unique_ptr< version_type > p);

    // uri
    //
    typedef ::xml_schema::uri uri_type;
    typedef ::xsd::cxx::tree::traits< uri_type, char > uri_traits;

    const uri_type&
    uri () const;

    uri_type&
    uri ();

    void
    uri (const uri_type& x);

    void
    uri (::std::unique_ptr< uri_type > p);

    // id
    //
    typedef ::xml_schema::string id_type;
    typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

    const id_type&
    id () const;

    id_type&
    id ();

    void
    id (const id_type& x);

    void
    id (::std::unique_ptr< id_type > p);

    // Constructors.
    //
    cvType ();

    cvType (const fullName_type&,
            const uri_type&,
            const id_type&);

    cvType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    cvType (const cvType& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual cvType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    cvType&
    operator= (const cvType& x);

    virtual 
    ~cvType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< fullName_type > fullName_;
    version_optional version_;
    ::xsd::cxx::tree::one< uri_type > uri_;
    ::xsd::cxx::tree::one< id_type > id_;
  };

  class AuditCollectionType: public ::xml_schema::type
  {
    public:
    // Person
    //
    typedef ::mzIdentML120::PersonType Person_type;
    typedef ::xsd::cxx::tree::sequence< Person_type > Person_sequence;
    typedef Person_sequence::iterator Person_iterator;
    typedef Person_sequence::const_iterator Person_const_iterator;
    typedef ::xsd::cxx::tree::traits< Person_type, char > Person_traits;

    const Person_sequence&
    Person () const;

    Person_sequence&
    Person ();

    void
    Person (const Person_sequence& s);

    // Organization
    //
    typedef ::mzIdentML120::OrganizationType Organization_type;
    typedef ::xsd::cxx::tree::sequence< Organization_type > Organization_sequence;
    typedef Organization_sequence::iterator Organization_iterator;
    typedef Organization_sequence::const_iterator Organization_const_iterator;
    typedef ::xsd::cxx::tree::traits< Organization_type, char > Organization_traits;

    const Organization_sequence&
    Organization () const;

    Organization_sequence&
    Organization ();

    void
    Organization (const Organization_sequence& s);

    // Constructors.
    //
    AuditCollectionType ();

    AuditCollectionType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    AuditCollectionType (const AuditCollectionType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual AuditCollectionType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AuditCollectionType&
    operator= (const AuditCollectionType& x);

    virtual 
    ~AuditCollectionType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Person_sequence Person_;
    Organization_sequence Organization_;
  };

  class ProviderType: public ::mzIdentML120::IdentifiableType
  {
    public:
    // ContactRole
    //
    typedef ::mzIdentML120::ContactRoleType ContactRole_type;
    typedef ::xsd::cxx::tree::optional< ContactRole_type > ContactRole_optional;
    typedef ::xsd::cxx::tree::traits< ContactRole_type, char > ContactRole_traits;

    const ContactRole_optional&
    ContactRole () const;

    ContactRole_optional&
    ContactRole ();

    void
    ContactRole (const ContactRole_type& x);

    void
    ContactRole (const ContactRole_optional& x);

    void
    ContactRole (::std::unique_ptr< ContactRole_type > p);

    // analysisSoftware_ref
    //
    typedef ::xml_schema::string analysisSoftware_ref_type;
    typedef ::xsd::cxx::tree::optional< analysisSoftware_ref_type > analysisSoftware_ref_optional;
    typedef ::xsd::cxx::tree::traits< analysisSoftware_ref_type, char > analysisSoftware_ref_traits;

    const analysisSoftware_ref_optional&
    analysisSoftware_ref () const;

    analysisSoftware_ref_optional&
    analysisSoftware_ref ();

    void
    analysisSoftware_ref (const analysisSoftware_ref_type& x);

    void
    analysisSoftware_ref (const analysisSoftware_ref_optional& x);

    void
    analysisSoftware_ref (::std::unique_ptr< analysisSoftware_ref_type > p);

    // Constructors.
    //
    ProviderType ();

    ProviderType (const id_type&);

    ProviderType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    ProviderType (const ProviderType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual ProviderType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ProviderType&
    operator= (const ProviderType& x);

    virtual 
    ~ProviderType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ContactRole_optional ContactRole_;
    analysisSoftware_ref_optional analysisSoftware_ref_;
  };

  class ParamListType: public ::xml_schema::type
  {
    public:
    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
    typedef cvParam_sequence::iterator cvParam_iterator;
    typedef cvParam_sequence::const_iterator cvParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_sequence&
    cvParam () const;

    cvParam_sequence&
    cvParam ();

    void
    cvParam (const cvParam_sequence& s);

    // userParam
    //
    typedef ::mzIdentML120::UserParamType userParam_type;
    typedef ::xsd::cxx::tree::sequence< userParam_type > userParam_sequence;
    typedef userParam_sequence::iterator userParam_iterator;
    typedef userParam_sequence::const_iterator userParam_const_iterator;
    typedef ::xsd::cxx::tree::traits< userParam_type, char > userParam_traits;

    const userParam_sequence&
    userParam () const;

    userParam_sequence&
    userParam ();

    void
    userParam (const userParam_sequence& s);

    // Constructors.
    //
    ParamListType ();

    ParamListType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    ParamListType (const ParamListType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual ParamListType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ParamListType&
    operator= (const ParamListType& x);

    virtual 
    ~ParamListType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    cvParam_sequence cvParam_;
    userParam_sequence userParam_;
  };

  class ParamType: public ::xml_schema::type
  {
    public:
    // cvParam
    //
    typedef ::mzIdentML120::CVParamType cvParam_type;
    typedef ::xsd::cxx::tree::optional< cvParam_type > cvParam_optional;
    typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

    const cvParam_optional&
    cvParam () const;

    cvParam_optional&
    cvParam ();

    void
    cvParam (const cvParam_type& x);

    void
    cvParam (const cvParam_optional& x);

    void
    cvParam (::std::unique_ptr< cvParam_type > p);

    // userParam
    //
    typedef ::mzIdentML120::UserParamType userParam_type;
    typedef ::xsd::cxx::tree::optional< userParam_type > userParam_optional;
    typedef ::xsd::cxx::tree::traits< userParam_type, char > userParam_traits;

    const userParam_optional&
    userParam () const;

    userParam_optional&
    userParam ();

    void
    userParam (const userParam_type& x);

    void
    userParam (const userParam_optional& x);

    void
    userParam (::std::unique_ptr< userParam_type > p);

    // Constructors.
    //
    ParamType ();

    ParamType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    ParamType (const ParamType& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual ParamType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ParamType&
    operator= (const ParamType& x);

    virtual 
    ~ParamType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    cvParam_optional cvParam_;
    userParam_optional userParam_;
  };

  class originalResidue: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    originalResidue ();

    originalResidue (const char*);

    originalResidue (const ::std::string&);

    originalResidue (const ::xml_schema::string&);

    originalResidue (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    originalResidue (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    originalResidue (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    originalResidue (const originalResidue& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual originalResidue*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~originalResidue ();
  };

  class replacementResidue: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    replacementResidue ();

    replacementResidue (const char*);

    replacementResidue (const ::std::string&);

    replacementResidue (const ::xml_schema::string&);

    replacementResidue (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    replacementResidue (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    replacementResidue (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    replacementResidue (const replacementResidue& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual replacementResidue*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~replacementResidue ();
  };

  class nTermGain: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    nTermGain ();

    nTermGain (const char*);

    nTermGain (const ::std::string&);

    nTermGain (const ::xml_schema::string&);

    nTermGain (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    nTermGain (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    nTermGain (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    nTermGain (const nTermGain& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual nTermGain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~nTermGain ();
  };

  class cTermGain: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    cTermGain ();

    cTermGain (const char*);

    cTermGain (const ::std::string&);

    cTermGain (const ::xml_schema::string&);

    cTermGain (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    cTermGain (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    cTermGain (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    cTermGain (const cTermGain& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual cTermGain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~cTermGain ();
  };

  class minDistance: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >
  {
    public:
    // Constructors.
    //
    minDistance ();

    minDistance (const ::xml_schema::int_&);

    minDistance (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    minDistance (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    minDistance (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    minDistance (const minDistance& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual minDistance*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~minDistance ();
  };

  class pre: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    pre ();

    pre (const char*);

    pre (const ::std::string&);

    pre (const ::xml_schema::string&);

    pre (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

    pre (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

    pre (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

    pre (const pre& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

    virtual pre*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~pre ();
  };

  class post: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    post ();

    post (const char*);

    post (const ::std::string&);

    post (const ::xml_schema::string&);

    post (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    post (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    post (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    post (const post& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual post*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~post ();
  };

  class listOfCharsOrAny_member: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::mzIdentML120::chars, char >
  {
    public:
    listOfCharsOrAny_member ();

    listOfCharsOrAny_member (size_type n, const ::mzIdentML120::chars& x);

    template < typename I >
    listOfCharsOrAny_member (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::mzIdentML120::chars, char > (begin, end, this)
    {
    }

    listOfCharsOrAny_member (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    listOfCharsOrAny_member (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    listOfCharsOrAny_member (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    listOfCharsOrAny_member (const listOfCharsOrAny_member& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual listOfCharsOrAny_member*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~listOfCharsOrAny_member ();
  };

  class listOfCharsOrAny_member1: public ::xml_schema::string
  {
    public:
    enum value
    {
      cxx_
    };

    listOfCharsOrAny_member1 ();

    listOfCharsOrAny_member1 (value v);

    listOfCharsOrAny_member1 (const char* v);

    listOfCharsOrAny_member1 (const ::std::string& v);

    listOfCharsOrAny_member1 (const ::xml_schema::string& v);

    listOfCharsOrAny_member1 (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    listOfCharsOrAny_member1 (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    listOfCharsOrAny_member1 (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    listOfCharsOrAny_member1 (const listOfCharsOrAny_member1& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual listOfCharsOrAny_member1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    listOfCharsOrAny_member1&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_listOfCharsOrAny_member1_convert ();
    }

    protected:
    value
    _xsd_listOfCharsOrAny_member1_convert () const;

    public:
    static const char* const _xsd_listOfCharsOrAny_member1_literals_[1];
    static const value _xsd_listOfCharsOrAny_member1_indexes_[1];
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace mzIdentML120
{
  // Parse a URI or a local file.
  //

  ::std::unique_ptr< ::mzIdentML120::MzIdentMLType >
  MzIdentML (const ::std::string& uri,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::mzIdentML120::MzIdentMLType >
  MzIdentML (const ::std::string& uri,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::mzIdentML120::MzIdentMLType >
  MzIdentML (const ::std::string& uri,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse std::istream.
  //

  ::std::unique_ptr< ::mzIdentML120::MzIdentMLType >
  MzIdentML (::std::istream& is,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::mzIdentML120::MzIdentMLType >
  MzIdentML (::std::istream& is,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::mzIdentML120::MzIdentMLType >
  MzIdentML (::std::istream& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::mzIdentML120::MzIdentMLType >
  MzIdentML (::std::istream& is,
             const ::std::string& id,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::mzIdentML120::MzIdentMLType >
  MzIdentML (::std::istream& is,
             const ::std::string& id,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::mzIdentML120::MzIdentMLType >
  MzIdentML (::std::istream& is,
             const ::std::string& id,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::InputSource.
  //

  ::std::unique_ptr< ::mzIdentML120::MzIdentMLType >
  MzIdentML (::xercesc::InputSource& is,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::mzIdentML120::MzIdentMLType >
  MzIdentML (::xercesc::InputSource& is,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::mzIdentML120::MzIdentMLType >
  MzIdentML (::xercesc::InputSource& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::unique_ptr< ::mzIdentML120::MzIdentMLType >
  MzIdentML (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::mzIdentML120::MzIdentMLType >
  MzIdentML (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace mzIdentML120
{
  // Serialize to std::ostream.
  //

  void
  MzIdentML (::std::ostream& os,
             const ::mzIdentML120::MzIdentMLType& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

  void
  MzIdentML (::std::ostream& os,
             const ::mzIdentML120::MzIdentMLType& x, 
             ::xml_schema::error_handler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

  void
  MzIdentML (::std::ostream& os,
             const ::mzIdentML120::MzIdentMLType& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  MzIdentML (::xercesc::XMLFormatTarget& ft,
             const ::mzIdentML120::MzIdentMLType& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

  void
  MzIdentML (::xercesc::XMLFormatTarget& ft,
             const ::mzIdentML120::MzIdentMLType& x, 
             ::xml_schema::error_handler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

  void
  MzIdentML (::xercesc::XMLFormatTarget& ft,
             const ::mzIdentML120::MzIdentMLType& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  MzIdentML (::xercesc::DOMDocument& d,
             const ::mzIdentML120::MzIdentMLType& x,
             ::xml_schema::flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  MzIdentML (const ::mzIdentML120::MzIdentMLType& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             ::xml_schema::flags f = 0);

  void
  operator<< (::xercesc::DOMElement&, const CVListType&);

  void
  operator<< (::xercesc::DOMElement&, const AnalysisSoftwareListType&);

  void
  operator<< (::xercesc::DOMElement&, const AnalysisSampleCollectionType&);

  void
  operator<< (::xercesc::DOMElement&, const SequenceCollectionType&);

  void
  operator<< (::xercesc::DOMElement&, const AnalysisCollectionType&);

  void
  operator<< (::xercesc::DOMElement&, const AnalysisProtocolCollectionType&);

  void
  operator<< (::xercesc::DOMElement&, const InputsType&);

  void
  operator<< (::xercesc::DOMElement&, const AnalysisDataType&);

  void
  operator<< (::xercesc::DOMElement&, const DataCollectionType&);

  void
  operator<< (::xercesc::DOMElement&, const IdentifiableType&);

  void
  operator<< (::xercesc::DOMElement&, const MzIdentMLType&);

  void
  operator<< (::xercesc::DOMElement&, const ExternalDataType&);

  void
  operator<< (::xercesc::DOMElement&, const SearchDatabaseType&);

  void
  operator<< (::xercesc::DOMElement&, const SourceFileType&);

  void
  operator<< (::xercesc::DOMElement&, const ModificationParamsType&);

  void
  operator<< (::xercesc::DOMElement&, const FilterType&);

  void
  operator<< (::xercesc::DOMElement&, const DatabaseFiltersType&);

  void
  operator<< (::xercesc::DOMElement&, const TranslationTableType&);

  void
  operator<< (::xercesc::DOMElement&, const DatabaseTranslationType&);

  void
  operator<< (::xercesc::DOMElement&, const SpectrumIdentificationProtocolType&);

  void
  operator<< (::xercesc::DOMElement&, const InputSpectraType&);

  void
  operator<< (::xercesc::DOMElement&, const SearchDatabaseRefType&);

  void
  operator<< (::xercesc::DOMElement&, const ProtocolApplicationType&);

  void
  operator<< (::xercesc::DOMElement&, const SpectrumIdentificationType&);

  void
  operator<< (::xercesc::DOMElement&, const MeasureType&);

  void
  operator<< (::xercesc::DOMElement&, const FragmentationTableType&);

  void
  operator<< (::xercesc::DOMElement&, const SpectrumIdentificationListType&);

  void
  operator<< (::xercesc::DOMElement&, const SpecificityRulesType&);

  void
  operator<< (::xercesc::DOMElement&, const SearchModificationType&);

  void
  operator<< (::xercesc::DOMElement&, const FragmentArrayType&);

  void
  operator<< (::xercesc::DOMElement&, const IonTypeType&);

  void
  operator<< (::xercesc::DOMElement&, const FragmentationType&);

  void
  operator<< (::xercesc::DOMElement&, const PeptideEvidenceRefType&);

  void
  operator<< (::xercesc::DOMElement&, const SpectrumIdentificationItemType&);

  void
  operator<< (::xercesc::DOMElement&, const SpectrumIdentificationResultType&);

  void
  operator<< (::xercesc::DOMElement&, const InputSpectrumIdentificationsType&);

  void
  operator<< (::xercesc::DOMElement&, const ProteinDetectionType&);

  void
  operator<< (::xercesc::DOMElement&, const ProteinDetectionProtocolType&);

  void
  operator<< (::xercesc::DOMElement&, const ProteinDetectionListType&);

  void
  operator<< (::xercesc::DOMElement&, const SpectrumIdentificationItemRefType&);

  void
  operator<< (::xercesc::DOMElement&, const PeptideHypothesisType&);

  void
  operator<< (::xercesc::DOMElement&, const ProteinDetectionHypothesisType&);

  void
  operator<< (::xercesc::DOMElement&, const ProteinAmbiguityGroupType&);

  void
  operator<< (::xercesc::DOMElement&, const ModificationType&);

  void
  operator<< (::xercesc::DOMElement&, const PeptideType&);

  void
  operator<< (::xercesc::DOMElement&, const SubstitutionModificationType&);

  void
  operator<< (::xercesc::DOMElement&, const SpectraDataType&);

  void
  operator<< (::xercesc::DOMElement&, const AnalysisSoftwareType&);

  void
  operator<< (::xercesc::DOMElement&, const EnzymeType&);

  void
  operator<< (::xercesc::DOMElement&, const EnzymesType&);

  void
  operator<< (::xercesc::DOMElement&, const ResidueType&);

  void
  operator<< (::xercesc::DOMElement&, const AmbiguousResidueType&);

  void
  operator<< (::xercesc::DOMElement&, const MassTableType&);

  void
  operator<< (::xercesc::DOMElement&, const PeptideEvidenceType&);

  void
  operator<< (::xercesc::DOMElement&, const ToleranceType&);

  void
  operator<< (::xercesc::DOMElement&, const SpectrumIDFormatType&);

  void
  operator<< (::xercesc::DOMElement&, const DBSequenceType&);

  void
  operator<< (::xercesc::DOMElement&, const SampleType&);

  void
  operator<< (::xercesc::DOMElement&, const SubSampleType&);

  void
  operator<< (::xercesc::DOMElement&, const listOfIntegers&);

  void
  operator<< (::xercesc::DOMAttr&, const listOfIntegers&);

  void
  operator<< (::xml_schema::list_stream&,
              const listOfIntegers&);

  void
  operator<< (::xercesc::DOMElement&, const listOfFloats&);

  void
  operator<< (::xercesc::DOMAttr&, const listOfFloats&);

  void
  operator<< (::xml_schema::list_stream&,
              const listOfFloats&);

  void
  operator<< (::xercesc::DOMElement&, const listOfChars&);

  void
  operator<< (::xercesc::DOMAttr&, const listOfChars&);

  void
  operator<< (::xml_schema::list_stream&,
              const listOfChars&);

  void
  operator<< (::xercesc::DOMElement&, const listOfCharsOrAny&);

  void
  operator<< (::xercesc::DOMAttr&, const listOfCharsOrAny&);

  void
  operator<< (::xml_schema::list_stream&,
              const listOfCharsOrAny&);

  void
  operator<< (::xercesc::DOMElement&, const chars&);

  void
  operator<< (::xercesc::DOMAttr&, const chars&);

  void
  operator<< (::xml_schema::list_stream&,
              const chars&);

  void
  operator<< (::xercesc::DOMElement&, const sequence&);

  void
  operator<< (::xercesc::DOMAttr&, const sequence&);

  void
  operator<< (::xml_schema::list_stream&,
              const sequence&);

  void
  operator<< (::xercesc::DOMElement&, const allowed_frames&);

  void
  operator<< (::xercesc::DOMAttr&, const allowed_frames&);

  void
  operator<< (::xml_schema::list_stream&,
              const allowed_frames&);

  void
  operator<< (::xercesc::DOMElement&, const listOfAllowedFrames&);

  void
  operator<< (::xercesc::DOMAttr&, const listOfAllowedFrames&);

  void
  operator<< (::xml_schema::list_stream&,
              const listOfAllowedFrames&);

  void
  operator<< (::xercesc::DOMElement&, const versionRegex&);

  void
  operator<< (::xercesc::DOMAttr&, const versionRegex&);

  void
  operator<< (::xml_schema::list_stream&,
              const versionRegex&);

  void
  operator<< (::xercesc::DOMElement&, const FileFormatType&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractContactType&);

  void
  operator<< (::xercesc::DOMElement&, const PersonType&);

  void
  operator<< (::xercesc::DOMElement&, const AffiliationType&);

  void
  operator<< (::xercesc::DOMElement&, const OrganizationType&);

  void
  operator<< (::xercesc::DOMElement&, const ParentOrganizationType&);

  void
  operator<< (::xercesc::DOMElement&, const ContactRoleType&);

  void
  operator<< (::xercesc::DOMElement&, const RoleType&);

  void
  operator<< (::xercesc::DOMElement&, const BibliographicReferenceType&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractParamType&);

  void
  operator<< (::xercesc::DOMElement&, const UserParamType&);

  void
  operator<< (::xercesc::DOMElement&, const CVParamType&);

  void
  operator<< (::xercesc::DOMElement&, const cvType&);

  void
  operator<< (::xercesc::DOMElement&, const AuditCollectionType&);

  void
  operator<< (::xercesc::DOMElement&, const ProviderType&);

  void
  operator<< (::xercesc::DOMElement&, const ParamListType&);

  void
  operator<< (::xercesc::DOMElement&, const ParamType&);

  void
  operator<< (::xercesc::DOMElement&, const originalResidue&);

  void
  operator<< (::xercesc::DOMAttr&, const originalResidue&);

  void
  operator<< (::xml_schema::list_stream&,
              const originalResidue&);

  void
  operator<< (::xercesc::DOMElement&, const replacementResidue&);

  void
  operator<< (::xercesc::DOMAttr&, const replacementResidue&);

  void
  operator<< (::xml_schema::list_stream&,
              const replacementResidue&);

  void
  operator<< (::xercesc::DOMElement&, const nTermGain&);

  void
  operator<< (::xercesc::DOMAttr&, const nTermGain&);

  void
  operator<< (::xml_schema::list_stream&,
              const nTermGain&);

  void
  operator<< (::xercesc::DOMElement&, const cTermGain&);

  void
  operator<< (::xercesc::DOMAttr&, const cTermGain&);

  void
  operator<< (::xml_schema::list_stream&,
              const cTermGain&);

  void
  operator<< (::xercesc::DOMElement&, const minDistance&);

  void
  operator<< (::xercesc::DOMAttr&, const minDistance&);

  void
  operator<< (::xml_schema::list_stream&,
              const minDistance&);

  void
  operator<< (::xercesc::DOMElement&, const pre&);

  void
  operator<< (::xercesc::DOMAttr&, const pre&);

  void
  operator<< (::xml_schema::list_stream&,
              const pre&);

  void
  operator<< (::xercesc::DOMElement&, const post&);

  void
  operator<< (::xercesc::DOMAttr&, const post&);

  void
  operator<< (::xml_schema::list_stream&,
              const post&);

  void
  operator<< (::xercesc::DOMElement&, const listOfCharsOrAny_member&);

  void
  operator<< (::xercesc::DOMAttr&, const listOfCharsOrAny_member&);

  void
  operator<< (::xml_schema::list_stream&,
              const listOfCharsOrAny_member&);

  void
  operator<< (::xercesc::DOMElement&, const listOfCharsOrAny_member1&);

  void
  operator<< (::xercesc::DOMAttr&, const listOfCharsOrAny_member1&);

  void
  operator<< (::xml_schema::list_stream&,
              const listOfCharsOrAny_member1&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // MZ_IDENT_ML120_H
