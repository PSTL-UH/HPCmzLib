// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "PSI-MOD.obo.h"

// def
// 

const def::defstr_optional& def::
defstr () const
{
  return this->defstr_;
}

def::defstr_optional& def::
defstr ()
{
  return this->defstr_;
}

void def::
defstr (const defstr_type& x)
{
  this->defstr_.set (x);
}

void def::
defstr (const defstr_optional& x)
{
  this->defstr_ = x;
}

void def::
defstr (::std::unique_ptr< defstr_type > x)
{
  this->defstr_.set (std::move (x));
}

const def::dbxref_sequence& def::
dbxref () const
{
  return this->dbxref_;
}

def::dbxref_sequence& def::
dbxref ()
{
  return this->dbxref_;
}

void def::
dbxref (const dbxref_sequence& s)
{
  this->dbxref_ = s;
}


// obo
// 

const obo::def_sequence& obo::
def () const
{
  return this->def_;
}

obo::def_sequence& obo::
def ()
{
  return this->def_;
}

void obo::
def (const def_sequence& s)
{
  this->def_ = s;
}

const obo::source_sequence& obo::
source () const
{
  return this->source_;
}

obo::source_sequence& obo::
source ()
{
  return this->source_;
}

void obo::
source (const source_sequence& s)
{
  this->source_ = s;
}

const obo::header_sequence& obo::
header () const
{
  return this->header_;
}

obo::header_sequence& obo::
header ()
{
  return this->header_;
}

void obo::
header (const header_sequence& s)
{
  this->header_ = s;
}

const obo::term_sequence& obo::
term () const
{
  return this->term_;
}

obo::term_sequence& obo::
term ()
{
  return this->term_;
}

void obo::
term (const term_sequence& s)
{
  this->term_ = s;
}

const obo::typedef_sequence& obo::
typedef_ () const
{
  return this->typedef__;
}

obo::typedef_sequence& obo::
typedef_ ()
{
  return this->typedef__;
}

void obo::
typedef_ (const typedef_sequence& s)
{
  this->typedef__ = s;
}


// dbxref
// 

const dbxref::acc_optional& dbxref::
acc () const
{
  return this->acc_;
}

dbxref::acc_optional& dbxref::
acc ()
{
  return this->acc_;
}

void dbxref::
acc (const acc_type& x)
{
  this->acc_.set (x);
}

void dbxref::
acc (const acc_optional& x)
{
  this->acc_ = x;
}

void dbxref::
acc (::std::unique_ptr< acc_type > x)
{
  this->acc_.set (std::move (x));
}

const dbxref::dbname_optional& dbxref::
dbname () const
{
  return this->dbname_;
}

dbxref::dbname_optional& dbxref::
dbname ()
{
  return this->dbname_;
}

void dbxref::
dbname (const dbname_type& x)
{
  this->dbname_.set (x);
}

void dbxref::
dbname (const dbname_optional& x)
{
  this->dbname_ = x;
}

void dbxref::
dbname (::std::unique_ptr< dbname_type > x)
{
  this->dbname_.set (std::move (x));
}


// source
// 

const source::source_type_optional& source::
source_type () const
{
  return this->source_type_;
}

source::source_type_optional& source::
source_type ()
{
  return this->source_type_;
}

void source::
source_type (const source_type_type& x)
{
  this->source_type_.set (x);
}

void source::
source_type (const source_type_optional& x)
{
  this->source_type_ = x;
}

void source::
source_type (::std::unique_ptr< source_type_type > x)
{
  this->source_type_.set (std::move (x));
}

const source::source_path_optional& source::
source_path () const
{
  return this->source_path_;
}

source::source_path_optional& source::
source_path ()
{
  return this->source_path_;
}

void source::
source_path (const source_path_type& x)
{
  this->source_path_.set (x);
}

void source::
source_path (const source_path_optional& x)
{
  this->source_path_ = x;
}

void source::
source_path (::std::unique_ptr< source_path_type > x)
{
  this->source_path_.set (std::move (x));
}


// header
// 

const header::format_version_optional& header::
format_version () const
{
  return this->format_version_;
}

header::format_version_optional& header::
format_version ()
{
  return this->format_version_;
}

void header::
format_version (const format_version_type& x)
{
  this->format_version_.set (x);
}

void header::
format_version (const format_version_optional& x)
{
  this->format_version_ = x;
}

void header::
format_version (::std::unique_ptr< format_version_type > x)
{
  this->format_version_.set (std::move (x));
}

const header::date_optional& header::
date () const
{
  return this->date_;
}

header::date_optional& header::
date ()
{
  return this->date_;
}

void header::
date (const date_type& x)
{
  this->date_.set (x);
}

void header::
date (const date_optional& x)
{
  this->date_ = x;
}

void header::
date (::std::unique_ptr< date_type > x)
{
  this->date_.set (std::move (x));
}

const header::saved_by_optional& header::
saved_by () const
{
  return this->saved_by_;
}

header::saved_by_optional& header::
saved_by ()
{
  return this->saved_by_;
}

void header::
saved_by (const saved_by_type& x)
{
  this->saved_by_.set (x);
}

void header::
saved_by (const saved_by_optional& x)
{
  this->saved_by_ = x;
}

void header::
saved_by (::std::unique_ptr< saved_by_type > x)
{
  this->saved_by_.set (std::move (x));
}

const header::auto_generated_by_optional& header::
auto_generated_by () const
{
  return this->auto_generated_by_;
}

header::auto_generated_by_optional& header::
auto_generated_by ()
{
  return this->auto_generated_by_;
}

void header::
auto_generated_by (const auto_generated_by_type& x)
{
  this->auto_generated_by_.set (x);
}

void header::
auto_generated_by (const auto_generated_by_optional& x)
{
  this->auto_generated_by_ = x;
}

void header::
auto_generated_by (::std::unique_ptr< auto_generated_by_type > x)
{
  this->auto_generated_by_.set (std::move (x));
}

const header::default_namespace_optional& header::
default_namespace () const
{
  return this->default_namespace_;
}

header::default_namespace_optional& header::
default_namespace ()
{
  return this->default_namespace_;
}

void header::
default_namespace (const default_namespace_type& x)
{
  this->default_namespace_.set (x);
}

void header::
default_namespace (const default_namespace_optional& x)
{
  this->default_namespace_ = x;
}

void header::
default_namespace (::std::unique_ptr< default_namespace_type > x)
{
  this->default_namespace_.set (std::move (x));
}

const header::subsetdef_sequence& header::
subsetdef () const
{
  return this->subsetdef_;
}

header::subsetdef_sequence& header::
subsetdef ()
{
  return this->subsetdef_;
}

void header::
subsetdef (const subsetdef_sequence& s)
{
  this->subsetdef_ = s;
}

const header::synonymtypedef_sequence& header::
synonymtypedef () const
{
  return this->synonymtypedef_;
}

header::synonymtypedef_sequence& header::
synonymtypedef ()
{
  return this->synonymtypedef_;
}

void header::
synonymtypedef (const synonymtypedef_sequence& s)
{
  this->synonymtypedef_ = s;
}

const header::remark_sequence& header::
remark () const
{
  return this->remark_;
}

header::remark_sequence& header::
remark ()
{
  return this->remark_;
}

void header::
remark (const remark_sequence& s)
{
  this->remark_ = s;
}


// term
// 

const term::id_optional& term::
id () const
{
  return this->id_;
}

term::id_optional& term::
id ()
{
  return this->id_;
}

void term::
id (const id_type& x)
{
  this->id_.set (x);
}

void term::
id (const id_optional& x)
{
  this->id_ = x;
}

void term::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const term::name_optional& term::
name () const
{
  return this->name_;
}

term::name_optional& term::
name ()
{
  return this->name_;
}

void term::
name (const name_type& x)
{
  this->name_.set (x);
}

void term::
name (const name_optional& x)
{
  this->name_ = x;
}

void term::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const term::is_obsolete_optional& term::
is_obsolete () const
{
  return this->is_obsolete_;
}

term::is_obsolete_optional& term::
is_obsolete ()
{
  return this->is_obsolete_;
}

void term::
is_obsolete (const is_obsolete_type& x)
{
  this->is_obsolete_.set (x);
}

void term::
is_obsolete (const is_obsolete_optional& x)
{
  this->is_obsolete_ = x;
}

void term::
is_obsolete (::std::unique_ptr< is_obsolete_type > x)
{
  this->is_obsolete_.set (std::move (x));
}

const term::comment_optional& term::
comment () const
{
  return this->comment_;
}

term::comment_optional& term::
comment ()
{
  return this->comment_;
}

void term::
comment (const comment_type& x)
{
  this->comment_.set (x);
}

void term::
comment (const comment_optional& x)
{
  this->comment_ = x;
}

void term::
comment (::std::unique_ptr< comment_type > x)
{
  this->comment_.set (std::move (x));
}

const term::subset_optional& term::
subset () const
{
  return this->subset_;
}

term::subset_optional& term::
subset ()
{
  return this->subset_;
}

void term::
subset (const subset_type& x)
{
  this->subset_.set (x);
}

void term::
subset (const subset_optional& x)
{
  this->subset_ = x;
}

void term::
subset (::std::unique_ptr< subset_type > x)
{
  this->subset_.set (std::move (x));
}

const term::namespace_optional& term::
namespace_ () const
{
  return this->namespace__;
}

term::namespace_optional& term::
namespace_ ()
{
  return this->namespace__;
}

void term::
namespace_ (const namespace_type& x)
{
  this->namespace__.set (x);
}

void term::
namespace_ (const namespace_optional& x)
{
  this->namespace__ = x;
}

void term::
namespace_ (::std::unique_ptr< namespace_type > x)
{
  this->namespace__.set (std::move (x));
}

const term::is_root_optional& term::
is_root () const
{
  return this->is_root_;
}

term::is_root_optional& term::
is_root ()
{
  return this->is_root_;
}

void term::
is_root (const is_root_type& x)
{
  this->is_root_.set (x);
}

void term::
is_root (const is_root_optional& x)
{
  this->is_root_ = x;
}

void term::
is_root (::std::unique_ptr< is_root_type > x)
{
  this->is_root_.set (std::move (x));
}

const term::def_sequence& term::
def () const
{
  return this->def_;
}

term::def_sequence& term::
def ()
{
  return this->def_;
}

void term::
def (const def_sequence& s)
{
  this->def_ = s;
}

const term::synonym_sequence& term::
synonym () const
{
  return this->synonym_;
}

term::synonym_sequence& term::
synonym ()
{
  return this->synonym_;
}

void term::
synonym (const synonym_sequence& s)
{
  this->synonym_ = s;
}

const term::xref_analog_sequence& term::
xref_analog () const
{
  return this->xref_analog_;
}

term::xref_analog_sequence& term::
xref_analog ()
{
  return this->xref_analog_;
}

void term::
xref_analog (const xref_analog_sequence& s)
{
  this->xref_analog_ = s;
}

const term::is_a_sequence& term::
is_a () const
{
  return this->is_a_;
}

term::is_a_sequence& term::
is_a ()
{
  return this->is_a_;
}

void term::
is_a (const is_a_sequence& s)
{
  this->is_a_ = s;
}

const term::relationship_sequence& term::
relationship () const
{
  return this->relationship_;
}

term::relationship_sequence& term::
relationship ()
{
  return this->relationship_;
}

void term::
relationship (const relationship_sequence& s)
{
  this->relationship_ = s;
}


// typedef_
// 

const typedef_::id_optional& typedef_::
id () const
{
  return this->id_;
}

typedef_::id_optional& typedef_::
id ()
{
  return this->id_;
}

void typedef_::
id (const id_type& x)
{
  this->id_.set (x);
}

void typedef_::
id (const id_optional& x)
{
  this->id_ = x;
}

void typedef_::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const typedef_::name_optional& typedef_::
name () const
{
  return this->name_;
}

typedef_::name_optional& typedef_::
name ()
{
  return this->name_;
}

void typedef_::
name (const name_type& x)
{
  this->name_.set (x);
}

void typedef_::
name (const name_optional& x)
{
  this->name_ = x;
}

void typedef_::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const typedef_::comment_optional& typedef_::
comment () const
{
  return this->comment_;
}

typedef_::comment_optional& typedef_::
comment ()
{
  return this->comment_;
}

void typedef_::
comment (const comment_type& x)
{
  this->comment_.set (x);
}

void typedef_::
comment (const comment_optional& x)
{
  this->comment_ = x;
}

void typedef_::
comment (::std::unique_ptr< comment_type > x)
{
  this->comment_.set (std::move (x));
}

const typedef_::is_transitive_optional& typedef_::
is_transitive () const
{
  return this->is_transitive_;
}

typedef_::is_transitive_optional& typedef_::
is_transitive ()
{
  return this->is_transitive_;
}

void typedef_::
is_transitive (const is_transitive_type& x)
{
  this->is_transitive_.set (x);
}

void typedef_::
is_transitive (const is_transitive_optional& x)
{
  this->is_transitive_ = x;
}

void typedef_::
is_transitive (::std::unique_ptr< is_transitive_type > x)
{
  this->is_transitive_.set (std::move (x));
}

const typedef_::namespace_optional& typedef_::
namespace_ () const
{
  return this->namespace__;
}

typedef_::namespace_optional& typedef_::
namespace_ ()
{
  return this->namespace__;
}

void typedef_::
namespace_ (const namespace_type& x)
{
  this->namespace__.set (x);
}

void typedef_::
namespace_ (const namespace_optional& x)
{
  this->namespace__ = x;
}

void typedef_::
namespace_ (::std::unique_ptr< namespace_type > x)
{
  this->namespace__.set (std::move (x));
}

const typedef_::def_sequence& typedef_::
def () const
{
  return this->def_;
}

typedef_::def_sequence& typedef_::
def ()
{
  return this->def_;
}

void typedef_::
def (const def_sequence& s)
{
  this->def_ = s;
}


// subsetdef
// 

const subsetdef::id_optional& subsetdef::
id () const
{
  return this->id_;
}

subsetdef::id_optional& subsetdef::
id ()
{
  return this->id_;
}

void subsetdef::
id (const id_type& x)
{
  this->id_.set (x);
}

void subsetdef::
id (const id_optional& x)
{
  this->id_ = x;
}

void subsetdef::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const subsetdef::name_optional& subsetdef::
name () const
{
  return this->name_;
}

subsetdef::name_optional& subsetdef::
name ()
{
  return this->name_;
}

void subsetdef::
name (const name_type& x)
{
  this->name_.set (x);
}

void subsetdef::
name (const name_optional& x)
{
  this->name_ = x;
}

void subsetdef::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}


// synonymtypedef
// 

const synonymtypedef::name_optional& synonymtypedef::
name () const
{
  return this->name_;
}

synonymtypedef::name_optional& synonymtypedef::
name ()
{
  return this->name_;
}

void synonymtypedef::
name (const name_type& x)
{
  this->name_.set (x);
}

void synonymtypedef::
name (const name_optional& x)
{
  this->name_ = x;
}

void synonymtypedef::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const synonymtypedef::description_optional& synonymtypedef::
description () const
{
  return this->description_;
}

synonymtypedef::description_optional& synonymtypedef::
description ()
{
  return this->description_;
}

void synonymtypedef::
description (const description_type& x)
{
  this->description_.set (x);
}

void synonymtypedef::
description (const description_optional& x)
{
  this->description_ = x;
}

void synonymtypedef::
description (::std::unique_ptr< description_type > x)
{
  this->description_.set (std::move (x));
}

const synonymtypedef::defaultscope_optional& synonymtypedef::
defaultscope () const
{
  return this->defaultscope_;
}

synonymtypedef::defaultscope_optional& synonymtypedef::
defaultscope ()
{
  return this->defaultscope_;
}

void synonymtypedef::
defaultscope (const defaultscope_type& x)
{
  this->defaultscope_.set (x);
}

void synonymtypedef::
defaultscope (const defaultscope_optional& x)
{
  this->defaultscope_ = x;
}

void synonymtypedef::
defaultscope (::std::unique_ptr< defaultscope_type > x)
{
  this->defaultscope_.set (std::move (x));
}


// remark
// 


// synonym
// 

const synonym::synonym_text_optional& synonym::
synonym_text () const
{
  return this->synonym_text_;
}

synonym::synonym_text_optional& synonym::
synonym_text ()
{
  return this->synonym_text_;
}

void synonym::
synonym_text (const synonym_text_type& x)
{
  this->synonym_text_.set (x);
}

void synonym::
synonym_text (const synonym_text_optional& x)
{
  this->synonym_text_ = x;
}

void synonym::
synonym_text (::std::unique_ptr< synonym_text_type > x)
{
  this->synonym_text_.set (std::move (x));
}

const synonym::synonym_type_optional& synonym::
synonym_type () const
{
  return this->synonym_type_;
}

synonym::synonym_type_optional& synonym::
synonym_type ()
{
  return this->synonym_type_;
}

void synonym::
synonym_type (const synonym_type_type& x)
{
  this->synonym_type_.set (x);
}

void synonym::
synonym_type (const synonym_type_optional& x)
{
  this->synonym_type_ = x;
}

void synonym::
synonym_type (::std::unique_ptr< synonym_type_type > x)
{
  this->synonym_type_.set (std::move (x));
}

const synonym::scope_optional& synonym::
scope () const
{
  return this->scope_;
}

synonym::scope_optional& synonym::
scope ()
{
  return this->scope_;
}

void synonym::
scope (const scope_type& x)
{
  this->scope_.set (x);
}

void synonym::
scope (const scope_optional& x)
{
  this->scope_ = x;
}

void synonym::
scope (::std::unique_ptr< scope_type > x)
{
  this->scope_.set (std::move (x));
}


// xref_analog
// 

const xref_analog::acc_optional& xref_analog::
acc () const
{
  return this->acc_;
}

xref_analog::acc_optional& xref_analog::
acc ()
{
  return this->acc_;
}

void xref_analog::
acc (const acc_type& x)
{
  this->acc_.set (x);
}

void xref_analog::
acc (const acc_optional& x)
{
  this->acc_ = x;
}

void xref_analog::
acc (::std::unique_ptr< acc_type > x)
{
  this->acc_.set (std::move (x));
}

const xref_analog::dbname_optional& xref_analog::
dbname () const
{
  return this->dbname_;
}

xref_analog::dbname_optional& xref_analog::
dbname ()
{
  return this->dbname_;
}

void xref_analog::
dbname (const dbname_type& x)
{
  this->dbname_.set (x);
}

void xref_analog::
dbname (const dbname_optional& x)
{
  this->dbname_ = x;
}

void xref_analog::
dbname (::std::unique_ptr< dbname_type > x)
{
  this->dbname_.set (std::move (x));
}

const xref_analog::name_optional& xref_analog::
name () const
{
  return this->name_;
}

xref_analog::name_optional& xref_analog::
name ()
{
  return this->name_;
}

void xref_analog::
name (const name_type& x)
{
  this->name_.set (x);
}

void xref_analog::
name (const name_optional& x)
{
  this->name_ = x;
}

void xref_analog::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}


// is_a
// 


// relationship
// 

const relationship::type_optional& relationship::
type () const
{
  return this->type_;
}

relationship::type_optional& relationship::
type ()
{
  return this->type_;
}

void relationship::
type (const type_type& x)
{
  this->type_.set (x);
}

void relationship::
type (const type_optional& x)
{
  this->type_ = x;
}

void relationship::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const relationship::to_optional& relationship::
to () const
{
  return this->to_;
}

relationship::to_optional& relationship::
to ()
{
  return this->to_;
}

void relationship::
to (const to_type& x)
{
  this->to_.set (x);
}

void relationship::
to (const to_optional& x)
{
  this->to_ = x;
}

void relationship::
to (::std::unique_ptr< to_type > x)
{
  this->to_.set (std::move (x));
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// def
//

def::
def ()
: ::xml_schema::type (),
  defstr_ (this),
  dbxref_ (this)
{
}

def::
def (const def& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  defstr_ (x.defstr_, f, this),
  dbxref_ (x.dbxref_, f, this)
{
}

def::
def (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  defstr_ (this),
  dbxref_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void def::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // defstr
    //
    if (n.name () == "defstr" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< defstr_type > r (
        defstr_traits::create (i, f, this));

      if (!this->defstr_)
      {
        this->defstr_.set (::std::move (r));
        continue;
      }
    }

    // dbxref
    //
    if (n.name () == "dbxref" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dbxref_type > r (
        dbxref_traits::create (i, f, this));

      this->dbxref_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

def* def::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class def (*this, f, c);
}

def& def::
operator= (const def& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->defstr_ = x.defstr_;
    this->dbxref_ = x.dbxref_;
  }

  return *this;
}

def::
~def ()
{
}

// obo
//

obo::
obo ()
: ::xml_schema::type (),
  def_ (this),
  source_ (this),
  header_ (this),
  term_ (this),
  typedef__ (this)
{
}

obo::
obo (const obo& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  def_ (x.def_, f, this),
  source_ (x.source_, f, this),
  header_ (x.header_, f, this),
  term_ (x.term_, f, this),
  typedef__ (x.typedef__, f, this)
{
}

obo::
obo (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  def_ (this),
  source_ (this),
  header_ (this),
  term_ (this),
  typedef__ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void obo::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // def
    //
    if (n.name () == "def" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< def_type > r (
        def_traits::create (i, f, this));

      this->def_.push_back (::std::move (r));
      continue;
    }

    // source
    //
    if (n.name () == "source" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< source_type > r (
        source_traits::create (i, f, this));

      this->source_.push_back (::std::move (r));
      continue;
    }

    // header
    //
    if (n.name () == "header" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< header_type > r (
        header_traits::create (i, f, this));

      this->header_.push_back (::std::move (r));
      continue;
    }

    // term
    //
    if (n.name () == "term" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< term_type > r (
        term_traits::create (i, f, this));

      this->term_.push_back (::std::move (r));
      continue;
    }

    // typedef
    //
    if (n.name () == "typedef" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< typedef_type > r (
        typedef_traits::create (i, f, this));

      this->typedef__.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

obo* obo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class obo (*this, f, c);
}

obo& obo::
operator= (const obo& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->def_ = x.def_;
    this->source_ = x.source_;
    this->header_ = x.header_;
    this->term_ = x.term_;
    this->typedef__ = x.typedef__;
  }

  return *this;
}

obo::
~obo ()
{
}

// dbxref
//

dbxref::
dbxref ()
: ::xml_schema::type (),
  acc_ (this),
  dbname_ (this)
{
}

dbxref::
dbxref (const dbxref& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  acc_ (x.acc_, f, this),
  dbname_ (x.dbname_, f, this)
{
}

dbxref::
dbxref (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  acc_ (this),
  dbname_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void dbxref::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // acc
    //
    if (n.name () == "acc" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< acc_type > r (
        acc_traits::create (i, f, this));

      if (!this->acc_)
      {
        this->acc_.set (::std::move (r));
        continue;
      }
    }

    // dbname
    //
    if (n.name () == "dbname" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dbname_type > r (
        dbname_traits::create (i, f, this));

      if (!this->dbname_)
      {
        this->dbname_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

dbxref* dbxref::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class dbxref (*this, f, c);
}

dbxref& dbxref::
operator= (const dbxref& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->acc_ = x.acc_;
    this->dbname_ = x.dbname_;
  }

  return *this;
}

dbxref::
~dbxref ()
{
}

// source
//

source::
source ()
: ::xml_schema::type (),
  source_type_ (this),
  source_path_ (this)
{
}

source::
source (const source& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  source_type_ (x.source_type_, f, this),
  source_path_ (x.source_path_, f, this)
{
}

source::
source (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  source_type_ (this),
  source_path_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void source::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // source_type
    //
    if (n.name () == "source_type" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< source_type_type > r (
        source_type_traits::create (i, f, this));

      if (!this->source_type_)
      {
        this->source_type_.set (::std::move (r));
        continue;
      }
    }

    // source_path
    //
    if (n.name () == "source_path" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< source_path_type > r (
        source_path_traits::create (i, f, this));

      if (!this->source_path_)
      {
        this->source_path_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

source* source::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class source (*this, f, c);
}

source& source::
operator= (const source& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->source_type_ = x.source_type_;
    this->source_path_ = x.source_path_;
  }

  return *this;
}

source::
~source ()
{
}

// header
//

header::
header ()
: ::xml_schema::type (),
  format_version_ (this),
  date_ (this),
  saved_by_ (this),
  auto_generated_by_ (this),
  default_namespace_ (this),
  subsetdef_ (this),
  synonymtypedef_ (this),
  remark_ (this)
{
}

header::
header (const header& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  format_version_ (x.format_version_, f, this),
  date_ (x.date_, f, this),
  saved_by_ (x.saved_by_, f, this),
  auto_generated_by_ (x.auto_generated_by_, f, this),
  default_namespace_ (x.default_namespace_, f, this),
  subsetdef_ (x.subsetdef_, f, this),
  synonymtypedef_ (x.synonymtypedef_, f, this),
  remark_ (x.remark_, f, this)
{
}

header::
header (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  format_version_ (this),
  date_ (this),
  saved_by_ (this),
  auto_generated_by_ (this),
  default_namespace_ (this),
  subsetdef_ (this),
  synonymtypedef_ (this),
  remark_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void header::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // format-version
    //
    if (n.name () == "format-version" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< format_version_type > r (
        format_version_traits::create (i, f, this));

      if (!this->format_version_)
      {
        this->format_version_.set (::std::move (r));
        continue;
      }
    }

    // date
    //
    if (n.name () == "date" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< date_type > r (
        date_traits::create (i, f, this));

      if (!this->date_)
      {
        this->date_.set (::std::move (r));
        continue;
      }
    }

    // saved-by
    //
    if (n.name () == "saved-by" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< saved_by_type > r (
        saved_by_traits::create (i, f, this));

      if (!this->saved_by_)
      {
        this->saved_by_.set (::std::move (r));
        continue;
      }
    }

    // auto-generated-by
    //
    if (n.name () == "auto-generated-by" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< auto_generated_by_type > r (
        auto_generated_by_traits::create (i, f, this));

      if (!this->auto_generated_by_)
      {
        this->auto_generated_by_.set (::std::move (r));
        continue;
      }
    }

    // default-namespace
    //
    if (n.name () == "default-namespace" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< default_namespace_type > r (
        default_namespace_traits::create (i, f, this));

      if (!this->default_namespace_)
      {
        this->default_namespace_.set (::std::move (r));
        continue;
      }
    }

    // subsetdef
    //
    if (n.name () == "subsetdef" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< subsetdef_type > r (
        subsetdef_traits::create (i, f, this));

      this->subsetdef_.push_back (::std::move (r));
      continue;
    }

    // synonymtypedef
    //
    if (n.name () == "synonymtypedef" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< synonymtypedef_type > r (
        synonymtypedef_traits::create (i, f, this));

      this->synonymtypedef_.push_back (::std::move (r));
      continue;
    }

    // remark
    //
    if (n.name () == "remark" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< remark_type > r (
        remark_traits::create (i, f, this));

      this->remark_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

header* header::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class header (*this, f, c);
}

header& header::
operator= (const header& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->format_version_ = x.format_version_;
    this->date_ = x.date_;
    this->saved_by_ = x.saved_by_;
    this->auto_generated_by_ = x.auto_generated_by_;
    this->default_namespace_ = x.default_namespace_;
    this->subsetdef_ = x.subsetdef_;
    this->synonymtypedef_ = x.synonymtypedef_;
    this->remark_ = x.remark_;
  }

  return *this;
}

header::
~header ()
{
}

// term
//

term::
term ()
: ::xml_schema::type (),
  id_ (this),
  name_ (this),
  is_obsolete_ (this),
  comment_ (this),
  subset_ (this),
  namespace__ (this),
  is_root_ (this),
  def_ (this),
  synonym_ (this),
  xref_analog_ (this),
  is_a_ (this),
  relationship_ (this)
{
}

term::
term (const term& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  name_ (x.name_, f, this),
  is_obsolete_ (x.is_obsolete_, f, this),
  comment_ (x.comment_, f, this),
  subset_ (x.subset_, f, this),
  namespace__ (x.namespace__, f, this),
  is_root_ (x.is_root_, f, this),
  def_ (x.def_, f, this),
  synonym_ (x.synonym_, f, this),
  xref_analog_ (x.xref_analog_, f, this),
  is_a_ (x.is_a_, f, this),
  relationship_ (x.relationship_, f, this)
{
}

term::
term (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (this),
  name_ (this),
  is_obsolete_ (this),
  comment_ (this),
  subset_ (this),
  namespace__ (this),
  is_root_ (this),
  def_ (this),
  synonym_ (this),
  xref_analog_ (this),
  is_a_ (this),
  relationship_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void term::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< id_type > r (
        id_traits::create (i, f, this));

      if (!this->id_)
      {
        this->id_.set (::std::move (r));
        continue;
      }
    }

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!this->name_)
      {
        this->name_.set (::std::move (r));
        continue;
      }
    }

    // is_obsolete
    //
    if (n.name () == "is_obsolete" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< is_obsolete_type > r (
        is_obsolete_traits::create (i, f, this));

      if (!this->is_obsolete_)
      {
        this->is_obsolete_.set (::std::move (r));
        continue;
      }
    }

    // comment
    //
    if (n.name () == "comment" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< comment_type > r (
        comment_traits::create (i, f, this));

      if (!this->comment_)
      {
        this->comment_.set (::std::move (r));
        continue;
      }
    }

    // subset
    //
    if (n.name () == "subset" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< subset_type > r (
        subset_traits::create (i, f, this));

      if (!this->subset_)
      {
        this->subset_.set (::std::move (r));
        continue;
      }
    }

    // namespace
    //
    if (n.name () == "namespace" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< namespace_type > r (
        namespace_traits::create (i, f, this));

      if (!this->namespace__)
      {
        this->namespace__.set (::std::move (r));
        continue;
      }
    }

    // is_root
    //
    if (n.name () == "is_root" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< is_root_type > r (
        is_root_traits::create (i, f, this));

      if (!this->is_root_)
      {
        this->is_root_.set (::std::move (r));
        continue;
      }
    }

    // def
    //
    if (n.name () == "def" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< def_type > r (
        def_traits::create (i, f, this));

      this->def_.push_back (::std::move (r));
      continue;
    }

    // synonym
    //
    if (n.name () == "synonym" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< synonym_type > r (
        synonym_traits::create (i, f, this));

      this->synonym_.push_back (::std::move (r));
      continue;
    }

    // xref_analog
    //
    if (n.name () == "xref_analog" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< xref_analog_type > r (
        xref_analog_traits::create (i, f, this));

      this->xref_analog_.push_back (::std::move (r));
      continue;
    }

    // is_a
    //
    if (n.name () == "is_a" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< is_a_type > r (
        is_a_traits::create (i, f, this));

      this->is_a_.push_back (::std::move (r));
      continue;
    }

    // relationship
    //
    if (n.name () == "relationship" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< relationship_type > r (
        relationship_traits::create (i, f, this));

      this->relationship_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

term* term::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class term (*this, f, c);
}

term& term::
operator= (const term& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->id_ = x.id_;
    this->name_ = x.name_;
    this->is_obsolete_ = x.is_obsolete_;
    this->comment_ = x.comment_;
    this->subset_ = x.subset_;
    this->namespace__ = x.namespace__;
    this->is_root_ = x.is_root_;
    this->def_ = x.def_;
    this->synonym_ = x.synonym_;
    this->xref_analog_ = x.xref_analog_;
    this->is_a_ = x.is_a_;
    this->relationship_ = x.relationship_;
  }

  return *this;
}

term::
~term ()
{
}

// typedef_
//

typedef_::
typedef_ ()
: ::xml_schema::type (),
  id_ (this),
  name_ (this),
  comment_ (this),
  is_transitive_ (this),
  namespace__ (this),
  def_ (this)
{
}

typedef_::
typedef_ (const typedef_& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  name_ (x.name_, f, this),
  comment_ (x.comment_, f, this),
  is_transitive_ (x.is_transitive_, f, this),
  namespace__ (x.namespace__, f, this),
  def_ (x.def_, f, this)
{
}

typedef_::
typedef_ (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (this),
  name_ (this),
  comment_ (this),
  is_transitive_ (this),
  namespace__ (this),
  def_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void typedef_::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< id_type > r (
        id_traits::create (i, f, this));

      if (!this->id_)
      {
        this->id_.set (::std::move (r));
        continue;
      }
    }

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!this->name_)
      {
        this->name_.set (::std::move (r));
        continue;
      }
    }

    // comment
    //
    if (n.name () == "comment" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< comment_type > r (
        comment_traits::create (i, f, this));

      if (!this->comment_)
      {
        this->comment_.set (::std::move (r));
        continue;
      }
    }

    // is_transitive
    //
    if (n.name () == "is_transitive" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< is_transitive_type > r (
        is_transitive_traits::create (i, f, this));

      if (!this->is_transitive_)
      {
        this->is_transitive_.set (::std::move (r));
        continue;
      }
    }

    // namespace
    //
    if (n.name () == "namespace" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< namespace_type > r (
        namespace_traits::create (i, f, this));

      if (!this->namespace__)
      {
        this->namespace__.set (::std::move (r));
        continue;
      }
    }

    // def
    //
    if (n.name () == "def" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< def_type > r (
        def_traits::create (i, f, this));

      this->def_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

typedef_* typedef_::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class typedef_ (*this, f, c);
}

typedef_& typedef_::
operator= (const typedef_& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->id_ = x.id_;
    this->name_ = x.name_;
    this->comment_ = x.comment_;
    this->is_transitive_ = x.is_transitive_;
    this->namespace__ = x.namespace__;
    this->def_ = x.def_;
  }

  return *this;
}

typedef_::
~typedef_ ()
{
}

// subsetdef
//

subsetdef::
subsetdef ()
: ::xml_schema::type (),
  id_ (this),
  name_ (this)
{
}

subsetdef::
subsetdef (const subsetdef& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  name_ (x.name_, f, this)
{
}

subsetdef::
subsetdef (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (this),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void subsetdef::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< id_type > r (
        id_traits::create (i, f, this));

      if (!this->id_)
      {
        this->id_.set (::std::move (r));
        continue;
      }
    }

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!this->name_)
      {
        this->name_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

subsetdef* subsetdef::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class subsetdef (*this, f, c);
}

subsetdef& subsetdef::
operator= (const subsetdef& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->id_ = x.id_;
    this->name_ = x.name_;
  }

  return *this;
}

subsetdef::
~subsetdef ()
{
}

// synonymtypedef
//

synonymtypedef::
synonymtypedef ()
: ::xml_schema::type (),
  name_ (this),
  description_ (this),
  defaultscope_ (this)
{
}

synonymtypedef::
synonymtypedef (const synonymtypedef& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  description_ (x.description_, f, this),
  defaultscope_ (x.defaultscope_, f, this)
{
}

synonymtypedef::
synonymtypedef (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this),
  description_ (this),
  defaultscope_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void synonymtypedef::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!this->name_)
      {
        this->name_.set (::std::move (r));
        continue;
      }
    }

    // description
    //
    if (n.name () == "description" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< description_type > r (
        description_traits::create (i, f, this));

      if (!this->description_)
      {
        this->description_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "defaultscope" && n.namespace_ ().empty ())
    {
      this->defaultscope_.set (defaultscope_traits::create (i, f, this));
      continue;
    }
  }
}

synonymtypedef* synonymtypedef::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class synonymtypedef (*this, f, c);
}

synonymtypedef& synonymtypedef::
operator= (const synonymtypedef& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
    this->description_ = x.description_;
    this->defaultscope_ = x.defaultscope_;
  }

  return *this;
}

synonymtypedef::
~synonymtypedef ()
{
}

// remark
//

remark::
remark ()
: ::xml_schema::string ()
{
}

remark::
remark (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

remark::
remark (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

remark::
remark (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

remark::
remark (const remark& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

remark::
remark (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

remark::
remark (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

remark::
remark (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

remark* remark::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class remark (*this, f, c);
}

remark::
~remark ()
{
}

// synonym
//

synonym::
synonym ()
: ::xml_schema::type (),
  synonym_text_ (this),
  synonym_type_ (this),
  scope_ (this)
{
}

synonym::
synonym (const synonym& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  synonym_text_ (x.synonym_text_, f, this),
  synonym_type_ (x.synonym_type_, f, this),
  scope_ (x.scope_, f, this)
{
}

synonym::
synonym (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  synonym_text_ (this),
  synonym_type_ (this),
  scope_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void synonym::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // synonym_text
    //
    if (n.name () == "synonym_text" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< synonym_text_type > r (
        synonym_text_traits::create (i, f, this));

      if (!this->synonym_text_)
      {
        this->synonym_text_.set (::std::move (r));
        continue;
      }
    }

    // synonym_type
    //
    if (n.name () == "synonym_type" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< synonym_type_type > r (
        synonym_type_traits::create (i, f, this));

      if (!this->synonym_type_)
      {
        this->synonym_type_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "scope" && n.namespace_ ().empty ())
    {
      this->scope_.set (scope_traits::create (i, f, this));
      continue;
    }
  }
}

synonym* synonym::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class synonym (*this, f, c);
}

synonym& synonym::
operator= (const synonym& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->synonym_text_ = x.synonym_text_;
    this->synonym_type_ = x.synonym_type_;
    this->scope_ = x.scope_;
  }

  return *this;
}

synonym::
~synonym ()
{
}

// xref_analog
//

xref_analog::
xref_analog ()
: ::xml_schema::type (),
  acc_ (this),
  dbname_ (this),
  name_ (this)
{
}

xref_analog::
xref_analog (const xref_analog& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  acc_ (x.acc_, f, this),
  dbname_ (x.dbname_, f, this),
  name_ (x.name_, f, this)
{
}

xref_analog::
xref_analog (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  acc_ (this),
  dbname_ (this),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void xref_analog::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // acc
    //
    if (n.name () == "acc" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< acc_type > r (
        acc_traits::create (i, f, this));

      if (!this->acc_)
      {
        this->acc_.set (::std::move (r));
        continue;
      }
    }

    // dbname
    //
    if (n.name () == "dbname" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dbname_type > r (
        dbname_traits::create (i, f, this));

      if (!this->dbname_)
      {
        this->dbname_.set (::std::move (r));
        continue;
      }
    }

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!this->name_)
      {
        this->name_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

xref_analog* xref_analog::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class xref_analog (*this, f, c);
}

xref_analog& xref_analog::
operator= (const xref_analog& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->acc_ = x.acc_;
    this->dbname_ = x.dbname_;
    this->name_ = x.name_;
  }

  return *this;
}

xref_analog::
~xref_analog ()
{
}

// is_a
//

is_a::
is_a ()
: ::xml_schema::string ()
{
}

is_a::
is_a (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

is_a::
is_a (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

is_a::
is_a (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

is_a::
is_a (const is_a& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

is_a::
is_a (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

is_a::
is_a (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

is_a::
is_a (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

is_a* is_a::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class is_a (*this, f, c);
}

is_a::
~is_a ()
{
}

// relationship
//

relationship::
relationship ()
: ::xml_schema::type (),
  type_ (this),
  to_ (this)
{
}

relationship::
relationship (const relationship& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  to_ (x.to_, f, this)
{
}

relationship::
relationship (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this),
  to_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void relationship::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!this->type_)
      {
        this->type_.set (::std::move (r));
        continue;
      }
    }

    // to
    //
    if (n.name () == "to" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< to_type > r (
        to_traits::create (i, f, this));

      if (!this->to_)
      {
        this->to_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

relationship* relationship::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class relationship (*this, f, c);
}

relationship& relationship::
operator= (const relationship& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
    this->to_ = x.to_;
  }

  return *this;
}

relationship::
~relationship ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::def >
def_ (const ::std::string& u,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::def > (
    ::def_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::def >
def_ (const ::std::string& u,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::def > (
    ::def_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::def >
def_ (const ::std::string& u,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::def > (
    ::def_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::def >
def_ (::std::istream& is,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::def_ (isrc, f, p);
}

::std::unique_ptr< ::def >
def_ (::std::istream& is,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::def_ (isrc, h, f, p);
}

::std::unique_ptr< ::def >
def_ (::std::istream& is,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::def_ (isrc, h, f, p);
}

::std::unique_ptr< ::def >
def_ (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::def_ (isrc, f, p);
}

::std::unique_ptr< ::def >
def_ (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::def_ (isrc, h, f, p);
}

::std::unique_ptr< ::def >
def_ (::std::istream& is,
      const ::std::string& sid,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::def_ (isrc, h, f, p);
}

::std::unique_ptr< ::def >
def_ (::xercesc::InputSource& i,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::def > (
    ::def_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::def >
def_ (::xercesc::InputSource& i,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::def > (
    ::def_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::def >
def_ (::xercesc::InputSource& i,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::def > (
    ::def_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::def >
def_ (const ::xercesc::DOMDocument& doc,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::def > (
      ::def_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "def" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::def > r (
      ::xsd::cxx::tree::traits< ::def, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "def",
    "");
}

::std::unique_ptr< ::def >
def_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
      ::xml_schema::flags f,
      const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "def" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::def > r (
      ::xsd::cxx::tree::traits< ::def, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "def",
    "");
}

::std::unique_ptr< ::obo >
obo_ (const ::std::string& u,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::obo > (
    ::obo_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::obo >
obo_ (const ::std::string& u,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::obo > (
    ::obo_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::obo >
obo_ (const ::std::string& u,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::obo > (
    ::obo_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::obo >
obo_ (::std::istream& is,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::obo_ (isrc, f, p);
}

::std::unique_ptr< ::obo >
obo_ (::std::istream& is,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::obo_ (isrc, h, f, p);
}

::std::unique_ptr< ::obo >
obo_ (::std::istream& is,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::obo_ (isrc, h, f, p);
}

::std::unique_ptr< ::obo >
obo_ (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::obo_ (isrc, f, p);
}

::std::unique_ptr< ::obo >
obo_ (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::obo_ (isrc, h, f, p);
}

::std::unique_ptr< ::obo >
obo_ (::std::istream& is,
      const ::std::string& sid,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::obo_ (isrc, h, f, p);
}

::std::unique_ptr< ::obo >
obo_ (::xercesc::InputSource& i,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::obo > (
    ::obo_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::obo >
obo_ (::xercesc::InputSource& i,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::obo > (
    ::obo_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::obo >
obo_ (::xercesc::InputSource& i,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::obo > (
    ::obo_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::obo >
obo_ (const ::xercesc::DOMDocument& doc,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::obo > (
      ::obo_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "obo" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::obo > r (
      ::xsd::cxx::tree::traits< ::obo, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "obo",
    "");
}

::std::unique_ptr< ::obo >
obo_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
      ::xml_schema::flags f,
      const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "obo" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::obo > r (
      ::xsd::cxx::tree::traits< ::obo, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "obo",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
def_ (::std::ostream& o,
      const ::def& s,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::def_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
def_ (::std::ostream& o,
      const ::def& s,
      ::xml_schema::error_handler& h,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::def_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
def_ (::std::ostream& o,
      const ::def& s,
      ::xercesc::DOMErrorHandler& h,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::def_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
def_ (::xercesc::XMLFormatTarget& t,
      const ::def& s,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::def_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
def_ (::xercesc::XMLFormatTarget& t,
      const ::def& s,
      ::xml_schema::error_handler& h,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::def_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
def_ (::xercesc::XMLFormatTarget& t,
      const ::def& s,
      ::xercesc::DOMErrorHandler& h,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::def_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
def_ (::xercesc::DOMDocument& d,
      const ::def& s,
      ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "def" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "def",
      "");
  }
}

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
def_ (const ::def& s,
      const ::xml_schema::namespace_infomap& m,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "def",
      "",
      m, f));

  ::def_ (*d, s, f);
  return d;
}

void
obo_ (::std::ostream& o,
      const ::obo& s,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::obo_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
obo_ (::std::ostream& o,
      const ::obo& s,
      ::xml_schema::error_handler& h,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::obo_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
obo_ (::std::ostream& o,
      const ::obo& s,
      ::xercesc::DOMErrorHandler& h,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::obo_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
obo_ (::xercesc::XMLFormatTarget& t,
      const ::obo& s,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::obo_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
obo_ (::xercesc::XMLFormatTarget& t,
      const ::obo& s,
      ::xml_schema::error_handler& h,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::obo_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
obo_ (::xercesc::XMLFormatTarget& t,
      const ::obo& s,
      ::xercesc::DOMErrorHandler& h,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::obo_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
obo_ (::xercesc::DOMDocument& d,
      const ::obo& s,
      ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "obo" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "obo",
      "");
  }
}

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
obo_ (const ::obo& s,
      const ::xml_schema::namespace_infomap& m,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "obo",
      "",
      m, f));

  ::obo_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const def& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // defstr
  //
  if (i.defstr ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "defstr",
        e));

    s << *i.defstr ();
  }

  // dbxref
  //
  for (def::dbxref_const_iterator
       b (i.dbxref ().begin ()), n (i.dbxref ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dbxref",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const obo& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // def
  //
  for (obo::def_const_iterator
       b (i.def ().begin ()), n (i.def ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "def",
        e));

    s << *b;
  }

  // source
  //
  for (obo::source_const_iterator
       b (i.source ().begin ()), n (i.source ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "source",
        e));

    s << *b;
  }

  // header
  //
  for (obo::header_const_iterator
       b (i.header ().begin ()), n (i.header ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "header",
        e));

    s << *b;
  }

  // term
  //
  for (obo::term_const_iterator
       b (i.term ().begin ()), n (i.term ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "term",
        e));

    s << *b;
  }

  // typedef
  //
  for (obo::typedef_const_iterator
       b (i.typedef_ ().begin ()), n (i.typedef_ ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "typedef",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const dbxref& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // acc
  //
  if (i.acc ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "acc",
        e));

    s << *i.acc ();
  }

  // dbname
  //
  if (i.dbname ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dbname",
        e));

    s << *i.dbname ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const source& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // source_type
  //
  if (i.source_type ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "source_type",
        e));

    s << *i.source_type ();
  }

  // source_path
  //
  if (i.source_path ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "source_path",
        e));

    s << *i.source_path ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const header& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // format-version
  //
  if (i.format_version ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "format-version",
        e));

    s << *i.format_version ();
  }

  // date
  //
  if (i.date ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "date",
        e));

    s << *i.date ();
  }

  // saved-by
  //
  if (i.saved_by ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "saved-by",
        e));

    s << *i.saved_by ();
  }

  // auto-generated-by
  //
  if (i.auto_generated_by ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "auto-generated-by",
        e));

    s << *i.auto_generated_by ();
  }

  // default-namespace
  //
  if (i.default_namespace ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "default-namespace",
        e));

    s << *i.default_namespace ();
  }

  // subsetdef
  //
  for (header::subsetdef_const_iterator
       b (i.subsetdef ().begin ()), n (i.subsetdef ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "subsetdef",
        e));

    s << *b;
  }

  // synonymtypedef
  //
  for (header::synonymtypedef_const_iterator
       b (i.synonymtypedef ().begin ()), n (i.synonymtypedef ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "synonymtypedef",
        e));

    s << *b;
  }

  // remark
  //
  for (header::remark_const_iterator
       b (i.remark ().begin ()), n (i.remark ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "remark",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const term& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  if (i.id ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << *i.id ();
  }

  // name
  //
  if (i.name ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "name",
        e));

    s << *i.name ();
  }

  // is_obsolete
  //
  if (i.is_obsolete ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "is_obsolete",
        e));

    s << *i.is_obsolete ();
  }

  // comment
  //
  if (i.comment ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "comment",
        e));

    s << *i.comment ();
  }

  // subset
  //
  if (i.subset ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "subset",
        e));

    s << *i.subset ();
  }

  // namespace
  //
  if (i.namespace_ ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "namespace",
        e));

    s << *i.namespace_ ();
  }

  // is_root
  //
  if (i.is_root ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "is_root",
        e));

    s << *i.is_root ();
  }

  // def
  //
  for (term::def_const_iterator
       b (i.def ().begin ()), n (i.def ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "def",
        e));

    s << *b;
  }

  // synonym
  //
  for (term::synonym_const_iterator
       b (i.synonym ().begin ()), n (i.synonym ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "synonym",
        e));

    s << *b;
  }

  // xref_analog
  //
  for (term::xref_analog_const_iterator
       b (i.xref_analog ().begin ()), n (i.xref_analog ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "xref_analog",
        e));

    s << *b;
  }

  // is_a
  //
  for (term::is_a_const_iterator
       b (i.is_a ().begin ()), n (i.is_a ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "is_a",
        e));

    s << *b;
  }

  // relationship
  //
  for (term::relationship_const_iterator
       b (i.relationship ().begin ()), n (i.relationship ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "relationship",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const typedef_& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  if (i.id ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << *i.id ();
  }

  // name
  //
  if (i.name ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "name",
        e));

    s << *i.name ();
  }

  // comment
  //
  if (i.comment ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "comment",
        e));

    s << *i.comment ();
  }

  // is_transitive
  //
  if (i.is_transitive ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "is_transitive",
        e));

    s << *i.is_transitive ();
  }

  // namespace
  //
  if (i.namespace_ ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "namespace",
        e));

    s << *i.namespace_ ();
  }

  // def
  //
  for (typedef_::def_const_iterator
       b (i.def ().begin ()), n (i.def ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "def",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const subsetdef& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  if (i.id ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << *i.id ();
  }

  // name
  //
  if (i.name ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "name",
        e));

    s << *i.name ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const synonymtypedef& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // name
  //
  if (i.name ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "name",
        e));

    s << *i.name ();
  }

  // description
  //
  if (i.description ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "description",
        e));

    s << *i.description ();
  }

  // defaultscope
  //
  if (i.defaultscope ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "defaultscope",
        e));

    a << *i.defaultscope ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const remark& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const remark& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const remark& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const synonym& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // synonym_text
  //
  if (i.synonym_text ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "synonym_text",
        e));

    s << *i.synonym_text ();
  }

  // synonym_type
  //
  if (i.synonym_type ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "synonym_type",
        e));

    s << *i.synonym_type ();
  }

  // scope
  //
  if (i.scope ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "scope",
        e));

    a << *i.scope ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const xref_analog& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // acc
  //
  if (i.acc ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "acc",
        e));

    s << *i.acc ();
  }

  // dbname
  //
  if (i.dbname ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dbname",
        e));

    s << *i.dbname ();
  }

  // name
  //
  if (i.name ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "name",
        e));

    s << *i.name ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const is_a& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const is_a& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const is_a& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const relationship& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // type
  //
  if (i.type ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        e));

    s << *i.type ();
  }

  // to
  //
  if (i.to ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "to",
        e));

    s << *i.to ();
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

