// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef PSI_MOD_OBO_H
#define PSI_MOD_OBO_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class def;
class obo;
class dbxref;
class source;
class header;
class term;
class typedef_;
class subsetdef;
class synonymtypedef;
class remark;
class synonym;
class xref_analog;
class is_a;
class relationship;

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class def: public ::xml_schema::type
{
  public:
  // defstr
  //
  typedef ::xml_schema::string defstr_type;
  typedef ::xsd::cxx::tree::optional< defstr_type > defstr_optional;
  typedef ::xsd::cxx::tree::traits< defstr_type, char > defstr_traits;

  const defstr_optional&
  defstr () const;

  defstr_optional&
  defstr ();

  void
  defstr (const defstr_type& x);

  void
  defstr (const defstr_optional& x);

  void
  defstr (::std::unique_ptr< defstr_type > p);

  // dbxref
  //
  typedef ::dbxref dbxref_type;
  typedef ::xsd::cxx::tree::sequence< dbxref_type > dbxref_sequence;
  typedef dbxref_sequence::iterator dbxref_iterator;
  typedef dbxref_sequence::const_iterator dbxref_const_iterator;
  typedef ::xsd::cxx::tree::traits< dbxref_type, char > dbxref_traits;

  const dbxref_sequence&
  dbxref () const;

  dbxref_sequence&
  dbxref ();

  void
  dbxref (const dbxref_sequence& s);

  // Constructors.
  //
  def ();

  def (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  def (const def& x,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  virtual def*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  def&
  operator= (const def& x);

  virtual 
  ~def ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  defstr_optional defstr_;
  dbxref_sequence dbxref_;
};

class obo: public ::xml_schema::type
{
  public:
  // def
  //
  typedef ::def def_type;
  typedef ::xsd::cxx::tree::sequence< def_type > def_sequence;
  typedef def_sequence::iterator def_iterator;
  typedef def_sequence::const_iterator def_const_iterator;
  typedef ::xsd::cxx::tree::traits< def_type, char > def_traits;

  const def_sequence&
  def () const;

  def_sequence&
  def ();

  void
  def (const def_sequence& s);

  // source
  //
  typedef ::source source_type;
  typedef ::xsd::cxx::tree::sequence< source_type > source_sequence;
  typedef source_sequence::iterator source_iterator;
  typedef source_sequence::const_iterator source_const_iterator;
  typedef ::xsd::cxx::tree::traits< source_type, char > source_traits;

  const source_sequence&
  source () const;

  source_sequence&
  source ();

  void
  source (const source_sequence& s);

  // header
  //
  typedef ::header header_type;
  typedef ::xsd::cxx::tree::sequence< header_type > header_sequence;
  typedef header_sequence::iterator header_iterator;
  typedef header_sequence::const_iterator header_const_iterator;
  typedef ::xsd::cxx::tree::traits< header_type, char > header_traits;

  const header_sequence&
  header () const;

  header_sequence&
  header ();

  void
  header (const header_sequence& s);

  // term
  //
  typedef ::term term_type;
  typedef ::xsd::cxx::tree::sequence< term_type > term_sequence;
  typedef term_sequence::iterator term_iterator;
  typedef term_sequence::const_iterator term_const_iterator;
  typedef ::xsd::cxx::tree::traits< term_type, char > term_traits;

  const term_sequence&
  term () const;

  term_sequence&
  term ();

  void
  term (const term_sequence& s);

  // typedef
  //
  typedef ::typedef_ typedef_type;
  typedef ::xsd::cxx::tree::sequence< typedef_type > typedef_sequence;
  typedef typedef_sequence::iterator typedef_iterator;
  typedef typedef_sequence::const_iterator typedef_const_iterator;
  typedef ::xsd::cxx::tree::traits< typedef_type, char > typedef_traits;

  const typedef_sequence&
  typedef_ () const;

  typedef_sequence&
  typedef_ ();

  void
  typedef_ (const typedef_sequence& s);

  // Constructors.
  //
  obo ();

  obo (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  obo (const obo& x,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  virtual obo*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  obo&
  operator= (const obo& x);

  virtual 
  ~obo ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  def_sequence def_;
  source_sequence source_;
  header_sequence header_;
  term_sequence term_;
  typedef_sequence typedef__;
};

class dbxref: public ::xml_schema::type
{
  public:
  // acc
  //
  typedef ::xml_schema::string acc_type;
  typedef ::xsd::cxx::tree::optional< acc_type > acc_optional;
  typedef ::xsd::cxx::tree::traits< acc_type, char > acc_traits;

  const acc_optional&
  acc () const;

  acc_optional&
  acc ();

  void
  acc (const acc_type& x);

  void
  acc (const acc_optional& x);

  void
  acc (::std::unique_ptr< acc_type > p);

  // dbname
  //
  typedef ::xml_schema::string dbname_type;
  typedef ::xsd::cxx::tree::optional< dbname_type > dbname_optional;
  typedef ::xsd::cxx::tree::traits< dbname_type, char > dbname_traits;

  const dbname_optional&
  dbname () const;

  dbname_optional&
  dbname ();

  void
  dbname (const dbname_type& x);

  void
  dbname (const dbname_optional& x);

  void
  dbname (::std::unique_ptr< dbname_type > p);

  // Constructors.
  //
  dbxref ();

  dbxref (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  dbxref (const dbxref& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual dbxref*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  dbxref&
  operator= (const dbxref& x);

  virtual 
  ~dbxref ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  acc_optional acc_;
  dbname_optional dbname_;
};

class source: public ::xml_schema::type
{
  public:
  // source_type
  //
  typedef ::xml_schema::string source_type_type;
  typedef ::xsd::cxx::tree::optional< source_type_type > source_type_optional;
  typedef ::xsd::cxx::tree::traits< source_type_type, char > source_type_traits;

  const source_type_optional&
  source_type () const;

  source_type_optional&
  source_type ();

  void
  source_type (const source_type_type& x);

  void
  source_type (const source_type_optional& x);

  void
  source_type (::std::unique_ptr< source_type_type > p);

  // source_path
  //
  typedef ::xml_schema::string source_path_type;
  typedef ::xsd::cxx::tree::optional< source_path_type > source_path_optional;
  typedef ::xsd::cxx::tree::traits< source_path_type, char > source_path_traits;

  const source_path_optional&
  source_path () const;

  source_path_optional&
  source_path ();

  void
  source_path (const source_path_type& x);

  void
  source_path (const source_path_optional& x);

  void
  source_path (::std::unique_ptr< source_path_type > p);

  // Constructors.
  //
  source ();

  source (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  source (const source& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual source*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  source&
  operator= (const source& x);

  virtual 
  ~source ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  source_type_optional source_type_;
  source_path_optional source_path_;
};

class header: public ::xml_schema::type
{
  public:
  // format-version
  //
  typedef ::xml_schema::string format_version_type;
  typedef ::xsd::cxx::tree::optional< format_version_type > format_version_optional;
  typedef ::xsd::cxx::tree::traits< format_version_type, char > format_version_traits;

  const format_version_optional&
  format_version () const;

  format_version_optional&
  format_version ();

  void
  format_version (const format_version_type& x);

  void
  format_version (const format_version_optional& x);

  void
  format_version (::std::unique_ptr< format_version_type > p);

  // date
  //
  typedef ::xml_schema::string date_type;
  typedef ::xsd::cxx::tree::optional< date_type > date_optional;
  typedef ::xsd::cxx::tree::traits< date_type, char > date_traits;

  const date_optional&
  date () const;

  date_optional&
  date ();

  void
  date (const date_type& x);

  void
  date (const date_optional& x);

  void
  date (::std::unique_ptr< date_type > p);

  // saved-by
  //
  typedef ::xml_schema::string saved_by_type;
  typedef ::xsd::cxx::tree::optional< saved_by_type > saved_by_optional;
  typedef ::xsd::cxx::tree::traits< saved_by_type, char > saved_by_traits;

  const saved_by_optional&
  saved_by () const;

  saved_by_optional&
  saved_by ();

  void
  saved_by (const saved_by_type& x);

  void
  saved_by (const saved_by_optional& x);

  void
  saved_by (::std::unique_ptr< saved_by_type > p);

  // auto-generated-by
  //
  typedef ::xml_schema::string auto_generated_by_type;
  typedef ::xsd::cxx::tree::optional< auto_generated_by_type > auto_generated_by_optional;
  typedef ::xsd::cxx::tree::traits< auto_generated_by_type, char > auto_generated_by_traits;

  const auto_generated_by_optional&
  auto_generated_by () const;

  auto_generated_by_optional&
  auto_generated_by ();

  void
  auto_generated_by (const auto_generated_by_type& x);

  void
  auto_generated_by (const auto_generated_by_optional& x);

  void
  auto_generated_by (::std::unique_ptr< auto_generated_by_type > p);

  // default-namespace
  //
  typedef ::xml_schema::string default_namespace_type;
  typedef ::xsd::cxx::tree::optional< default_namespace_type > default_namespace_optional;
  typedef ::xsd::cxx::tree::traits< default_namespace_type, char > default_namespace_traits;

  const default_namespace_optional&
  default_namespace () const;

  default_namespace_optional&
  default_namespace ();

  void
  default_namespace (const default_namespace_type& x);

  void
  default_namespace (const default_namespace_optional& x);

  void
  default_namespace (::std::unique_ptr< default_namespace_type > p);

  // subsetdef
  //
  typedef ::subsetdef subsetdef_type;
  typedef ::xsd::cxx::tree::sequence< subsetdef_type > subsetdef_sequence;
  typedef subsetdef_sequence::iterator subsetdef_iterator;
  typedef subsetdef_sequence::const_iterator subsetdef_const_iterator;
  typedef ::xsd::cxx::tree::traits< subsetdef_type, char > subsetdef_traits;

  const subsetdef_sequence&
  subsetdef () const;

  subsetdef_sequence&
  subsetdef ();

  void
  subsetdef (const subsetdef_sequence& s);

  // synonymtypedef
  //
  typedef ::synonymtypedef synonymtypedef_type;
  typedef ::xsd::cxx::tree::sequence< synonymtypedef_type > synonymtypedef_sequence;
  typedef synonymtypedef_sequence::iterator synonymtypedef_iterator;
  typedef synonymtypedef_sequence::const_iterator synonymtypedef_const_iterator;
  typedef ::xsd::cxx::tree::traits< synonymtypedef_type, char > synonymtypedef_traits;

  const synonymtypedef_sequence&
  synonymtypedef () const;

  synonymtypedef_sequence&
  synonymtypedef ();

  void
  synonymtypedef (const synonymtypedef_sequence& s);

  // remark
  //
  typedef ::remark remark_type;
  typedef ::xsd::cxx::tree::sequence< remark_type > remark_sequence;
  typedef remark_sequence::iterator remark_iterator;
  typedef remark_sequence::const_iterator remark_const_iterator;
  typedef ::xsd::cxx::tree::traits< remark_type, char > remark_traits;

  const remark_sequence&
  remark () const;

  remark_sequence&
  remark ();

  void
  remark (const remark_sequence& s);

  // Constructors.
  //
  header ();

  header (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  header (const header& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual header*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  header&
  operator= (const header& x);

  virtual 
  ~header ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  format_version_optional format_version_;
  date_optional date_;
  saved_by_optional saved_by_;
  auto_generated_by_optional auto_generated_by_;
  default_namespace_optional default_namespace_;
  subsetdef_sequence subsetdef_;
  synonymtypedef_sequence synonymtypedef_;
  remark_sequence remark_;
};

class term: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // is_obsolete
  //
  typedef ::xml_schema::string is_obsolete_type;
  typedef ::xsd::cxx::tree::optional< is_obsolete_type > is_obsolete_optional;
  typedef ::xsd::cxx::tree::traits< is_obsolete_type, char > is_obsolete_traits;

  const is_obsolete_optional&
  is_obsolete () const;

  is_obsolete_optional&
  is_obsolete ();

  void
  is_obsolete (const is_obsolete_type& x);

  void
  is_obsolete (const is_obsolete_optional& x);

  void
  is_obsolete (::std::unique_ptr< is_obsolete_type > p);

  // comment
  //
  typedef ::xml_schema::string comment_type;
  typedef ::xsd::cxx::tree::optional< comment_type > comment_optional;
  typedef ::xsd::cxx::tree::traits< comment_type, char > comment_traits;

  const comment_optional&
  comment () const;

  comment_optional&
  comment ();

  void
  comment (const comment_type& x);

  void
  comment (const comment_optional& x);

  void
  comment (::std::unique_ptr< comment_type > p);

  // subset
  //
  typedef ::xml_schema::string subset_type;
  typedef ::xsd::cxx::tree::optional< subset_type > subset_optional;
  typedef ::xsd::cxx::tree::traits< subset_type, char > subset_traits;

  const subset_optional&
  subset () const;

  subset_optional&
  subset ();

  void
  subset (const subset_type& x);

  void
  subset (const subset_optional& x);

  void
  subset (::std::unique_ptr< subset_type > p);

  // namespace
  //
  typedef ::xml_schema::string namespace_type;
  typedef ::xsd::cxx::tree::optional< namespace_type > namespace_optional;
  typedef ::xsd::cxx::tree::traits< namespace_type, char > namespace_traits;

  const namespace_optional&
  namespace_ () const;

  namespace_optional&
  namespace_ ();

  void
  namespace_ (const namespace_type& x);

  void
  namespace_ (const namespace_optional& x);

  void
  namespace_ (::std::unique_ptr< namespace_type > p);

  // is_root
  //
  typedef ::xml_schema::string is_root_type;
  typedef ::xsd::cxx::tree::optional< is_root_type > is_root_optional;
  typedef ::xsd::cxx::tree::traits< is_root_type, char > is_root_traits;

  const is_root_optional&
  is_root () const;

  is_root_optional&
  is_root ();

  void
  is_root (const is_root_type& x);

  void
  is_root (const is_root_optional& x);

  void
  is_root (::std::unique_ptr< is_root_type > p);

  // def
  //
  typedef ::def def_type;
  typedef ::xsd::cxx::tree::sequence< def_type > def_sequence;
  typedef def_sequence::iterator def_iterator;
  typedef def_sequence::const_iterator def_const_iterator;
  typedef ::xsd::cxx::tree::traits< def_type, char > def_traits;

  const def_sequence&
  def () const;

  def_sequence&
  def ();

  void
  def (const def_sequence& s);

  // synonym
  //
  typedef ::synonym synonym_type;
  typedef ::xsd::cxx::tree::sequence< synonym_type > synonym_sequence;
  typedef synonym_sequence::iterator synonym_iterator;
  typedef synonym_sequence::const_iterator synonym_const_iterator;
  typedef ::xsd::cxx::tree::traits< synonym_type, char > synonym_traits;

  const synonym_sequence&
  synonym () const;

  synonym_sequence&
  synonym ();

  void
  synonym (const synonym_sequence& s);

  // xref_analog
  //
  typedef ::xref_analog xref_analog_type;
  typedef ::xsd::cxx::tree::sequence< xref_analog_type > xref_analog_sequence;
  typedef xref_analog_sequence::iterator xref_analog_iterator;
  typedef xref_analog_sequence::const_iterator xref_analog_const_iterator;
  typedef ::xsd::cxx::tree::traits< xref_analog_type, char > xref_analog_traits;

  const xref_analog_sequence&
  xref_analog () const;

  xref_analog_sequence&
  xref_analog ();

  void
  xref_analog (const xref_analog_sequence& s);

  // is_a
  //
  typedef ::is_a is_a_type;
  typedef ::xsd::cxx::tree::sequence< is_a_type > is_a_sequence;
  typedef is_a_sequence::iterator is_a_iterator;
  typedef is_a_sequence::const_iterator is_a_const_iterator;
  typedef ::xsd::cxx::tree::traits< is_a_type, char > is_a_traits;

  const is_a_sequence&
  is_a () const;

  is_a_sequence&
  is_a ();

  void
  is_a (const is_a_sequence& s);

  // relationship
  //
  typedef ::relationship relationship_type;
  typedef ::xsd::cxx::tree::sequence< relationship_type > relationship_sequence;
  typedef relationship_sequence::iterator relationship_iterator;
  typedef relationship_sequence::const_iterator relationship_const_iterator;
  typedef ::xsd::cxx::tree::traits< relationship_type, char > relationship_traits;

  const relationship_sequence&
  relationship () const;

  relationship_sequence&
  relationship ();

  void
  relationship (const relationship_sequence& s);

  // Constructors.
  //
  term ();

  term (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  term (const term& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual term*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  term&
  operator= (const term& x);

  virtual 
  ~term ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  id_optional id_;
  name_optional name_;
  is_obsolete_optional is_obsolete_;
  comment_optional comment_;
  subset_optional subset_;
  namespace_optional namespace__;
  is_root_optional is_root_;
  def_sequence def_;
  synonym_sequence synonym_;
  xref_analog_sequence xref_analog_;
  is_a_sequence is_a_;
  relationship_sequence relationship_;
};

class typedef_: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // comment
  //
  typedef ::xml_schema::string comment_type;
  typedef ::xsd::cxx::tree::optional< comment_type > comment_optional;
  typedef ::xsd::cxx::tree::traits< comment_type, char > comment_traits;

  const comment_optional&
  comment () const;

  comment_optional&
  comment ();

  void
  comment (const comment_type& x);

  void
  comment (const comment_optional& x);

  void
  comment (::std::unique_ptr< comment_type > p);

  // is_transitive
  //
  typedef ::xml_schema::string is_transitive_type;
  typedef ::xsd::cxx::tree::optional< is_transitive_type > is_transitive_optional;
  typedef ::xsd::cxx::tree::traits< is_transitive_type, char > is_transitive_traits;

  const is_transitive_optional&
  is_transitive () const;

  is_transitive_optional&
  is_transitive ();

  void
  is_transitive (const is_transitive_type& x);

  void
  is_transitive (const is_transitive_optional& x);

  void
  is_transitive (::std::unique_ptr< is_transitive_type > p);

  // namespace
  //
  typedef ::xml_schema::string namespace_type;
  typedef ::xsd::cxx::tree::optional< namespace_type > namespace_optional;
  typedef ::xsd::cxx::tree::traits< namespace_type, char > namespace_traits;

  const namespace_optional&
  namespace_ () const;

  namespace_optional&
  namespace_ ();

  void
  namespace_ (const namespace_type& x);

  void
  namespace_ (const namespace_optional& x);

  void
  namespace_ (::std::unique_ptr< namespace_type > p);

  // def
  //
  typedef ::def def_type;
  typedef ::xsd::cxx::tree::sequence< def_type > def_sequence;
  typedef def_sequence::iterator def_iterator;
  typedef def_sequence::const_iterator def_const_iterator;
  typedef ::xsd::cxx::tree::traits< def_type, char > def_traits;

  const def_sequence&
  def () const;

  def_sequence&
  def ();

  void
  def (const def_sequence& s);

  // Constructors.
  //
  typedef_ ();

  typedef_ (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  typedef_ (const typedef_& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual typedef_*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  typedef_&
  operator= (const typedef_& x);

  virtual 
  ~typedef_ ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  id_optional id_;
  name_optional name_;
  comment_optional comment_;
  is_transitive_optional is_transitive_;
  namespace_optional namespace__;
  def_sequence def_;
};

class subsetdef: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // Constructors.
  //
  subsetdef ();

  subsetdef (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  subsetdef (const subsetdef& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual subsetdef*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  subsetdef&
  operator= (const subsetdef& x);

  virtual 
  ~subsetdef ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  id_optional id_;
  name_optional name_;
};

class synonymtypedef: public ::xml_schema::type
{
  public:
  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // description
  //
  typedef ::xml_schema::string description_type;
  typedef ::xsd::cxx::tree::optional< description_type > description_optional;
  typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

  const description_optional&
  description () const;

  description_optional&
  description ();

  void
  description (const description_type& x);

  void
  description (const description_optional& x);

  void
  description (::std::unique_ptr< description_type > p);

  // defaultscope
  //
  typedef ::xml_schema::string defaultscope_type;
  typedef ::xsd::cxx::tree::optional< defaultscope_type > defaultscope_optional;
  typedef ::xsd::cxx::tree::traits< defaultscope_type, char > defaultscope_traits;

  const defaultscope_optional&
  defaultscope () const;

  defaultscope_optional&
  defaultscope ();

  void
  defaultscope (const defaultscope_type& x);

  void
  defaultscope (const defaultscope_optional& x);

  void
  defaultscope (::std::unique_ptr< defaultscope_type > p);

  // Constructors.
  //
  synonymtypedef ();

  synonymtypedef (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  synonymtypedef (const synonymtypedef& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual synonymtypedef*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  synonymtypedef&
  operator= (const synonymtypedef& x);

  virtual 
  ~synonymtypedef ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  name_optional name_;
  description_optional description_;
  defaultscope_optional defaultscope_;
};

class remark: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  remark ();

  remark (const char*);

  remark (const ::std::string&);

  remark (const ::xml_schema::string&);

  remark (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  remark (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  remark (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  remark (const remark& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual remark*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~remark ();
};

class synonym: public ::xml_schema::type
{
  public:
  // synonym_text
  //
  typedef ::xml_schema::string synonym_text_type;
  typedef ::xsd::cxx::tree::optional< synonym_text_type > synonym_text_optional;
  typedef ::xsd::cxx::tree::traits< synonym_text_type, char > synonym_text_traits;

  const synonym_text_optional&
  synonym_text () const;

  synonym_text_optional&
  synonym_text ();

  void
  synonym_text (const synonym_text_type& x);

  void
  synonym_text (const synonym_text_optional& x);

  void
  synonym_text (::std::unique_ptr< synonym_text_type > p);

  // synonym_type
  //
  typedef ::xml_schema::string synonym_type_type;
  typedef ::xsd::cxx::tree::optional< synonym_type_type > synonym_type_optional;
  typedef ::xsd::cxx::tree::traits< synonym_type_type, char > synonym_type_traits;

  const synonym_type_optional&
  synonym_type () const;

  synonym_type_optional&
  synonym_type ();

  void
  synonym_type (const synonym_type_type& x);

  void
  synonym_type (const synonym_type_optional& x);

  void
  synonym_type (::std::unique_ptr< synonym_type_type > p);

  // scope
  //
  typedef ::xml_schema::string scope_type;
  typedef ::xsd::cxx::tree::optional< scope_type > scope_optional;
  typedef ::xsd::cxx::tree::traits< scope_type, char > scope_traits;

  const scope_optional&
  scope () const;

  scope_optional&
  scope ();

  void
  scope (const scope_type& x);

  void
  scope (const scope_optional& x);

  void
  scope (::std::unique_ptr< scope_type > p);

  // Constructors.
  //
  synonym ();

  synonym (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  synonym (const synonym& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual synonym*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  synonym&
  operator= (const synonym& x);

  virtual 
  ~synonym ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  synonym_text_optional synonym_text_;
  synonym_type_optional synonym_type_;
  scope_optional scope_;
};

class xref_analog: public ::xml_schema::type
{
  public:
  // acc
  //
  typedef ::xml_schema::string acc_type;
  typedef ::xsd::cxx::tree::optional< acc_type > acc_optional;
  typedef ::xsd::cxx::tree::traits< acc_type, char > acc_traits;

  const acc_optional&
  acc () const;

  acc_optional&
  acc ();

  void
  acc (const acc_type& x);

  void
  acc (const acc_optional& x);

  void
  acc (::std::unique_ptr< acc_type > p);

  // dbname
  //
  typedef ::xml_schema::string dbname_type;
  typedef ::xsd::cxx::tree::optional< dbname_type > dbname_optional;
  typedef ::xsd::cxx::tree::traits< dbname_type, char > dbname_traits;

  const dbname_optional&
  dbname () const;

  dbname_optional&
  dbname ();

  void
  dbname (const dbname_type& x);

  void
  dbname (const dbname_optional& x);

  void
  dbname (::std::unique_ptr< dbname_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // Constructors.
  //
  xref_analog ();

  xref_analog (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  xref_analog (const xref_analog& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual xref_analog*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  xref_analog&
  operator= (const xref_analog& x);

  virtual 
  ~xref_analog ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  acc_optional acc_;
  dbname_optional dbname_;
  name_optional name_;
};

class is_a: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  is_a ();

  is_a (const char*);

  is_a (const ::std::string&);

  is_a (const ::xml_schema::string&);

  is_a (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  is_a (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  is_a (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  is_a (const is_a& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual is_a*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~is_a ();
};

class relationship: public ::xml_schema::type
{
  public:
  // type
  //
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // to
  //
  typedef ::xml_schema::string to_type;
  typedef ::xsd::cxx::tree::optional< to_type > to_optional;
  typedef ::xsd::cxx::tree::traits< to_type, char > to_traits;

  const to_optional&
  to () const;

  to_optional&
  to ();

  void
  to (const to_type& x);

  void
  to (const to_optional& x);

  void
  to (::std::unique_ptr< to_type > p);

  // Constructors.
  //
  relationship ();

  relationship (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  relationship (const relationship& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual relationship*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  relationship&
  operator= (const relationship& x);

  virtual 
  ~relationship ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  type_optional type_;
  to_optional to_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::unique_ptr< ::def >
def_ (const ::std::string& uri,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::def >
def_ (const ::std::string& uri,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::def >
def_ (const ::std::string& uri,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::unique_ptr< ::def >
def_ (::std::istream& is,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::def >
def_ (::std::istream& is,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::def >
def_ (::std::istream& is,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::def >
def_ (::std::istream& is,
      const ::std::string& id,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::def >
def_ (::std::istream& is,
      const ::std::string& id,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::def >
def_ (::std::istream& is,
      const ::std::string& id,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::unique_ptr< ::def >
def_ (::xercesc::InputSource& is,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::def >
def_ (::xercesc::InputSource& is,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::def >
def_ (::xercesc::InputSource& is,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::unique_ptr< ::def >
def_ (const ::xercesc::DOMDocument& d,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::def >
def_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse a URI or a local file.
//

::std::unique_ptr< ::obo >
obo_ (const ::std::string& uri,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::obo >
obo_ (const ::std::string& uri,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::obo >
obo_ (const ::std::string& uri,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::unique_ptr< ::obo >
obo_ (::std::istream& is,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::obo >
obo_ (::std::istream& is,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::obo >
obo_ (::std::istream& is,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::obo >
obo_ (::std::istream& is,
      const ::std::string& id,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::obo >
obo_ (::std::istream& is,
      const ::std::string& id,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::obo >
obo_ (::std::istream& is,
      const ::std::string& id,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::unique_ptr< ::obo >
obo_ (::xercesc::InputSource& is,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::obo >
obo_ (::xercesc::InputSource& is,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::obo >
obo_ (::xercesc::InputSource& is,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::unique_ptr< ::obo >
obo_ (const ::xercesc::DOMDocument& d,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::obo >
obo_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

// Serialize to std::ostream.
//

void
def_ (::std::ostream& os,
      const ::def& x, 
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

void
def_ (::std::ostream& os,
      const ::def& x, 
      ::xml_schema::error_handler& eh,
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

void
def_ (::std::ostream& os,
      const ::def& x, 
      ::xercesc::DOMErrorHandler& eh,
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
def_ (::xercesc::XMLFormatTarget& ft,
      const ::def& x, 
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

void
def_ (::xercesc::XMLFormatTarget& ft,
      const ::def& x, 
      ::xml_schema::error_handler& eh,
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

void
def_ (::xercesc::XMLFormatTarget& ft,
      const ::def& x, 
      ::xercesc::DOMErrorHandler& eh,
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
def_ (::xercesc::DOMDocument& d,
      const ::def& x,
      ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
def_ (const ::def& x, 
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      ::xml_schema::flags f = 0);

// Serialize to std::ostream.
//

void
obo_ (::std::ostream& os,
      const ::obo& x, 
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

void
obo_ (::std::ostream& os,
      const ::obo& x, 
      ::xml_schema::error_handler& eh,
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

void
obo_ (::std::ostream& os,
      const ::obo& x, 
      ::xercesc::DOMErrorHandler& eh,
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
obo_ (::xercesc::XMLFormatTarget& ft,
      const ::obo& x, 
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

void
obo_ (::xercesc::XMLFormatTarget& ft,
      const ::obo& x, 
      ::xml_schema::error_handler& eh,
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

void
obo_ (::xercesc::XMLFormatTarget& ft,
      const ::obo& x, 
      ::xercesc::DOMErrorHandler& eh,
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
obo_ (::xercesc::DOMDocument& d,
      const ::obo& x,
      ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
obo_ (const ::obo& x, 
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      ::xml_schema::flags f = 0);

void
operator<< (::xercesc::DOMElement&, const def&);

void
operator<< (::xercesc::DOMElement&, const obo&);

void
operator<< (::xercesc::DOMElement&, const dbxref&);

void
operator<< (::xercesc::DOMElement&, const source&);

void
operator<< (::xercesc::DOMElement&, const header&);

void
operator<< (::xercesc::DOMElement&, const term&);

void
operator<< (::xercesc::DOMElement&, const typedef_&);

void
operator<< (::xercesc::DOMElement&, const subsetdef&);

void
operator<< (::xercesc::DOMElement&, const synonymtypedef&);

void
operator<< (::xercesc::DOMElement&, const remark&);

void
operator<< (::xercesc::DOMAttr&, const remark&);

void
operator<< (::xml_schema::list_stream&,
            const remark&);

void
operator<< (::xercesc::DOMElement&, const synonym&);

void
operator<< (::xercesc::DOMElement&, const xref_analog&);

void
operator<< (::xercesc::DOMElement&, const is_a&);

void
operator<< (::xercesc::DOMAttr&, const is_a&);

void
operator<< (::xml_schema::list_stream&,
            const is_a&);

void
operator<< (::xercesc::DOMElement&, const relationship&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // PSI_MOD_OBO_H
