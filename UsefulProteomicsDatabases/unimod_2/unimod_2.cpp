// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "unimod_2.h"

namespace xmlns
{
  namespace schema
  {
    namespace unimod_2
    {
      // unimod_t
      // 

      const unimod_t::elements_optional& unimod_t::
      elements () const
      {
        return this->elements_;
      }

      unimod_t::elements_optional& unimod_t::
      elements ()
      {
        return this->elements_;
      }

      void unimod_t::
      elements (const elements_type& x)
      {
        this->elements_.set (x);
      }

      void unimod_t::
      elements (const elements_optional& x)
      {
        this->elements_ = x;
      }

      void unimod_t::
      elements (::std::unique_ptr< elements_type > x)
      {
        this->elements_.set (std::move (x));
      }

      const unimod_t::modifications_optional& unimod_t::
      modifications () const
      {
        return this->modifications_;
      }

      unimod_t::modifications_optional& unimod_t::
      modifications ()
      {
        return this->modifications_;
      }

      void unimod_t::
      modifications (const modifications_type& x)
      {
        this->modifications_.set (x);
      }

      void unimod_t::
      modifications (const modifications_optional& x)
      {
        this->modifications_ = x;
      }

      void unimod_t::
      modifications (::std::unique_ptr< modifications_type > x)
      {
        this->modifications_.set (std::move (x));
      }

      const unimod_t::amino_acids_optional& unimod_t::
      amino_acids () const
      {
        return this->amino_acids_;
      }

      unimod_t::amino_acids_optional& unimod_t::
      amino_acids ()
      {
        return this->amino_acids_;
      }

      void unimod_t::
      amino_acids (const amino_acids_type& x)
      {
        this->amino_acids_.set (x);
      }

      void unimod_t::
      amino_acids (const amino_acids_optional& x)
      {
        this->amino_acids_ = x;
      }

      void unimod_t::
      amino_acids (::std::unique_ptr< amino_acids_type > x)
      {
        this->amino_acids_.set (std::move (x));
      }

      const unimod_t::mod_bricks_optional& unimod_t::
      mod_bricks () const
      {
        return this->mod_bricks_;
      }

      unimod_t::mod_bricks_optional& unimod_t::
      mod_bricks ()
      {
        return this->mod_bricks_;
      }

      void unimod_t::
      mod_bricks (const mod_bricks_type& x)
      {
        this->mod_bricks_.set (x);
      }

      void unimod_t::
      mod_bricks (const mod_bricks_optional& x)
      {
        this->mod_bricks_ = x;
      }

      void unimod_t::
      mod_bricks (::std::unique_ptr< mod_bricks_type > x)
      {
        this->mod_bricks_.set (std::move (x));
      }

      const unimod_t::majorVersion_type& unimod_t::
      majorVersion () const
      {
        return this->majorVersion_.get ();
      }

      unimod_t::majorVersion_type unimod_t::
      majorVersion_default_value ()
      {
        return majorVersion_type (2U);
      }

      const unimod_t::minorVersion_type& unimod_t::
      minorVersion () const
      {
        return this->minorVersion_.get ();
      }

      unimod_t::minorVersion_type& unimod_t::
      minorVersion ()
      {
        return this->minorVersion_.get ();
      }

      void unimod_t::
      minorVersion (const minorVersion_type& x)
      {
        this->minorVersion_.set (x);
      }

      void unimod_t::
      minorVersion (::std::unique_ptr< minorVersion_type > x)
      {
        this->minorVersion_.set (std::move (x));
      }


      // minorVersion_t
      // 


      // elements_t
      // 

      const elements_t::elem_sequence& elements_t::
      elem () const
      {
        return this->elem_;
      }

      elements_t::elem_sequence& elements_t::
      elem ()
      {
        return this->elem_;
      }

      void elements_t::
      elem (const elem_sequence& s)
      {
        this->elem_ = s;
      }


      // modifications_t
      // 

      const modifications_t::mod_sequence& modifications_t::
      mod () const
      {
        return this->mod_;
      }

      modifications_t::mod_sequence& modifications_t::
      mod ()
      {
        return this->mod_;
      }

      void modifications_t::
      mod (const mod_sequence& s)
      {
        this->mod_ = s;
      }


      // amino_acids_t
      // 

      const amino_acids_t::aa_sequence& amino_acids_t::
      aa () const
      {
        return this->aa_;
      }

      amino_acids_t::aa_sequence& amino_acids_t::
      aa ()
      {
        return this->aa_;
      }

      void amino_acids_t::
      aa (const aa_sequence& s)
      {
        this->aa_ = s;
      }


      // mod_bricks_t
      // 

      const mod_bricks_t::brick_sequence& mod_bricks_t::
      brick () const
      {
        return this->brick_;
      }

      mod_bricks_t::brick_sequence& mod_bricks_t::
      brick ()
      {
        return this->brick_;
      }

      void mod_bricks_t::
      brick (const brick_sequence& s)
      {
        this->brick_ = s;
      }


      // elem_t
      // 

      const elem_t::title_type& elem_t::
      title () const
      {
        return this->title_.get ();
      }

      elem_t::title_type& elem_t::
      title ()
      {
        return this->title_.get ();
      }

      void elem_t::
      title (const title_type& x)
      {
        this->title_.set (x);
      }

      void elem_t::
      title (::std::unique_ptr< title_type > x)
      {
        this->title_.set (std::move (x));
      }

      const elem_t::full_name_type& elem_t::
      full_name () const
      {
        return this->full_name_.get ();
      }

      elem_t::full_name_type& elem_t::
      full_name ()
      {
        return this->full_name_.get ();
      }

      void elem_t::
      full_name (const full_name_type& x)
      {
        this->full_name_.set (x);
      }

      void elem_t::
      full_name (::std::unique_ptr< full_name_type > x)
      {
        this->full_name_.set (std::move (x));
      }

      const elem_t::avge_mass_type& elem_t::
      avge_mass () const
      {
        return this->avge_mass_.get ();
      }

      elem_t::avge_mass_type& elem_t::
      avge_mass ()
      {
        return this->avge_mass_.get ();
      }

      void elem_t::
      avge_mass (const avge_mass_type& x)
      {
        this->avge_mass_.set (x);
      }

      const elem_t::mono_mass_type& elem_t::
      mono_mass () const
      {
        return this->mono_mass_.get ();
      }

      elem_t::mono_mass_type& elem_t::
      mono_mass ()
      {
        return this->mono_mass_.get ();
      }

      void elem_t::
      mono_mass (const mono_mass_type& x)
      {
        this->mono_mass_.set (x);
      }


      // mod_t
      // 

      const mod_t::specificity_sequence& mod_t::
      specificity () const
      {
        return this->specificity_;
      }

      mod_t::specificity_sequence& mod_t::
      specificity ()
      {
        return this->specificity_;
      }

      void mod_t::
      specificity (const specificity_sequence& s)
      {
        this->specificity_ = s;
      }

      const mod_t::delta_type& mod_t::
      delta () const
      {
        return this->delta_.get ();
      }

      mod_t::delta_type& mod_t::
      delta ()
      {
        return this->delta_.get ();
      }

      void mod_t::
      delta (const delta_type& x)
      {
        this->delta_.set (x);
      }

      void mod_t::
      delta (::std::unique_ptr< delta_type > x)
      {
        this->delta_.set (std::move (x));
      }

      const mod_t::Ignore_sequence& mod_t::
      Ignore () const
      {
        return this->Ignore_;
      }

      mod_t::Ignore_sequence& mod_t::
      Ignore ()
      {
        return this->Ignore_;
      }

      void mod_t::
      Ignore (const Ignore_sequence& s)
      {
        this->Ignore_ = s;
      }

      const mod_t::alt_name_sequence& mod_t::
      alt_name () const
      {
        return this->alt_name_;
      }

      mod_t::alt_name_sequence& mod_t::
      alt_name ()
      {
        return this->alt_name_;
      }

      void mod_t::
      alt_name (const alt_name_sequence& s)
      {
        this->alt_name_ = s;
      }

      const mod_t::xref_sequence& mod_t::
      xref () const
      {
        return this->xref_;
      }

      mod_t::xref_sequence& mod_t::
      xref ()
      {
        return this->xref_;
      }

      void mod_t::
      xref (const xref_sequence& s)
      {
        this->xref_ = s;
      }

      const mod_t::misc_notes_optional& mod_t::
      misc_notes () const
      {
        return this->misc_notes_;
      }

      mod_t::misc_notes_optional& mod_t::
      misc_notes ()
      {
        return this->misc_notes_;
      }

      void mod_t::
      misc_notes (const misc_notes_type& x)
      {
        this->misc_notes_.set (x);
      }

      void mod_t::
      misc_notes (const misc_notes_optional& x)
      {
        this->misc_notes_ = x;
      }

      void mod_t::
      misc_notes (::std::unique_ptr< misc_notes_type > x)
      {
        this->misc_notes_.set (std::move (x));
      }

      const mod_t::title_type& mod_t::
      title () const
      {
        return this->title_.get ();
      }

      mod_t::title_type& mod_t::
      title ()
      {
        return this->title_.get ();
      }

      void mod_t::
      title (const title_type& x)
      {
        this->title_.set (x);
      }

      void mod_t::
      title (::std::unique_ptr< title_type > x)
      {
        this->title_.set (std::move (x));
      }

      const mod_t::full_name_type& mod_t::
      full_name () const
      {
        return this->full_name_.get ();
      }

      mod_t::full_name_type& mod_t::
      full_name ()
      {
        return this->full_name_.get ();
      }

      void mod_t::
      full_name (const full_name_type& x)
      {
        this->full_name_.set (x);
      }

      void mod_t::
      full_name (::std::unique_ptr< full_name_type > x)
      {
        this->full_name_.set (std::move (x));
      }

      const mod_t::username_of_poster_type& mod_t::
      username_of_poster () const
      {
        return this->username_of_poster_.get ();
      }

      mod_t::username_of_poster_type& mod_t::
      username_of_poster ()
      {
        return this->username_of_poster_.get ();
      }

      void mod_t::
      username_of_poster (const username_of_poster_type& x)
      {
        this->username_of_poster_.set (x);
      }

      void mod_t::
      username_of_poster (::std::unique_ptr< username_of_poster_type > x)
      {
        this->username_of_poster_.set (std::move (x));
      }

      const mod_t::group_of_poster_optional& mod_t::
      group_of_poster () const
      {
        return this->group_of_poster_;
      }

      mod_t::group_of_poster_optional& mod_t::
      group_of_poster ()
      {
        return this->group_of_poster_;
      }

      void mod_t::
      group_of_poster (const group_of_poster_type& x)
      {
        this->group_of_poster_.set (x);
      }

      void mod_t::
      group_of_poster (const group_of_poster_optional& x)
      {
        this->group_of_poster_ = x;
      }

      void mod_t::
      group_of_poster (::std::unique_ptr< group_of_poster_type > x)
      {
        this->group_of_poster_.set (std::move (x));
      }

      const mod_t::date_time_posted_type& mod_t::
      date_time_posted () const
      {
        return this->date_time_posted_.get ();
      }

      mod_t::date_time_posted_type& mod_t::
      date_time_posted ()
      {
        return this->date_time_posted_.get ();
      }

      void mod_t::
      date_time_posted (const date_time_posted_type& x)
      {
        this->date_time_posted_.set (x);
      }

      void mod_t::
      date_time_posted (::std::unique_ptr< date_time_posted_type > x)
      {
        this->date_time_posted_.set (std::move (x));
      }

      const mod_t::date_time_modified_type& mod_t::
      date_time_modified () const
      {
        return this->date_time_modified_.get ();
      }

      mod_t::date_time_modified_type& mod_t::
      date_time_modified ()
      {
        return this->date_time_modified_.get ();
      }

      void mod_t::
      date_time_modified (const date_time_modified_type& x)
      {
        this->date_time_modified_.set (x);
      }

      void mod_t::
      date_time_modified (::std::unique_ptr< date_time_modified_type > x)
      {
        this->date_time_modified_.set (std::move (x));
      }

      const mod_t::approved_optional& mod_t::
      approved () const
      {
        return this->approved_;
      }

      mod_t::approved_optional& mod_t::
      approved ()
      {
        return this->approved_;
      }

      void mod_t::
      approved (const approved_type& x)
      {
        this->approved_.set (x);
      }

      void mod_t::
      approved (const approved_optional& x)
      {
        this->approved_ = x;
      }

      const mod_t::ex_code_name_optional& mod_t::
      ex_code_name () const
      {
        return this->ex_code_name_;
      }

      mod_t::ex_code_name_optional& mod_t::
      ex_code_name ()
      {
        return this->ex_code_name_;
      }

      void mod_t::
      ex_code_name (const ex_code_name_type& x)
      {
        this->ex_code_name_.set (x);
      }

      void mod_t::
      ex_code_name (const ex_code_name_optional& x)
      {
        this->ex_code_name_ = x;
      }

      void mod_t::
      ex_code_name (::std::unique_ptr< ex_code_name_type > x)
      {
        this->ex_code_name_.set (std::move (x));
      }

      const mod_t::record_id_optional& mod_t::
      record_id () const
      {
        return this->record_id_;
      }

      mod_t::record_id_optional& mod_t::
      record_id ()
      {
        return this->record_id_;
      }

      void mod_t::
      record_id (const record_id_type& x)
      {
        this->record_id_.set (x);
      }

      void mod_t::
      record_id (const record_id_optional& x)
      {
        this->record_id_ = x;
      }


      // aa_t
      // 

      const aa_t::element_sequence& aa_t::
      element () const
      {
        return this->element_;
      }

      aa_t::element_sequence& aa_t::
      element ()
      {
        return this->element_;
      }

      void aa_t::
      element (const element_sequence& s)
      {
        this->element_ = s;
      }

      const aa_t::title_optional& aa_t::
      title () const
      {
        return this->title_;
      }

      aa_t::title_optional& aa_t::
      title ()
      {
        return this->title_;
      }

      void aa_t::
      title (const title_type& x)
      {
        this->title_.set (x);
      }

      void aa_t::
      title (const title_optional& x)
      {
        this->title_ = x;
      }

      void aa_t::
      title (::std::unique_ptr< title_type > x)
      {
        this->title_.set (std::move (x));
      }

      const aa_t::three_letter_optional& aa_t::
      three_letter () const
      {
        return this->three_letter_;
      }

      aa_t::three_letter_optional& aa_t::
      three_letter ()
      {
        return this->three_letter_;
      }

      void aa_t::
      three_letter (const three_letter_type& x)
      {
        this->three_letter_.set (x);
      }

      void aa_t::
      three_letter (const three_letter_optional& x)
      {
        this->three_letter_ = x;
      }

      void aa_t::
      three_letter (::std::unique_ptr< three_letter_type > x)
      {
        this->three_letter_.set (std::move (x));
      }

      const aa_t::full_name_optional& aa_t::
      full_name () const
      {
        return this->full_name_;
      }

      aa_t::full_name_optional& aa_t::
      full_name ()
      {
        return this->full_name_;
      }

      void aa_t::
      full_name (const full_name_type& x)
      {
        this->full_name_.set (x);
      }

      void aa_t::
      full_name (const full_name_optional& x)
      {
        this->full_name_ = x;
      }

      void aa_t::
      full_name (::std::unique_ptr< full_name_type > x)
      {
        this->full_name_.set (std::move (x));
      }

      const aa_t::mono_mass_optional& aa_t::
      mono_mass () const
      {
        return this->mono_mass_;
      }

      aa_t::mono_mass_optional& aa_t::
      mono_mass ()
      {
        return this->mono_mass_;
      }

      void aa_t::
      mono_mass (const mono_mass_type& x)
      {
        this->mono_mass_.set (x);
      }

      void aa_t::
      mono_mass (const mono_mass_optional& x)
      {
        this->mono_mass_ = x;
      }

      const aa_t::avge_mass_optional& aa_t::
      avge_mass () const
      {
        return this->avge_mass_;
      }

      aa_t::avge_mass_optional& aa_t::
      avge_mass ()
      {
        return this->avge_mass_;
      }

      void aa_t::
      avge_mass (const avge_mass_type& x)
      {
        this->avge_mass_.set (x);
      }

      void aa_t::
      avge_mass (const avge_mass_optional& x)
      {
        this->avge_mass_ = x;
      }


      // brick_t
      // 

      const brick_t::element_sequence& brick_t::
      element () const
      {
        return this->element_;
      }

      brick_t::element_sequence& brick_t::
      element ()
      {
        return this->element_;
      }

      void brick_t::
      element (const element_sequence& s)
      {
        this->element_ = s;
      }

      const brick_t::title_optional& brick_t::
      title () const
      {
        return this->title_;
      }

      brick_t::title_optional& brick_t::
      title ()
      {
        return this->title_;
      }

      void brick_t::
      title (const title_type& x)
      {
        this->title_.set (x);
      }

      void brick_t::
      title (const title_optional& x)
      {
        this->title_ = x;
      }

      void brick_t::
      title (::std::unique_ptr< title_type > x)
      {
        this->title_.set (std::move (x));
      }

      const brick_t::full_name_optional& brick_t::
      full_name () const
      {
        return this->full_name_;
      }

      brick_t::full_name_optional& brick_t::
      full_name ()
      {
        return this->full_name_;
      }

      void brick_t::
      full_name (const full_name_type& x)
      {
        this->full_name_.set (x);
      }

      void brick_t::
      full_name (const full_name_optional& x)
      {
        this->full_name_ = x;
      }

      void brick_t::
      full_name (::std::unique_ptr< full_name_type > x)
      {
        this->full_name_.set (std::move (x));
      }

      const brick_t::mono_mass_optional& brick_t::
      mono_mass () const
      {
        return this->mono_mass_;
      }

      brick_t::mono_mass_optional& brick_t::
      mono_mass ()
      {
        return this->mono_mass_;
      }

      void brick_t::
      mono_mass (const mono_mass_type& x)
      {
        this->mono_mass_.set (x);
      }

      void brick_t::
      mono_mass (const mono_mass_optional& x)
      {
        this->mono_mass_ = x;
      }

      const brick_t::avge_mass_optional& brick_t::
      avge_mass () const
      {
        return this->avge_mass_;
      }

      brick_t::avge_mass_optional& brick_t::
      avge_mass ()
      {
        return this->avge_mass_;
      }

      void brick_t::
      avge_mass (const avge_mass_type& x)
      {
        this->avge_mass_.set (x);
      }

      void brick_t::
      avge_mass (const avge_mass_optional& x)
      {
        this->avge_mass_ = x;
      }


      // specificity_t
      // 

      const specificity_t::NeutralLoss_sequence& specificity_t::
      NeutralLoss () const
      {
        return this->NeutralLoss_;
      }

      specificity_t::NeutralLoss_sequence& specificity_t::
      NeutralLoss ()
      {
        return this->NeutralLoss_;
      }

      void specificity_t::
      NeutralLoss (const NeutralLoss_sequence& s)
      {
        this->NeutralLoss_ = s;
      }

      const specificity_t::PepNeutralLoss_sequence& specificity_t::
      PepNeutralLoss () const
      {
        return this->PepNeutralLoss_;
      }

      specificity_t::PepNeutralLoss_sequence& specificity_t::
      PepNeutralLoss ()
      {
        return this->PepNeutralLoss_;
      }

      void specificity_t::
      PepNeutralLoss (const PepNeutralLoss_sequence& s)
      {
        this->PepNeutralLoss_ = s;
      }

      const specificity_t::misc_notes_optional& specificity_t::
      misc_notes () const
      {
        return this->misc_notes_;
      }

      specificity_t::misc_notes_optional& specificity_t::
      misc_notes ()
      {
        return this->misc_notes_;
      }

      void specificity_t::
      misc_notes (const misc_notes_type& x)
      {
        this->misc_notes_.set (x);
      }

      void specificity_t::
      misc_notes (const misc_notes_optional& x)
      {
        this->misc_notes_ = x;
      }

      void specificity_t::
      misc_notes (::std::unique_ptr< misc_notes_type > x)
      {
        this->misc_notes_.set (std::move (x));
      }

      const specificity_t::hidden_type& specificity_t::
      hidden () const
      {
        return this->hidden_.get ();
      }

      specificity_t::hidden_type& specificity_t::
      hidden ()
      {
        return this->hidden_.get ();
      }

      void specificity_t::
      hidden (const hidden_type& x)
      {
        this->hidden_.set (x);
      }

      specificity_t::hidden_type specificity_t::
      hidden_default_value ()
      {
        return hidden_type (false);
      }

      const specificity_t::site_type& specificity_t::
      site () const
      {
        return this->site_.get ();
      }

      specificity_t::site_type& specificity_t::
      site ()
      {
        return this->site_.get ();
      }

      void specificity_t::
      site (const site_type& x)
      {
        this->site_.set (x);
      }

      void specificity_t::
      site (::std::unique_ptr< site_type > x)
      {
        this->site_.set (std::move (x));
      }

      const specificity_t::position_type& specificity_t::
      position () const
      {
        return this->position_.get ();
      }

      specificity_t::position_type& specificity_t::
      position ()
      {
        return this->position_.get ();
      }

      void specificity_t::
      position (const position_type& x)
      {
        this->position_.set (x);
      }

      void specificity_t::
      position (::std::unique_ptr< position_type > x)
      {
        this->position_.set (std::move (x));
      }

      const specificity_t::classification_type& specificity_t::
      classification () const
      {
        return this->classification_.get ();
      }

      specificity_t::classification_type& specificity_t::
      classification ()
      {
        return this->classification_.get ();
      }

      void specificity_t::
      classification (const classification_type& x)
      {
        this->classification_.set (x);
      }

      void specificity_t::
      classification (::std::unique_ptr< classification_type > x)
      {
        this->classification_.set (std::move (x));
      }

      const specificity_t::spec_group_type& specificity_t::
      spec_group () const
      {
        return this->spec_group_.get ();
      }

      specificity_t::spec_group_type& specificity_t::
      spec_group ()
      {
        return this->spec_group_.get ();
      }

      void specificity_t::
      spec_group (const spec_group_type& x)
      {
        this->spec_group_.set (x);
      }

      specificity_t::spec_group_type specificity_t::
      spec_group_default_value ()
      {
        return spec_group_type (1LL);
      }


      // composition_t
      // 

      const composition_t::element_sequence& composition_t::
      element () const
      {
        return this->element_;
      }

      composition_t::element_sequence& composition_t::
      element ()
      {
        return this->element_;
      }

      void composition_t::
      element (const element_sequence& s)
      {
        this->element_ = s;
      }

      const composition_t::composition_type& composition_t::
      composition () const
      {
        return this->composition_.get ();
      }

      composition_t::composition_type& composition_t::
      composition ()
      {
        return this->composition_.get ();
      }

      void composition_t::
      composition (const composition_type& x)
      {
        this->composition_.set (x);
      }

      void composition_t::
      composition (::std::unique_ptr< composition_type > x)
      {
        this->composition_.set (std::move (x));
      }

      const composition_t::mono_mass_optional& composition_t::
      mono_mass () const
      {
        return this->mono_mass_;
      }

      composition_t::mono_mass_optional& composition_t::
      mono_mass ()
      {
        return this->mono_mass_;
      }

      void composition_t::
      mono_mass (const mono_mass_type& x)
      {
        this->mono_mass_.set (x);
      }

      void composition_t::
      mono_mass (const mono_mass_optional& x)
      {
        this->mono_mass_ = x;
      }

      const composition_t::avge_mass_optional& composition_t::
      avge_mass () const
      {
        return this->avge_mass_;
      }

      composition_t::avge_mass_optional& composition_t::
      avge_mass ()
      {
        return this->avge_mass_;
      }

      void composition_t::
      avge_mass (const avge_mass_type& x)
      {
        this->avge_mass_.set (x);
      }

      void composition_t::
      avge_mass (const avge_mass_optional& x)
      {
        this->avge_mass_ = x;
      }


      // NeutralLoss_t
      // 

      const NeutralLoss_t::flag_type& NeutralLoss_t::
      flag () const
      {
        return this->flag_.get ();
      }

      NeutralLoss_t::flag_type& NeutralLoss_t::
      flag ()
      {
        return this->flag_.get ();
      }

      void NeutralLoss_t::
      flag (const flag_type& x)
      {
        this->flag_.set (x);
      }

      NeutralLoss_t::flag_type NeutralLoss_t::
      flag_default_value ()
      {
        return flag_type (false);
      }


      // PepNeutralLoss_t
      // 

      const PepNeutralLoss_t::required_type& PepNeutralLoss_t::
      required () const
      {
        return this->required_.get ();
      }

      PepNeutralLoss_t::required_type& PepNeutralLoss_t::
      required ()
      {
        return this->required_.get ();
      }

      void PepNeutralLoss_t::
      required (const required_type& x)
      {
        this->required_.set (x);
      }

      PepNeutralLoss_t::required_type PepNeutralLoss_t::
      required_default_value ()
      {
        return required_type (false);
      }


      // elem_ref_t
      // 

      const elem_ref_t::symbol_type& elem_ref_t::
      symbol () const
      {
        return this->symbol_.get ();
      }

      elem_ref_t::symbol_type& elem_ref_t::
      symbol ()
      {
        return this->symbol_.get ();
      }

      void elem_ref_t::
      symbol (const symbol_type& x)
      {
        this->symbol_.set (x);
      }

      void elem_ref_t::
      symbol (::std::unique_ptr< symbol_type > x)
      {
        this->symbol_.set (std::move (x));
      }

      const elem_ref_t::number_type& elem_ref_t::
      number () const
      {
        return this->number_.get ();
      }

      elem_ref_t::number_type& elem_ref_t::
      number ()
      {
        return this->number_.get ();
      }

      void elem_ref_t::
      number (const number_type& x)
      {
        this->number_.set (x);
      }

      elem_ref_t::number_type elem_ref_t::
      number_default_value ()
      {
        return number_type (1LL);
      }


      // position_t
      // 

      position_t::
      position_t ()
      : ::xml_schema::string ()
      {
      }

      position_t::
      position_t (value v)
      : ::xml_schema::string (_xsd_position_t_literals_[v])
      {
      }

      position_t::
      position_t (const char* v)
      : ::xml_schema::string (v)
      {
      }

      position_t::
      position_t (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      position_t::
      position_t (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      position_t::
      position_t (const position_t& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      position_t& position_t::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_position_t_literals_[v]);

        return *this;
      }


      // xref_t
      // 

      const xref_t::text_type& xref_t::
      text () const
      {
        return this->text_.get ();
      }

      xref_t::text_type& xref_t::
      text ()
      {
        return this->text_.get ();
      }

      void xref_t::
      text (const text_type& x)
      {
        this->text_.set (x);
      }

      void xref_t::
      text (::std::unique_ptr< text_type > x)
      {
        this->text_.set (std::move (x));
      }

      const xref_t::source_type& xref_t::
      source () const
      {
        return this->source_.get ();
      }

      xref_t::source_type& xref_t::
      source ()
      {
        return this->source_.get ();
      }

      void xref_t::
      source (const source_type& x)
      {
        this->source_.set (x);
      }

      void xref_t::
      source (::std::unique_ptr< source_type > x)
      {
        this->source_.set (std::move (x));
      }

      const xref_t::url_optional& xref_t::
      url () const
      {
        return this->url_;
      }

      xref_t::url_optional& xref_t::
      url ()
      {
        return this->url_;
      }

      void xref_t::
      url (const url_type& x)
      {
        this->url_.set (x);
      }

      void xref_t::
      url (const url_optional& x)
      {
        this->url_ = x;
      }

      void xref_t::
      url (::std::unique_ptr< url_type > x)
      {
        this->url_.set (std::move (x));
      }


      // xref_source_t
      // 

      xref_source_t::
      xref_source_t ()
      : ::xml_schema::string ()
      {
      }

      xref_source_t::
      xref_source_t (value v)
      : ::xml_schema::string (_xsd_xref_source_t_literals_[v])
      {
      }

      xref_source_t::
      xref_source_t (const char* v)
      : ::xml_schema::string (v)
      {
      }

      xref_source_t::
      xref_source_t (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      xref_source_t::
      xref_source_t (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      xref_source_t::
      xref_source_t (const xref_source_t& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      xref_source_t& xref_source_t::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_xref_source_t_literals_[v]);

        return *this;
      }


      // classification_t
      // 

      classification_t::
      classification_t ()
      : ::xml_schema::string ()
      {
      }

      classification_t::
      classification_t (value v)
      : ::xml_schema::string (_xsd_classification_t_literals_[v])
      {
      }

      classification_t::
      classification_t (const char* v)
      : ::xml_schema::string (v)
      {
      }

      classification_t::
      classification_t (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      classification_t::
      classification_t (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      classification_t::
      classification_t (const classification_t& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      classification_t& classification_t::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_classification_t_literals_[v]);

        return *this;
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace xmlns
{
  namespace schema
  {
    namespace unimod_2
    {
      // unimod_t
      //

      unimod_t::
      unimod_t ()
      : ::xml_schema::type (),
        elements_ (this),
        modifications_ (this),
        amino_acids_ (this),
        mod_bricks_ (this),
        majorVersion_ (majorVersion_default_value (), this),
        minorVersion_ (this)
      {
      }

      unimod_t::
      unimod_t (const minorVersion_type& minorVersion)
      : ::xml_schema::type (),
        elements_ (this),
        modifications_ (this),
        amino_acids_ (this),
        mod_bricks_ (this),
        majorVersion_ (majorVersion_default_value (), this),
        minorVersion_ (minorVersion, this)
      {
      }

      unimod_t::
      unimod_t (const unimod_t& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        elements_ (x.elements_, f, this),
        modifications_ (x.modifications_, f, this),
        amino_acids_ (x.amino_acids_, f, this),
        mod_bricks_ (x.mod_bricks_, f, this),
        majorVersion_ (x.majorVersion_, f, this),
        minorVersion_ (x.minorVersion_, f, this)
      {
      }

      unimod_t::
      unimod_t (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        elements_ (this),
        modifications_ (this),
        amino_acids_ (this),
        mod_bricks_ (this),
        majorVersion_ (this),
        minorVersion_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void unimod_t::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // elements
          //
          if (n.name () == "elements" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< elements_type > r (
              elements_traits::create (i, f, this));

            if (!this->elements_)
            {
              this->elements_.set (::std::move (r));
              continue;
            }
          }

          // modifications
          //
          if (n.name () == "modifications" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< modifications_type > r (
              modifications_traits::create (i, f, this));

            if (!this->modifications_)
            {
              this->modifications_.set (::std::move (r));
              continue;
            }
          }

          // amino_acids
          //
          if (n.name () == "amino_acids" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< amino_acids_type > r (
              amino_acids_traits::create (i, f, this));

            if (!this->amino_acids_)
            {
              this->amino_acids_.set (::std::move (r));
              continue;
            }
          }

          // mod_bricks
          //
          if (n.name () == "mod_bricks" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< mod_bricks_type > r (
              mod_bricks_traits::create (i, f, this));

            if (!this->mod_bricks_)
            {
              this->mod_bricks_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "majorVersion" && n.namespace_ ().empty ())
          {
            this->majorVersion_.set (majorVersion_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "minorVersion" && n.namespace_ ().empty ())
          {
            this->minorVersion_.set (minorVersion_traits::create (i, f, this));
            continue;
          }
        }

        if (!majorVersion_.present ())
        {
          this->majorVersion_.set (majorVersion_default_value ());
        }

        if (!minorVersion_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "minorVersion",
            "");
        }
      }

      unimod_t* unimod_t::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class unimod_t (*this, f, c);
      }

      unimod_t& unimod_t::
      operator= (const unimod_t& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->elements_ = x.elements_;
          this->modifications_ = x.modifications_;
          this->amino_acids_ = x.amino_acids_;
          this->mod_bricks_ = x.mod_bricks_;
          this->majorVersion_ = x.majorVersion_;
          this->minorVersion_ = x.minorVersion_;
        }

        return *this;
      }

      unimod_t::
      ~unimod_t ()
      {
      }

      // minorVersion_t
      //

      minorVersion_t::
      minorVersion_t ()
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > ()
      {
      }

      minorVersion_t::
      minorVersion_t (const ::xml_schema::unsigned_short& _xsd_unsigned_short_base)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (_xsd_unsigned_short_base)
      {
      }

      minorVersion_t::
      minorVersion_t (const minorVersion_t& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (x, f, c)
      {
      }

      minorVersion_t::
      minorVersion_t (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (e, f, c)
      {
      }

      minorVersion_t::
      minorVersion_t (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (a, f, c)
      {
      }

      minorVersion_t::
      minorVersion_t (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (s, e, f, c)
      {
      }

      minorVersion_t* minorVersion_t::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class minorVersion_t (*this, f, c);
      }

      minorVersion_t::
      ~minorVersion_t ()
      {
      }

      // elements_t
      //

      elements_t::
      elements_t ()
      : ::xml_schema::type (),
        elem_ (this)
      {
      }

      elements_t::
      elements_t (const elements_t& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        elem_ (x.elem_, f, this)
      {
      }

      elements_t::
      elements_t (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        elem_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void elements_t::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // elem
          //
          if (n.name () == "elem" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< elem_type > r (
              elem_traits::create (i, f, this));

            this->elem_.push_back (::std::move (r));
            continue;
          }

          break;
        }
      }

      elements_t* elements_t::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class elements_t (*this, f, c);
      }

      elements_t& elements_t::
      operator= (const elements_t& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->elem_ = x.elem_;
        }

        return *this;
      }

      elements_t::
      ~elements_t ()
      {
      }

      // modifications_t
      //

      modifications_t::
      modifications_t ()
      : ::xml_schema::type (),
        mod_ (this)
      {
      }

      modifications_t::
      modifications_t (const modifications_t& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        mod_ (x.mod_, f, this)
      {
      }

      modifications_t::
      modifications_t (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        mod_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void modifications_t::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // mod
          //
          if (n.name () == "mod" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< mod_type > r (
              mod_traits::create (i, f, this));

            this->mod_.push_back (::std::move (r));
            continue;
          }

          break;
        }
      }

      modifications_t* modifications_t::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class modifications_t (*this, f, c);
      }

      modifications_t& modifications_t::
      operator= (const modifications_t& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->mod_ = x.mod_;
        }

        return *this;
      }

      modifications_t::
      ~modifications_t ()
      {
      }

      // amino_acids_t
      //

      amino_acids_t::
      amino_acids_t ()
      : ::xml_schema::type (),
        aa_ (this)
      {
      }

      amino_acids_t::
      amino_acids_t (const amino_acids_t& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        aa_ (x.aa_, f, this)
      {
      }

      amino_acids_t::
      amino_acids_t (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        aa_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void amino_acids_t::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // aa
          //
          if (n.name () == "aa" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< aa_type > r (
              aa_traits::create (i, f, this));

            this->aa_.push_back (::std::move (r));
            continue;
          }

          break;
        }
      }

      amino_acids_t* amino_acids_t::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class amino_acids_t (*this, f, c);
      }

      amino_acids_t& amino_acids_t::
      operator= (const amino_acids_t& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->aa_ = x.aa_;
        }

        return *this;
      }

      amino_acids_t::
      ~amino_acids_t ()
      {
      }

      // mod_bricks_t
      //

      mod_bricks_t::
      mod_bricks_t ()
      : ::xml_schema::type (),
        brick_ (this)
      {
      }

      mod_bricks_t::
      mod_bricks_t (const mod_bricks_t& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        brick_ (x.brick_, f, this)
      {
      }

      mod_bricks_t::
      mod_bricks_t (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        brick_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void mod_bricks_t::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // brick
          //
          if (n.name () == "brick" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< brick_type > r (
              brick_traits::create (i, f, this));

            this->brick_.push_back (::std::move (r));
            continue;
          }

          break;
        }
      }

      mod_bricks_t* mod_bricks_t::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class mod_bricks_t (*this, f, c);
      }

      mod_bricks_t& mod_bricks_t::
      operator= (const mod_bricks_t& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->brick_ = x.brick_;
        }

        return *this;
      }

      mod_bricks_t::
      ~mod_bricks_t ()
      {
      }

      // elem_t
      //

      elem_t::
      elem_t ()
      : ::xml_schema::type (),
        title_ (this),
        full_name_ (this),
        avge_mass_ (this),
        mono_mass_ (this)
      {
      }

      elem_t::
      elem_t (const title_type& title,
              const full_name_type& full_name,
              const avge_mass_type& avge_mass,
              const mono_mass_type& mono_mass)
      : ::xml_schema::type (),
        title_ (title, this),
        full_name_ (full_name, this),
        avge_mass_ (avge_mass, this),
        mono_mass_ (mono_mass, this)
      {
      }

      elem_t::
      elem_t (const elem_t& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        title_ (x.title_, f, this),
        full_name_ (x.full_name_, f, this),
        avge_mass_ (x.avge_mass_, f, this),
        mono_mass_ (x.mono_mass_, f, this)
      {
      }

      elem_t::
      elem_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        title_ (this),
        full_name_ (this),
        avge_mass_ (this),
        mono_mass_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void elem_t::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "title" && n.namespace_ ().empty ())
          {
            this->title_.set (title_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "full_name" && n.namespace_ ().empty ())
          {
            this->full_name_.set (full_name_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "avge_mass" && n.namespace_ ().empty ())
          {
            this->avge_mass_.set (avge_mass_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "mono_mass" && n.namespace_ ().empty ())
          {
            this->mono_mass_.set (mono_mass_traits::create (i, f, this));
            continue;
          }
        }

        if (!title_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "title",
            "");
        }

        if (!full_name_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "full_name",
            "");
        }

        if (!avge_mass_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "avge_mass",
            "");
        }

        if (!mono_mass_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "mono_mass",
            "");
        }
      }

      elem_t* elem_t::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class elem_t (*this, f, c);
      }

      elem_t& elem_t::
      operator= (const elem_t& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->title_ = x.title_;
          this->full_name_ = x.full_name_;
          this->avge_mass_ = x.avge_mass_;
          this->mono_mass_ = x.mono_mass_;
        }

        return *this;
      }

      elem_t::
      ~elem_t ()
      {
      }

      // mod_t
      //

      mod_t::
      mod_t ()
      : ::xml_schema::type (),
        specificity_ (this),
        delta_ (this),
        Ignore_ (this),
        alt_name_ (this),
        xref_ (this),
        misc_notes_ (this),
        title_ (this),
        full_name_ (this),
        username_of_poster_ (this),
        group_of_poster_ (this),
        date_time_posted_ (this),
        date_time_modified_ (this),
        approved_ (this),
        ex_code_name_ (this),
        record_id_ (this)
      {
      }

      mod_t::
      mod_t (const delta_type& delta,
             const title_type& title,
             const full_name_type& full_name,
             const username_of_poster_type& username_of_poster,
             const date_time_posted_type& date_time_posted,
             const date_time_modified_type& date_time_modified)
      : ::xml_schema::type (),
        specificity_ (this),
        delta_ (delta, this),
        Ignore_ (this),
        alt_name_ (this),
        xref_ (this),
        misc_notes_ (this),
        title_ (title, this),
        full_name_ (full_name, this),
        username_of_poster_ (username_of_poster, this),
        group_of_poster_ (this),
        date_time_posted_ (date_time_posted, this),
        date_time_modified_ (date_time_modified, this),
        approved_ (this),
        ex_code_name_ (this),
        record_id_ (this)
      {
      }

      mod_t::
      mod_t (::std::unique_ptr< delta_type > delta,
             const title_type& title,
             const full_name_type& full_name,
             const username_of_poster_type& username_of_poster,
             const date_time_posted_type& date_time_posted,
             const date_time_modified_type& date_time_modified)
      : ::xml_schema::type (),
        specificity_ (this),
        delta_ (std::move (delta), this),
        Ignore_ (this),
        alt_name_ (this),
        xref_ (this),
        misc_notes_ (this),
        title_ (title, this),
        full_name_ (full_name, this),
        username_of_poster_ (username_of_poster, this),
        group_of_poster_ (this),
        date_time_posted_ (date_time_posted, this),
        date_time_modified_ (date_time_modified, this),
        approved_ (this),
        ex_code_name_ (this),
        record_id_ (this)
      {
      }

      mod_t::
      mod_t (const mod_t& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        specificity_ (x.specificity_, f, this),
        delta_ (x.delta_, f, this),
        Ignore_ (x.Ignore_, f, this),
        alt_name_ (x.alt_name_, f, this),
        xref_ (x.xref_, f, this),
        misc_notes_ (x.misc_notes_, f, this),
        title_ (x.title_, f, this),
        full_name_ (x.full_name_, f, this),
        username_of_poster_ (x.username_of_poster_, f, this),
        group_of_poster_ (x.group_of_poster_, f, this),
        date_time_posted_ (x.date_time_posted_, f, this),
        date_time_modified_ (x.date_time_modified_, f, this),
        approved_ (x.approved_, f, this),
        ex_code_name_ (x.ex_code_name_, f, this),
        record_id_ (x.record_id_, f, this)
      {
      }

      mod_t::
      mod_t (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        specificity_ (this),
        delta_ (this),
        Ignore_ (this),
        alt_name_ (this),
        xref_ (this),
        misc_notes_ (this),
        title_ (this),
        full_name_ (this),
        username_of_poster_ (this),
        group_of_poster_ (this),
        date_time_posted_ (this),
        date_time_modified_ (this),
        approved_ (this),
        ex_code_name_ (this),
        record_id_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void mod_t::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // specificity
          //
          if (n.name () == "specificity" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< specificity_type > r (
              specificity_traits::create (i, f, this));

            this->specificity_.push_back (::std::move (r));
            continue;
          }

          // delta
          //
          if (n.name () == "delta" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< delta_type > r (
              delta_traits::create (i, f, this));

            if (!delta_.present ())
            {
              this->delta_.set (::std::move (r));
              continue;
            }
          }

          // Ignore
          //
          if (n.name () == "Ignore" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< Ignore_type > r (
              Ignore_traits::create (i, f, this));

            this->Ignore_.push_back (::std::move (r));
            continue;
          }

          // alt_name
          //
          if (n.name () == "alt_name" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< alt_name_type > r (
              alt_name_traits::create (i, f, this));

            this->alt_name_.push_back (::std::move (r));
            continue;
          }

          // xref
          //
          if (n.name () == "xref" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< xref_type > r (
              xref_traits::create (i, f, this));

            this->xref_.push_back (::std::move (r));
            continue;
          }

          // misc_notes
          //
          if (n.name () == "misc_notes" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< misc_notes_type > r (
              misc_notes_traits::create (i, f, this));

            if (!this->misc_notes_)
            {
              this->misc_notes_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!delta_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "delta",
            "http://www.unimod.org/xmlns/schema/unimod_2");
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "title" && n.namespace_ ().empty ())
          {
            this->title_.set (title_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "full_name" && n.namespace_ ().empty ())
          {
            this->full_name_.set (full_name_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "username_of_poster" && n.namespace_ ().empty ())
          {
            this->username_of_poster_.set (username_of_poster_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "group_of_poster" && n.namespace_ ().empty ())
          {
            this->group_of_poster_.set (group_of_poster_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "date_time_posted" && n.namespace_ ().empty ())
          {
            this->date_time_posted_.set (date_time_posted_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "date_time_modified" && n.namespace_ ().empty ())
          {
            this->date_time_modified_.set (date_time_modified_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "approved" && n.namespace_ ().empty ())
          {
            this->approved_.set (approved_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "ex_code_name" && n.namespace_ ().empty ())
          {
            this->ex_code_name_.set (ex_code_name_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "record_id" && n.namespace_ ().empty ())
          {
            this->record_id_.set (record_id_traits::create (i, f, this));
            continue;
          }
        }

        if (!title_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "title",
            "");
        }

        if (!full_name_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "full_name",
            "");
        }

        if (!username_of_poster_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "username_of_poster",
            "");
        }

        if (!date_time_posted_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "date_time_posted",
            "");
        }

        if (!date_time_modified_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "date_time_modified",
            "");
        }
      }

      mod_t* mod_t::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class mod_t (*this, f, c);
      }

      mod_t& mod_t::
      operator= (const mod_t& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->specificity_ = x.specificity_;
          this->delta_ = x.delta_;
          this->Ignore_ = x.Ignore_;
          this->alt_name_ = x.alt_name_;
          this->xref_ = x.xref_;
          this->misc_notes_ = x.misc_notes_;
          this->title_ = x.title_;
          this->full_name_ = x.full_name_;
          this->username_of_poster_ = x.username_of_poster_;
          this->group_of_poster_ = x.group_of_poster_;
          this->date_time_posted_ = x.date_time_posted_;
          this->date_time_modified_ = x.date_time_modified_;
          this->approved_ = x.approved_;
          this->ex_code_name_ = x.ex_code_name_;
          this->record_id_ = x.record_id_;
        }

        return *this;
      }

      mod_t::
      ~mod_t ()
      {
      }

      // aa_t
      //

      aa_t::
      aa_t ()
      : ::xml_schema::type (),
        element_ (this),
        title_ (this),
        three_letter_ (this),
        full_name_ (this),
        mono_mass_ (this),
        avge_mass_ (this)
      {
      }

      aa_t::
      aa_t (const aa_t& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        element_ (x.element_, f, this),
        title_ (x.title_, f, this),
        three_letter_ (x.three_letter_, f, this),
        full_name_ (x.full_name_, f, this),
        mono_mass_ (x.mono_mass_, f, this),
        avge_mass_ (x.avge_mass_, f, this)
      {
      }

      aa_t::
      aa_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        element_ (this),
        title_ (this),
        three_letter_ (this),
        full_name_ (this),
        mono_mass_ (this),
        avge_mass_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void aa_t::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // element
          //
          if (n.name () == "element" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< element_type > r (
              element_traits::create (i, f, this));

            this->element_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "title" && n.namespace_ ().empty ())
          {
            this->title_.set (title_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "three_letter" && n.namespace_ ().empty ())
          {
            this->three_letter_.set (three_letter_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "full_name" && n.namespace_ ().empty ())
          {
            this->full_name_.set (full_name_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "mono_mass" && n.namespace_ ().empty ())
          {
            this->mono_mass_.set (mono_mass_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "avge_mass" && n.namespace_ ().empty ())
          {
            this->avge_mass_.set (avge_mass_traits::create (i, f, this));
            continue;
          }
        }
      }

      aa_t* aa_t::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class aa_t (*this, f, c);
      }

      aa_t& aa_t::
      operator= (const aa_t& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->element_ = x.element_;
          this->title_ = x.title_;
          this->three_letter_ = x.three_letter_;
          this->full_name_ = x.full_name_;
          this->mono_mass_ = x.mono_mass_;
          this->avge_mass_ = x.avge_mass_;
        }

        return *this;
      }

      aa_t::
      ~aa_t ()
      {
      }

      // brick_t
      //

      brick_t::
      brick_t ()
      : ::xml_schema::type (),
        element_ (this),
        title_ (this),
        full_name_ (this),
        mono_mass_ (this),
        avge_mass_ (this)
      {
      }

      brick_t::
      brick_t (const brick_t& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        element_ (x.element_, f, this),
        title_ (x.title_, f, this),
        full_name_ (x.full_name_, f, this),
        mono_mass_ (x.mono_mass_, f, this),
        avge_mass_ (x.avge_mass_, f, this)
      {
      }

      brick_t::
      brick_t (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        element_ (this),
        title_ (this),
        full_name_ (this),
        mono_mass_ (this),
        avge_mass_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void brick_t::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // element
          //
          if (n.name () == "element" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< element_type > r (
              element_traits::create (i, f, this));

            this->element_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "title" && n.namespace_ ().empty ())
          {
            this->title_.set (title_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "full_name" && n.namespace_ ().empty ())
          {
            this->full_name_.set (full_name_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "mono_mass" && n.namespace_ ().empty ())
          {
            this->mono_mass_.set (mono_mass_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "avge_mass" && n.namespace_ ().empty ())
          {
            this->avge_mass_.set (avge_mass_traits::create (i, f, this));
            continue;
          }
        }
      }

      brick_t* brick_t::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class brick_t (*this, f, c);
      }

      brick_t& brick_t::
      operator= (const brick_t& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->element_ = x.element_;
          this->title_ = x.title_;
          this->full_name_ = x.full_name_;
          this->mono_mass_ = x.mono_mass_;
          this->avge_mass_ = x.avge_mass_;
        }

        return *this;
      }

      brick_t::
      ~brick_t ()
      {
      }

      // specificity_t
      //

      specificity_t::
      specificity_t ()
      : ::xml_schema::type (),
        NeutralLoss_ (this),
        PepNeutralLoss_ (this),
        misc_notes_ (this),
        hidden_ (hidden_default_value (), this),
        site_ (this),
        position_ (this),
        classification_ (this),
        spec_group_ (spec_group_default_value (), this)
      {
      }

      specificity_t::
      specificity_t (const site_type& site,
                     const position_type& position,
                     const classification_type& classification)
      : ::xml_schema::type (),
        NeutralLoss_ (this),
        PepNeutralLoss_ (this),
        misc_notes_ (this),
        hidden_ (hidden_default_value (), this),
        site_ (site, this),
        position_ (position, this),
        classification_ (classification, this),
        spec_group_ (spec_group_default_value (), this)
      {
      }

      specificity_t::
      specificity_t (const specificity_t& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        NeutralLoss_ (x.NeutralLoss_, f, this),
        PepNeutralLoss_ (x.PepNeutralLoss_, f, this),
        misc_notes_ (x.misc_notes_, f, this),
        hidden_ (x.hidden_, f, this),
        site_ (x.site_, f, this),
        position_ (x.position_, f, this),
        classification_ (x.classification_, f, this),
        spec_group_ (x.spec_group_, f, this)
      {
      }

      specificity_t::
      specificity_t (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        NeutralLoss_ (this),
        PepNeutralLoss_ (this),
        misc_notes_ (this),
        hidden_ (this),
        site_ (this),
        position_ (this),
        classification_ (this),
        spec_group_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void specificity_t::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // NeutralLoss
          //
          if (n.name () == "NeutralLoss" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< NeutralLoss_type > r (
              NeutralLoss_traits::create (i, f, this));

            this->NeutralLoss_.push_back (::std::move (r));
            continue;
          }

          // PepNeutralLoss
          //
          if (n.name () == "PepNeutralLoss" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< PepNeutralLoss_type > r (
              PepNeutralLoss_traits::create (i, f, this));

            this->PepNeutralLoss_.push_back (::std::move (r));
            continue;
          }

          // misc_notes
          //
          if (n.name () == "misc_notes" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< misc_notes_type > r (
              misc_notes_traits::create (i, f, this));

            if (!this->misc_notes_)
            {
              this->misc_notes_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "hidden" && n.namespace_ ().empty ())
          {
            this->hidden_.set (hidden_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "site" && n.namespace_ ().empty ())
          {
            this->site_.set (site_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "position" && n.namespace_ ().empty ())
          {
            this->position_.set (position_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "classification" && n.namespace_ ().empty ())
          {
            this->classification_.set (classification_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "spec_group" && n.namespace_ ().empty ())
          {
            this->spec_group_.set (spec_group_traits::create (i, f, this));
            continue;
          }
        }

        if (!hidden_.present ())
        {
          this->hidden_.set (hidden_default_value ());
        }

        if (!site_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "site",
            "");
        }

        if (!position_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "position",
            "");
        }

        if (!classification_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "classification",
            "");
        }

        if (!spec_group_.present ())
        {
          this->spec_group_.set (spec_group_default_value ());
        }
      }

      specificity_t* specificity_t::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class specificity_t (*this, f, c);
      }

      specificity_t& specificity_t::
      operator= (const specificity_t& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->NeutralLoss_ = x.NeutralLoss_;
          this->PepNeutralLoss_ = x.PepNeutralLoss_;
          this->misc_notes_ = x.misc_notes_;
          this->hidden_ = x.hidden_;
          this->site_ = x.site_;
          this->position_ = x.position_;
          this->classification_ = x.classification_;
          this->spec_group_ = x.spec_group_;
        }

        return *this;
      }

      specificity_t::
      ~specificity_t ()
      {
      }

      // composition_t
      //

      composition_t::
      composition_t ()
      : ::xml_schema::type (),
        element_ (this),
        composition_ (this),
        mono_mass_ (this),
        avge_mass_ (this)
      {
      }

      composition_t::
      composition_t (const composition_type& composition)
      : ::xml_schema::type (),
        element_ (this),
        composition_ (composition, this),
        mono_mass_ (this),
        avge_mass_ (this)
      {
      }

      composition_t::
      composition_t (const composition_t& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        element_ (x.element_, f, this),
        composition_ (x.composition_, f, this),
        mono_mass_ (x.mono_mass_, f, this),
        avge_mass_ (x.avge_mass_, f, this)
      {
      }

      composition_t::
      composition_t (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        element_ (this),
        composition_ (this),
        mono_mass_ (this),
        avge_mass_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void composition_t::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // element
          //
          if (n.name () == "element" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< element_type > r (
              element_traits::create (i, f, this));

            this->element_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "composition" && n.namespace_ ().empty ())
          {
            this->composition_.set (composition_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "mono_mass" && n.namespace_ ().empty ())
          {
            this->mono_mass_.set (mono_mass_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "avge_mass" && n.namespace_ ().empty ())
          {
            this->avge_mass_.set (avge_mass_traits::create (i, f, this));
            continue;
          }
        }

        if (!composition_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "composition",
            "");
        }
      }

      composition_t* composition_t::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class composition_t (*this, f, c);
      }

      composition_t& composition_t::
      operator= (const composition_t& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->element_ = x.element_;
          this->composition_ = x.composition_;
          this->mono_mass_ = x.mono_mass_;
          this->avge_mass_ = x.avge_mass_;
        }

        return *this;
      }

      composition_t::
      ~composition_t ()
      {
      }

      // NeutralLoss_t
      //

      NeutralLoss_t::
      NeutralLoss_t ()
      : ::xmlns::schema::unimod_2::composition_t (),
        flag_ (flag_default_value (), this)
      {
      }

      NeutralLoss_t::
      NeutralLoss_t (const composition_type& composition)
      : ::xmlns::schema::unimod_2::composition_t (composition),
        flag_ (flag_default_value (), this)
      {
      }

      NeutralLoss_t::
      NeutralLoss_t (const NeutralLoss_t& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
      : ::xmlns::schema::unimod_2::composition_t (x, f, c),
        flag_ (x.flag_, f, this)
      {
      }

      NeutralLoss_t::
      NeutralLoss_t (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
      : ::xmlns::schema::unimod_2::composition_t (e, f | ::xml_schema::flags::base, c),
        flag_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void NeutralLoss_t::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        this->::xmlns::schema::unimod_2::composition_t::parse (p, f);

        p.reset_attributes ();

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "flag" && n.namespace_ ().empty ())
          {
            this->flag_.set (flag_traits::create (i, f, this));
            continue;
          }
        }

        if (!flag_.present ())
        {
          this->flag_.set (flag_default_value ());
        }
      }

      NeutralLoss_t* NeutralLoss_t::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class NeutralLoss_t (*this, f, c);
      }

      NeutralLoss_t& NeutralLoss_t::
      operator= (const NeutralLoss_t& x)
      {
        if (this != &x)
        {
          static_cast< ::xmlns::schema::unimod_2::composition_t& > (*this) = x;
          this->flag_ = x.flag_;
        }

        return *this;
      }

      NeutralLoss_t::
      ~NeutralLoss_t ()
      {
      }

      // PepNeutralLoss_t
      //

      PepNeutralLoss_t::
      PepNeutralLoss_t ()
      : ::xmlns::schema::unimod_2::composition_t (),
        required_ (required_default_value (), this)
      {
      }

      PepNeutralLoss_t::
      PepNeutralLoss_t (const composition_type& composition)
      : ::xmlns::schema::unimod_2::composition_t (composition),
        required_ (required_default_value (), this)
      {
      }

      PepNeutralLoss_t::
      PepNeutralLoss_t (const PepNeutralLoss_t& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
      : ::xmlns::schema::unimod_2::composition_t (x, f, c),
        required_ (x.required_, f, this)
      {
      }

      PepNeutralLoss_t::
      PepNeutralLoss_t (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
      : ::xmlns::schema::unimod_2::composition_t (e, f | ::xml_schema::flags::base, c),
        required_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void PepNeutralLoss_t::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        this->::xmlns::schema::unimod_2::composition_t::parse (p, f);

        p.reset_attributes ();

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "required" && n.namespace_ ().empty ())
          {
            this->required_.set (required_traits::create (i, f, this));
            continue;
          }
        }

        if (!required_.present ())
        {
          this->required_.set (required_default_value ());
        }
      }

      PepNeutralLoss_t* PepNeutralLoss_t::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class PepNeutralLoss_t (*this, f, c);
      }

      PepNeutralLoss_t& PepNeutralLoss_t::
      operator= (const PepNeutralLoss_t& x)
      {
        if (this != &x)
        {
          static_cast< ::xmlns::schema::unimod_2::composition_t& > (*this) = x;
          this->required_ = x.required_;
        }

        return *this;
      }

      PepNeutralLoss_t::
      ~PepNeutralLoss_t ()
      {
      }

      // elem_ref_t
      //

      elem_ref_t::
      elem_ref_t ()
      : ::xml_schema::type (),
        symbol_ (this),
        number_ (number_default_value (), this)
      {
      }

      elem_ref_t::
      elem_ref_t (const symbol_type& symbol)
      : ::xml_schema::type (),
        symbol_ (symbol, this),
        number_ (number_default_value (), this)
      {
      }

      elem_ref_t::
      elem_ref_t (const elem_ref_t& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        symbol_ (x.symbol_, f, this),
        number_ (x.number_, f, this)
      {
      }

      elem_ref_t::
      elem_ref_t (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        symbol_ (this),
        number_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void elem_ref_t::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "symbol" && n.namespace_ ().empty ())
          {
            this->symbol_.set (symbol_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "number" && n.namespace_ ().empty ())
          {
            this->number_.set (number_traits::create (i, f, this));
            continue;
          }
        }

        if (!symbol_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "symbol",
            "");
        }

        if (!number_.present ())
        {
          this->number_.set (number_default_value ());
        }
      }

      elem_ref_t* elem_ref_t::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class elem_ref_t (*this, f, c);
      }

      elem_ref_t& elem_ref_t::
      operator= (const elem_ref_t& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->symbol_ = x.symbol_;
          this->number_ = x.number_;
        }

        return *this;
      }

      elem_ref_t::
      ~elem_ref_t ()
      {
      }

      // position_t
      //

      position_t::
      position_t (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_position_t_convert ();
      }

      position_t::
      position_t (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_position_t_convert ();
      }

      position_t::
      position_t (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_position_t_convert ();
      }

      position_t* position_t::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class position_t (*this, f, c);
      }

      position_t::value position_t::
      _xsd_position_t_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_position_t_literals_);
        const value* i (::std::lower_bound (
                          _xsd_position_t_indexes_,
                          _xsd_position_t_indexes_ + 5,
                          *this,
                          c));

        if (i == _xsd_position_t_indexes_ + 5 || _xsd_position_t_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const position_t::
      _xsd_position_t_literals_[5] =
      {
        "Anywhere",
        "Any N-term",
        "Any C-term",
        "Protein N-term",
        "Protein C-term"
      };

      const position_t::value position_t::
      _xsd_position_t_indexes_[5] =
      {
        ::xmlns::schema::unimod_2::position_t::Any_C_term,
        ::xmlns::schema::unimod_2::position_t::Any_N_term,
        ::xmlns::schema::unimod_2::position_t::Anywhere,
        ::xmlns::schema::unimod_2::position_t::Protein_C_term,
        ::xmlns::schema::unimod_2::position_t::Protein_N_term
      };

      // xref_t
      //

      xref_t::
      xref_t ()
      : ::xml_schema::type (),
        text_ (this),
        source_ (this),
        url_ (this)
      {
      }

      xref_t::
      xref_t (const text_type& text,
              const source_type& source)
      : ::xml_schema::type (),
        text_ (text, this),
        source_ (source, this),
        url_ (this)
      {
      }

      xref_t::
      xref_t (const xref_t& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        text_ (x.text_, f, this),
        source_ (x.source_, f, this),
        url_ (x.url_, f, this)
      {
      }

      xref_t::
      xref_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        text_ (this),
        source_ (this),
        url_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void xref_t::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // text
          //
          if (n.name () == "text" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< text_type > r (
              text_traits::create (i, f, this));

            if (!text_.present ())
            {
              this->text_.set (::std::move (r));
              continue;
            }
          }

          // source
          //
          if (n.name () == "source" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< source_type > r (
              source_traits::create (i, f, this));

            if (!source_.present ())
            {
              this->source_.set (::std::move (r));
              continue;
            }
          }

          // url
          //
          if (n.name () == "url" && n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
          {
            ::std::unique_ptr< url_type > r (
              url_traits::create (i, f, this));

            if (!this->url_)
            {
              this->url_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!text_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "text",
            "http://www.unimod.org/xmlns/schema/unimod_2");
        }

        if (!source_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "source",
            "http://www.unimod.org/xmlns/schema/unimod_2");
        }
      }

      xref_t* xref_t::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class xref_t (*this, f, c);
      }

      xref_t& xref_t::
      operator= (const xref_t& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::type& > (*this) = x;
          this->text_ = x.text_;
          this->source_ = x.source_;
          this->url_ = x.url_;
        }

        return *this;
      }

      xref_t::
      ~xref_t ()
      {
      }

      // xref_source_t
      //

      xref_source_t::
      xref_source_t (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_xref_source_t_convert ();
      }

      xref_source_t::
      xref_source_t (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_xref_source_t_convert ();
      }

      xref_source_t::
      xref_source_t (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_xref_source_t_convert ();
      }

      xref_source_t* xref_source_t::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class xref_source_t (*this, f, c);
      }

      xref_source_t::value xref_source_t::
      _xsd_xref_source_t_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_xref_source_t_literals_);
        const value* i (::std::lower_bound (
                          _xsd_xref_source_t_indexes_,
                          _xsd_xref_source_t_indexes_ + 13,
                          *this,
                          c));

        if (i == _xsd_xref_source_t_indexes_ + 13 || _xsd_xref_source_t_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const xref_source_t::
      _xsd_xref_source_t_literals_[13] =
      {
        "-",
        "PubMed PMID",
        "CAS Registry",
        "CarbBank",
        "RESID",
        "Swiss-Prot",
        "Prosite",
        "Entrez",
        "Book",
        "Journal",
        "Misc. URL",
        "FindMod",
        "Other"
      };

      const xref_source_t::value xref_source_t::
      _xsd_xref_source_t_indexes_[13] =
      {
        ::xmlns::schema::unimod_2::xref_source_t::cxx_,
        ::xmlns::schema::unimod_2::xref_source_t::Book,
        ::xmlns::schema::unimod_2::xref_source_t::CAS_Registry,
        ::xmlns::schema::unimod_2::xref_source_t::CarbBank,
        ::xmlns::schema::unimod_2::xref_source_t::Entrez,
        ::xmlns::schema::unimod_2::xref_source_t::FindMod,
        ::xmlns::schema::unimod_2::xref_source_t::Journal,
        ::xmlns::schema::unimod_2::xref_source_t::Misc__URL,
        ::xmlns::schema::unimod_2::xref_source_t::Other,
        ::xmlns::schema::unimod_2::xref_source_t::Prosite,
        ::xmlns::schema::unimod_2::xref_source_t::PubMed_PMID,
        ::xmlns::schema::unimod_2::xref_source_t::RESID,
        ::xmlns::schema::unimod_2::xref_source_t::Swiss_Prot
      };

      // classification_t
      //

      classification_t::
      classification_t (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_classification_t_convert ();
      }

      classification_t::
      classification_t (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_classification_t_convert ();
      }

      classification_t::
      classification_t (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_classification_t_convert ();
      }

      classification_t* classification_t::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class classification_t (*this, f, c);
      }

      classification_t::value classification_t::
      _xsd_classification_t_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_classification_t_literals_);
        const value* i (::std::lower_bound (
                          _xsd_classification_t_indexes_,
                          _xsd_classification_t_indexes_ + 15,
                          *this,
                          c));

        if (i == _xsd_classification_t_indexes_ + 15 || _xsd_classification_t_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const classification_t::
      _xsd_classification_t_literals_[15] =
      {
        "-",
        "Post-translational",
        "Co-translational",
        "Pre-translational",
        "Chemical derivative",
        "Artefact",
        "N-linked glycosylation",
        "O-linked glycosylation",
        "Other glycosylation",
        "Synth. pep. protect. gp.",
        "Isotopic label",
        "Non-standard residue",
        "Multiple",
        "Other",
        "AA substitution"
      };

      const classification_t::value classification_t::
      _xsd_classification_t_indexes_[15] =
      {
        ::xmlns::schema::unimod_2::classification_t::cxx_,
        ::xmlns::schema::unimod_2::classification_t::AA_substitution,
        ::xmlns::schema::unimod_2::classification_t::Artefact,
        ::xmlns::schema::unimod_2::classification_t::Chemical_derivative,
        ::xmlns::schema::unimod_2::classification_t::Co_translational,
        ::xmlns::schema::unimod_2::classification_t::Isotopic_label,
        ::xmlns::schema::unimod_2::classification_t::Multiple,
        ::xmlns::schema::unimod_2::classification_t::N_linked_glycosylation,
        ::xmlns::schema::unimod_2::classification_t::Non_standard_residue,
        ::xmlns::schema::unimod_2::classification_t::O_linked_glycosylation,
        ::xmlns::schema::unimod_2::classification_t::Other,
        ::xmlns::schema::unimod_2::classification_t::Other_glycosylation,
        ::xmlns::schema::unimod_2::classification_t::Post_translational,
        ::xmlns::schema::unimod_2::classification_t::Pre_translational,
        ::xmlns::schema::unimod_2::classification_t::Synth__pep__protect__gp_
      };
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xmlns
{
  namespace schema
  {
    namespace unimod_2
    {
      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< char > h;

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t > (
          ::xmlns::schema::unimod_2::unimod (
            std::move (d), f | ::xml_schema::flags::own_dom, p));
      }

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t > (
          ::xmlns::schema::unimod_2::unimod (
            std::move (d), f | ::xml_schema::flags::own_dom, p));
      }

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t > (
          ::xmlns::schema::unimod_2::unimod (
            std::move (d), f | ::xml_schema::flags::own_dom, p));
      }

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::xmlns::schema::unimod_2::unimod (isrc, f, p);
      }

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::xmlns::schema::unimod_2::unimod (isrc, h, f, p);
      }

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::xmlns::schema::unimod_2::unimod (isrc, h, f, p);
      }

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::xmlns::schema::unimod_2::unimod (isrc, f, p);
      }

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::xmlns::schema::unimod_2::unimod (isrc, h, f, p);
      }

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::xmlns::schema::unimod_2::unimod (isrc, h, f, p);
      }

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
      {
        ::xsd::cxx::tree::error_handler< char > h;

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t > (
          ::xmlns::schema::unimod_2::unimod (
            std::move (d), f | ::xml_schema::flags::own_dom, p));
      }

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t > (
          ::xmlns::schema::unimod_2::unimod (
            std::move (d), f | ::xml_schema::flags::own_dom, p));
      }

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t > (
          ::xmlns::schema::unimod_2::unimod (
            std::move (d), f | ::xml_schema::flags::own_dom, p));
      }

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
      {
        if (f & ::xml_schema::flags::keep_dom)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

          return ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t > (
            ::xmlns::schema::unimod_2::unimod (
              std::move (d), f | ::xml_schema::flags::own_dom, p));
        }

        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "unimod" &&
            n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
        {
          ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t > r (
            ::xsd::cxx::tree::traits< ::xmlns::schema::unimod_2::unimod_t, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "unimod",
          "http://www.unimod.org/xmlns/schema/unimod_2");
      }

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
          ((f & ::xml_schema::flags::keep_dom) &&
           !(f & ::xml_schema::flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (f & ::xml_schema::flags::keep_dom)
          doc.setUserData (::xml_schema::dom::tree_node_key,
                           (c.get () ? &c : &d),
                           0);

        if (n.name () == "unimod" &&
            n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
        {
          ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t > r (
            ::xsd::cxx::tree::traits< ::xmlns::schema::unimod_2::unimod_t, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "unimod",
          "http://www.unimod.org/xmlns/schema/unimod_2");
      }
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace xmlns
{
  namespace schema
  {
    namespace unimod_2
    {
      void
      unimod (::std::ostream& o,
              const ::xmlns::schema::unimod_2::unimod_t& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0);

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xmlns::schema::unimod_2::unimod (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      unimod (::std::ostream& o,
              const ::xmlns::schema::unimod_2::unimod_t& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0);

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xmlns::schema::unimod_2::unimod (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      unimod (::std::ostream& o,
              const ::xmlns::schema::unimod_2::unimod_t& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xmlns::schema::unimod_2::unimod (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      unimod (::xercesc::XMLFormatTarget& t,
              const ::xmlns::schema::unimod_2::unimod_t& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xmlns::schema::unimod_2::unimod (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      unimod (::xercesc::XMLFormatTarget& t,
              const ::xmlns::schema::unimod_2::unimod_t& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xmlns::schema::unimod_2::unimod (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      unimod (::xercesc::XMLFormatTarget& t,
              const ::xmlns::schema::unimod_2::unimod_t& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xmlns::schema::unimod_2::unimod (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      unimod (::xercesc::DOMDocument& d,
              const ::xmlns::schema::unimod_2::unimod_t& s,
              ::xml_schema::flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "unimod" &&
            n.namespace_ () == "http://www.unimod.org/xmlns/schema/unimod_2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "unimod",
            "http://www.unimod.org/xmlns/schema/unimod_2");
        }
      }

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
      unimod (const ::xmlns::schema::unimod_2::unimod_t& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "unimod",
            "http://www.unimod.org/xmlns/schema/unimod_2",
            m, f));

        ::xmlns::schema::unimod_2::unimod (*d, s, f);
        return d;
      }

      void
      operator<< (::xercesc::DOMElement& e, const unimod_t& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // elements
        //
        if (i.elements ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "elements",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << *i.elements ();
        }

        // modifications
        //
        if (i.modifications ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "modifications",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << *i.modifications ();
        }

        // amino_acids
        //
        if (i.amino_acids ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "amino_acids",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << *i.amino_acids ();
        }

        // mod_bricks
        //
        if (i.mod_bricks ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "mod_bricks",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << *i.mod_bricks ();
        }

        // majorVersion
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "majorVersion",
              e));

          a << i.majorVersion ();
        }

        // minorVersion
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "minorVersion",
              e));

          a << i.minorVersion ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const minorVersion_t& i)
      {
        e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type >& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const minorVersion_t& i)
      {
        a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type >& > (i);
      }

      void
      operator<< (::xml_schema::list_stream& l,
                  const minorVersion_t& i)
      {
        l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type >& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const elements_t& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // elem
        //
        for (elements_t::elem_const_iterator
             b (i.elem ().begin ()), n (i.elem ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "elem",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const modifications_t& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // mod
        //
        for (modifications_t::mod_const_iterator
             b (i.mod ().begin ()), n (i.mod ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "mod",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const amino_acids_t& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // aa
        //
        for (amino_acids_t::aa_const_iterator
             b (i.aa ().begin ()), n (i.aa ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "aa",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const mod_bricks_t& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // brick
        //
        for (mod_bricks_t::brick_const_iterator
             b (i.brick ().begin ()), n (i.brick ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "brick",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const elem_t& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // title
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "title",
              e));

          a << i.title ();
        }

        // full_name
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "full_name",
              e));

          a << i.full_name ();
        }

        // avge_mass
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "avge_mass",
              e));

          a << ::xml_schema::as_double(i.avge_mass ());
        }

        // mono_mass
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "mono_mass",
              e));

          a << ::xml_schema::as_double(i.mono_mass ());
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const mod_t& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // specificity
        //
        for (mod_t::specificity_const_iterator
             b (i.specificity ().begin ()), n (i.specificity ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "specificity",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << *b;
        }

        // delta
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "delta",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << i.delta ();
        }

        // Ignore
        //
        for (mod_t::Ignore_const_iterator
             b (i.Ignore ().begin ()), n (i.Ignore ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Ignore",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << *b;
        }

        // alt_name
        //
        for (mod_t::alt_name_const_iterator
             b (i.alt_name ().begin ()), n (i.alt_name ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "alt_name",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << *b;
        }

        // xref
        //
        for (mod_t::xref_const_iterator
             b (i.xref ().begin ()), n (i.xref ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "xref",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << *b;
        }

        // misc_notes
        //
        if (i.misc_notes ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "misc_notes",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << *i.misc_notes ();
        }

        // title
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "title",
              e));

          a << i.title ();
        }

        // full_name
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "full_name",
              e));

          a << i.full_name ();
        }

        // username_of_poster
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "username_of_poster",
              e));

          a << i.username_of_poster ();
        }

        // group_of_poster
        //
        if (i.group_of_poster ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "group_of_poster",
              e));

          a << *i.group_of_poster ();
        }

        // date_time_posted
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "date_time_posted",
              e));

          a << i.date_time_posted ();
        }

        // date_time_modified
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "date_time_modified",
              e));

          a << i.date_time_modified ();
        }

        // approved
        //
        if (i.approved ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "approved",
              e));

          a << *i.approved ();
        }

        // ex_code_name
        //
        if (i.ex_code_name ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "ex_code_name",
              e));

          a << *i.ex_code_name ();
        }

        // record_id
        //
        if (i.record_id ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "record_id",
              e));

          a << *i.record_id ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const aa_t& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // element
        //
        for (aa_t::element_const_iterator
             b (i.element ().begin ()), n (i.element ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "element",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << *b;
        }

        // title
        //
        if (i.title ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "title",
              e));

          a << *i.title ();
        }

        // three_letter
        //
        if (i.three_letter ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "three_letter",
              e));

          a << *i.three_letter ();
        }

        // full_name
        //
        if (i.full_name ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "full_name",
              e));

          a << *i.full_name ();
        }

        // mono_mass
        //
        if (i.mono_mass ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "mono_mass",
              e));

          a << ::xml_schema::as_double(*i.mono_mass ());
        }

        // avge_mass
        //
        if (i.avge_mass ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "avge_mass",
              e));

          a << ::xml_schema::as_double(*i.avge_mass ());
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const brick_t& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // element
        //
        for (brick_t::element_const_iterator
             b (i.element ().begin ()), n (i.element ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "element",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << *b;
        }

        // title
        //
        if (i.title ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "title",
              e));

          a << *i.title ();
        }

        // full_name
        //
        if (i.full_name ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "full_name",
              e));

          a << *i.full_name ();
        }

        // mono_mass
        //
        if (i.mono_mass ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "mono_mass",
              e));

          a << ::xml_schema::as_double(*i.mono_mass ());
        }

        // avge_mass
        //
        if (i.avge_mass ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "avge_mass",
              e));

          a << ::xml_schema::as_double(*i.avge_mass ());
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const specificity_t& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // NeutralLoss
        //
        for (specificity_t::NeutralLoss_const_iterator
             b (i.NeutralLoss ().begin ()), n (i.NeutralLoss ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "NeutralLoss",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << *b;
        }

        // PepNeutralLoss
        //
        for (specificity_t::PepNeutralLoss_const_iterator
             b (i.PepNeutralLoss ().begin ()), n (i.PepNeutralLoss ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PepNeutralLoss",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << *b;
        }

        // misc_notes
        //
        if (i.misc_notes ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "misc_notes",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << *i.misc_notes ();
        }

        // hidden
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "hidden",
              e));

          a << i.hidden ();
        }

        // site
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "site",
              e));

          a << i.site ();
        }

        // position
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "position",
              e));

          a << i.position ();
        }

        // classification
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "classification",
              e));

          a << i.classification ();
        }

        // spec_group
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "spec_group",
              e));

          a << i.spec_group ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const composition_t& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // element
        //
        for (composition_t::element_const_iterator
             b (i.element ().begin ()), n (i.element ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "element",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << *b;
        }

        // composition
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "composition",
              e));

          a << i.composition ();
        }

        // mono_mass
        //
        if (i.mono_mass ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "mono_mass",
              e));

          a << ::xml_schema::as_double(*i.mono_mass ());
        }

        // avge_mass
        //
        if (i.avge_mass ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "avge_mass",
              e));

          a << ::xml_schema::as_double(*i.avge_mass ());
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const NeutralLoss_t& i)
      {
        e << static_cast< const ::xmlns::schema::unimod_2::composition_t& > (i);

        // flag
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "flag",
              e));

          a << i.flag ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const PepNeutralLoss_t& i)
      {
        e << static_cast< const ::xmlns::schema::unimod_2::composition_t& > (i);

        // required
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "required",
              e));

          a << i.required ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const elem_ref_t& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // symbol
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "symbol",
              e));

          a << i.symbol ();
        }

        // number
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "number",
              e));

          a << i.number ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const position_t& i)
      {
        e << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const position_t& i)
      {
        a << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xml_schema::list_stream& l,
                  const position_t& i)
      {
        l << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const xref_t& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // text
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "text",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << i.text ();
        }

        // source
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "source",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << i.source ();
        }

        // url
        //
        if (i.url ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "url",
              "http://www.unimod.org/xmlns/schema/unimod_2",
              e));

          s << *i.url ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const xref_source_t& i)
      {
        e << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const xref_source_t& i)
      {
        a << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xml_schema::list_stream& l,
                  const xref_source_t& i)
      {
        l << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const classification_t& i)
      {
        e << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const classification_t& i)
      {
        a << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xml_schema::list_stream& l,
                  const classification_t& i)
      {
        l << static_cast< const ::xml_schema::string& > (i);
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

