// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef UNIMOD_2_H
#define UNIMOD_2_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xmlns
{
  namespace schema
  {
    namespace unimod_2
    {
      class unimod_t;
      class minorVersion_t;
      class elements_t;
      class modifications_t;
      class amino_acids_t;
      class mod_bricks_t;
      class elem_t;
      class mod_t;
      class aa_t;
      class brick_t;
      class specificity_t;
      class composition_t;
      class NeutralLoss_t;
      class PepNeutralLoss_t;
      class elem_ref_t;
      class position_t;
      class xref_t;
      class xref_source_t;
      class classification_t;
    }
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

namespace xmlns
{
  namespace schema
  {
    namespace unimod_2
    {
      class unimod_t: public ::xml_schema::type
      {
        public:
        // elements
        //
        typedef ::xmlns::schema::unimod_2::elements_t elements_type;
        typedef ::xsd::cxx::tree::optional< elements_type > elements_optional;
        typedef ::xsd::cxx::tree::traits< elements_type, char > elements_traits;

        const elements_optional&
        elements () const;

        elements_optional&
        elements ();

        void
        elements (const elements_type& x);

        void
        elements (const elements_optional& x);

        void
        elements (::std::unique_ptr< elements_type > p);

        // modifications
        //
        typedef ::xmlns::schema::unimod_2::modifications_t modifications_type;
        typedef ::xsd::cxx::tree::optional< modifications_type > modifications_optional;
        typedef ::xsd::cxx::tree::traits< modifications_type, char > modifications_traits;

        const modifications_optional&
        modifications () const;

        modifications_optional&
        modifications ();

        void
        modifications (const modifications_type& x);

        void
        modifications (const modifications_optional& x);

        void
        modifications (::std::unique_ptr< modifications_type > p);

        // amino_acids
        //
        typedef ::xmlns::schema::unimod_2::amino_acids_t amino_acids_type;
        typedef ::xsd::cxx::tree::optional< amino_acids_type > amino_acids_optional;
        typedef ::xsd::cxx::tree::traits< amino_acids_type, char > amino_acids_traits;

        const amino_acids_optional&
        amino_acids () const;

        amino_acids_optional&
        amino_acids ();

        void
        amino_acids (const amino_acids_type& x);

        void
        amino_acids (const amino_acids_optional& x);

        void
        amino_acids (::std::unique_ptr< amino_acids_type > p);

        // mod_bricks
        //
        typedef ::xmlns::schema::unimod_2::mod_bricks_t mod_bricks_type;
        typedef ::xsd::cxx::tree::optional< mod_bricks_type > mod_bricks_optional;
        typedef ::xsd::cxx::tree::traits< mod_bricks_type, char > mod_bricks_traits;

        const mod_bricks_optional&
        mod_bricks () const;

        mod_bricks_optional&
        mod_bricks ();

        void
        mod_bricks (const mod_bricks_type& x);

        void
        mod_bricks (const mod_bricks_optional& x);

        void
        mod_bricks (::std::unique_ptr< mod_bricks_type > p);

        // majorVersion
        //
        typedef ::xml_schema::unsigned_short majorVersion_type;
        typedef ::xsd::cxx::tree::traits< majorVersion_type, char > majorVersion_traits;

        const majorVersion_type&
        majorVersion () const;

        static majorVersion_type
        majorVersion_default_value ();

        // minorVersion
        //
        typedef ::xmlns::schema::unimod_2::minorVersion_t minorVersion_type;
        typedef ::xsd::cxx::tree::traits< minorVersion_type, char > minorVersion_traits;

        const minorVersion_type&
        minorVersion () const;

        minorVersion_type&
        minorVersion ();

        void
        minorVersion (const minorVersion_type& x);

        void
        minorVersion (::std::unique_ptr< minorVersion_type > p);

        // Constructors.
        //
        unimod_t ();

        unimod_t (const minorVersion_type&);

        unimod_t (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        unimod_t (const unimod_t& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        virtual unimod_t*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        unimod_t&
        operator= (const unimod_t& x);

        virtual 
        ~unimod_t ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        elements_optional elements_;
        modifications_optional modifications_;
        amino_acids_optional amino_acids_;
        mod_bricks_optional mod_bricks_;
        ::xsd::cxx::tree::one< majorVersion_type > majorVersion_;
        ::xsd::cxx::tree::one< minorVersion_type > minorVersion_;
      };

      class minorVersion_t: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type >
      {
        public:
        // Constructors.
        //
        minorVersion_t ();

        minorVersion_t (const ::xml_schema::unsigned_short&);

        minorVersion_t (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        minorVersion_t (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        minorVersion_t (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        minorVersion_t (const minorVersion_t& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        virtual minorVersion_t*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        virtual 
        ~minorVersion_t ();
      };

      class elements_t: public ::xml_schema::type
      {
        public:
        // elem
        //
        typedef ::xmlns::schema::unimod_2::elem_t elem_type;
        typedef ::xsd::cxx::tree::sequence< elem_type > elem_sequence;
        typedef elem_sequence::iterator elem_iterator;
        typedef elem_sequence::const_iterator elem_const_iterator;
        typedef ::xsd::cxx::tree::traits< elem_type, char > elem_traits;

        const elem_sequence&
        elem () const;

        elem_sequence&
        elem ();

        void
        elem (const elem_sequence& s);

        // Constructors.
        //
        elements_t ();

        elements_t (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        elements_t (const elements_t& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        virtual elements_t*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        elements_t&
        operator= (const elements_t& x);

        virtual 
        ~elements_t ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        elem_sequence elem_;
      };

      class modifications_t: public ::xml_schema::type
      {
        public:
        // mod
        //
        typedef ::xmlns::schema::unimod_2::mod_t mod_type;
        typedef ::xsd::cxx::tree::sequence< mod_type > mod_sequence;
        typedef mod_sequence::iterator mod_iterator;
        typedef mod_sequence::const_iterator mod_const_iterator;
        typedef ::xsd::cxx::tree::traits< mod_type, char > mod_traits;

        const mod_sequence&
        mod () const;

        mod_sequence&
        mod ();

        void
        mod (const mod_sequence& s);

        // Constructors.
        //
        modifications_t ();

        modifications_t (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        modifications_t (const modifications_t& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        virtual modifications_t*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        modifications_t&
        operator= (const modifications_t& x);

        virtual 
        ~modifications_t ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        mod_sequence mod_;
      };

      class amino_acids_t: public ::xml_schema::type
      {
        public:
        // aa
        //
        typedef ::xmlns::schema::unimod_2::aa_t aa_type;
        typedef ::xsd::cxx::tree::sequence< aa_type > aa_sequence;
        typedef aa_sequence::iterator aa_iterator;
        typedef aa_sequence::const_iterator aa_const_iterator;
        typedef ::xsd::cxx::tree::traits< aa_type, char > aa_traits;

        const aa_sequence&
        aa () const;

        aa_sequence&
        aa ();

        void
        aa (const aa_sequence& s);

        // Constructors.
        //
        amino_acids_t ();

        amino_acids_t (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        amino_acids_t (const amino_acids_t& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        virtual amino_acids_t*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        amino_acids_t&
        operator= (const amino_acids_t& x);

        virtual 
        ~amino_acids_t ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        aa_sequence aa_;
      };

      class mod_bricks_t: public ::xml_schema::type
      {
        public:
        // brick
        //
        typedef ::xmlns::schema::unimod_2::brick_t brick_type;
        typedef ::xsd::cxx::tree::sequence< brick_type > brick_sequence;
        typedef brick_sequence::iterator brick_iterator;
        typedef brick_sequence::const_iterator brick_const_iterator;
        typedef ::xsd::cxx::tree::traits< brick_type, char > brick_traits;

        const brick_sequence&
        brick () const;

        brick_sequence&
        brick ();

        void
        brick (const brick_sequence& s);

        // Constructors.
        //
        mod_bricks_t ();

        mod_bricks_t (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        mod_bricks_t (const mod_bricks_t& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        virtual mod_bricks_t*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        mod_bricks_t&
        operator= (const mod_bricks_t& x);

        virtual 
        ~mod_bricks_t ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        brick_sequence brick_;
      };

      class elem_t: public ::xml_schema::type
      {
        public:
        // title
        //
        typedef ::xml_schema::string title_type;
        typedef ::xsd::cxx::tree::traits< title_type, char > title_traits;

        const title_type&
        title () const;

        title_type&
        title ();

        void
        title (const title_type& x);

        void
        title (::std::unique_ptr< title_type > p);

        // full_name
        //
        typedef ::xml_schema::string full_name_type;
        typedef ::xsd::cxx::tree::traits< full_name_type, char > full_name_traits;

        const full_name_type&
        full_name () const;

        full_name_type&
        full_name ();

        void
        full_name (const full_name_type& x);

        void
        full_name (::std::unique_ptr< full_name_type > p);

        // avge_mass
        //
        typedef ::xml_schema::double_ avge_mass_type;
        typedef ::xsd::cxx::tree::traits< avge_mass_type, char, ::xsd::cxx::tree::schema_type::double_ > avge_mass_traits;

        const avge_mass_type&
        avge_mass () const;

        avge_mass_type&
        avge_mass ();

        void
        avge_mass (const avge_mass_type& x);

        // mono_mass
        //
        typedef ::xml_schema::double_ mono_mass_type;
        typedef ::xsd::cxx::tree::traits< mono_mass_type, char, ::xsd::cxx::tree::schema_type::double_ > mono_mass_traits;

        const mono_mass_type&
        mono_mass () const;

        mono_mass_type&
        mono_mass ();

        void
        mono_mass (const mono_mass_type& x);

        // Constructors.
        //
        elem_t ();

        elem_t (const title_type&,
                const full_name_type&,
                const avge_mass_type&,
                const mono_mass_type&);

        elem_t (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

        elem_t (const elem_t& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

        virtual elem_t*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        elem_t&
        operator= (const elem_t& x);

        virtual 
        ~elem_t ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< title_type > title_;
        ::xsd::cxx::tree::one< full_name_type > full_name_;
        ::xsd::cxx::tree::one< avge_mass_type > avge_mass_;
        ::xsd::cxx::tree::one< mono_mass_type > mono_mass_;
      };

      class mod_t: public ::xml_schema::type
      {
        public:
        // specificity
        //
        typedef ::xmlns::schema::unimod_2::specificity_t specificity_type;
        typedef ::xsd::cxx::tree::sequence< specificity_type > specificity_sequence;
        typedef specificity_sequence::iterator specificity_iterator;
        typedef specificity_sequence::const_iterator specificity_const_iterator;
        typedef ::xsd::cxx::tree::traits< specificity_type, char > specificity_traits;

        const specificity_sequence&
        specificity () const;

        specificity_sequence&
        specificity ();

        void
        specificity (const specificity_sequence& s);

        // delta
        //
        typedef ::xmlns::schema::unimod_2::composition_t delta_type;
        typedef ::xsd::cxx::tree::traits< delta_type, char > delta_traits;

        const delta_type&
        delta () const;

        delta_type&
        delta ();

        void
        delta (const delta_type& x);

        void
        delta (::std::unique_ptr< delta_type > p);

        // Ignore
        //
        typedef ::xmlns::schema::unimod_2::composition_t Ignore_type;
        typedef ::xsd::cxx::tree::sequence< Ignore_type > Ignore_sequence;
        typedef Ignore_sequence::iterator Ignore_iterator;
        typedef Ignore_sequence::const_iterator Ignore_const_iterator;
        typedef ::xsd::cxx::tree::traits< Ignore_type, char > Ignore_traits;

        const Ignore_sequence&
        Ignore () const;

        Ignore_sequence&
        Ignore ();

        void
        Ignore (const Ignore_sequence& s);

        // alt_name
        //
        typedef ::xml_schema::string alt_name_type;
        typedef ::xsd::cxx::tree::sequence< alt_name_type > alt_name_sequence;
        typedef alt_name_sequence::iterator alt_name_iterator;
        typedef alt_name_sequence::const_iterator alt_name_const_iterator;
        typedef ::xsd::cxx::tree::traits< alt_name_type, char > alt_name_traits;

        const alt_name_sequence&
        alt_name () const;

        alt_name_sequence&
        alt_name ();

        void
        alt_name (const alt_name_sequence& s);

        // xref
        //
        typedef ::xmlns::schema::unimod_2::xref_t xref_type;
        typedef ::xsd::cxx::tree::sequence< xref_type > xref_sequence;
        typedef xref_sequence::iterator xref_iterator;
        typedef xref_sequence::const_iterator xref_const_iterator;
        typedef ::xsd::cxx::tree::traits< xref_type, char > xref_traits;

        const xref_sequence&
        xref () const;

        xref_sequence&
        xref ();

        void
        xref (const xref_sequence& s);

        // misc_notes
        //
        typedef ::xml_schema::string misc_notes_type;
        typedef ::xsd::cxx::tree::optional< misc_notes_type > misc_notes_optional;
        typedef ::xsd::cxx::tree::traits< misc_notes_type, char > misc_notes_traits;

        const misc_notes_optional&
        misc_notes () const;

        misc_notes_optional&
        misc_notes ();

        void
        misc_notes (const misc_notes_type& x);

        void
        misc_notes (const misc_notes_optional& x);

        void
        misc_notes (::std::unique_ptr< misc_notes_type > p);

        // title
        //
        typedef ::xml_schema::string title_type;
        typedef ::xsd::cxx::tree::traits< title_type, char > title_traits;

        const title_type&
        title () const;

        title_type&
        title ();

        void
        title (const title_type& x);

        void
        title (::std::unique_ptr< title_type > p);

        // full_name
        //
        typedef ::xml_schema::string full_name_type;
        typedef ::xsd::cxx::tree::traits< full_name_type, char > full_name_traits;

        const full_name_type&
        full_name () const;

        full_name_type&
        full_name ();

        void
        full_name (const full_name_type& x);

        void
        full_name (::std::unique_ptr< full_name_type > p);

        // username_of_poster
        //
        typedef ::xml_schema::string username_of_poster_type;
        typedef ::xsd::cxx::tree::traits< username_of_poster_type, char > username_of_poster_traits;

        const username_of_poster_type&
        username_of_poster () const;

        username_of_poster_type&
        username_of_poster ();

        void
        username_of_poster (const username_of_poster_type& x);

        void
        username_of_poster (::std::unique_ptr< username_of_poster_type > p);

        // group_of_poster
        //
        typedef ::xml_schema::string group_of_poster_type;
        typedef ::xsd::cxx::tree::optional< group_of_poster_type > group_of_poster_optional;
        typedef ::xsd::cxx::tree::traits< group_of_poster_type, char > group_of_poster_traits;

        const group_of_poster_optional&
        group_of_poster () const;

        group_of_poster_optional&
        group_of_poster ();

        void
        group_of_poster (const group_of_poster_type& x);

        void
        group_of_poster (const group_of_poster_optional& x);

        void
        group_of_poster (::std::unique_ptr< group_of_poster_type > p);

        // date_time_posted
        //
        typedef ::xml_schema::string date_time_posted_type;
        typedef ::xsd::cxx::tree::traits< date_time_posted_type, char > date_time_posted_traits;

        const date_time_posted_type&
        date_time_posted () const;

        date_time_posted_type&
        date_time_posted ();

        void
        date_time_posted (const date_time_posted_type& x);

        void
        date_time_posted (::std::unique_ptr< date_time_posted_type > p);

        // date_time_modified
        //
        typedef ::xml_schema::string date_time_modified_type;
        typedef ::xsd::cxx::tree::traits< date_time_modified_type, char > date_time_modified_traits;

        const date_time_modified_type&
        date_time_modified () const;

        date_time_modified_type&
        date_time_modified ();

        void
        date_time_modified (const date_time_modified_type& x);

        void
        date_time_modified (::std::unique_ptr< date_time_modified_type > p);

        // approved
        //
        typedef ::xml_schema::boolean approved_type;
        typedef ::xsd::cxx::tree::optional< approved_type > approved_optional;
        typedef ::xsd::cxx::tree::traits< approved_type, char > approved_traits;

        const approved_optional&
        approved () const;

        approved_optional&
        approved ();

        void
        approved (const approved_type& x);

        void
        approved (const approved_optional& x);

        // ex_code_name
        //
        typedef ::xml_schema::string ex_code_name_type;
        typedef ::xsd::cxx::tree::optional< ex_code_name_type > ex_code_name_optional;
        typedef ::xsd::cxx::tree::traits< ex_code_name_type, char > ex_code_name_traits;

        const ex_code_name_optional&
        ex_code_name () const;

        ex_code_name_optional&
        ex_code_name ();

        void
        ex_code_name (const ex_code_name_type& x);

        void
        ex_code_name (const ex_code_name_optional& x);

        void
        ex_code_name (::std::unique_ptr< ex_code_name_type > p);

        // record_id
        //
        typedef ::xml_schema::long_ record_id_type;
        typedef ::xsd::cxx::tree::optional< record_id_type > record_id_optional;
        typedef ::xsd::cxx::tree::traits< record_id_type, char > record_id_traits;

        const record_id_optional&
        record_id () const;

        record_id_optional&
        record_id ();

        void
        record_id (const record_id_type& x);

        void
        record_id (const record_id_optional& x);

        // Constructors.
        //
        mod_t ();

        mod_t (const delta_type&,
               const title_type&,
               const full_name_type&,
               const username_of_poster_type&,
               const date_time_posted_type&,
               const date_time_modified_type&);

        mod_t (::std::unique_ptr< delta_type >,
               const title_type&,
               const full_name_type&,
               const username_of_poster_type&,
               const date_time_posted_type&,
               const date_time_modified_type&);

        mod_t (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

        mod_t (const mod_t& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

        virtual mod_t*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        mod_t&
        operator= (const mod_t& x);

        virtual 
        ~mod_t ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        specificity_sequence specificity_;
        ::xsd::cxx::tree::one< delta_type > delta_;
        Ignore_sequence Ignore_;
        alt_name_sequence alt_name_;
        xref_sequence xref_;
        misc_notes_optional misc_notes_;
        ::xsd::cxx::tree::one< title_type > title_;
        ::xsd::cxx::tree::one< full_name_type > full_name_;
        ::xsd::cxx::tree::one< username_of_poster_type > username_of_poster_;
        group_of_poster_optional group_of_poster_;
        ::xsd::cxx::tree::one< date_time_posted_type > date_time_posted_;
        ::xsd::cxx::tree::one< date_time_modified_type > date_time_modified_;
        approved_optional approved_;
        ex_code_name_optional ex_code_name_;
        record_id_optional record_id_;
      };

      class aa_t: public ::xml_schema::type
      {
        public:
        // element
        //
        typedef ::xmlns::schema::unimod_2::elem_ref_t element_type;
        typedef ::xsd::cxx::tree::sequence< element_type > element_sequence;
        typedef element_sequence::iterator element_iterator;
        typedef element_sequence::const_iterator element_const_iterator;
        typedef ::xsd::cxx::tree::traits< element_type, char > element_traits;

        const element_sequence&
        element () const;

        element_sequence&
        element ();

        void
        element (const element_sequence& s);

        // title
        //
        typedef ::xml_schema::string title_type;
        typedef ::xsd::cxx::tree::optional< title_type > title_optional;
        typedef ::xsd::cxx::tree::traits< title_type, char > title_traits;

        const title_optional&
        title () const;

        title_optional&
        title ();

        void
        title (const title_type& x);

        void
        title (const title_optional& x);

        void
        title (::std::unique_ptr< title_type > p);

        // three_letter
        //
        typedef ::xml_schema::string three_letter_type;
        typedef ::xsd::cxx::tree::optional< three_letter_type > three_letter_optional;
        typedef ::xsd::cxx::tree::traits< three_letter_type, char > three_letter_traits;

        const three_letter_optional&
        three_letter () const;

        three_letter_optional&
        three_letter ();

        void
        three_letter (const three_letter_type& x);

        void
        three_letter (const three_letter_optional& x);

        void
        three_letter (::std::unique_ptr< three_letter_type > p);

        // full_name
        //
        typedef ::xml_schema::string full_name_type;
        typedef ::xsd::cxx::tree::optional< full_name_type > full_name_optional;
        typedef ::xsd::cxx::tree::traits< full_name_type, char > full_name_traits;

        const full_name_optional&
        full_name () const;

        full_name_optional&
        full_name ();

        void
        full_name (const full_name_type& x);

        void
        full_name (const full_name_optional& x);

        void
        full_name (::std::unique_ptr< full_name_type > p);

        // mono_mass
        //
        typedef ::xml_schema::double_ mono_mass_type;
        typedef ::xsd::cxx::tree::optional< mono_mass_type > mono_mass_optional;
        typedef ::xsd::cxx::tree::traits< mono_mass_type, char, ::xsd::cxx::tree::schema_type::double_ > mono_mass_traits;

        const mono_mass_optional&
        mono_mass () const;

        mono_mass_optional&
        mono_mass ();

        void
        mono_mass (const mono_mass_type& x);

        void
        mono_mass (const mono_mass_optional& x);

        // avge_mass
        //
        typedef ::xml_schema::double_ avge_mass_type;
        typedef ::xsd::cxx::tree::optional< avge_mass_type > avge_mass_optional;
        typedef ::xsd::cxx::tree::traits< avge_mass_type, char, ::xsd::cxx::tree::schema_type::double_ > avge_mass_traits;

        const avge_mass_optional&
        avge_mass () const;

        avge_mass_optional&
        avge_mass ();

        void
        avge_mass (const avge_mass_type& x);

        void
        avge_mass (const avge_mass_optional& x);

        // Constructors.
        //
        aa_t ();

        aa_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

        aa_t (const aa_t& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

        virtual aa_t*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        aa_t&
        operator= (const aa_t& x);

        virtual 
        ~aa_t ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        element_sequence element_;
        title_optional title_;
        three_letter_optional three_letter_;
        full_name_optional full_name_;
        mono_mass_optional mono_mass_;
        avge_mass_optional avge_mass_;
      };

      class brick_t: public ::xml_schema::type
      {
        public:
        // element
        //
        typedef ::xmlns::schema::unimod_2::elem_ref_t element_type;
        typedef ::xsd::cxx::tree::sequence< element_type > element_sequence;
        typedef element_sequence::iterator element_iterator;
        typedef element_sequence::const_iterator element_const_iterator;
        typedef ::xsd::cxx::tree::traits< element_type, char > element_traits;

        const element_sequence&
        element () const;

        element_sequence&
        element ();

        void
        element (const element_sequence& s);

        // title
        //
        typedef ::xml_schema::string title_type;
        typedef ::xsd::cxx::tree::optional< title_type > title_optional;
        typedef ::xsd::cxx::tree::traits< title_type, char > title_traits;

        const title_optional&
        title () const;

        title_optional&
        title ();

        void
        title (const title_type& x);

        void
        title (const title_optional& x);

        void
        title (::std::unique_ptr< title_type > p);

        // full_name
        //
        typedef ::xml_schema::string full_name_type;
        typedef ::xsd::cxx::tree::optional< full_name_type > full_name_optional;
        typedef ::xsd::cxx::tree::traits< full_name_type, char > full_name_traits;

        const full_name_optional&
        full_name () const;

        full_name_optional&
        full_name ();

        void
        full_name (const full_name_type& x);

        void
        full_name (const full_name_optional& x);

        void
        full_name (::std::unique_ptr< full_name_type > p);

        // mono_mass
        //
        typedef ::xml_schema::double_ mono_mass_type;
        typedef ::xsd::cxx::tree::optional< mono_mass_type > mono_mass_optional;
        typedef ::xsd::cxx::tree::traits< mono_mass_type, char, ::xsd::cxx::tree::schema_type::double_ > mono_mass_traits;

        const mono_mass_optional&
        mono_mass () const;

        mono_mass_optional&
        mono_mass ();

        void
        mono_mass (const mono_mass_type& x);

        void
        mono_mass (const mono_mass_optional& x);

        // avge_mass
        //
        typedef ::xml_schema::double_ avge_mass_type;
        typedef ::xsd::cxx::tree::optional< avge_mass_type > avge_mass_optional;
        typedef ::xsd::cxx::tree::traits< avge_mass_type, char, ::xsd::cxx::tree::schema_type::double_ > avge_mass_traits;

        const avge_mass_optional&
        avge_mass () const;

        avge_mass_optional&
        avge_mass ();

        void
        avge_mass (const avge_mass_type& x);

        void
        avge_mass (const avge_mass_optional& x);

        // Constructors.
        //
        brick_t ();

        brick_t (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

        brick_t (const brick_t& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

        virtual brick_t*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        brick_t&
        operator= (const brick_t& x);

        virtual 
        ~brick_t ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        element_sequence element_;
        title_optional title_;
        full_name_optional full_name_;
        mono_mass_optional mono_mass_;
        avge_mass_optional avge_mass_;
      };

      class specificity_t: public ::xml_schema::type
      {
        public:
        // NeutralLoss
        //
        typedef ::xmlns::schema::unimod_2::NeutralLoss_t NeutralLoss_type;
        typedef ::xsd::cxx::tree::sequence< NeutralLoss_type > NeutralLoss_sequence;
        typedef NeutralLoss_sequence::iterator NeutralLoss_iterator;
        typedef NeutralLoss_sequence::const_iterator NeutralLoss_const_iterator;
        typedef ::xsd::cxx::tree::traits< NeutralLoss_type, char > NeutralLoss_traits;

        const NeutralLoss_sequence&
        NeutralLoss () const;

        NeutralLoss_sequence&
        NeutralLoss ();

        void
        NeutralLoss (const NeutralLoss_sequence& s);

        // PepNeutralLoss
        //
        typedef ::xmlns::schema::unimod_2::PepNeutralLoss_t PepNeutralLoss_type;
        typedef ::xsd::cxx::tree::sequence< PepNeutralLoss_type > PepNeutralLoss_sequence;
        typedef PepNeutralLoss_sequence::iterator PepNeutralLoss_iterator;
        typedef PepNeutralLoss_sequence::const_iterator PepNeutralLoss_const_iterator;
        typedef ::xsd::cxx::tree::traits< PepNeutralLoss_type, char > PepNeutralLoss_traits;

        const PepNeutralLoss_sequence&
        PepNeutralLoss () const;

        PepNeutralLoss_sequence&
        PepNeutralLoss ();

        void
        PepNeutralLoss (const PepNeutralLoss_sequence& s);

        // misc_notes
        //
        typedef ::xml_schema::string misc_notes_type;
        typedef ::xsd::cxx::tree::optional< misc_notes_type > misc_notes_optional;
        typedef ::xsd::cxx::tree::traits< misc_notes_type, char > misc_notes_traits;

        const misc_notes_optional&
        misc_notes () const;

        misc_notes_optional&
        misc_notes ();

        void
        misc_notes (const misc_notes_type& x);

        void
        misc_notes (const misc_notes_optional& x);

        void
        misc_notes (::std::unique_ptr< misc_notes_type > p);

        // hidden
        //
        typedef ::xml_schema::boolean hidden_type;
        typedef ::xsd::cxx::tree::traits< hidden_type, char > hidden_traits;

        const hidden_type&
        hidden () const;

        hidden_type&
        hidden ();

        void
        hidden (const hidden_type& x);

        static hidden_type
        hidden_default_value ();

        // site
        //
        typedef ::xml_schema::string site_type;
        typedef ::xsd::cxx::tree::traits< site_type, char > site_traits;

        const site_type&
        site () const;

        site_type&
        site ();

        void
        site (const site_type& x);

        void
        site (::std::unique_ptr< site_type > p);

        // position
        //
        typedef ::xmlns::schema::unimod_2::position_t position_type;
        typedef ::xsd::cxx::tree::traits< position_type, char > position_traits;

        const position_type&
        position () const;

        position_type&
        position ();

        void
        position (const position_type& x);

        void
        position (::std::unique_ptr< position_type > p);

        // classification
        //
        typedef ::xmlns::schema::unimod_2::classification_t classification_type;
        typedef ::xsd::cxx::tree::traits< classification_type, char > classification_traits;

        const classification_type&
        classification () const;

        classification_type&
        classification ();

        void
        classification (const classification_type& x);

        void
        classification (::std::unique_ptr< classification_type > p);

        // spec_group
        //
        typedef ::xml_schema::integer spec_group_type;
        typedef ::xsd::cxx::tree::traits< spec_group_type, char > spec_group_traits;

        const spec_group_type&
        spec_group () const;

        spec_group_type&
        spec_group ();

        void
        spec_group (const spec_group_type& x);

        static spec_group_type
        spec_group_default_value ();

        // Constructors.
        //
        specificity_t ();

        specificity_t (const site_type&,
                       const position_type&,
                       const classification_type&);

        specificity_t (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        specificity_t (const specificity_t& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        virtual specificity_t*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        specificity_t&
        operator= (const specificity_t& x);

        virtual 
        ~specificity_t ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        NeutralLoss_sequence NeutralLoss_;
        PepNeutralLoss_sequence PepNeutralLoss_;
        misc_notes_optional misc_notes_;
        ::xsd::cxx::tree::one< hidden_type > hidden_;
        ::xsd::cxx::tree::one< site_type > site_;
        ::xsd::cxx::tree::one< position_type > position_;
        ::xsd::cxx::tree::one< classification_type > classification_;
        ::xsd::cxx::tree::one< spec_group_type > spec_group_;
      };

      class composition_t: public ::xml_schema::type
      {
        public:
        // element
        //
        typedef ::xmlns::schema::unimod_2::elem_ref_t element_type;
        typedef ::xsd::cxx::tree::sequence< element_type > element_sequence;
        typedef element_sequence::iterator element_iterator;
        typedef element_sequence::const_iterator element_const_iterator;
        typedef ::xsd::cxx::tree::traits< element_type, char > element_traits;

        const element_sequence&
        element () const;

        element_sequence&
        element ();

        void
        element (const element_sequence& s);

        // composition
        //
        typedef ::xml_schema::string composition_type;
        typedef ::xsd::cxx::tree::traits< composition_type, char > composition_traits;

        const composition_type&
        composition () const;

        composition_type&
        composition ();

        void
        composition (const composition_type& x);

        void
        composition (::std::unique_ptr< composition_type > p);

        // mono_mass
        //
        typedef ::xml_schema::double_ mono_mass_type;
        typedef ::xsd::cxx::tree::optional< mono_mass_type > mono_mass_optional;
        typedef ::xsd::cxx::tree::traits< mono_mass_type, char, ::xsd::cxx::tree::schema_type::double_ > mono_mass_traits;

        const mono_mass_optional&
        mono_mass () const;

        mono_mass_optional&
        mono_mass ();

        void
        mono_mass (const mono_mass_type& x);

        void
        mono_mass (const mono_mass_optional& x);

        // avge_mass
        //
        typedef ::xml_schema::double_ avge_mass_type;
        typedef ::xsd::cxx::tree::optional< avge_mass_type > avge_mass_optional;
        typedef ::xsd::cxx::tree::traits< avge_mass_type, char, ::xsd::cxx::tree::schema_type::double_ > avge_mass_traits;

        const avge_mass_optional&
        avge_mass () const;

        avge_mass_optional&
        avge_mass ();

        void
        avge_mass (const avge_mass_type& x);

        void
        avge_mass (const avge_mass_optional& x);

        // Constructors.
        //
        composition_t ();

        composition_t (const composition_type&);

        composition_t (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        composition_t (const composition_t& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        virtual composition_t*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        composition_t&
        operator= (const composition_t& x);

        virtual 
        ~composition_t ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        element_sequence element_;
        ::xsd::cxx::tree::one< composition_type > composition_;
        mono_mass_optional mono_mass_;
        avge_mass_optional avge_mass_;
      };

      class NeutralLoss_t: public ::xmlns::schema::unimod_2::composition_t
      {
        public:
        // flag
        //
        typedef ::xml_schema::boolean flag_type;
        typedef ::xsd::cxx::tree::traits< flag_type, char > flag_traits;

        const flag_type&
        flag () const;

        flag_type&
        flag ();

        void
        flag (const flag_type& x);

        static flag_type
        flag_default_value ();

        // Constructors.
        //
        NeutralLoss_t ();

        NeutralLoss_t (const composition_type&);

        NeutralLoss_t (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        NeutralLoss_t (const NeutralLoss_t& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        virtual NeutralLoss_t*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        NeutralLoss_t&
        operator= (const NeutralLoss_t& x);

        virtual 
        ~NeutralLoss_t ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< flag_type > flag_;
      };

      class PepNeutralLoss_t: public ::xmlns::schema::unimod_2::composition_t
      {
        public:
        // required
        //
        typedef ::xml_schema::boolean required_type;
        typedef ::xsd::cxx::tree::traits< required_type, char > required_traits;

        const required_type&
        required () const;

        required_type&
        required ();

        void
        required (const required_type& x);

        static required_type
        required_default_value ();

        // Constructors.
        //
        PepNeutralLoss_t ();

        PepNeutralLoss_t (const composition_type&);

        PepNeutralLoss_t (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

        PepNeutralLoss_t (const PepNeutralLoss_t& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

        virtual PepNeutralLoss_t*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        PepNeutralLoss_t&
        operator= (const PepNeutralLoss_t& x);

        virtual 
        ~PepNeutralLoss_t ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< required_type > required_;
      };

      class elem_ref_t: public ::xml_schema::type
      {
        public:
        // symbol
        //
        typedef ::xml_schema::string symbol_type;
        typedef ::xsd::cxx::tree::traits< symbol_type, char > symbol_traits;

        const symbol_type&
        symbol () const;

        symbol_type&
        symbol ();

        void
        symbol (const symbol_type& x);

        void
        symbol (::std::unique_ptr< symbol_type > p);

        // number
        //
        typedef ::xml_schema::integer number_type;
        typedef ::xsd::cxx::tree::traits< number_type, char > number_traits;

        const number_type&
        number () const;

        number_type&
        number ();

        void
        number (const number_type& x);

        static number_type
        number_default_value ();

        // Constructors.
        //
        elem_ref_t ();

        elem_ref_t (const symbol_type&);

        elem_ref_t (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        elem_ref_t (const elem_ref_t& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        virtual elem_ref_t*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        elem_ref_t&
        operator= (const elem_ref_t& x);

        virtual 
        ~elem_ref_t ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< symbol_type > symbol_;
        ::xsd::cxx::tree::one< number_type > number_;
      };

      class position_t: public ::xml_schema::string
      {
        public:
        enum value
        {
          Anywhere,
          Any_N_term,
          Any_C_term,
          Protein_N_term,
          Protein_C_term
        };

        position_t ();

        position_t (value v);

        position_t (const char* v);

        position_t (const ::std::string& v);

        position_t (const ::xml_schema::string& v);

        position_t (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        position_t (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        position_t (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        position_t (const position_t& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        virtual position_t*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        position_t&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_position_t_convert ();
        }

        protected:
        value
        _xsd_position_t_convert () const;

        public:
        static const char* const _xsd_position_t_literals_[5];
        static const value _xsd_position_t_indexes_[5];
      };

      class xref_t: public ::xml_schema::type
      {
        public:
        // text
        //
        typedef ::xml_schema::string text_type;
        typedef ::xsd::cxx::tree::traits< text_type, char > text_traits;

        const text_type&
        text () const;

        text_type&
        text ();

        void
        text (const text_type& x);

        void
        text (::std::unique_ptr< text_type > p);

        // source
        //
        typedef ::xmlns::schema::unimod_2::xref_source_t source_type;
        typedef ::xsd::cxx::tree::traits< source_type, char > source_traits;

        const source_type&
        source () const;

        source_type&
        source ();

        void
        source (const source_type& x);

        void
        source (::std::unique_ptr< source_type > p);

        // url
        //
        typedef ::xml_schema::string url_type;
        typedef ::xsd::cxx::tree::optional< url_type > url_optional;
        typedef ::xsd::cxx::tree::traits< url_type, char > url_traits;

        const url_optional&
        url () const;

        url_optional&
        url ();

        void
        url (const url_type& x);

        void
        url (const url_optional& x);

        void
        url (::std::unique_ptr< url_type > p);

        // Constructors.
        //
        xref_t ();

        xref_t (const text_type&,
                const source_type&);

        xref_t (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

        xref_t (const xref_t& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

        virtual xref_t*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        xref_t&
        operator= (const xref_t& x);

        virtual 
        ~xref_t ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< text_type > text_;
        ::xsd::cxx::tree::one< source_type > source_;
        url_optional url_;
      };

      class xref_source_t: public ::xml_schema::string
      {
        public:
        enum value
        {
          cxx_,
          PubMed_PMID,
          CAS_Registry,
          CarbBank,
          RESID,
          Swiss_Prot,
          Prosite,
          Entrez,
          Book,
          Journal,
          Misc__URL,
          FindMod,
          Other
        };

        xref_source_t ();

        xref_source_t (value v);

        xref_source_t (const char* v);

        xref_source_t (const ::std::string& v);

        xref_source_t (const ::xml_schema::string& v);

        xref_source_t (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        xref_source_t (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        xref_source_t (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        xref_source_t (const xref_source_t& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        virtual xref_source_t*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        xref_source_t&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_xref_source_t_convert ();
        }

        protected:
        value
        _xsd_xref_source_t_convert () const;

        public:
        static const char* const _xsd_xref_source_t_literals_[13];
        static const value _xsd_xref_source_t_indexes_[13];
      };

      class classification_t: public ::xml_schema::string
      {
        public:
        enum value
        {
          cxx_,
          Post_translational,
          Co_translational,
          Pre_translational,
          Chemical_derivative,
          Artefact,
          N_linked_glycosylation,
          O_linked_glycosylation,
          Other_glycosylation,
          Synth__pep__protect__gp_,
          Isotopic_label,
          Non_standard_residue,
          Multiple,
          Other,
          AA_substitution
        };

        classification_t ();

        classification_t (value v);

        classification_t (const char* v);

        classification_t (const ::std::string& v);

        classification_t (const ::xml_schema::string& v);

        classification_t (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

        classification_t (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

        classification_t (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

        classification_t (const classification_t& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

        virtual classification_t*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        classification_t&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_classification_t_convert ();
        }

        protected:
        value
        _xsd_classification_t_convert () const;

        public:
        static const char* const _xsd_classification_t_literals_[15];
        static const value _xsd_classification_t_indexes_[15];
      };
    }
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xmlns
{
  namespace schema
  {
    namespace unimod_2
    {
      // Parse a URI or a local file.
      //

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (const ::std::string& uri,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (const ::std::string& uri,
              ::xml_schema::error_handler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (const ::std::string& uri,
              ::xercesc::DOMErrorHandler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

      // Parse std::istream.
      //

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (::std::istream& is,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (::std::istream& is,
              ::xml_schema::error_handler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (::std::istream& is,
              ::xercesc::DOMErrorHandler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (::std::istream& is,
              const ::std::string& id,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (::std::istream& is,
              const ::std::string& id,
              ::xml_schema::error_handler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (::std::istream& is,
              const ::std::string& id,
              ::xercesc::DOMErrorHandler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

      // Parse xercesc::InputSource.
      //

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (::xercesc::InputSource& is,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (::xercesc::InputSource& is,
              ::xml_schema::error_handler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (::xercesc::InputSource& is,
              ::xercesc::DOMErrorHandler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

      // Parse xercesc::DOMDocument.
      //

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

      ::std::unique_ptr< ::xmlns::schema::unimod_2::unimod_t >
      unimod (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());
    }
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xmlns
{
  namespace schema
  {
    namespace unimod_2
    {
      // Serialize to std::ostream.
      //

      void
      unimod (::std::ostream& os,
              const ::xmlns::schema::unimod_2::unimod_t& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::flags f = 0);

      void
      unimod (::std::ostream& os,
              const ::xmlns::schema::unimod_2::unimod_t& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::flags f = 0);

      void
      unimod (::std::ostream& os,
              const ::xmlns::schema::unimod_2::unimod_t& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::flags f = 0);

      // Serialize to xercesc::XMLFormatTarget.
      //

      void
      unimod (::xercesc::XMLFormatTarget& ft,
              const ::xmlns::schema::unimod_2::unimod_t& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::flags f = 0);

      void
      unimod (::xercesc::XMLFormatTarget& ft,
              const ::xmlns::schema::unimod_2::unimod_t& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::flags f = 0);

      void
      unimod (::xercesc::XMLFormatTarget& ft,
              const ::xmlns::schema::unimod_2::unimod_t& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::flags f = 0);

      // Serialize to an existing xercesc::DOMDocument.
      //

      void
      unimod (::xercesc::DOMDocument& d,
              const ::xmlns::schema::unimod_2::unimod_t& x,
              ::xml_schema::flags f = 0);

      // Serialize to a new xercesc::DOMDocument.
      //

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
      unimod (const ::xmlns::schema::unimod_2::unimod_t& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              ::xml_schema::flags f = 0);

      void
      operator<< (::xercesc::DOMElement&, const unimod_t&);

      void
      operator<< (::xercesc::DOMElement&, const minorVersion_t&);

      void
      operator<< (::xercesc::DOMAttr&, const minorVersion_t&);

      void
      operator<< (::xml_schema::list_stream&,
                  const minorVersion_t&);

      void
      operator<< (::xercesc::DOMElement&, const elements_t&);

      void
      operator<< (::xercesc::DOMElement&, const modifications_t&);

      void
      operator<< (::xercesc::DOMElement&, const amino_acids_t&);

      void
      operator<< (::xercesc::DOMElement&, const mod_bricks_t&);

      void
      operator<< (::xercesc::DOMElement&, const elem_t&);

      void
      operator<< (::xercesc::DOMElement&, const mod_t&);

      void
      operator<< (::xercesc::DOMElement&, const aa_t&);

      void
      operator<< (::xercesc::DOMElement&, const brick_t&);

      void
      operator<< (::xercesc::DOMElement&, const specificity_t&);

      void
      operator<< (::xercesc::DOMElement&, const composition_t&);

      void
      operator<< (::xercesc::DOMElement&, const NeutralLoss_t&);

      void
      operator<< (::xercesc::DOMElement&, const PepNeutralLoss_t&);

      void
      operator<< (::xercesc::DOMElement&, const elem_ref_t&);

      void
      operator<< (::xercesc::DOMElement&, const position_t&);

      void
      operator<< (::xercesc::DOMAttr&, const position_t&);

      void
      operator<< (::xml_schema::list_stream&,
                  const position_t&);

      void
      operator<< (::xercesc::DOMElement&, const xref_t&);

      void
      operator<< (::xercesc::DOMElement&, const xref_source_t&);

      void
      operator<< (::xercesc::DOMAttr&, const xref_source_t&);

      void
      operator<< (::xml_schema::list_stream&,
                  const xref_source_t&);

      void
      operator<< (::xercesc::DOMElement&, const classification_t&);

      void
      operator<< (::xercesc::DOMAttr&, const classification_t&);

      void
      operator<< (::xml_schema::list_stream&,
                  const classification_t&);
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // UNIMOD_2_H
