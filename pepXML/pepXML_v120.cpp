// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "pepXML_v120.h"

namespace pepXML
{
  // engineType
  // 

  engineType::
  engineType ()
  : ::xml_schema::string ()
  {
  }

  engineType::
  engineType (value v)
  : ::xml_schema::string (_xsd_engineType_literals_[v])
  {
  }

  engineType::
  engineType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  engineType::
  engineType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  engineType::
  engineType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  engineType::
  engineType (const engineType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  engineType& engineType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_engineType_literals_[v]);

    return *this;
  }


  // activationMethodType
  // 

  activationMethodType::
  activationMethodType ()
  : ::xml_schema::string ()
  {
  }

  activationMethodType::
  activationMethodType (value v)
  : ::xml_schema::string (_xsd_activationMethodType_literals_[v])
  {
  }

  activationMethodType::
  activationMethodType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  activationMethodType::
  activationMethodType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  activationMethodType::
  activationMethodType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  activationMethodType::
  activationMethodType (const activationMethodType& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  activationMethodType& activationMethodType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_activationMethodType_literals_[v]);

    return *this;
  }


  // model_dis_type
  // 

  model_dis_type::
  model_dis_type ()
  : ::xml_schema::string ()
  {
  }

  model_dis_type::
  model_dis_type (value v)
  : ::xml_schema::string (_xsd_model_dis_type_literals_[v])
  {
  }

  model_dis_type::
  model_dis_type (const char* v)
  : ::xml_schema::string (v)
  {
  }

  model_dis_type::
  model_dis_type (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  model_dis_type::
  model_dis_type (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  model_dis_type::
  model_dis_type (const model_dis_type& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  model_dis_type& model_dis_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_model_dis_type_literals_[v]);

    return *this;
  }


  // massType
  // 

  massType::
  massType ()
  : ::xml_schema::string ()
  {
  }

  massType::
  massType (value v)
  : ::xml_schema::string (_xsd_massType_literals_[v])
  {
  }

  massType::
  massType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  massType::
  massType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  massType::
  massType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  massType::
  massType (const massType& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  massType& massType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_massType_literals_[v]);

    return *this;
  }


  // aa_symbolType
  // 

  aa_symbolType::
  aa_symbolType ()
  : ::xml_schema::string ()
  {
  }

  aa_symbolType::
  aa_symbolType (value v)
  : ::xml_schema::string (_xsd_aa_symbolType_literals_[v])
  {
  }

  aa_symbolType::
  aa_symbolType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  aa_symbolType::
  aa_symbolType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  aa_symbolType::
  aa_symbolType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  aa_symbolType::
  aa_symbolType (const aa_symbolType& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  aa_symbolType& aa_symbolType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_aa_symbolType_literals_[v]);

    return *this;
  }


  // term_symbolType
  // 

  term_symbolType::
  term_symbolType ()
  : ::xml_schema::string ()
  {
  }

  term_symbolType::
  term_symbolType (value v)
  : ::xml_schema::string (_xsd_term_symbolType_literals_[v])
  {
  }

  term_symbolType::
  term_symbolType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  term_symbolType::
  term_symbolType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  term_symbolType::
  term_symbolType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  term_symbolType::
  term_symbolType (const term_symbolType& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  term_symbolType& term_symbolType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_term_symbolType_literals_[v]);

    return *this;
  }


  // positiveInt
  // 


  // nameValueType
  // 

  const nameValueType::name_type& nameValueType::
  name () const
  {
    return this->name_.get ();
  }

  nameValueType::name_type& nameValueType::
  name ()
  {
    return this->name_.get ();
  }

  void nameValueType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void nameValueType::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const nameValueType::value_type& nameValueType::
  value () const
  {
    return this->value_.get ();
  }

  nameValueType::value_type& nameValueType::
  value ()
  {
    return this->value_.get ();
  }

  void nameValueType::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void nameValueType::
  value (::std::unique_ptr< value_type > x)
  {
    this->value_.set (std::move (x));
  }

  const nameValueType::type_optional& nameValueType::
  type () const
  {
    return this->type_;
  }

  nameValueType::type_optional& nameValueType::
  type ()
  {
    return this->type_;
  }

  void nameValueType::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void nameValueType::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void nameValueType::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // inputFileType
  // 

  const inputFileType::name_type& inputFileType::
  name () const
  {
    return this->name_.get ();
  }

  inputFileType::name_type& inputFileType::
  name ()
  {
    return this->name_.get ();
  }

  void inputFileType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void inputFileType::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const inputFileType::directory_optional& inputFileType::
  directory () const
  {
    return this->directory_;
  }

  inputFileType::directory_optional& inputFileType::
  directory ()
  {
    return this->directory_;
  }

  void inputFileType::
  directory (const directory_type& x)
  {
    this->directory_.set (x);
  }

  void inputFileType::
  directory (const directory_optional& x)
  {
    this->directory_ = x;
  }

  void inputFileType::
  directory (::std::unique_ptr< directory_type > x)
  {
    this->directory_.set (std::move (x));
  }


  // rocErrorDataType
  // 

  const rocErrorDataType::roc_data_point_sequence& rocErrorDataType::
  roc_data_point () const
  {
    return this->roc_data_point_;
  }

  rocErrorDataType::roc_data_point_sequence& rocErrorDataType::
  roc_data_point ()
  {
    return this->roc_data_point_;
  }

  void rocErrorDataType::
  roc_data_point (const roc_data_point_sequence& s)
  {
    this->roc_data_point_ = s;
  }

  const rocErrorDataType::error_point_sequence& rocErrorDataType::
  error_point () const
  {
    return this->error_point_;
  }

  rocErrorDataType::error_point_sequence& rocErrorDataType::
  error_point ()
  {
    return this->error_point_;
  }

  void rocErrorDataType::
  error_point (const error_point_sequence& s)
  {
    this->error_point_ = s;
  }

  const rocErrorDataType::charge_type& rocErrorDataType::
  charge () const
  {
    return this->charge_.get ();
  }

  rocErrorDataType::charge_type& rocErrorDataType::
  charge ()
  {
    return this->charge_.get ();
  }

  void rocErrorDataType::
  charge (const charge_type& x)
  {
    this->charge_.set (x);
  }

  void rocErrorDataType::
  charge (::std::unique_ptr< charge_type > x)
  {
    this->charge_.set (std::move (x));
  }

  const rocErrorDataType::charge_est_correct_optional& rocErrorDataType::
  charge_est_correct () const
  {
    return this->charge_est_correct_;
  }

  rocErrorDataType::charge_est_correct_optional& rocErrorDataType::
  charge_est_correct ()
  {
    return this->charge_est_correct_;
  }

  void rocErrorDataType::
  charge_est_correct (const charge_est_correct_type& x)
  {
    this->charge_est_correct_.set (x);
  }

  void rocErrorDataType::
  charge_est_correct (const charge_est_correct_optional& x)
  {
    this->charge_est_correct_ = x;
  }


  // mixtureModelType
  // 

  const mixtureModelType::point_sequence& mixtureModelType::
  point () const
  {
    return this->point_;
  }

  mixtureModelType::point_sequence& mixtureModelType::
  point ()
  {
    return this->point_;
  }

  void mixtureModelType::
  point (const point_sequence& s)
  {
    this->point_ = s;
  }

  const mixtureModelType::name_type& mixtureModelType::
  name () const
  {
    return this->name_.get ();
  }

  mixtureModelType::name_type& mixtureModelType::
  name ()
  {
    return this->name_.get ();
  }

  void mixtureModelType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void mixtureModelType::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const mixtureModelType::pos_bandwidth_type& mixtureModelType::
  pos_bandwidth () const
  {
    return this->pos_bandwidth_.get ();
  }

  mixtureModelType::pos_bandwidth_type& mixtureModelType::
  pos_bandwidth ()
  {
    return this->pos_bandwidth_.get ();
  }

  void mixtureModelType::
  pos_bandwidth (const pos_bandwidth_type& x)
  {
    this->pos_bandwidth_.set (x);
  }

  const mixtureModelType::neg_bandwidth_type& mixtureModelType::
  neg_bandwidth () const
  {
    return this->neg_bandwidth_.get ();
  }

  mixtureModelType::neg_bandwidth_type& mixtureModelType::
  neg_bandwidth ()
  {
    return this->neg_bandwidth_.get ();
  }

  void mixtureModelType::
  neg_bandwidth (const neg_bandwidth_type& x)
  {
    this->neg_bandwidth_.set (x);
  }


  // modInfoDataType
  // 

  const modInfoDataType::aminoacid_substitution_sequence& modInfoDataType::
  aminoacid_substitution () const
  {
    return this->aminoacid_substitution_;
  }

  modInfoDataType::aminoacid_substitution_sequence& modInfoDataType::
  aminoacid_substitution ()
  {
    return this->aminoacid_substitution_;
  }

  void modInfoDataType::
  aminoacid_substitution (const aminoacid_substitution_sequence& s)
  {
    this->aminoacid_substitution_ = s;
  }

  const modInfoDataType::mod_aminoacid_mass_sequence& modInfoDataType::
  mod_aminoacid_mass () const
  {
    return this->mod_aminoacid_mass_;
  }

  modInfoDataType::mod_aminoacid_mass_sequence& modInfoDataType::
  mod_aminoacid_mass ()
  {
    return this->mod_aminoacid_mass_;
  }

  void modInfoDataType::
  mod_aminoacid_mass (const mod_aminoacid_mass_sequence& s)
  {
    this->mod_aminoacid_mass_ = s;
  }

  const modInfoDataType::mod_nterm_mass_optional& modInfoDataType::
  mod_nterm_mass () const
  {
    return this->mod_nterm_mass_;
  }

  modInfoDataType::mod_nterm_mass_optional& modInfoDataType::
  mod_nterm_mass ()
  {
    return this->mod_nterm_mass_;
  }

  void modInfoDataType::
  mod_nterm_mass (const mod_nterm_mass_type& x)
  {
    this->mod_nterm_mass_.set (x);
  }

  void modInfoDataType::
  mod_nterm_mass (const mod_nterm_mass_optional& x)
  {
    this->mod_nterm_mass_ = x;
  }

  const modInfoDataType::mod_cterm_mass_optional& modInfoDataType::
  mod_cterm_mass () const
  {
    return this->mod_cterm_mass_;
  }

  modInfoDataType::mod_cterm_mass_optional& modInfoDataType::
  mod_cterm_mass ()
  {
    return this->mod_cterm_mass_;
  }

  void modInfoDataType::
  mod_cterm_mass (const mod_cterm_mass_type& x)
  {
    this->mod_cterm_mass_.set (x);
  }

  void modInfoDataType::
  mod_cterm_mass (const mod_cterm_mass_optional& x)
  {
    this->mod_cterm_mass_ = x;
  }

  const modInfoDataType::modified_peptide_optional& modInfoDataType::
  modified_peptide () const
  {
    return this->modified_peptide_;
  }

  modInfoDataType::modified_peptide_optional& modInfoDataType::
  modified_peptide ()
  {
    return this->modified_peptide_;
  }

  void modInfoDataType::
  modified_peptide (const modified_peptide_type& x)
  {
    this->modified_peptide_.set (x);
  }

  void modInfoDataType::
  modified_peptide (const modified_peptide_optional& x)
  {
    this->modified_peptide_ = x;
  }

  void modInfoDataType::
  modified_peptide (::std::unique_ptr< modified_peptide_type > x)
  {
    this->modified_peptide_.set (std::move (x));
  }


  // subInfoDataType
  // 

  const subInfoDataType::position_optional& subInfoDataType::
  position () const
  {
    return this->position_;
  }

  subInfoDataType::position_optional& subInfoDataType::
  position ()
  {
    return this->position_;
  }

  void subInfoDataType::
  position (const position_type& x)
  {
    this->position_.set (x);
  }

  void subInfoDataType::
  position (const position_optional& x)
  {
    this->position_ = x;
  }

  const subInfoDataType::orig_aa_optional& subInfoDataType::
  orig_aa () const
  {
    return this->orig_aa_;
  }

  subInfoDataType::orig_aa_optional& subInfoDataType::
  orig_aa ()
  {
    return this->orig_aa_;
  }

  void subInfoDataType::
  orig_aa (const orig_aa_type& x)
  {
    this->orig_aa_.set (x);
  }

  void subInfoDataType::
  orig_aa (const orig_aa_optional& x)
  {
    this->orig_aa_ = x;
  }

  void subInfoDataType::
  orig_aa (::std::unique_ptr< orig_aa_type > x)
  {
    this->orig_aa_.set (std::move (x));
  }

  const subInfoDataType::num_tol_term_optional& subInfoDataType::
  num_tol_term () const
  {
    return this->num_tol_term_;
  }

  subInfoDataType::num_tol_term_optional& subInfoDataType::
  num_tol_term ()
  {
    return this->num_tol_term_;
  }

  void subInfoDataType::
  num_tol_term (const num_tol_term_type& x)
  {
    this->num_tol_term_.set (x);
  }

  void subInfoDataType::
  num_tol_term (const num_tol_term_optional& x)
  {
    this->num_tol_term_ = x;
  }

  const subInfoDataType::peptide_prev_aa_optional& subInfoDataType::
  peptide_prev_aa () const
  {
    return this->peptide_prev_aa_;
  }

  subInfoDataType::peptide_prev_aa_optional& subInfoDataType::
  peptide_prev_aa ()
  {
    return this->peptide_prev_aa_;
  }

  void subInfoDataType::
  peptide_prev_aa (const peptide_prev_aa_type& x)
  {
    this->peptide_prev_aa_.set (x);
  }

  void subInfoDataType::
  peptide_prev_aa (const peptide_prev_aa_optional& x)
  {
    this->peptide_prev_aa_ = x;
  }

  void subInfoDataType::
  peptide_prev_aa (::std::unique_ptr< peptide_prev_aa_type > x)
  {
    this->peptide_prev_aa_.set (std::move (x));
  }

  const subInfoDataType::peptide_next_aa_optional& subInfoDataType::
  peptide_next_aa () const
  {
    return this->peptide_next_aa_;
  }

  subInfoDataType::peptide_next_aa_optional& subInfoDataType::
  peptide_next_aa ()
  {
    return this->peptide_next_aa_;
  }

  void subInfoDataType::
  peptide_next_aa (const peptide_next_aa_type& x)
  {
    this->peptide_next_aa_.set (x);
  }

  void subInfoDataType::
  peptide_next_aa (const peptide_next_aa_optional& x)
  {
    this->peptide_next_aa_ = x;
  }

  void subInfoDataType::
  peptide_next_aa (::std::unique_ptr< peptide_next_aa_type > x)
  {
    this->peptide_next_aa_.set (std::move (x));
  }


  // altProteinDataType
  // 

  const altProteinDataType::aminoacid_substitution_sequence& altProteinDataType::
  aminoacid_substitution () const
  {
    return this->aminoacid_substitution_;
  }

  altProteinDataType::aminoacid_substitution_sequence& altProteinDataType::
  aminoacid_substitution ()
  {
    return this->aminoacid_substitution_;
  }

  void altProteinDataType::
  aminoacid_substitution (const aminoacid_substitution_sequence& s)
  {
    this->aminoacid_substitution_ = s;
  }

  const altProteinDataType::protein_type& altProteinDataType::
  protein () const
  {
    return this->protein_.get ();
  }

  altProteinDataType::protein_type& altProteinDataType::
  protein ()
  {
    return this->protein_.get ();
  }

  void altProteinDataType::
  protein (const protein_type& x)
  {
    this->protein_.set (x);
  }

  void altProteinDataType::
  protein (::std::unique_ptr< protein_type > x)
  {
    this->protein_.set (std::move (x));
  }

  const altProteinDataType::protein_descr_optional& altProteinDataType::
  protein_descr () const
  {
    return this->protein_descr_;
  }

  altProteinDataType::protein_descr_optional& altProteinDataType::
  protein_descr ()
  {
    return this->protein_descr_;
  }

  void altProteinDataType::
  protein_descr (const protein_descr_type& x)
  {
    this->protein_descr_.set (x);
  }

  void altProteinDataType::
  protein_descr (const protein_descr_optional& x)
  {
    this->protein_descr_ = x;
  }

  void altProteinDataType::
  protein_descr (::std::unique_ptr< protein_descr_type > x)
  {
    this->protein_descr_.set (std::move (x));
  }

  const altProteinDataType::num_tol_term_optional& altProteinDataType::
  num_tol_term () const
  {
    return this->num_tol_term_;
  }

  altProteinDataType::num_tol_term_optional& altProteinDataType::
  num_tol_term ()
  {
    return this->num_tol_term_;
  }

  void altProteinDataType::
  num_tol_term (const num_tol_term_type& x)
  {
    this->num_tol_term_.set (x);
  }

  void altProteinDataType::
  num_tol_term (const num_tol_term_optional& x)
  {
    this->num_tol_term_ = x;
  }

  const altProteinDataType::protein_mw_optional& altProteinDataType::
  protein_mw () const
  {
    return this->protein_mw_;
  }

  altProteinDataType::protein_mw_optional& altProteinDataType::
  protein_mw ()
  {
    return this->protein_mw_;
  }

  void altProteinDataType::
  protein_mw (const protein_mw_type& x)
  {
    this->protein_mw_.set (x);
  }

  void altProteinDataType::
  protein_mw (const protein_mw_optional& x)
  {
    this->protein_mw_ = x;
  }

  const altProteinDataType::peptide_prev_aa_optional& altProteinDataType::
  peptide_prev_aa () const
  {
    return this->peptide_prev_aa_;
  }

  altProteinDataType::peptide_prev_aa_optional& altProteinDataType::
  peptide_prev_aa ()
  {
    return this->peptide_prev_aa_;
  }

  void altProteinDataType::
  peptide_prev_aa (const peptide_prev_aa_type& x)
  {
    this->peptide_prev_aa_.set (x);
  }

  void altProteinDataType::
  peptide_prev_aa (const peptide_prev_aa_optional& x)
  {
    this->peptide_prev_aa_ = x;
  }

  void altProteinDataType::
  peptide_prev_aa (::std::unique_ptr< peptide_prev_aa_type > x)
  {
    this->peptide_prev_aa_.set (std::move (x));
  }

  const altProteinDataType::peptide_next_aa_optional& altProteinDataType::
  peptide_next_aa () const
  {
    return this->peptide_next_aa_;
  }

  altProteinDataType::peptide_next_aa_optional& altProteinDataType::
  peptide_next_aa ()
  {
    return this->peptide_next_aa_;
  }

  void altProteinDataType::
  peptide_next_aa (const peptide_next_aa_type& x)
  {
    this->peptide_next_aa_.set (x);
  }

  void altProteinDataType::
  peptide_next_aa (const peptide_next_aa_optional& x)
  {
    this->peptide_next_aa_ = x;
  }

  void altProteinDataType::
  peptide_next_aa (::std::unique_ptr< peptide_next_aa_type > x)
  {
    this->peptide_next_aa_.set (std::move (x));
  }


  // msms_pipeline_analysis
  // 

  const msms_pipeline_analysis::analysis_summary_sequence& msms_pipeline_analysis::
  analysis_summary () const
  {
    return this->analysis_summary_;
  }

  msms_pipeline_analysis::analysis_summary_sequence& msms_pipeline_analysis::
  analysis_summary ()
  {
    return this->analysis_summary_;
  }

  void msms_pipeline_analysis::
  analysis_summary (const analysis_summary_sequence& s)
  {
    this->analysis_summary_ = s;
  }

  const msms_pipeline_analysis::dataset_derivation_optional& msms_pipeline_analysis::
  dataset_derivation () const
  {
    return this->dataset_derivation_;
  }

  msms_pipeline_analysis::dataset_derivation_optional& msms_pipeline_analysis::
  dataset_derivation ()
  {
    return this->dataset_derivation_;
  }

  void msms_pipeline_analysis::
  dataset_derivation (const dataset_derivation_type& x)
  {
    this->dataset_derivation_.set (x);
  }

  void msms_pipeline_analysis::
  dataset_derivation (const dataset_derivation_optional& x)
  {
    this->dataset_derivation_ = x;
  }

  void msms_pipeline_analysis::
  dataset_derivation (::std::unique_ptr< dataset_derivation_type > x)
  {
    this->dataset_derivation_.set (std::move (x));
  }

  const msms_pipeline_analysis::msms_run_summary_sequence& msms_pipeline_analysis::
  msms_run_summary () const
  {
    return this->msms_run_summary_;
  }

  msms_pipeline_analysis::msms_run_summary_sequence& msms_pipeline_analysis::
  msms_run_summary ()
  {
    return this->msms_run_summary_;
  }

  void msms_pipeline_analysis::
  msms_run_summary (const msms_run_summary_sequence& s)
  {
    this->msms_run_summary_ = s;
  }

  const msms_pipeline_analysis::name_optional& msms_pipeline_analysis::
  name () const
  {
    return this->name_;
  }

  msms_pipeline_analysis::name_optional& msms_pipeline_analysis::
  name ()
  {
    return this->name_;
  }

  void msms_pipeline_analysis::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void msms_pipeline_analysis::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void msms_pipeline_analysis::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const msms_pipeline_analysis::date_type& msms_pipeline_analysis::
  date () const
  {
    return this->date_.get ();
  }

  msms_pipeline_analysis::date_type& msms_pipeline_analysis::
  date ()
  {
    return this->date_.get ();
  }

  void msms_pipeline_analysis::
  date (const date_type& x)
  {
    this->date_.set (x);
  }

  void msms_pipeline_analysis::
  date (::std::unique_ptr< date_type > x)
  {
    this->date_.set (std::move (x));
  }

  const msms_pipeline_analysis::summary_xml_type& msms_pipeline_analysis::
  summary_xml () const
  {
    return this->summary_xml_.get ();
  }

  msms_pipeline_analysis::summary_xml_type& msms_pipeline_analysis::
  summary_xml ()
  {
    return this->summary_xml_.get ();
  }

  void msms_pipeline_analysis::
  summary_xml (const summary_xml_type& x)
  {
    this->summary_xml_.set (x);
  }

  void msms_pipeline_analysis::
  summary_xml (::std::unique_ptr< summary_xml_type > x)
  {
    this->summary_xml_.set (std::move (x));
  }


  // peptideprophet_summary
  // 

  const peptideprophet_summary::inputfile_sequence& peptideprophet_summary::
  inputfile () const
  {
    return this->inputfile_;
  }

  peptideprophet_summary::inputfile_sequence& peptideprophet_summary::
  inputfile ()
  {
    return this->inputfile_;
  }

  void peptideprophet_summary::
  inputfile (const inputfile_sequence& s)
  {
    this->inputfile_ = s;
  }

  const peptideprophet_summary::roc_error_data_sequence& peptideprophet_summary::
  roc_error_data () const
  {
    return this->roc_error_data_;
  }

  peptideprophet_summary::roc_error_data_sequence& peptideprophet_summary::
  roc_error_data ()
  {
    return this->roc_error_data_;
  }

  void peptideprophet_summary::
  roc_error_data (const roc_error_data_sequence& s)
  {
    this->roc_error_data_ = s;
  }

  const peptideprophet_summary::distribution_point_sequence& peptideprophet_summary::
  distribution_point () const
  {
    return this->distribution_point_;
  }

  peptideprophet_summary::distribution_point_sequence& peptideprophet_summary::
  distribution_point ()
  {
    return this->distribution_point_;
  }

  void peptideprophet_summary::
  distribution_point (const distribution_point_sequence& s)
  {
    this->distribution_point_ = s;
  }

  const peptideprophet_summary::mixture_model_sequence& peptideprophet_summary::
  mixture_model () const
  {
    return this->mixture_model_;
  }

  peptideprophet_summary::mixture_model_sequence& peptideprophet_summary::
  mixture_model ()
  {
    return this->mixture_model_;
  }

  void peptideprophet_summary::
  mixture_model (const mixture_model_sequence& s)
  {
    this->mixture_model_ = s;
  }

  const peptideprophet_summary::version_type& peptideprophet_summary::
  version () const
  {
    return this->version_.get ();
  }

  peptideprophet_summary::version_type& peptideprophet_summary::
  version ()
  {
    return this->version_.get ();
  }

  void peptideprophet_summary::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void peptideprophet_summary::
  version (::std::unique_ptr< version_type > x)
  {
    this->version_.set (std::move (x));
  }

  const peptideprophet_summary::author_type& peptideprophet_summary::
  author () const
  {
    return this->author_.get ();
  }

  peptideprophet_summary::author_type& peptideprophet_summary::
  author ()
  {
    return this->author_.get ();
  }

  void peptideprophet_summary::
  author (const author_type& x)
  {
    this->author_.set (x);
  }

  void peptideprophet_summary::
  author (::std::unique_ptr< author_type > x)
  {
    this->author_.set (std::move (x));
  }

  const peptideprophet_summary::min_prob_type& peptideprophet_summary::
  min_prob () const
  {
    return this->min_prob_.get ();
  }

  peptideprophet_summary::min_prob_type& peptideprophet_summary::
  min_prob ()
  {
    return this->min_prob_.get ();
  }

  void peptideprophet_summary::
  min_prob (const min_prob_type& x)
  {
    this->min_prob_.set (x);
  }

  const peptideprophet_summary::options_optional& peptideprophet_summary::
  options () const
  {
    return this->options_;
  }

  peptideprophet_summary::options_optional& peptideprophet_summary::
  options ()
  {
    return this->options_;
  }

  void peptideprophet_summary::
  options (const options_type& x)
  {
    this->options_.set (x);
  }

  void peptideprophet_summary::
  options (const options_optional& x)
  {
    this->options_ = x;
  }

  void peptideprophet_summary::
  options (::std::unique_ptr< options_type > x)
  {
    this->options_.set (std::move (x));
  }

  const peptideprophet_summary::est_tot_num_correct_optional& peptideprophet_summary::
  est_tot_num_correct () const
  {
    return this->est_tot_num_correct_;
  }

  peptideprophet_summary::est_tot_num_correct_optional& peptideprophet_summary::
  est_tot_num_correct ()
  {
    return this->est_tot_num_correct_;
  }

  void peptideprophet_summary::
  est_tot_num_correct (const est_tot_num_correct_type& x)
  {
    this->est_tot_num_correct_.set (x);
  }

  void peptideprophet_summary::
  est_tot_num_correct (const est_tot_num_correct_optional& x)
  {
    this->est_tot_num_correct_ = x;
  }


  // interprophet_summary
  // 

  const interprophet_summary::inputfile_sequence& interprophet_summary::
  inputfile () const
  {
    return this->inputfile_;
  }

  interprophet_summary::inputfile_sequence& interprophet_summary::
  inputfile ()
  {
    return this->inputfile_;
  }

  void interprophet_summary::
  inputfile (const inputfile_sequence& s)
  {
    this->inputfile_ = s;
  }

  const interprophet_summary::roc_error_data_sequence& interprophet_summary::
  roc_error_data () const
  {
    return this->roc_error_data_;
  }

  interprophet_summary::roc_error_data_sequence& interprophet_summary::
  roc_error_data ()
  {
    return this->roc_error_data_;
  }

  void interprophet_summary::
  roc_error_data (const roc_error_data_sequence& s)
  {
    this->roc_error_data_ = s;
  }

  const interprophet_summary::mixturemodel_sequence& interprophet_summary::
  mixturemodel () const
  {
    return this->mixturemodel_;
  }

  interprophet_summary::mixturemodel_sequence& interprophet_summary::
  mixturemodel ()
  {
    return this->mixturemodel_;
  }

  void interprophet_summary::
  mixturemodel (const mixturemodel_sequence& s)
  {
    this->mixturemodel_ = s;
  }

  const interprophet_summary::version_type& interprophet_summary::
  version () const
  {
    return this->version_.get ();
  }

  interprophet_summary::version_type& interprophet_summary::
  version ()
  {
    return this->version_.get ();
  }

  void interprophet_summary::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void interprophet_summary::
  version (::std::unique_ptr< version_type > x)
  {
    this->version_.set (std::move (x));
  }

  const interprophet_summary::options_optional& interprophet_summary::
  options () const
  {
    return this->options_;
  }

  interprophet_summary::options_optional& interprophet_summary::
  options ()
  {
    return this->options_;
  }

  void interprophet_summary::
  options (const options_type& x)
  {
    this->options_.set (x);
  }

  void interprophet_summary::
  options (const options_optional& x)
  {
    this->options_ = x;
  }

  void interprophet_summary::
  options (::std::unique_ptr< options_type > x)
  {
    this->options_.set (std::move (x));
  }

  const interprophet_summary::est_tot_num_correct_psm_optional& interprophet_summary::
  est_tot_num_correct_psm () const
  {
    return this->est_tot_num_correct_psm_;
  }

  interprophet_summary::est_tot_num_correct_psm_optional& interprophet_summary::
  est_tot_num_correct_psm ()
  {
    return this->est_tot_num_correct_psm_;
  }

  void interprophet_summary::
  est_tot_num_correct_psm (const est_tot_num_correct_psm_type& x)
  {
    this->est_tot_num_correct_psm_.set (x);
  }

  void interprophet_summary::
  est_tot_num_correct_psm (const est_tot_num_correct_psm_optional& x)
  {
    this->est_tot_num_correct_psm_ = x;
  }

  const interprophet_summary::est_tot_num_correct_pep_optional& interprophet_summary::
  est_tot_num_correct_pep () const
  {
    return this->est_tot_num_correct_pep_;
  }

  interprophet_summary::est_tot_num_correct_pep_optional& interprophet_summary::
  est_tot_num_correct_pep ()
  {
    return this->est_tot_num_correct_pep_;
  }

  void interprophet_summary::
  est_tot_num_correct_pep (const est_tot_num_correct_pep_type& x)
  {
    this->est_tot_num_correct_pep_.set (x);
  }

  void interprophet_summary::
  est_tot_num_correct_pep (const est_tot_num_correct_pep_optional& x)
  {
    this->est_tot_num_correct_pep_ = x;
  }


  // ptmprophet_summary
  // 

  const ptmprophet_summary::inputfile_sequence& ptmprophet_summary::
  inputfile () const
  {
    return this->inputfile_;
  }

  ptmprophet_summary::inputfile_sequence& ptmprophet_summary::
  inputfile ()
  {
    return this->inputfile_;
  }

  void ptmprophet_summary::
  inputfile (const inputfile_sequence& s)
  {
    this->inputfile_ = s;
  }

  const ptmprophet_summary::mixturemodel_sequence& ptmprophet_summary::
  mixturemodel () const
  {
    return this->mixturemodel_;
  }

  ptmprophet_summary::mixturemodel_sequence& ptmprophet_summary::
  mixturemodel ()
  {
    return this->mixturemodel_;
  }

  void ptmprophet_summary::
  mixturemodel (const mixturemodel_sequence& s)
  {
    this->mixturemodel_ = s;
  }

  const ptmprophet_summary::version_type& ptmprophet_summary::
  version () const
  {
    return this->version_.get ();
  }

  ptmprophet_summary::version_type& ptmprophet_summary::
  version ()
  {
    return this->version_.get ();
  }

  void ptmprophet_summary::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void ptmprophet_summary::
  version (::std::unique_ptr< version_type > x)
  {
    this->version_.set (std::move (x));
  }

  const ptmprophet_summary::options_optional& ptmprophet_summary::
  options () const
  {
    return this->options_;
  }

  ptmprophet_summary::options_optional& ptmprophet_summary::
  options ()
  {
    return this->options_;
  }

  void ptmprophet_summary::
  options (const options_type& x)
  {
    this->options_.set (x);
  }

  void ptmprophet_summary::
  options (const options_optional& x)
  {
    this->options_ = x;
  }

  void ptmprophet_summary::
  options (::std::unique_ptr< options_type > x)
  {
    this->options_.set (std::move (x));
  }


  // asapratio_summary
  // 

  const asapratio_summary::version_type& asapratio_summary::
  version () const
  {
    return this->version_.get ();
  }

  asapratio_summary::version_type& asapratio_summary::
  version ()
  {
    return this->version_.get ();
  }

  void asapratio_summary::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void asapratio_summary::
  version (::std::unique_ptr< version_type > x)
  {
    this->version_.set (std::move (x));
  }

  const asapratio_summary::author_type& asapratio_summary::
  author () const
  {
    return this->author_.get ();
  }

  asapratio_summary::author_type& asapratio_summary::
  author ()
  {
    return this->author_.get ();
  }

  void asapratio_summary::
  author (const author_type& x)
  {
    this->author_.set (x);
  }

  void asapratio_summary::
  author (::std::unique_ptr< author_type > x)
  {
    this->author_.set (std::move (x));
  }

  const asapratio_summary::elution_type& asapratio_summary::
  elution () const
  {
    return this->elution_.get ();
  }

  asapratio_summary::elution_type& asapratio_summary::
  elution ()
  {
    return this->elution_.get ();
  }

  void asapratio_summary::
  elution (const elution_type& x)
  {
    this->elution_.set (x);
  }

  const asapratio_summary::labeled_residues_type& asapratio_summary::
  labeled_residues () const
  {
    return this->labeled_residues_.get ();
  }

  asapratio_summary::labeled_residues_type& asapratio_summary::
  labeled_residues ()
  {
    return this->labeled_residues_.get ();
  }

  void asapratio_summary::
  labeled_residues (const labeled_residues_type& x)
  {
    this->labeled_residues_.set (x);
  }

  void asapratio_summary::
  labeled_residues (::std::unique_ptr< labeled_residues_type > x)
  {
    this->labeled_residues_.set (std::move (x));
  }

  const asapratio_summary::area_flag_type& asapratio_summary::
  area_flag () const
  {
    return this->area_flag_.get ();
  }

  asapratio_summary::area_flag_type& asapratio_summary::
  area_flag ()
  {
    return this->area_flag_.get ();
  }

  void asapratio_summary::
  area_flag (const area_flag_type& x)
  {
    this->area_flag_.set (x);
  }

  const asapratio_summary::static_quant_type& asapratio_summary::
  static_quant () const
  {
    return this->static_quant_.get ();
  }

  asapratio_summary::static_quant_type& asapratio_summary::
  static_quant ()
  {
    return this->static_quant_.get ();
  }

  void asapratio_summary::
  static_quant (const static_quant_type& x)
  {
    this->static_quant_.set (x);
  }

  void asapratio_summary::
  static_quant (::std::unique_ptr< static_quant_type > x)
  {
    this->static_quant_.set (std::move (x));
  }

  const asapratio_summary::specified_residue_masses_optional& asapratio_summary::
  specified_residue_masses () const
  {
    return this->specified_residue_masses_;
  }

  asapratio_summary::specified_residue_masses_optional& asapratio_summary::
  specified_residue_masses ()
  {
    return this->specified_residue_masses_;
  }

  void asapratio_summary::
  specified_residue_masses (const specified_residue_masses_type& x)
  {
    this->specified_residue_masses_.set (x);
  }

  void asapratio_summary::
  specified_residue_masses (const specified_residue_masses_optional& x)
  {
    this->specified_residue_masses_ = x;
  }

  void asapratio_summary::
  specified_residue_masses (::std::unique_ptr< specified_residue_masses_type > x)
  {
    this->specified_residue_masses_.set (std::move (x));
  }


  // xpressratio_summary
  // 

  const xpressratio_summary::version_type& xpressratio_summary::
  version () const
  {
    return this->version_.get ();
  }

  xpressratio_summary::version_type& xpressratio_summary::
  version ()
  {
    return this->version_.get ();
  }

  void xpressratio_summary::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void xpressratio_summary::
  version (::std::unique_ptr< version_type > x)
  {
    this->version_.set (std::move (x));
  }

  const xpressratio_summary::author_type& xpressratio_summary::
  author () const
  {
    return this->author_.get ();
  }

  xpressratio_summary::author_type& xpressratio_summary::
  author ()
  {
    return this->author_.get ();
  }

  void xpressratio_summary::
  author (const author_type& x)
  {
    this->author_.set (x);
  }

  void xpressratio_summary::
  author (::std::unique_ptr< author_type > x)
  {
    this->author_.set (std::move (x));
  }

  const xpressratio_summary::same_scan_range_type& xpressratio_summary::
  same_scan_range () const
  {
    return this->same_scan_range_.get ();
  }

  xpressratio_summary::same_scan_range_type& xpressratio_summary::
  same_scan_range ()
  {
    return this->same_scan_range_.get ();
  }

  void xpressratio_summary::
  same_scan_range (const same_scan_range_type& x)
  {
    this->same_scan_range_.set (x);
  }

  void xpressratio_summary::
  same_scan_range (::std::unique_ptr< same_scan_range_type > x)
  {
    this->same_scan_range_.set (std::move (x));
  }

  const xpressratio_summary::labeled_residues_type& xpressratio_summary::
  labeled_residues () const
  {
    return this->labeled_residues_.get ();
  }

  xpressratio_summary::labeled_residues_type& xpressratio_summary::
  labeled_residues ()
  {
    return this->labeled_residues_.get ();
  }

  void xpressratio_summary::
  labeled_residues (const labeled_residues_type& x)
  {
    this->labeled_residues_.set (x);
  }

  void xpressratio_summary::
  labeled_residues (::std::unique_ptr< labeled_residues_type > x)
  {
    this->labeled_residues_.set (std::move (x));
  }

  const xpressratio_summary::xpress_light_type& xpressratio_summary::
  xpress_light () const
  {
    return this->xpress_light_.get ();
  }

  xpressratio_summary::xpress_light_type& xpressratio_summary::
  xpress_light ()
  {
    return this->xpress_light_.get ();
  }

  void xpressratio_summary::
  xpress_light (const xpress_light_type& x)
  {
    this->xpress_light_.set (x);
  }

  const xpressratio_summary::massdiff_type& xpressratio_summary::
  massdiff () const
  {
    return this->massdiff_.get ();
  }

  xpressratio_summary::massdiff_type& xpressratio_summary::
  massdiff ()
  {
    return this->massdiff_.get ();
  }

  void xpressratio_summary::
  massdiff (const massdiff_type& x)
  {
    this->massdiff_.set (x);
  }

  const xpressratio_summary::masstol_type& xpressratio_summary::
  masstol () const
  {
    return this->masstol_.get ();
  }

  xpressratio_summary::masstol_type& xpressratio_summary::
  masstol ()
  {
    return this->masstol_.get ();
  }

  void xpressratio_summary::
  masstol (const masstol_type& x)
  {
    this->masstol_.set (x);
  }

  const xpressratio_summary::ppmtol_type& xpressratio_summary::
  ppmtol () const
  {
    return this->ppmtol_.get ();
  }

  xpressratio_summary::ppmtol_type& xpressratio_summary::
  ppmtol ()
  {
    return this->ppmtol_.get ();
  }

  void xpressratio_summary::
  ppmtol (const ppmtol_type& x)
  {
    this->ppmtol_.set (x);
  }

  const xpressratio_summary::min_num_chromatogram_points_type& xpressratio_summary::
  min_num_chromatogram_points () const
  {
    return this->min_num_chromatogram_points_.get ();
  }

  xpressratio_summary::min_num_chromatogram_points_type& xpressratio_summary::
  min_num_chromatogram_points ()
  {
    return this->min_num_chromatogram_points_.get ();
  }

  void xpressratio_summary::
  min_num_chromatogram_points (const min_num_chromatogram_points_type& x)
  {
    this->min_num_chromatogram_points_.set (x);
  }

  const xpressratio_summary::min_num_isotope_peaks_type& xpressratio_summary::
  min_num_isotope_peaks () const
  {
    return this->min_num_isotope_peaks_.get ();
  }

  xpressratio_summary::min_num_isotope_peaks_type& xpressratio_summary::
  min_num_isotope_peaks ()
  {
    return this->min_num_isotope_peaks_.get ();
  }

  void xpressratio_summary::
  min_num_isotope_peaks (const min_num_isotope_peaks_type& x)
  {
    this->min_num_isotope_peaks_.set (x);
  }


  // ptmprophet_result
  // 

  const ptmprophet_result::mod_aminoacid_probability_sequence& ptmprophet_result::
  mod_aminoacid_probability () const
  {
    return this->mod_aminoacid_probability_;
  }

  ptmprophet_result::mod_aminoacid_probability_sequence& ptmprophet_result::
  mod_aminoacid_probability ()
  {
    return this->mod_aminoacid_probability_;
  }

  void ptmprophet_result::
  mod_aminoacid_probability (const mod_aminoacid_probability_sequence& s)
  {
    this->mod_aminoacid_probability_ = s;
  }

  const ptmprophet_result::prior_type& ptmprophet_result::
  prior () const
  {
    return this->prior_.get ();
  }

  ptmprophet_result::prior_type& ptmprophet_result::
  prior ()
  {
    return this->prior_.get ();
  }

  void ptmprophet_result::
  prior (const prior_type& x)
  {
    this->prior_.set (x);
  }

  const ptmprophet_result::ptm_type& ptmprophet_result::
  ptm () const
  {
    return this->ptm_.get ();
  }

  ptmprophet_result::ptm_type& ptmprophet_result::
  ptm ()
  {
    return this->ptm_.get ();
  }

  void ptmprophet_result::
  ptm (const ptm_type& x)
  {
    this->ptm_.set (x);
  }

  void ptmprophet_result::
  ptm (::std::unique_ptr< ptm_type > x)
  {
    this->ptm_.set (std::move (x));
  }

  const ptmprophet_result::ptm_peptide_type& ptmprophet_result::
  ptm_peptide () const
  {
    return this->ptm_peptide_.get ();
  }

  ptmprophet_result::ptm_peptide_type& ptmprophet_result::
  ptm_peptide ()
  {
    return this->ptm_peptide_.get ();
  }

  void ptmprophet_result::
  ptm_peptide (const ptm_peptide_type& x)
  {
    this->ptm_peptide_.set (x);
  }

  void ptmprophet_result::
  ptm_peptide (::std::unique_ptr< ptm_peptide_type > x)
  {
    this->ptm_peptide_.set (std::move (x));
  }


  // peptideprophet_result
  // 

  const peptideprophet_result::search_score_summary_optional& peptideprophet_result::
  search_score_summary () const
  {
    return this->search_score_summary_;
  }

  peptideprophet_result::search_score_summary_optional& peptideprophet_result::
  search_score_summary ()
  {
    return this->search_score_summary_;
  }

  void peptideprophet_result::
  search_score_summary (const search_score_summary_type& x)
  {
    this->search_score_summary_.set (x);
  }

  void peptideprophet_result::
  search_score_summary (const search_score_summary_optional& x)
  {
    this->search_score_summary_ = x;
  }

  void peptideprophet_result::
  search_score_summary (::std::unique_ptr< search_score_summary_type > x)
  {
    this->search_score_summary_.set (std::move (x));
  }

  const peptideprophet_result::probability_type& peptideprophet_result::
  probability () const
  {
    return this->probability_.get ();
  }

  peptideprophet_result::probability_type& peptideprophet_result::
  probability ()
  {
    return this->probability_.get ();
  }

  void peptideprophet_result::
  probability (const probability_type& x)
  {
    this->probability_.set (x);
  }

  const peptideprophet_result::all_ntt_prob_optional& peptideprophet_result::
  all_ntt_prob () const
  {
    return this->all_ntt_prob_;
  }

  peptideprophet_result::all_ntt_prob_optional& peptideprophet_result::
  all_ntt_prob ()
  {
    return this->all_ntt_prob_;
  }

  void peptideprophet_result::
  all_ntt_prob (const all_ntt_prob_type& x)
  {
    this->all_ntt_prob_.set (x);
  }

  void peptideprophet_result::
  all_ntt_prob (const all_ntt_prob_optional& x)
  {
    this->all_ntt_prob_ = x;
  }

  void peptideprophet_result::
  all_ntt_prob (::std::unique_ptr< all_ntt_prob_type > x)
  {
    this->all_ntt_prob_.set (std::move (x));
  }

  const peptideprophet_result::analysis_optional& peptideprophet_result::
  analysis () const
  {
    return this->analysis_;
  }

  peptideprophet_result::analysis_optional& peptideprophet_result::
  analysis ()
  {
    return this->analysis_;
  }

  void peptideprophet_result::
  analysis (const analysis_type& x)
  {
    this->analysis_.set (x);
  }

  void peptideprophet_result::
  analysis (const analysis_optional& x)
  {
    this->analysis_ = x;
  }

  void peptideprophet_result::
  analysis (::std::unique_ptr< analysis_type > x)
  {
    this->analysis_.set (std::move (x));
  }


  // interprophet_result
  // 

  const interprophet_result::search_score_summary_optional& interprophet_result::
  search_score_summary () const
  {
    return this->search_score_summary_;
  }

  interprophet_result::search_score_summary_optional& interprophet_result::
  search_score_summary ()
  {
    return this->search_score_summary_;
  }

  void interprophet_result::
  search_score_summary (const search_score_summary_type& x)
  {
    this->search_score_summary_.set (x);
  }

  void interprophet_result::
  search_score_summary (const search_score_summary_optional& x)
  {
    this->search_score_summary_ = x;
  }

  void interprophet_result::
  search_score_summary (::std::unique_ptr< search_score_summary_type > x)
  {
    this->search_score_summary_.set (std::move (x));
  }

  const interprophet_result::probability_type& interprophet_result::
  probability () const
  {
    return this->probability_.get ();
  }

  interprophet_result::probability_type& interprophet_result::
  probability ()
  {
    return this->probability_.get ();
  }

  void interprophet_result::
  probability (const probability_type& x)
  {
    this->probability_.set (x);
  }

  const interprophet_result::all_ntt_prob_optional& interprophet_result::
  all_ntt_prob () const
  {
    return this->all_ntt_prob_;
  }

  interprophet_result::all_ntt_prob_optional& interprophet_result::
  all_ntt_prob ()
  {
    return this->all_ntt_prob_;
  }

  void interprophet_result::
  all_ntt_prob (const all_ntt_prob_type& x)
  {
    this->all_ntt_prob_.set (x);
  }

  void interprophet_result::
  all_ntt_prob (const all_ntt_prob_optional& x)
  {
    this->all_ntt_prob_ = x;
  }

  void interprophet_result::
  all_ntt_prob (::std::unique_ptr< all_ntt_prob_type > x)
  {
    this->all_ntt_prob_.set (std::move (x));
  }


  // asapratio_result
  // 

  const asapratio_result::asapratio_peptide_data_type& asapratio_result::
  asapratio_peptide_data () const
  {
    return this->asapratio_peptide_data_.get ();
  }

  asapratio_result::asapratio_peptide_data_type& asapratio_result::
  asapratio_peptide_data ()
  {
    return this->asapratio_peptide_data_.get ();
  }

  void asapratio_result::
  asapratio_peptide_data (const asapratio_peptide_data_type& x)
  {
    this->asapratio_peptide_data_.set (x);
  }

  void asapratio_result::
  asapratio_peptide_data (::std::unique_ptr< asapratio_peptide_data_type > x)
  {
    this->asapratio_peptide_data_.set (std::move (x));
  }

  const asapratio_result::mean_type& asapratio_result::
  mean () const
  {
    return this->mean_.get ();
  }

  asapratio_result::mean_type& asapratio_result::
  mean ()
  {
    return this->mean_.get ();
  }

  void asapratio_result::
  mean (const mean_type& x)
  {
    this->mean_.set (x);
  }

  const asapratio_result::error_type& asapratio_result::
  error () const
  {
    return this->error_.get ();
  }

  asapratio_result::error_type& asapratio_result::
  error ()
  {
    return this->error_.get ();
  }

  void asapratio_result::
  error (const error_type& x)
  {
    this->error_.set (x);
  }

  const asapratio_result::heavy2light_mean_type& asapratio_result::
  heavy2light_mean () const
  {
    return this->heavy2light_mean_.get ();
  }

  asapratio_result::heavy2light_mean_type& asapratio_result::
  heavy2light_mean ()
  {
    return this->heavy2light_mean_.get ();
  }

  void asapratio_result::
  heavy2light_mean (const heavy2light_mean_type& x)
  {
    this->heavy2light_mean_.set (x);
  }

  const asapratio_result::heavy2light_error_type& asapratio_result::
  heavy2light_error () const
  {
    return this->heavy2light_error_.get ();
  }

  asapratio_result::heavy2light_error_type& asapratio_result::
  heavy2light_error ()
  {
    return this->heavy2light_error_.get ();
  }

  void asapratio_result::
  heavy2light_error (const heavy2light_error_type& x)
  {
    this->heavy2light_error_.set (x);
  }


  // asapratio_peptide_data
  // 

  const asapratio_peptide_data::asapratio_contribution_sequence& asapratio_peptide_data::
  asapratio_contribution () const
  {
    return this->asapratio_contribution_;
  }

  asapratio_peptide_data::asapratio_contribution_sequence& asapratio_peptide_data::
  asapratio_contribution ()
  {
    return this->asapratio_contribution_;
  }

  void asapratio_peptide_data::
  asapratio_contribution (const asapratio_contribution_sequence& s)
  {
    this->asapratio_contribution_ = s;
  }

  const asapratio_peptide_data::status_type& asapratio_peptide_data::
  status () const
  {
    return this->status_.get ();
  }

  asapratio_peptide_data::status_type& asapratio_peptide_data::
  status ()
  {
    return this->status_.get ();
  }

  void asapratio_peptide_data::
  status (const status_type& x)
  {
    this->status_.set (x);
  }

  const asapratio_peptide_data::cidIndex_type& asapratio_peptide_data::
  cidIndex () const
  {
    return this->cidIndex_.get ();
  }

  asapratio_peptide_data::cidIndex_type& asapratio_peptide_data::
  cidIndex ()
  {
    return this->cidIndex_.get ();
  }

  void asapratio_peptide_data::
  cidIndex (const cidIndex_type& x)
  {
    this->cidIndex_.set (x);
  }

  const asapratio_peptide_data::light_mass_type& asapratio_peptide_data::
  light_mass () const
  {
    return this->light_mass_.get ();
  }

  asapratio_peptide_data::light_mass_type& asapratio_peptide_data::
  light_mass ()
  {
    return this->light_mass_.get ();
  }

  void asapratio_peptide_data::
  light_mass (const light_mass_type& x)
  {
    this->light_mass_.set (x);
  }

  const asapratio_peptide_data::heavy_mass_type& asapratio_peptide_data::
  heavy_mass () const
  {
    return this->heavy_mass_.get ();
  }

  asapratio_peptide_data::heavy_mass_type& asapratio_peptide_data::
  heavy_mass ()
  {
    return this->heavy_mass_.get ();
  }

  void asapratio_peptide_data::
  heavy_mass (const heavy_mass_type& x)
  {
    this->heavy_mass_.set (x);
  }

  const asapratio_peptide_data::area_flag_type& asapratio_peptide_data::
  area_flag () const
  {
    return this->area_flag_.get ();
  }

  asapratio_peptide_data::area_flag_type& asapratio_peptide_data::
  area_flag ()
  {
    return this->area_flag_.get ();
  }

  void asapratio_peptide_data::
  area_flag (const area_flag_type& x)
  {
    this->area_flag_.set (x);
  }


  // asapratio_contribution
  // 

  const asapratio_contribution::asapratio_lc_lightpeak_type& asapratio_contribution::
  asapratio_lc_lightpeak () const
  {
    return this->asapratio_lc_lightpeak_.get ();
  }

  asapratio_contribution::asapratio_lc_lightpeak_type& asapratio_contribution::
  asapratio_lc_lightpeak ()
  {
    return this->asapratio_lc_lightpeak_.get ();
  }

  void asapratio_contribution::
  asapratio_lc_lightpeak (const asapratio_lc_lightpeak_type& x)
  {
    this->asapratio_lc_lightpeak_.set (x);
  }

  void asapratio_contribution::
  asapratio_lc_lightpeak (::std::unique_ptr< asapratio_lc_lightpeak_type > x)
  {
    this->asapratio_lc_lightpeak_.set (std::move (x));
  }

  const asapratio_contribution::asapratio_lc_heavypeak_type& asapratio_contribution::
  asapratio_lc_heavypeak () const
  {
    return this->asapratio_lc_heavypeak_.get ();
  }

  asapratio_contribution::asapratio_lc_heavypeak_type& asapratio_contribution::
  asapratio_lc_heavypeak ()
  {
    return this->asapratio_lc_heavypeak_.get ();
  }

  void asapratio_contribution::
  asapratio_lc_heavypeak (const asapratio_lc_heavypeak_type& x)
  {
    this->asapratio_lc_heavypeak_.set (x);
  }

  void asapratio_contribution::
  asapratio_lc_heavypeak (::std::unique_ptr< asapratio_lc_heavypeak_type > x)
  {
    this->asapratio_lc_heavypeak_.set (std::move (x));
  }

  const asapratio_contribution::ratio_type& asapratio_contribution::
  ratio () const
  {
    return this->ratio_.get ();
  }

  asapratio_contribution::ratio_type& asapratio_contribution::
  ratio ()
  {
    return this->ratio_.get ();
  }

  void asapratio_contribution::
  ratio (const ratio_type& x)
  {
    this->ratio_.set (x);
  }

  const asapratio_contribution::error_type& asapratio_contribution::
  error () const
  {
    return this->error_.get ();
  }

  asapratio_contribution::error_type& asapratio_contribution::
  error ()
  {
    return this->error_.get ();
  }

  void asapratio_contribution::
  error (const error_type& x)
  {
    this->error_.set (x);
  }

  const asapratio_contribution::charge_type& asapratio_contribution::
  charge () const
  {
    return this->charge_.get ();
  }

  asapratio_contribution::charge_type& asapratio_contribution::
  charge ()
  {
    return this->charge_.get ();
  }

  void asapratio_contribution::
  charge (const charge_type& x)
  {
    this->charge_.set (x);
  }

  const asapratio_contribution::use_type& asapratio_contribution::
  use () const
  {
    return this->use_.get ();
  }

  asapratio_contribution::use_type& asapratio_contribution::
  use ()
  {
    return this->use_.get ();
  }

  void asapratio_contribution::
  use (const use_type& x)
  {
    this->use_.set (x);
  }


  // asapratio_lc_lightpeak
  // 

  const asapratio_lc_lightpeak::status_type& asapratio_lc_lightpeak::
  status () const
  {
    return this->status_.get ();
  }

  asapratio_lc_lightpeak::status_type& asapratio_lc_lightpeak::
  status ()
  {
    return this->status_.get ();
  }

  void asapratio_lc_lightpeak::
  status (const status_type& x)
  {
    this->status_.set (x);
  }

  const asapratio_lc_lightpeak::left_valley_type& asapratio_lc_lightpeak::
  left_valley () const
  {
    return this->left_valley_.get ();
  }

  asapratio_lc_lightpeak::left_valley_type& asapratio_lc_lightpeak::
  left_valley ()
  {
    return this->left_valley_.get ();
  }

  void asapratio_lc_lightpeak::
  left_valley (const left_valley_type& x)
  {
    this->left_valley_.set (x);
  }

  const asapratio_lc_lightpeak::right_valley_type& asapratio_lc_lightpeak::
  right_valley () const
  {
    return this->right_valley_.get ();
  }

  asapratio_lc_lightpeak::right_valley_type& asapratio_lc_lightpeak::
  right_valley ()
  {
    return this->right_valley_.get ();
  }

  void asapratio_lc_lightpeak::
  right_valley (const right_valley_type& x)
  {
    this->right_valley_.set (x);
  }

  const asapratio_lc_lightpeak::background_type& asapratio_lc_lightpeak::
  background () const
  {
    return this->background_.get ();
  }

  asapratio_lc_lightpeak::background_type& asapratio_lc_lightpeak::
  background ()
  {
    return this->background_.get ();
  }

  void asapratio_lc_lightpeak::
  background (const background_type& x)
  {
    this->background_.set (x);
  }

  const asapratio_lc_lightpeak::area_type& asapratio_lc_lightpeak::
  area () const
  {
    return this->area_.get ();
  }

  asapratio_lc_lightpeak::area_type& asapratio_lc_lightpeak::
  area ()
  {
    return this->area_.get ();
  }

  void asapratio_lc_lightpeak::
  area (const area_type& x)
  {
    this->area_.set (x);
  }

  const asapratio_lc_lightpeak::area_error_type& asapratio_lc_lightpeak::
  area_error () const
  {
    return this->area_error_.get ();
  }

  asapratio_lc_lightpeak::area_error_type& asapratio_lc_lightpeak::
  area_error ()
  {
    return this->area_error_.get ();
  }

  void asapratio_lc_lightpeak::
  area_error (const area_error_type& x)
  {
    this->area_error_.set (x);
  }

  const asapratio_lc_lightpeak::time_type& asapratio_lc_lightpeak::
  time () const
  {
    return this->time_.get ();
  }

  asapratio_lc_lightpeak::time_type& asapratio_lc_lightpeak::
  time ()
  {
    return this->time_.get ();
  }

  void asapratio_lc_lightpeak::
  time (const time_type& x)
  {
    this->time_.set (x);
  }

  const asapratio_lc_lightpeak::time_width_type& asapratio_lc_lightpeak::
  time_width () const
  {
    return this->time_width_.get ();
  }

  asapratio_lc_lightpeak::time_width_type& asapratio_lc_lightpeak::
  time_width ()
  {
    return this->time_width_.get ();
  }

  void asapratio_lc_lightpeak::
  time_width (const time_width_type& x)
  {
    this->time_width_.set (x);
  }

  const asapratio_lc_lightpeak::is_heavy_type& asapratio_lc_lightpeak::
  is_heavy () const
  {
    return this->is_heavy_.get ();
  }

  asapratio_lc_lightpeak::is_heavy_type& asapratio_lc_lightpeak::
  is_heavy ()
  {
    return this->is_heavy_.get ();
  }

  void asapratio_lc_lightpeak::
  is_heavy (const is_heavy_type& x)
  {
    this->is_heavy_.set (x);
  }

  void asapratio_lc_lightpeak::
  is_heavy (::std::unique_ptr< is_heavy_type > x)
  {
    this->is_heavy_.set (std::move (x));
  }


  // asapratio_lc_heavypeak
  // 

  const asapratio_lc_heavypeak::status_type& asapratio_lc_heavypeak::
  status () const
  {
    return this->status_.get ();
  }

  asapratio_lc_heavypeak::status_type& asapratio_lc_heavypeak::
  status ()
  {
    return this->status_.get ();
  }

  void asapratio_lc_heavypeak::
  status (const status_type& x)
  {
    this->status_.set (x);
  }

  const asapratio_lc_heavypeak::left_valley_type& asapratio_lc_heavypeak::
  left_valley () const
  {
    return this->left_valley_.get ();
  }

  asapratio_lc_heavypeak::left_valley_type& asapratio_lc_heavypeak::
  left_valley ()
  {
    return this->left_valley_.get ();
  }

  void asapratio_lc_heavypeak::
  left_valley (const left_valley_type& x)
  {
    this->left_valley_.set (x);
  }

  const asapratio_lc_heavypeak::right_valley_type& asapratio_lc_heavypeak::
  right_valley () const
  {
    return this->right_valley_.get ();
  }

  asapratio_lc_heavypeak::right_valley_type& asapratio_lc_heavypeak::
  right_valley ()
  {
    return this->right_valley_.get ();
  }

  void asapratio_lc_heavypeak::
  right_valley (const right_valley_type& x)
  {
    this->right_valley_.set (x);
  }

  const asapratio_lc_heavypeak::background_type& asapratio_lc_heavypeak::
  background () const
  {
    return this->background_.get ();
  }

  asapratio_lc_heavypeak::background_type& asapratio_lc_heavypeak::
  background ()
  {
    return this->background_.get ();
  }

  void asapratio_lc_heavypeak::
  background (const background_type& x)
  {
    this->background_.set (x);
  }

  const asapratio_lc_heavypeak::area_type& asapratio_lc_heavypeak::
  area () const
  {
    return this->area_.get ();
  }

  asapratio_lc_heavypeak::area_type& asapratio_lc_heavypeak::
  area ()
  {
    return this->area_.get ();
  }

  void asapratio_lc_heavypeak::
  area (const area_type& x)
  {
    this->area_.set (x);
  }

  const asapratio_lc_heavypeak::area_error_type& asapratio_lc_heavypeak::
  area_error () const
  {
    return this->area_error_.get ();
  }

  asapratio_lc_heavypeak::area_error_type& asapratio_lc_heavypeak::
  area_error ()
  {
    return this->area_error_.get ();
  }

  void asapratio_lc_heavypeak::
  area_error (const area_error_type& x)
  {
    this->area_error_.set (x);
  }

  const asapratio_lc_heavypeak::time_type& asapratio_lc_heavypeak::
  time () const
  {
    return this->time_.get ();
  }

  asapratio_lc_heavypeak::time_type& asapratio_lc_heavypeak::
  time ()
  {
    return this->time_.get ();
  }

  void asapratio_lc_heavypeak::
  time (const time_type& x)
  {
    this->time_.set (x);
  }

  const asapratio_lc_heavypeak::time_width_type& asapratio_lc_heavypeak::
  time_width () const
  {
    return this->time_width_.get ();
  }

  asapratio_lc_heavypeak::time_width_type& asapratio_lc_heavypeak::
  time_width ()
  {
    return this->time_width_.get ();
  }

  void asapratio_lc_heavypeak::
  time_width (const time_width_type& x)
  {
    this->time_width_.set (x);
  }

  const asapratio_lc_heavypeak::is_heavy_type& asapratio_lc_heavypeak::
  is_heavy () const
  {
    return this->is_heavy_.get ();
  }

  asapratio_lc_heavypeak::is_heavy_type& asapratio_lc_heavypeak::
  is_heavy ()
  {
    return this->is_heavy_.get ();
  }

  void asapratio_lc_heavypeak::
  is_heavy (const is_heavy_type& x)
  {
    this->is_heavy_.set (x);
  }

  void asapratio_lc_heavypeak::
  is_heavy (::std::unique_ptr< is_heavy_type > x)
  {
    this->is_heavy_.set (std::move (x));
  }


  // database_refresh_timestamp
  // 

  const database_refresh_timestamp::database_type& database_refresh_timestamp::
  database () const
  {
    return this->database_.get ();
  }

  database_refresh_timestamp::database_type& database_refresh_timestamp::
  database ()
  {
    return this->database_.get ();
  }

  void database_refresh_timestamp::
  database (const database_type& x)
  {
    this->database_.set (x);
  }

  void database_refresh_timestamp::
  database (::std::unique_ptr< database_type > x)
  {
    this->database_.set (std::move (x));
  }

  const database_refresh_timestamp::min_num_enz_term_optional& database_refresh_timestamp::
  min_num_enz_term () const
  {
    return this->min_num_enz_term_;
  }

  database_refresh_timestamp::min_num_enz_term_optional& database_refresh_timestamp::
  min_num_enz_term ()
  {
    return this->min_num_enz_term_;
  }

  void database_refresh_timestamp::
  min_num_enz_term (const min_num_enz_term_type& x)
  {
    this->min_num_enz_term_.set (x);
  }

  void database_refresh_timestamp::
  min_num_enz_term (const min_num_enz_term_optional& x)
  {
    this->min_num_enz_term_ = x;
  }


  // xpressratio_timestamp
  // 

  const xpressratio_timestamp::xpress_light_type& xpressratio_timestamp::
  xpress_light () const
  {
    return this->xpress_light_.get ();
  }

  xpressratio_timestamp::xpress_light_type& xpressratio_timestamp::
  xpress_light ()
  {
    return this->xpress_light_.get ();
  }

  void xpressratio_timestamp::
  xpress_light (const xpress_light_type& x)
  {
    this->xpress_light_.set (x);
  }


  // asapratio_timestamp
  // 

  const asapratio_timestamp::quant_label_masses_optional& asapratio_timestamp::
  quant_label_masses () const
  {
    return this->quant_label_masses_;
  }

  asapratio_timestamp::quant_label_masses_optional& asapratio_timestamp::
  quant_label_masses ()
  {
    return this->quant_label_masses_;
  }

  void asapratio_timestamp::
  quant_label_masses (const quant_label_masses_type& x)
  {
    this->quant_label_masses_.set (x);
  }

  void asapratio_timestamp::
  quant_label_masses (const quant_label_masses_optional& x)
  {
    this->quant_label_masses_ = x;
  }

  void asapratio_timestamp::
  quant_label_masses (::std::unique_ptr< quant_label_masses_type > x)
  {
    this->quant_label_masses_.set (std::move (x));
  }

  const asapratio_timestamp::static_quant_label_optional& asapratio_timestamp::
  static_quant_label () const
  {
    return this->static_quant_label_;
  }

  asapratio_timestamp::static_quant_label_optional& asapratio_timestamp::
  static_quant_label ()
  {
    return this->static_quant_label_;
  }

  void asapratio_timestamp::
  static_quant_label (const static_quant_label_type& x)
  {
    this->static_quant_label_.set (x);
  }

  void asapratio_timestamp::
  static_quant_label (const static_quant_label_optional& x)
  {
    this->static_quant_label_ = x;
  }

  void asapratio_timestamp::
  static_quant_label (::std::unique_ptr< static_quant_label_type > x)
  {
    this->static_quant_label_.set (std::move (x));
  }


  // xpressratio_result
  // 

  const xpressratio_result::light_firstscan_type& xpressratio_result::
  light_firstscan () const
  {
    return this->light_firstscan_.get ();
  }

  xpressratio_result::light_firstscan_type& xpressratio_result::
  light_firstscan ()
  {
    return this->light_firstscan_.get ();
  }

  void xpressratio_result::
  light_firstscan (const light_firstscan_type& x)
  {
    this->light_firstscan_.set (x);
  }

  const xpressratio_result::light_lastscan_type& xpressratio_result::
  light_lastscan () const
  {
    return this->light_lastscan_.get ();
  }

  xpressratio_result::light_lastscan_type& xpressratio_result::
  light_lastscan ()
  {
    return this->light_lastscan_.get ();
  }

  void xpressratio_result::
  light_lastscan (const light_lastscan_type& x)
  {
    this->light_lastscan_.set (x);
  }

  const xpressratio_result::light_mass_type& xpressratio_result::
  light_mass () const
  {
    return this->light_mass_.get ();
  }

  xpressratio_result::light_mass_type& xpressratio_result::
  light_mass ()
  {
    return this->light_mass_.get ();
  }

  void xpressratio_result::
  light_mass (const light_mass_type& x)
  {
    this->light_mass_.set (x);
  }

  const xpressratio_result::heavy_firstscan_type& xpressratio_result::
  heavy_firstscan () const
  {
    return this->heavy_firstscan_.get ();
  }

  xpressratio_result::heavy_firstscan_type& xpressratio_result::
  heavy_firstscan ()
  {
    return this->heavy_firstscan_.get ();
  }

  void xpressratio_result::
  heavy_firstscan (const heavy_firstscan_type& x)
  {
    this->heavy_firstscan_.set (x);
  }

  const xpressratio_result::heavy_lastscan_type& xpressratio_result::
  heavy_lastscan () const
  {
    return this->heavy_lastscan_.get ();
  }

  xpressratio_result::heavy_lastscan_type& xpressratio_result::
  heavy_lastscan ()
  {
    return this->heavy_lastscan_.get ();
  }

  void xpressratio_result::
  heavy_lastscan (const heavy_lastscan_type& x)
  {
    this->heavy_lastscan_.set (x);
  }

  const xpressratio_result::heavy_mass_type& xpressratio_result::
  heavy_mass () const
  {
    return this->heavy_mass_.get ();
  }

  xpressratio_result::heavy_mass_type& xpressratio_result::
  heavy_mass ()
  {
    return this->heavy_mass_.get ();
  }

  void xpressratio_result::
  heavy_mass (const heavy_mass_type& x)
  {
    this->heavy_mass_.set (x);
  }

  const xpressratio_result::mass_tol_type& xpressratio_result::
  mass_tol () const
  {
    return this->mass_tol_.get ();
  }

  xpressratio_result::mass_tol_type& xpressratio_result::
  mass_tol ()
  {
    return this->mass_tol_.get ();
  }

  void xpressratio_result::
  mass_tol (const mass_tol_type& x)
  {
    this->mass_tol_.set (x);
  }

  const xpressratio_result::ratio_type& xpressratio_result::
  ratio () const
  {
    return this->ratio_.get ();
  }

  xpressratio_result::ratio_type& xpressratio_result::
  ratio ()
  {
    return this->ratio_.get ();
  }

  void xpressratio_result::
  ratio (const ratio_type& x)
  {
    this->ratio_.set (x);
  }

  void xpressratio_result::
  ratio (::std::unique_ptr< ratio_type > x)
  {
    this->ratio_.set (std::move (x));
  }

  const xpressratio_result::heavy2light_ratio_type& xpressratio_result::
  heavy2light_ratio () const
  {
    return this->heavy2light_ratio_.get ();
  }

  xpressratio_result::heavy2light_ratio_type& xpressratio_result::
  heavy2light_ratio ()
  {
    return this->heavy2light_ratio_.get ();
  }

  void xpressratio_result::
  heavy2light_ratio (const heavy2light_ratio_type& x)
  {
    this->heavy2light_ratio_.set (x);
  }

  void xpressratio_result::
  heavy2light_ratio (::std::unique_ptr< heavy2light_ratio_type > x)
  {
    this->heavy2light_ratio_.set (std::move (x));
  }

  const xpressratio_result::light_area_type& xpressratio_result::
  light_area () const
  {
    return this->light_area_.get ();
  }

  xpressratio_result::light_area_type& xpressratio_result::
  light_area ()
  {
    return this->light_area_.get ();
  }

  void xpressratio_result::
  light_area (const light_area_type& x)
  {
    this->light_area_.set (x);
  }

  const xpressratio_result::heavy_area_type& xpressratio_result::
  heavy_area () const
  {
    return this->heavy_area_.get ();
  }

  xpressratio_result::heavy_area_type& xpressratio_result::
  heavy_area ()
  {
    return this->heavy_area_.get ();
  }

  void xpressratio_result::
  heavy_area (const heavy_area_type& x)
  {
    this->heavy_area_.set (x);
  }

  const xpressratio_result::decimal_ratio_type& xpressratio_result::
  decimal_ratio () const
  {
    return this->decimal_ratio_.get ();
  }

  xpressratio_result::decimal_ratio_type& xpressratio_result::
  decimal_ratio ()
  {
    return this->decimal_ratio_.get ();
  }

  void xpressratio_result::
  decimal_ratio (const decimal_ratio_type& x)
  {
    this->decimal_ratio_.set (x);
  }


  // interact_summary
  // 

  const interact_summary::inputfile_sequence& interact_summary::
  inputfile () const
  {
    return this->inputfile_;
  }

  interact_summary::inputfile_sequence& interact_summary::
  inputfile ()
  {
    return this->inputfile_;
  }

  void interact_summary::
  inputfile (const inputfile_sequence& s)
  {
    this->inputfile_ = s;
  }

  const interact_summary::filename_type& interact_summary::
  filename () const
  {
    return this->filename_.get ();
  }

  interact_summary::filename_type& interact_summary::
  filename ()
  {
    return this->filename_.get ();
  }

  void interact_summary::
  filename (const filename_type& x)
  {
    this->filename_.set (x);
  }

  void interact_summary::
  filename (::std::unique_ptr< filename_type > x)
  {
    this->filename_.set (std::move (x));
  }

  const interact_summary::directory_type& interact_summary::
  directory () const
  {
    return this->directory_.get ();
  }

  interact_summary::directory_type& interact_summary::
  directory ()
  {
    return this->directory_.get ();
  }

  void interact_summary::
  directory (const directory_type& x)
  {
    this->directory_.set (x);
  }

  void interact_summary::
  directory (::std::unique_ptr< directory_type > x)
  {
    this->directory_.set (std::move (x));
  }


  // libra_result
  // 

  const libra_result::intensity_sequence& libra_result::
  intensity () const
  {
    return this->intensity_;
  }

  libra_result::intensity_sequence& libra_result::
  intensity ()
  {
    return this->intensity_;
  }

  void libra_result::
  intensity (const intensity_sequence& s)
  {
    this->intensity_ = s;
  }

  const libra_result::is_rejected_type& libra_result::
  is_rejected () const
  {
    return this->is_rejected_.get ();
  }

  libra_result::is_rejected_type& libra_result::
  is_rejected ()
  {
    return this->is_rejected_.get ();
  }

  void libra_result::
  is_rejected (const is_rejected_type& x)
  {
    this->is_rejected_.set (x);
  }

  libra_result::is_rejected_type libra_result::
  is_rejected_default_value ()
  {
    return is_rejected_type (false);
  }


  // libra_summary
  // 

  const libra_summary::fragment_masses_sequence& libra_summary::
  fragment_masses () const
  {
    return this->fragment_masses_;
  }

  libra_summary::fragment_masses_sequence& libra_summary::
  fragment_masses ()
  {
    return this->fragment_masses_;
  }

  void libra_summary::
  fragment_masses (const fragment_masses_sequence& s)
  {
    this->fragment_masses_ = s;
  }

  const libra_summary::isotopic_contributions_optional& libra_summary::
  isotopic_contributions () const
  {
    return this->isotopic_contributions_;
  }

  libra_summary::isotopic_contributions_optional& libra_summary::
  isotopic_contributions ()
  {
    return this->isotopic_contributions_;
  }

  void libra_summary::
  isotopic_contributions (const isotopic_contributions_type& x)
  {
    this->isotopic_contributions_.set (x);
  }

  void libra_summary::
  isotopic_contributions (const isotopic_contributions_optional& x)
  {
    this->isotopic_contributions_ = x;
  }

  void libra_summary::
  isotopic_contributions (::std::unique_ptr< isotopic_contributions_type > x)
  {
    this->isotopic_contributions_.set (std::move (x));
  }

  const libra_summary::mass_tolerance_type& libra_summary::
  mass_tolerance () const
  {
    return this->mass_tolerance_.get ();
  }

  libra_summary::mass_tolerance_type& libra_summary::
  mass_tolerance ()
  {
    return this->mass_tolerance_.get ();
  }

  void libra_summary::
  mass_tolerance (const mass_tolerance_type& x)
  {
    this->mass_tolerance_.set (x);
  }

  const libra_summary::centroiding_preference_type& libra_summary::
  centroiding_preference () const
  {
    return this->centroiding_preference_.get ();
  }

  libra_summary::centroiding_preference_type& libra_summary::
  centroiding_preference ()
  {
    return this->centroiding_preference_.get ();
  }

  void libra_summary::
  centroiding_preference (const centroiding_preference_type& x)
  {
    this->centroiding_preference_.set (x);
  }

  const libra_summary::normalization_type& libra_summary::
  normalization () const
  {
    return this->normalization_.get ();
  }

  libra_summary::normalization_type& libra_summary::
  normalization ()
  {
    return this->normalization_.get ();
  }

  void libra_summary::
  normalization (const normalization_type& x)
  {
    this->normalization_.set (x);
  }

  const libra_summary::output_type_type& libra_summary::
  output_type () const
  {
    return this->output_type_.get ();
  }

  libra_summary::output_type_type& libra_summary::
  output_type ()
  {
    return this->output_type_.get ();
  }

  void libra_summary::
  output_type (const output_type_type& x)
  {
    this->output_type_.set (x);
  }

  const libra_summary::channel_code_optional& libra_summary::
  channel_code () const
  {
    return this->channel_code_;
  }

  libra_summary::channel_code_optional& libra_summary::
  channel_code ()
  {
    return this->channel_code_;
  }

  void libra_summary::
  channel_code (const channel_code_type& x)
  {
    this->channel_code_.set (x);
  }

  void libra_summary::
  channel_code (const channel_code_optional& x)
  {
    this->channel_code_ = x;
  }

  void libra_summary::
  channel_code (::std::unique_ptr< channel_code_type > x)
  {
    this->channel_code_.set (std::move (x));
  }


  // roc_data_point
  // 

  const roc_data_point::min_prob_type& roc_data_point::
  min_prob () const
  {
    return this->min_prob_.get ();
  }

  roc_data_point::min_prob_type& roc_data_point::
  min_prob ()
  {
    return this->min_prob_.get ();
  }

  void roc_data_point::
  min_prob (const min_prob_type& x)
  {
    this->min_prob_.set (x);
  }

  const roc_data_point::sensitivity_type& roc_data_point::
  sensitivity () const
  {
    return this->sensitivity_.get ();
  }

  roc_data_point::sensitivity_type& roc_data_point::
  sensitivity ()
  {
    return this->sensitivity_.get ();
  }

  void roc_data_point::
  sensitivity (const sensitivity_type& x)
  {
    this->sensitivity_.set (x);
  }

  const roc_data_point::error_type& roc_data_point::
  error () const
  {
    return this->error_.get ();
  }

  roc_data_point::error_type& roc_data_point::
  error ()
  {
    return this->error_.get ();
  }

  void roc_data_point::
  error (const error_type& x)
  {
    this->error_.set (x);
  }

  const roc_data_point::num_corr_type& roc_data_point::
  num_corr () const
  {
    return this->num_corr_.get ();
  }

  roc_data_point::num_corr_type& roc_data_point::
  num_corr ()
  {
    return this->num_corr_.get ();
  }

  void roc_data_point::
  num_corr (const num_corr_type& x)
  {
    this->num_corr_.set (x);
  }

  const roc_data_point::num_incorr_type& roc_data_point::
  num_incorr () const
  {
    return this->num_incorr_.get ();
  }

  roc_data_point::num_incorr_type& roc_data_point::
  num_incorr ()
  {
    return this->num_incorr_.get ();
  }

  void roc_data_point::
  num_incorr (const num_incorr_type& x)
  {
    this->num_incorr_.set (x);
  }


  // error_point
  // 

  const error_point::error_type& error_point::
  error () const
  {
    return this->error_.get ();
  }

  error_point::error_type& error_point::
  error ()
  {
    return this->error_.get ();
  }

  void error_point::
  error (const error_type& x)
  {
    this->error_.set (x);
  }

  const error_point::min_prob_type& error_point::
  min_prob () const
  {
    return this->min_prob_.get ();
  }

  error_point::min_prob_type& error_point::
  min_prob ()
  {
    return this->min_prob_.get ();
  }

  void error_point::
  min_prob (const min_prob_type& x)
  {
    this->min_prob_.set (x);
  }

  const error_point::num_corr_type& error_point::
  num_corr () const
  {
    return this->num_corr_.get ();
  }

  error_point::num_corr_type& error_point::
  num_corr ()
  {
    return this->num_corr_.get ();
  }

  void error_point::
  num_corr (const num_corr_type& x)
  {
    this->num_corr_.set (x);
  }

  const error_point::num_incorr_type& error_point::
  num_incorr () const
  {
    return this->num_incorr_.get ();
  }

  error_point::num_incorr_type& error_point::
  num_incorr ()
  {
    return this->num_incorr_.get ();
  }

  void error_point::
  num_incorr (const num_incorr_type& x)
  {
    this->num_incorr_.set (x);
  }


  // point
  // 

  const point::value_optional& point::
  value () const
  {
    return this->value_;
  }

  point::value_optional& point::
  value ()
  {
    return this->value_;
  }

  void point::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void point::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  const point::pos_dens_optional& point::
  pos_dens () const
  {
    return this->pos_dens_;
  }

  point::pos_dens_optional& point::
  pos_dens ()
  {
    return this->pos_dens_;
  }

  void point::
  pos_dens (const pos_dens_type& x)
  {
    this->pos_dens_.set (x);
  }

  void point::
  pos_dens (const pos_dens_optional& x)
  {
    this->pos_dens_ = x;
  }

  const point::neg_dens_optional& point::
  neg_dens () const
  {
    return this->neg_dens_;
  }

  point::neg_dens_optional& point::
  neg_dens ()
  {
    return this->neg_dens_;
  }

  void point::
  neg_dens (const neg_dens_type& x)
  {
    this->neg_dens_.set (x);
  }

  void point::
  neg_dens (const neg_dens_optional& x)
  {
    this->neg_dens_ = x;
  }

  const point::neg_obs_dens_optional& point::
  neg_obs_dens () const
  {
    return this->neg_obs_dens_;
  }

  point::neg_obs_dens_optional& point::
  neg_obs_dens ()
  {
    return this->neg_obs_dens_;
  }

  void point::
  neg_obs_dens (const neg_obs_dens_type& x)
  {
    this->neg_obs_dens_.set (x);
  }

  void point::
  neg_obs_dens (const neg_obs_dens_optional& x)
  {
    this->neg_obs_dens_ = x;
  }

  const point::pos_obs_dens_optional& point::
  pos_obs_dens () const
  {
    return this->pos_obs_dens_;
  }

  point::pos_obs_dens_optional& point::
  pos_obs_dens ()
  {
    return this->pos_obs_dens_;
  }

  void point::
  pos_obs_dens (const pos_obs_dens_type& x)
  {
    this->pos_obs_dens_.set (x);
  }

  void point::
  pos_obs_dens (const pos_obs_dens_optional& x)
  {
    this->pos_obs_dens_ = x;
  }


  // mod_aminoacid_mass
  // 

  const mod_aminoacid_mass::position_type& mod_aminoacid_mass::
  position () const
  {
    return this->position_.get ();
  }

  mod_aminoacid_mass::position_type& mod_aminoacid_mass::
  position ()
  {
    return this->position_.get ();
  }

  void mod_aminoacid_mass::
  position (const position_type& x)
  {
    this->position_.set (x);
  }

  const mod_aminoacid_mass::mass_type& mod_aminoacid_mass::
  mass () const
  {
    return this->mass_.get ();
  }

  mod_aminoacid_mass::mass_type& mod_aminoacid_mass::
  mass ()
  {
    return this->mass_.get ();
  }

  void mod_aminoacid_mass::
  mass (const mass_type& x)
  {
    this->mass_.set (x);
  }

  const mod_aminoacid_mass::source_optional& mod_aminoacid_mass::
  source () const
  {
    return this->source_;
  }

  mod_aminoacid_mass::source_optional& mod_aminoacid_mass::
  source ()
  {
    return this->source_;
  }

  void mod_aminoacid_mass::
  source (const source_type& x)
  {
    this->source_.set (x);
  }

  void mod_aminoacid_mass::
  source (const source_optional& x)
  {
    this->source_ = x;
  }

  void mod_aminoacid_mass::
  source (::std::unique_ptr< source_type > x)
  {
    this->source_.set (std::move (x));
  }


  // analysis_summary
  // 

  const analysis_summary::parameter_sequence& analysis_summary::
  parameter () const
  {
    return this->parameter_;
  }

  analysis_summary::parameter_sequence& analysis_summary::
  parameter ()
  {
    return this->parameter_;
  }

  void analysis_summary::
  parameter (const parameter_sequence& s)
  {
    this->parameter_ = s;
  }

  const analysis_summary::time_type& analysis_summary::
  time () const
  {
    return this->time_.get ();
  }

  analysis_summary::time_type& analysis_summary::
  time ()
  {
    return this->time_.get ();
  }

  void analysis_summary::
  time (const time_type& x)
  {
    this->time_.set (x);
  }

  void analysis_summary::
  time (::std::unique_ptr< time_type > x)
  {
    this->time_.set (std::move (x));
  }

  const analysis_summary::analysis_type& analysis_summary::
  analysis () const
  {
    return this->analysis_.get ();
  }

  analysis_summary::analysis_type& analysis_summary::
  analysis ()
  {
    return this->analysis_.get ();
  }

  void analysis_summary::
  analysis (const analysis_type& x)
  {
    this->analysis_.set (x);
  }

  void analysis_summary::
  analysis (::std::unique_ptr< analysis_type > x)
  {
    this->analysis_.set (std::move (x));
  }

  const analysis_summary::version_optional& analysis_summary::
  version () const
  {
    return this->version_;
  }

  analysis_summary::version_optional& analysis_summary::
  version ()
  {
    return this->version_;
  }

  void analysis_summary::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void analysis_summary::
  version (const version_optional& x)
  {
    this->version_ = x;
  }

  void analysis_summary::
  version (::std::unique_ptr< version_type > x)
  {
    this->version_.set (std::move (x));
  }


  // dataset_derivation
  // 

  const dataset_derivation::data_filter_sequence& dataset_derivation::
  data_filter () const
  {
    return this->data_filter_;
  }

  dataset_derivation::data_filter_sequence& dataset_derivation::
  data_filter ()
  {
    return this->data_filter_;
  }

  void dataset_derivation::
  data_filter (const data_filter_sequence& s)
  {
    this->data_filter_ = s;
  }

  const dataset_derivation::generation_no_type& dataset_derivation::
  generation_no () const
  {
    return this->generation_no_.get ();
  }

  dataset_derivation::generation_no_type& dataset_derivation::
  generation_no ()
  {
    return this->generation_no_.get ();
  }

  void dataset_derivation::
  generation_no (const generation_no_type& x)
  {
    this->generation_no_.set (x);
  }


  // msms_run_summary
  // 

  const msms_run_summary::sample_enzyme_optional& msms_run_summary::
  sample_enzyme () const
  {
    return this->sample_enzyme_;
  }

  msms_run_summary::sample_enzyme_optional& msms_run_summary::
  sample_enzyme ()
  {
    return this->sample_enzyme_;
  }

  void msms_run_summary::
  sample_enzyme (const sample_enzyme_type& x)
  {
    this->sample_enzyme_.set (x);
  }

  void msms_run_summary::
  sample_enzyme (const sample_enzyme_optional& x)
  {
    this->sample_enzyme_ = x;
  }

  void msms_run_summary::
  sample_enzyme (::std::unique_ptr< sample_enzyme_type > x)
  {
    this->sample_enzyme_.set (std::move (x));
  }

  const msms_run_summary::cross_linker_optional& msms_run_summary::
  cross_linker () const
  {
    return this->cross_linker_;
  }

  msms_run_summary::cross_linker_optional& msms_run_summary::
  cross_linker ()
  {
    return this->cross_linker_;
  }

  void msms_run_summary::
  cross_linker (const cross_linker_type& x)
  {
    this->cross_linker_.set (x);
  }

  void msms_run_summary::
  cross_linker (const cross_linker_optional& x)
  {
    this->cross_linker_ = x;
  }

  void msms_run_summary::
  cross_linker (::std::unique_ptr< cross_linker_type > x)
  {
    this->cross_linker_.set (std::move (x));
  }

  const msms_run_summary::search_summary_sequence& msms_run_summary::
  search_summary () const
  {
    return this->search_summary_;
  }

  msms_run_summary::search_summary_sequence& msms_run_summary::
  search_summary ()
  {
    return this->search_summary_;
  }

  void msms_run_summary::
  search_summary (const search_summary_sequence& s)
  {
    this->search_summary_ = s;
  }

  const msms_run_summary::analysis_timestamp_sequence& msms_run_summary::
  analysis_timestamp () const
  {
    return this->analysis_timestamp_;
  }

  msms_run_summary::analysis_timestamp_sequence& msms_run_summary::
  analysis_timestamp ()
  {
    return this->analysis_timestamp_;
  }

  void msms_run_summary::
  analysis_timestamp (const analysis_timestamp_sequence& s)
  {
    this->analysis_timestamp_ = s;
  }

  const msms_run_summary::spectrum_query_sequence& msms_run_summary::
  spectrum_query () const
  {
    return this->spectrum_query_;
  }

  msms_run_summary::spectrum_query_sequence& msms_run_summary::
  spectrum_query ()
  {
    return this->spectrum_query_;
  }

  void msms_run_summary::
  spectrum_query (const spectrum_query_sequence& s)
  {
    this->spectrum_query_ = s;
  }

  const msms_run_summary::base_name_type& msms_run_summary::
  base_name () const
  {
    return this->base_name_.get ();
  }

  msms_run_summary::base_name_type& msms_run_summary::
  base_name ()
  {
    return this->base_name_.get ();
  }

  void msms_run_summary::
  base_name (const base_name_type& x)
  {
    this->base_name_.set (x);
  }

  void msms_run_summary::
  base_name (::std::unique_ptr< base_name_type > x)
  {
    this->base_name_.set (std::move (x));
  }

  const msms_run_summary::raw_data_type_type& msms_run_summary::
  raw_data_type () const
  {
    return this->raw_data_type_.get ();
  }

  msms_run_summary::raw_data_type_type& msms_run_summary::
  raw_data_type ()
  {
    return this->raw_data_type_.get ();
  }

  void msms_run_summary::
  raw_data_type (const raw_data_type_type& x)
  {
    this->raw_data_type_.set (x);
  }

  void msms_run_summary::
  raw_data_type (::std::unique_ptr< raw_data_type_type > x)
  {
    this->raw_data_type_.set (std::move (x));
  }

  const msms_run_summary::raw_data_type1& msms_run_summary::
  raw_data () const
  {
    return this->raw_data_.get ();
  }

  msms_run_summary::raw_data_type1& msms_run_summary::
  raw_data ()
  {
    return this->raw_data_.get ();
  }

  void msms_run_summary::
  raw_data (const raw_data_type1& x)
  {
    this->raw_data_.set (x);
  }

  void msms_run_summary::
  raw_data (::std::unique_ptr< raw_data_type1 > x)
  {
    this->raw_data_.set (std::move (x));
  }

  const msms_run_summary::msManufacturer_optional& msms_run_summary::
  msManufacturer () const
  {
    return this->msManufacturer_;
  }

  msms_run_summary::msManufacturer_optional& msms_run_summary::
  msManufacturer ()
  {
    return this->msManufacturer_;
  }

  void msms_run_summary::
  msManufacturer (const msManufacturer_type& x)
  {
    this->msManufacturer_.set (x);
  }

  void msms_run_summary::
  msManufacturer (const msManufacturer_optional& x)
  {
    this->msManufacturer_ = x;
  }

  void msms_run_summary::
  msManufacturer (::std::unique_ptr< msManufacturer_type > x)
  {
    this->msManufacturer_.set (std::move (x));
  }

  const msms_run_summary::msModel_optional& msms_run_summary::
  msModel () const
  {
    return this->msModel_;
  }

  msms_run_summary::msModel_optional& msms_run_summary::
  msModel ()
  {
    return this->msModel_;
  }

  void msms_run_summary::
  msModel (const msModel_type& x)
  {
    this->msModel_.set (x);
  }

  void msms_run_summary::
  msModel (const msModel_optional& x)
  {
    this->msModel_ = x;
  }

  void msms_run_summary::
  msModel (::std::unique_ptr< msModel_type > x)
  {
    this->msModel_.set (std::move (x));
  }

  const msms_run_summary::msIonization_optional& msms_run_summary::
  msIonization () const
  {
    return this->msIonization_;
  }

  msms_run_summary::msIonization_optional& msms_run_summary::
  msIonization ()
  {
    return this->msIonization_;
  }

  void msms_run_summary::
  msIonization (const msIonization_type& x)
  {
    this->msIonization_.set (x);
  }

  void msms_run_summary::
  msIonization (const msIonization_optional& x)
  {
    this->msIonization_ = x;
  }

  void msms_run_summary::
  msIonization (::std::unique_ptr< msIonization_type > x)
  {
    this->msIonization_.set (std::move (x));
  }

  const msms_run_summary::msMassAnalyzer_optional& msms_run_summary::
  msMassAnalyzer () const
  {
    return this->msMassAnalyzer_;
  }

  msms_run_summary::msMassAnalyzer_optional& msms_run_summary::
  msMassAnalyzer ()
  {
    return this->msMassAnalyzer_;
  }

  void msms_run_summary::
  msMassAnalyzer (const msMassAnalyzer_type& x)
  {
    this->msMassAnalyzer_.set (x);
  }

  void msms_run_summary::
  msMassAnalyzer (const msMassAnalyzer_optional& x)
  {
    this->msMassAnalyzer_ = x;
  }

  void msms_run_summary::
  msMassAnalyzer (::std::unique_ptr< msMassAnalyzer_type > x)
  {
    this->msMassAnalyzer_.set (std::move (x));
  }

  const msms_run_summary::msDetector_optional& msms_run_summary::
  msDetector () const
  {
    return this->msDetector_;
  }

  msms_run_summary::msDetector_optional& msms_run_summary::
  msDetector ()
  {
    return this->msDetector_;
  }

  void msms_run_summary::
  msDetector (const msDetector_type& x)
  {
    this->msDetector_.set (x);
  }

  void msms_run_summary::
  msDetector (const msDetector_optional& x)
  {
    this->msDetector_ = x;
  }

  void msms_run_summary::
  msDetector (::std::unique_ptr< msDetector_type > x)
  {
    this->msDetector_.set (std::move (x));
  }


  // distribution_point
  // 

  const distribution_point::fvalue_type& distribution_point::
  fvalue () const
  {
    return this->fvalue_.get ();
  }

  distribution_point::fvalue_type& distribution_point::
  fvalue ()
  {
    return this->fvalue_.get ();
  }

  void distribution_point::
  fvalue (const fvalue_type& x)
  {
    this->fvalue_.set (x);
  }

  const distribution_point::obs_1_distr_type& distribution_point::
  obs_1_distr () const
  {
    return this->obs_1_distr_.get ();
  }

  distribution_point::obs_1_distr_type& distribution_point::
  obs_1_distr ()
  {
    return this->obs_1_distr_.get ();
  }

  void distribution_point::
  obs_1_distr (const obs_1_distr_type& x)
  {
    this->obs_1_distr_.set (x);
  }

  const distribution_point::model_1_pos_distr_type& distribution_point::
  model_1_pos_distr () const
  {
    return this->model_1_pos_distr_.get ();
  }

  distribution_point::model_1_pos_distr_type& distribution_point::
  model_1_pos_distr ()
  {
    return this->model_1_pos_distr_.get ();
  }

  void distribution_point::
  model_1_pos_distr (const model_1_pos_distr_type& x)
  {
    this->model_1_pos_distr_.set (x);
  }

  const distribution_point::model_1_neg_distr_type& distribution_point::
  model_1_neg_distr () const
  {
    return this->model_1_neg_distr_.get ();
  }

  distribution_point::model_1_neg_distr_type& distribution_point::
  model_1_neg_distr ()
  {
    return this->model_1_neg_distr_.get ();
  }

  void distribution_point::
  model_1_neg_distr (const model_1_neg_distr_type& x)
  {
    this->model_1_neg_distr_.set (x);
  }

  const distribution_point::obs_2_distr_type& distribution_point::
  obs_2_distr () const
  {
    return this->obs_2_distr_.get ();
  }

  distribution_point::obs_2_distr_type& distribution_point::
  obs_2_distr ()
  {
    return this->obs_2_distr_.get ();
  }

  void distribution_point::
  obs_2_distr (const obs_2_distr_type& x)
  {
    this->obs_2_distr_.set (x);
  }

  const distribution_point::model_2_pos_distr_type& distribution_point::
  model_2_pos_distr () const
  {
    return this->model_2_pos_distr_.get ();
  }

  distribution_point::model_2_pos_distr_type& distribution_point::
  model_2_pos_distr ()
  {
    return this->model_2_pos_distr_.get ();
  }

  void distribution_point::
  model_2_pos_distr (const model_2_pos_distr_type& x)
  {
    this->model_2_pos_distr_.set (x);
  }

  const distribution_point::model_2_neg_distr_type& distribution_point::
  model_2_neg_distr () const
  {
    return this->model_2_neg_distr_.get ();
  }

  distribution_point::model_2_neg_distr_type& distribution_point::
  model_2_neg_distr ()
  {
    return this->model_2_neg_distr_.get ();
  }

  void distribution_point::
  model_2_neg_distr (const model_2_neg_distr_type& x)
  {
    this->model_2_neg_distr_.set (x);
  }

  const distribution_point::obs_3_distr_type& distribution_point::
  obs_3_distr () const
  {
    return this->obs_3_distr_.get ();
  }

  distribution_point::obs_3_distr_type& distribution_point::
  obs_3_distr ()
  {
    return this->obs_3_distr_.get ();
  }

  void distribution_point::
  obs_3_distr (const obs_3_distr_type& x)
  {
    this->obs_3_distr_.set (x);
  }

  const distribution_point::model_3_pos_distr_type& distribution_point::
  model_3_pos_distr () const
  {
    return this->model_3_pos_distr_.get ();
  }

  distribution_point::model_3_pos_distr_type& distribution_point::
  model_3_pos_distr ()
  {
    return this->model_3_pos_distr_.get ();
  }

  void distribution_point::
  model_3_pos_distr (const model_3_pos_distr_type& x)
  {
    this->model_3_pos_distr_.set (x);
  }

  const distribution_point::model_3_neg_distr_type& distribution_point::
  model_3_neg_distr () const
  {
    return this->model_3_neg_distr_.get ();
  }

  distribution_point::model_3_neg_distr_type& distribution_point::
  model_3_neg_distr ()
  {
    return this->model_3_neg_distr_.get ();
  }

  void distribution_point::
  model_3_neg_distr (const model_3_neg_distr_type& x)
  {
    this->model_3_neg_distr_.set (x);
  }

  const distribution_point::obs_4_distr_type& distribution_point::
  obs_4_distr () const
  {
    return this->obs_4_distr_.get ();
  }

  distribution_point::obs_4_distr_type& distribution_point::
  obs_4_distr ()
  {
    return this->obs_4_distr_.get ();
  }

  void distribution_point::
  obs_4_distr (const obs_4_distr_type& x)
  {
    this->obs_4_distr_.set (x);
  }

  const distribution_point::model_4_pos_distr_type& distribution_point::
  model_4_pos_distr () const
  {
    return this->model_4_pos_distr_.get ();
  }

  distribution_point::model_4_pos_distr_type& distribution_point::
  model_4_pos_distr ()
  {
    return this->model_4_pos_distr_.get ();
  }

  void distribution_point::
  model_4_pos_distr (const model_4_pos_distr_type& x)
  {
    this->model_4_pos_distr_.set (x);
  }

  const distribution_point::model_4_neg_distr_type& distribution_point::
  model_4_neg_distr () const
  {
    return this->model_4_neg_distr_.get ();
  }

  distribution_point::model_4_neg_distr_type& distribution_point::
  model_4_neg_distr ()
  {
    return this->model_4_neg_distr_.get ();
  }

  void distribution_point::
  model_4_neg_distr (const model_4_neg_distr_type& x)
  {
    this->model_4_neg_distr_.set (x);
  }

  const distribution_point::obs_5_distr_type& distribution_point::
  obs_5_distr () const
  {
    return this->obs_5_distr_.get ();
  }

  distribution_point::obs_5_distr_type& distribution_point::
  obs_5_distr ()
  {
    return this->obs_5_distr_.get ();
  }

  void distribution_point::
  obs_5_distr (const obs_5_distr_type& x)
  {
    this->obs_5_distr_.set (x);
  }

  const distribution_point::model_5_pos_distr_type& distribution_point::
  model_5_pos_distr () const
  {
    return this->model_5_pos_distr_.get ();
  }

  distribution_point::model_5_pos_distr_type& distribution_point::
  model_5_pos_distr ()
  {
    return this->model_5_pos_distr_.get ();
  }

  void distribution_point::
  model_5_pos_distr (const model_5_pos_distr_type& x)
  {
    this->model_5_pos_distr_.set (x);
  }

  const distribution_point::model_5_neg_distr_type& distribution_point::
  model_5_neg_distr () const
  {
    return this->model_5_neg_distr_.get ();
  }

  distribution_point::model_5_neg_distr_type& distribution_point::
  model_5_neg_distr ()
  {
    return this->model_5_neg_distr_.get ();
  }

  void distribution_point::
  model_5_neg_distr (const model_5_neg_distr_type& x)
  {
    this->model_5_neg_distr_.set (x);
  }

  const distribution_point::obs_6_distr_type& distribution_point::
  obs_6_distr () const
  {
    return this->obs_6_distr_.get ();
  }

  distribution_point::obs_6_distr_type& distribution_point::
  obs_6_distr ()
  {
    return this->obs_6_distr_.get ();
  }

  void distribution_point::
  obs_6_distr (const obs_6_distr_type& x)
  {
    this->obs_6_distr_.set (x);
  }

  const distribution_point::model_6_pos_distr_type& distribution_point::
  model_6_pos_distr () const
  {
    return this->model_6_pos_distr_.get ();
  }

  distribution_point::model_6_pos_distr_type& distribution_point::
  model_6_pos_distr ()
  {
    return this->model_6_pos_distr_.get ();
  }

  void distribution_point::
  model_6_pos_distr (const model_6_pos_distr_type& x)
  {
    this->model_6_pos_distr_.set (x);
  }

  const distribution_point::model_6_neg_distr_type& distribution_point::
  model_6_neg_distr () const
  {
    return this->model_6_neg_distr_.get ();
  }

  distribution_point::model_6_neg_distr_type& distribution_point::
  model_6_neg_distr ()
  {
    return this->model_6_neg_distr_.get ();
  }

  void distribution_point::
  model_6_neg_distr (const model_6_neg_distr_type& x)
  {
    this->model_6_neg_distr_.set (x);
  }

  const distribution_point::obs_7_distr_type& distribution_point::
  obs_7_distr () const
  {
    return this->obs_7_distr_.get ();
  }

  distribution_point::obs_7_distr_type& distribution_point::
  obs_7_distr ()
  {
    return this->obs_7_distr_.get ();
  }

  void distribution_point::
  obs_7_distr (const obs_7_distr_type& x)
  {
    this->obs_7_distr_.set (x);
  }

  const distribution_point::model_7_pos_distr_type& distribution_point::
  model_7_pos_distr () const
  {
    return this->model_7_pos_distr_.get ();
  }

  distribution_point::model_7_pos_distr_type& distribution_point::
  model_7_pos_distr ()
  {
    return this->model_7_pos_distr_.get ();
  }

  void distribution_point::
  model_7_pos_distr (const model_7_pos_distr_type& x)
  {
    this->model_7_pos_distr_.set (x);
  }

  const distribution_point::model_7_neg_distr_type& distribution_point::
  model_7_neg_distr () const
  {
    return this->model_7_neg_distr_.get ();
  }

  distribution_point::model_7_neg_distr_type& distribution_point::
  model_7_neg_distr ()
  {
    return this->model_7_neg_distr_.get ();
  }

  void distribution_point::
  model_7_neg_distr (const model_7_neg_distr_type& x)
  {
    this->model_7_neg_distr_.set (x);
  }


  // mixture_model
  // 

  const mixture_model::mixturemodel_distribution_sequence& mixture_model::
  mixturemodel_distribution () const
  {
    return this->mixturemodel_distribution_;
  }

  mixture_model::mixturemodel_distribution_sequence& mixture_model::
  mixturemodel_distribution ()
  {
    return this->mixturemodel_distribution_;
  }

  void mixture_model::
  mixturemodel_distribution (const mixturemodel_distribution_sequence& s)
  {
    this->mixturemodel_distribution_ = s;
  }

  const mixture_model::mixturemodel_sequence& mixture_model::
  mixturemodel () const
  {
    return this->mixturemodel_;
  }

  mixture_model::mixturemodel_sequence& mixture_model::
  mixturemodel ()
  {
    return this->mixturemodel_;
  }

  void mixture_model::
  mixturemodel (const mixturemodel_sequence& s)
  {
    this->mixturemodel_ = s;
  }

  const mixture_model::precursor_ion_charge_type& mixture_model::
  precursor_ion_charge () const
  {
    return this->precursor_ion_charge_.get ();
  }

  mixture_model::precursor_ion_charge_type& mixture_model::
  precursor_ion_charge ()
  {
    return this->precursor_ion_charge_.get ();
  }

  void mixture_model::
  precursor_ion_charge (const precursor_ion_charge_type& x)
  {
    this->precursor_ion_charge_.set (x);
  }

  const mixture_model::comments_type& mixture_model::
  comments () const
  {
    return this->comments_.get ();
  }

  mixture_model::comments_type& mixture_model::
  comments ()
  {
    return this->comments_.get ();
  }

  void mixture_model::
  comments (const comments_type& x)
  {
    this->comments_.set (x);
  }

  void mixture_model::
  comments (::std::unique_ptr< comments_type > x)
  {
    this->comments_.set (std::move (x));
  }

  const mixture_model::prior_probability_type& mixture_model::
  prior_probability () const
  {
    return this->prior_probability_.get ();
  }

  mixture_model::prior_probability_type& mixture_model::
  prior_probability ()
  {
    return this->prior_probability_.get ();
  }

  void mixture_model::
  prior_probability (const prior_probability_type& x)
  {
    this->prior_probability_.set (x);
  }

  const mixture_model::est_tot_correct_type& mixture_model::
  est_tot_correct () const
  {
    return this->est_tot_correct_.get ();
  }

  mixture_model::est_tot_correct_type& mixture_model::
  est_tot_correct ()
  {
    return this->est_tot_correct_.get ();
  }

  void mixture_model::
  est_tot_correct (const est_tot_correct_type& x)
  {
    this->est_tot_correct_.set (x);
  }

  const mixture_model::tot_num_spectra_type& mixture_model::
  tot_num_spectra () const
  {
    return this->tot_num_spectra_.get ();
  }

  mixture_model::tot_num_spectra_type& mixture_model::
  tot_num_spectra ()
  {
    return this->tot_num_spectra_.get ();
  }

  void mixture_model::
  tot_num_spectra (const tot_num_spectra_type& x)
  {
    this->tot_num_spectra_.set (x);
  }

  const mixture_model::num_iterations_type& mixture_model::
  num_iterations () const
  {
    return this->num_iterations_.get ();
  }

  mixture_model::num_iterations_type& mixture_model::
  num_iterations ()
  {
    return this->num_iterations_.get ();
  }

  void mixture_model::
  num_iterations (const num_iterations_type& x)
  {
    this->num_iterations_.set (x);
  }


  // mod_aminoacid_probability
  // 

  const mod_aminoacid_probability::position_type& mod_aminoacid_probability::
  position () const
  {
    return this->position_.get ();
  }

  mod_aminoacid_probability::position_type& mod_aminoacid_probability::
  position ()
  {
    return this->position_.get ();
  }

  void mod_aminoacid_probability::
  position (const position_type& x)
  {
    this->position_.set (x);
  }

  const mod_aminoacid_probability::probability_type& mod_aminoacid_probability::
  probability () const
  {
    return this->probability_.get ();
  }

  mod_aminoacid_probability::probability_type& mod_aminoacid_probability::
  probability ()
  {
    return this->probability_.get ();
  }

  void mod_aminoacid_probability::
  probability (const probability_type& x)
  {
    this->probability_.set (x);
  }


  // search_score_summary
  // 

  const search_score_summary::parameter_sequence& search_score_summary::
  parameter () const
  {
    return this->parameter_;
  }

  search_score_summary::parameter_sequence& search_score_summary::
  parameter ()
  {
    return this->parameter_;
  }

  void search_score_summary::
  parameter (const parameter_sequence& s)
  {
    this->parameter_ = s;
  }


  // intensity
  // 

  const intensity::channel_type& intensity::
  channel () const
  {
    return this->channel_.get ();
  }

  intensity::channel_type& intensity::
  channel ()
  {
    return this->channel_.get ();
  }

  void intensity::
  channel (const channel_type& x)
  {
    this->channel_.set (x);
  }

  void intensity::
  channel (::std::unique_ptr< channel_type > x)
  {
    this->channel_.set (std::move (x));
  }

  const intensity::target_mass_type& intensity::
  target_mass () const
  {
    return this->target_mass_.get ();
  }

  intensity::target_mass_type& intensity::
  target_mass ()
  {
    return this->target_mass_.get ();
  }

  void intensity::
  target_mass (const target_mass_type& x)
  {
    this->target_mass_.set (x);
  }

  const intensity::absolute_type& intensity::
  absolute () const
  {
    return this->absolute_.get ();
  }

  intensity::absolute_type& intensity::
  absolute ()
  {
    return this->absolute_.get ();
  }

  void intensity::
  absolute (const absolute_type& x)
  {
    this->absolute_.set (x);
  }

  const intensity::normalized_type& intensity::
  normalized () const
  {
    return this->normalized_.get ();
  }

  intensity::normalized_type& intensity::
  normalized ()
  {
    return this->normalized_.get ();
  }

  void intensity::
  normalized (const normalized_type& x)
  {
    this->normalized_.set (x);
  }

  const intensity::reject_type& intensity::
  reject () const
  {
    return this->reject_.get ();
  }

  intensity::reject_type& intensity::
  reject ()
  {
    return this->reject_.get ();
  }

  void intensity::
  reject (const reject_type& x)
  {
    this->reject_.set (x);
  }

  intensity::reject_type intensity::
  reject_default_value ()
  {
    return reject_type (false);
  }


  // fragment_masses
  // 

  const fragment_masses::channel_type& fragment_masses::
  channel () const
  {
    return this->channel_.get ();
  }

  fragment_masses::channel_type& fragment_masses::
  channel ()
  {
    return this->channel_.get ();
  }

  void fragment_masses::
  channel (const channel_type& x)
  {
    this->channel_.set (x);
  }

  void fragment_masses::
  channel (::std::unique_ptr< channel_type > x)
  {
    this->channel_.set (std::move (x));
  }

  const fragment_masses::mz_type& fragment_masses::
  mz () const
  {
    return this->mz_.get ();
  }

  fragment_masses::mz_type& fragment_masses::
  mz ()
  {
    return this->mz_.get ();
  }

  void fragment_masses::
  mz (const mz_type& x)
  {
    this->mz_.set (x);
  }

  const fragment_masses::offset_optional& fragment_masses::
  offset () const
  {
    return this->offset_;
  }

  fragment_masses::offset_optional& fragment_masses::
  offset ()
  {
    return this->offset_;
  }

  void fragment_masses::
  offset (const offset_type& x)
  {
    this->offset_.set (x);
  }

  void fragment_masses::
  offset (const offset_optional& x)
  {
    this->offset_ = x;
  }


  // isotopic_contributions
  // 

  const isotopic_contributions::contributing_channel_sequence& isotopic_contributions::
  contributing_channel () const
  {
    return this->contributing_channel_;
  }

  isotopic_contributions::contributing_channel_sequence& isotopic_contributions::
  contributing_channel ()
  {
    return this->contributing_channel_;
  }

  void isotopic_contributions::
  contributing_channel (const contributing_channel_sequence& s)
  {
    this->contributing_channel_ = s;
  }


  // data_filter
  // 

  const data_filter::number_type& data_filter::
  number () const
  {
    return this->number_.get ();
  }

  data_filter::number_type& data_filter::
  number ()
  {
    return this->number_.get ();
  }

  void data_filter::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  const data_filter::parent_file_type& data_filter::
  parent_file () const
  {
    return this->parent_file_.get ();
  }

  data_filter::parent_file_type& data_filter::
  parent_file ()
  {
    return this->parent_file_.get ();
  }

  void data_filter::
  parent_file (const parent_file_type& x)
  {
    this->parent_file_.set (x);
  }

  void data_filter::
  parent_file (::std::unique_ptr< parent_file_type > x)
  {
    this->parent_file_.set (std::move (x));
  }

  const data_filter::windows_parent_optional& data_filter::
  windows_parent () const
  {
    return this->windows_parent_;
  }

  data_filter::windows_parent_optional& data_filter::
  windows_parent ()
  {
    return this->windows_parent_;
  }

  void data_filter::
  windows_parent (const windows_parent_type& x)
  {
    this->windows_parent_.set (x);
  }

  void data_filter::
  windows_parent (const windows_parent_optional& x)
  {
    this->windows_parent_ = x;
  }

  void data_filter::
  windows_parent (::std::unique_ptr< windows_parent_type > x)
  {
    this->windows_parent_.set (std::move (x));
  }

  const data_filter::description_type& data_filter::
  description () const
  {
    return this->description_.get ();
  }

  data_filter::description_type& data_filter::
  description ()
  {
    return this->description_.get ();
  }

  void data_filter::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void data_filter::
  description (::std::unique_ptr< description_type > x)
  {
    this->description_.set (std::move (x));
  }


  // sample_enzyme
  // 

  const sample_enzyme::specificity_sequence& sample_enzyme::
  specificity () const
  {
    return this->specificity_;
  }

  sample_enzyme::specificity_sequence& sample_enzyme::
  specificity ()
  {
    return this->specificity_;
  }

  void sample_enzyme::
  specificity (const specificity_sequence& s)
  {
    this->specificity_ = s;
  }

  const sample_enzyme::name_type& sample_enzyme::
  name () const
  {
    return this->name_.get ();
  }

  sample_enzyme::name_type& sample_enzyme::
  name ()
  {
    return this->name_.get ();
  }

  void sample_enzyme::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void sample_enzyme::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const sample_enzyme::description_optional& sample_enzyme::
  description () const
  {
    return this->description_;
  }

  sample_enzyme::description_optional& sample_enzyme::
  description ()
  {
    return this->description_;
  }

  void sample_enzyme::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void sample_enzyme::
  description (const description_optional& x)
  {
    this->description_ = x;
  }

  void sample_enzyme::
  description (::std::unique_ptr< description_type > x)
  {
    this->description_.set (std::move (x));
  }

  const sample_enzyme::fidelity_type& sample_enzyme::
  fidelity () const
  {
    return this->fidelity_.get ();
  }

  sample_enzyme::fidelity_type& sample_enzyme::
  fidelity ()
  {
    return this->fidelity_.get ();
  }

  void sample_enzyme::
  fidelity (const fidelity_type& x)
  {
    this->fidelity_.set (x);
  }

  void sample_enzyme::
  fidelity (::std::unique_ptr< fidelity_type > x)
  {
    this->fidelity_.set (std::move (x));
  }

  const sample_enzyme::fidelity_type& sample_enzyme::
  fidelity_default_value ()
  {
    return fidelity_default_value_;
  }

  const sample_enzyme::independent_type& sample_enzyme::
  independent () const
  {
    return this->independent_.get ();
  }

  sample_enzyme::independent_type& sample_enzyme::
  independent ()
  {
    return this->independent_.get ();
  }

  void sample_enzyme::
  independent (const independent_type& x)
  {
    this->independent_.set (x);
  }

  sample_enzyme::independent_type sample_enzyme::
  independent_default_value ()
  {
    return independent_type (true);
  }


  // cross_linker
  // 

  const cross_linker::cross_linker_info_sequence& cross_linker::
  cross_linker_info () const
  {
    return this->cross_linker_info_;
  }

  cross_linker::cross_linker_info_sequence& cross_linker::
  cross_linker_info ()
  {
    return this->cross_linker_info_;
  }

  void cross_linker::
  cross_linker_info (const cross_linker_info_sequence& s)
  {
    this->cross_linker_info_ = s;
  }

  const cross_linker::identifier_type& cross_linker::
  identifier () const
  {
    return this->identifier_.get ();
  }

  cross_linker::identifier_type& cross_linker::
  identifier ()
  {
    return this->identifier_.get ();
  }

  void cross_linker::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void cross_linker::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const cross_linker::mass_type& cross_linker::
  mass () const
  {
    return this->mass_.get ();
  }

  cross_linker::mass_type& cross_linker::
  mass ()
  {
    return this->mass_.get ();
  }

  void cross_linker::
  mass (const mass_type& x)
  {
    this->mass_.set (x);
  }

  const cross_linker::link_sites_type& cross_linker::
  link_sites () const
  {
    return this->link_sites_.get ();
  }

  cross_linker::link_sites_type& cross_linker::
  link_sites ()
  {
    return this->link_sites_.get ();
  }

  void cross_linker::
  link_sites (const link_sites_type& x)
  {
    this->link_sites_.set (x);
  }

  void cross_linker::
  link_sites (::std::unique_ptr< link_sites_type > x)
  {
    this->link_sites_.set (std::move (x));
  }

  const cross_linker::isotope_labeled_type& cross_linker::
  isotope_labeled () const
  {
    return this->isotope_labeled_.get ();
  }

  cross_linker::isotope_labeled_type& cross_linker::
  isotope_labeled ()
  {
    return this->isotope_labeled_.get ();
  }

  void cross_linker::
  isotope_labeled (const isotope_labeled_type& x)
  {
    this->isotope_labeled_.set (x);
  }

  void cross_linker::
  isotope_labeled (::std::unique_ptr< isotope_labeled_type > x)
  {
    this->isotope_labeled_.set (std::move (x));
  }


  // search_summary
  // 

  const search_summary::search_database_optional& search_summary::
  search_database () const
  {
    return this->search_database_;
  }

  search_summary::search_database_optional& search_summary::
  search_database ()
  {
    return this->search_database_;
  }

  void search_summary::
  search_database (const search_database_type& x)
  {
    this->search_database_.set (x);
  }

  void search_summary::
  search_database (const search_database_optional& x)
  {
    this->search_database_ = x;
  }

  void search_summary::
  search_database (::std::unique_ptr< search_database_type > x)
  {
    this->search_database_.set (std::move (x));
  }

  const search_summary::enzymatic_search_constraint_optional& search_summary::
  enzymatic_search_constraint () const
  {
    return this->enzymatic_search_constraint_;
  }

  search_summary::enzymatic_search_constraint_optional& search_summary::
  enzymatic_search_constraint ()
  {
    return this->enzymatic_search_constraint_;
  }

  void search_summary::
  enzymatic_search_constraint (const enzymatic_search_constraint_type& x)
  {
    this->enzymatic_search_constraint_.set (x);
  }

  void search_summary::
  enzymatic_search_constraint (const enzymatic_search_constraint_optional& x)
  {
    this->enzymatic_search_constraint_ = x;
  }

  void search_summary::
  enzymatic_search_constraint (::std::unique_ptr< enzymatic_search_constraint_type > x)
  {
    this->enzymatic_search_constraint_.set (std::move (x));
  }

  const search_summary::sequence_search_constraint_sequence& search_summary::
  sequence_search_constraint () const
  {
    return this->sequence_search_constraint_;
  }

  search_summary::sequence_search_constraint_sequence& search_summary::
  sequence_search_constraint ()
  {
    return this->sequence_search_constraint_;
  }

  void search_summary::
  sequence_search_constraint (const sequence_search_constraint_sequence& s)
  {
    this->sequence_search_constraint_ = s;
  }

  const search_summary::aminoacid_modification_sequence& search_summary::
  aminoacid_modification () const
  {
    return this->aminoacid_modification_;
  }

  search_summary::aminoacid_modification_sequence& search_summary::
  aminoacid_modification ()
  {
    return this->aminoacid_modification_;
  }

  void search_summary::
  aminoacid_modification (const aminoacid_modification_sequence& s)
  {
    this->aminoacid_modification_ = s;
  }

  const search_summary::terminal_modification_sequence& search_summary::
  terminal_modification () const
  {
    return this->terminal_modification_;
  }

  search_summary::terminal_modification_sequence& search_summary::
  terminal_modification ()
  {
    return this->terminal_modification_;
  }

  void search_summary::
  terminal_modification (const terminal_modification_sequence& s)
  {
    this->terminal_modification_ = s;
  }

  const search_summary::parameter_sequence& search_summary::
  parameter () const
  {
    return this->parameter_;
  }

  search_summary::parameter_sequence& search_summary::
  parameter ()
  {
    return this->parameter_;
  }

  void search_summary::
  parameter (const parameter_sequence& s)
  {
    this->parameter_ = s;
  }

  const search_summary::base_name_type& search_summary::
  base_name () const
  {
    return this->base_name_.get ();
  }

  search_summary::base_name_type& search_summary::
  base_name ()
  {
    return this->base_name_.get ();
  }

  void search_summary::
  base_name (const base_name_type& x)
  {
    this->base_name_.set (x);
  }

  void search_summary::
  base_name (::std::unique_ptr< base_name_type > x)
  {
    this->base_name_.set (std::move (x));
  }

  const search_summary::search_engine_type& search_summary::
  search_engine () const
  {
    return this->search_engine_.get ();
  }

  search_summary::search_engine_type& search_summary::
  search_engine ()
  {
    return this->search_engine_.get ();
  }

  void search_summary::
  search_engine (const search_engine_type& x)
  {
    this->search_engine_.set (x);
  }

  void search_summary::
  search_engine (::std::unique_ptr< search_engine_type > x)
  {
    this->search_engine_.set (std::move (x));
  }

  const search_summary::search_engine_version_optional& search_summary::
  search_engine_version () const
  {
    return this->search_engine_version_;
  }

  search_summary::search_engine_version_optional& search_summary::
  search_engine_version ()
  {
    return this->search_engine_version_;
  }

  void search_summary::
  search_engine_version (const search_engine_version_type& x)
  {
    this->search_engine_version_.set (x);
  }

  void search_summary::
  search_engine_version (const search_engine_version_optional& x)
  {
    this->search_engine_version_ = x;
  }

  void search_summary::
  search_engine_version (::std::unique_ptr< search_engine_version_type > x)
  {
    this->search_engine_version_.set (std::move (x));
  }

  const search_summary::precursor_mass_type_type& search_summary::
  precursor_mass_type () const
  {
    return this->precursor_mass_type_.get ();
  }

  search_summary::precursor_mass_type_type& search_summary::
  precursor_mass_type ()
  {
    return this->precursor_mass_type_.get ();
  }

  void search_summary::
  precursor_mass_type (const precursor_mass_type_type& x)
  {
    this->precursor_mass_type_.set (x);
  }

  void search_summary::
  precursor_mass_type (::std::unique_ptr< precursor_mass_type_type > x)
  {
    this->precursor_mass_type_.set (std::move (x));
  }

  const search_summary::fragment_mass_type_type& search_summary::
  fragment_mass_type () const
  {
    return this->fragment_mass_type_.get ();
  }

  search_summary::fragment_mass_type_type& search_summary::
  fragment_mass_type ()
  {
    return this->fragment_mass_type_.get ();
  }

  void search_summary::
  fragment_mass_type (const fragment_mass_type_type& x)
  {
    this->fragment_mass_type_.set (x);
  }

  void search_summary::
  fragment_mass_type (::std::unique_ptr< fragment_mass_type_type > x)
  {
    this->fragment_mass_type_.set (std::move (x));
  }

  const search_summary::out_data_type_optional& search_summary::
  out_data_type () const
  {
    return this->out_data_type_;
  }

  search_summary::out_data_type_optional& search_summary::
  out_data_type ()
  {
    return this->out_data_type_;
  }

  void search_summary::
  out_data_type (const out_data_type_type& x)
  {
    this->out_data_type_.set (x);
  }

  void search_summary::
  out_data_type (const out_data_type_optional& x)
  {
    this->out_data_type_ = x;
  }

  void search_summary::
  out_data_type (::std::unique_ptr< out_data_type_type > x)
  {
    this->out_data_type_.set (std::move (x));
  }

  const search_summary::out_data_optional& search_summary::
  out_data () const
  {
    return this->out_data_;
  }

  search_summary::out_data_optional& search_summary::
  out_data ()
  {
    return this->out_data_;
  }

  void search_summary::
  out_data (const out_data_type1& x)
  {
    this->out_data_.set (x);
  }

  void search_summary::
  out_data (const out_data_optional& x)
  {
    this->out_data_ = x;
  }

  void search_summary::
  out_data (::std::unique_ptr< out_data_type1 > x)
  {
    this->out_data_.set (std::move (x));
  }

  const search_summary::search_id_type& search_summary::
  search_id () const
  {
    return this->search_id_.get ();
  }

  search_summary::search_id_type& search_summary::
  search_id ()
  {
    return this->search_id_.get ();
  }

  void search_summary::
  search_id (const search_id_type& x)
  {
    this->search_id_.set (x);
  }

  void search_summary::
  search_id (::std::unique_ptr< search_id_type > x)
  {
    this->search_id_.set (std::move (x));
  }


  // analysis_timestamp
  // 

  const analysis_timestamp::time_type& analysis_timestamp::
  time () const
  {
    return this->time_.get ();
  }

  analysis_timestamp::time_type& analysis_timestamp::
  time ()
  {
    return this->time_.get ();
  }

  void analysis_timestamp::
  time (const time_type& x)
  {
    this->time_.set (x);
  }

  void analysis_timestamp::
  time (::std::unique_ptr< time_type > x)
  {
    this->time_.set (std::move (x));
  }

  const analysis_timestamp::analysis_type& analysis_timestamp::
  analysis () const
  {
    return this->analysis_.get ();
  }

  analysis_timestamp::analysis_type& analysis_timestamp::
  analysis ()
  {
    return this->analysis_.get ();
  }

  void analysis_timestamp::
  analysis (const analysis_type& x)
  {
    this->analysis_.set (x);
  }

  void analysis_timestamp::
  analysis (::std::unique_ptr< analysis_type > x)
  {
    this->analysis_.set (std::move (x));
  }

  const analysis_timestamp::id_type& analysis_timestamp::
  id () const
  {
    return this->id_.get ();
  }

  analysis_timestamp::id_type& analysis_timestamp::
  id ()
  {
    return this->id_.get ();
  }

  void analysis_timestamp::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void analysis_timestamp::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // spectrum_query
  // 

  const spectrum_query::search_result_sequence& spectrum_query::
  search_result () const
  {
    return this->search_result_;
  }

  spectrum_query::search_result_sequence& spectrum_query::
  search_result ()
  {
    return this->search_result_;
  }

  void spectrum_query::
  search_result (const search_result_sequence& s)
  {
    this->search_result_ = s;
  }

  const spectrum_query::spectrum_type& spectrum_query::
  spectrum () const
  {
    return this->spectrum_.get ();
  }

  spectrum_query::spectrum_type& spectrum_query::
  spectrum ()
  {
    return this->spectrum_.get ();
  }

  void spectrum_query::
  spectrum (const spectrum_type& x)
  {
    this->spectrum_.set (x);
  }

  void spectrum_query::
  spectrum (::std::unique_ptr< spectrum_type > x)
  {
    this->spectrum_.set (std::move (x));
  }

  const spectrum_query::spectrumNativeID_optional& spectrum_query::
  spectrumNativeID () const
  {
    return this->spectrumNativeID_;
  }

  spectrum_query::spectrumNativeID_optional& spectrum_query::
  spectrumNativeID ()
  {
    return this->spectrumNativeID_;
  }

  void spectrum_query::
  spectrumNativeID (const spectrumNativeID_type& x)
  {
    this->spectrumNativeID_.set (x);
  }

  void spectrum_query::
  spectrumNativeID (const spectrumNativeID_optional& x)
  {
    this->spectrumNativeID_ = x;
  }

  void spectrum_query::
  spectrumNativeID (::std::unique_ptr< spectrumNativeID_type > x)
  {
    this->spectrumNativeID_.set (std::move (x));
  }

  const spectrum_query::start_scan_type& spectrum_query::
  start_scan () const
  {
    return this->start_scan_.get ();
  }

  spectrum_query::start_scan_type& spectrum_query::
  start_scan ()
  {
    return this->start_scan_.get ();
  }

  void spectrum_query::
  start_scan (const start_scan_type& x)
  {
    this->start_scan_.set (x);
  }

  const spectrum_query::end_scan_type& spectrum_query::
  end_scan () const
  {
    return this->end_scan_.get ();
  }

  spectrum_query::end_scan_type& spectrum_query::
  end_scan ()
  {
    return this->end_scan_.get ();
  }

  void spectrum_query::
  end_scan (const end_scan_type& x)
  {
    this->end_scan_.set (x);
  }

  const spectrum_query::retention_time_sec_optional& spectrum_query::
  retention_time_sec () const
  {
    return this->retention_time_sec_;
  }

  spectrum_query::retention_time_sec_optional& spectrum_query::
  retention_time_sec ()
  {
    return this->retention_time_sec_;
  }

  void spectrum_query::
  retention_time_sec (const retention_time_sec_type& x)
  {
    this->retention_time_sec_.set (x);
  }

  void spectrum_query::
  retention_time_sec (const retention_time_sec_optional& x)
  {
    this->retention_time_sec_ = x;
  }

  const spectrum_query::collision_energy_optional& spectrum_query::
  collision_energy () const
  {
    return this->collision_energy_;
  }

  spectrum_query::collision_energy_optional& spectrum_query::
  collision_energy ()
  {
    return this->collision_energy_;
  }

  void spectrum_query::
  collision_energy (const collision_energy_type& x)
  {
    this->collision_energy_.set (x);
  }

  void spectrum_query::
  collision_energy (const collision_energy_optional& x)
  {
    this->collision_energy_ = x;
  }

  const spectrum_query::compensation_voltage_optional& spectrum_query::
  compensation_voltage () const
  {
    return this->compensation_voltage_;
  }

  spectrum_query::compensation_voltage_optional& spectrum_query::
  compensation_voltage ()
  {
    return this->compensation_voltage_;
  }

  void spectrum_query::
  compensation_voltage (const compensation_voltage_type& x)
  {
    this->compensation_voltage_.set (x);
  }

  void spectrum_query::
  compensation_voltage (const compensation_voltage_optional& x)
  {
    this->compensation_voltage_ = x;
  }

  const spectrum_query::precursor_intensity_optional& spectrum_query::
  precursor_intensity () const
  {
    return this->precursor_intensity_;
  }

  spectrum_query::precursor_intensity_optional& spectrum_query::
  precursor_intensity ()
  {
    return this->precursor_intensity_;
  }

  void spectrum_query::
  precursor_intensity (const precursor_intensity_type& x)
  {
    this->precursor_intensity_.set (x);
  }

  void spectrum_query::
  precursor_intensity (const precursor_intensity_optional& x)
  {
    this->precursor_intensity_ = x;
  }

  const spectrum_query::activation_method_optional& spectrum_query::
  activation_method () const
  {
    return this->activation_method_;
  }

  spectrum_query::activation_method_optional& spectrum_query::
  activation_method ()
  {
    return this->activation_method_;
  }

  void spectrum_query::
  activation_method (const activation_method_type& x)
  {
    this->activation_method_.set (x);
  }

  void spectrum_query::
  activation_method (const activation_method_optional& x)
  {
    this->activation_method_ = x;
  }

  void spectrum_query::
  activation_method (::std::unique_ptr< activation_method_type > x)
  {
    this->activation_method_.set (std::move (x));
  }

  const spectrum_query::precursor_neutral_mass_type& spectrum_query::
  precursor_neutral_mass () const
  {
    return this->precursor_neutral_mass_.get ();
  }

  spectrum_query::precursor_neutral_mass_type& spectrum_query::
  precursor_neutral_mass ()
  {
    return this->precursor_neutral_mass_.get ();
  }

  void spectrum_query::
  precursor_neutral_mass (const precursor_neutral_mass_type& x)
  {
    this->precursor_neutral_mass_.set (x);
  }

  const spectrum_query::assumed_charge_type& spectrum_query::
  assumed_charge () const
  {
    return this->assumed_charge_.get ();
  }

  spectrum_query::assumed_charge_type& spectrum_query::
  assumed_charge ()
  {
    return this->assumed_charge_.get ();
  }

  void spectrum_query::
  assumed_charge (const assumed_charge_type& x)
  {
    this->assumed_charge_.set (x);
  }

  const spectrum_query::search_specification_optional& spectrum_query::
  search_specification () const
  {
    return this->search_specification_;
  }

  spectrum_query::search_specification_optional& spectrum_query::
  search_specification ()
  {
    return this->search_specification_;
  }

  void spectrum_query::
  search_specification (const search_specification_type& x)
  {
    this->search_specification_.set (x);
  }

  void spectrum_query::
  search_specification (const search_specification_optional& x)
  {
    this->search_specification_ = x;
  }

  void spectrum_query::
  search_specification (::std::unique_ptr< search_specification_type > x)
  {
    this->search_specification_.set (std::move (x));
  }

  const spectrum_query::index_type& spectrum_query::
  index () const
  {
    return this->index_.get ();
  }

  spectrum_query::index_type& spectrum_query::
  index ()
  {
    return this->index_.get ();
  }

  void spectrum_query::
  index (const index_type& x)
  {
    this->index_.set (x);
  }

  void spectrum_query::
  index (::std::unique_ptr< index_type > x)
  {
    this->index_.set (std::move (x));
  }


  // mixturemodel_distribution
  // 

  const mixturemodel_distribution::posmodel_distribution_type& mixturemodel_distribution::
  posmodel_distribution () const
  {
    return this->posmodel_distribution_.get ();
  }

  mixturemodel_distribution::posmodel_distribution_type& mixturemodel_distribution::
  posmodel_distribution ()
  {
    return this->posmodel_distribution_.get ();
  }

  void mixturemodel_distribution::
  posmodel_distribution (const posmodel_distribution_type& x)
  {
    this->posmodel_distribution_.set (x);
  }

  void mixturemodel_distribution::
  posmodel_distribution (::std::unique_ptr< posmodel_distribution_type > x)
  {
    this->posmodel_distribution_.set (std::move (x));
  }

  const mixturemodel_distribution::negmodel_distribution_type& mixturemodel_distribution::
  negmodel_distribution () const
  {
    return this->negmodel_distribution_.get ();
  }

  mixturemodel_distribution::negmodel_distribution_type& mixturemodel_distribution::
  negmodel_distribution ()
  {
    return this->negmodel_distribution_.get ();
  }

  void mixturemodel_distribution::
  negmodel_distribution (const negmodel_distribution_type& x)
  {
    this->negmodel_distribution_.set (x);
  }

  void mixturemodel_distribution::
  negmodel_distribution (::std::unique_ptr< negmodel_distribution_type > x)
  {
    this->negmodel_distribution_.set (std::move (x));
  }

  const mixturemodel_distribution::name_type& mixturemodel_distribution::
  name () const
  {
    return this->name_.get ();
  }

  mixturemodel_distribution::name_type& mixturemodel_distribution::
  name ()
  {
    return this->name_.get ();
  }

  void mixturemodel_distribution::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void mixturemodel_distribution::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }


  // mixturemodel
  // 

  const mixturemodel::point_sequence& mixturemodel::
  point () const
  {
    return this->point_;
  }

  mixturemodel::point_sequence& mixturemodel::
  point ()
  {
    return this->point_;
  }

  void mixturemodel::
  point (const point_sequence& s)
  {
    this->point_ = s;
  }

  const mixturemodel::name_type& mixturemodel::
  name () const
  {
    return this->name_.get ();
  }

  mixturemodel::name_type& mixturemodel::
  name ()
  {
    return this->name_.get ();
  }

  void mixturemodel::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void mixturemodel::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const mixturemodel::pos_bandwidth_type& mixturemodel::
  pos_bandwidth () const
  {
    return this->pos_bandwidth_.get ();
  }

  mixturemodel::pos_bandwidth_type& mixturemodel::
  pos_bandwidth ()
  {
    return this->pos_bandwidth_.get ();
  }

  void mixturemodel::
  pos_bandwidth (const pos_bandwidth_type& x)
  {
    this->pos_bandwidth_.set (x);
  }

  const mixturemodel::neg_bandwidth_type& mixturemodel::
  neg_bandwidth () const
  {
    return this->neg_bandwidth_.get ();
  }

  mixturemodel::neg_bandwidth_type& mixturemodel::
  neg_bandwidth ()
  {
    return this->neg_bandwidth_.get ();
  }

  void mixturemodel::
  neg_bandwidth (const neg_bandwidth_type& x)
  {
    this->neg_bandwidth_.set (x);
  }


  // contributing_channel
  // 

  const contributing_channel::affected_channel_sequence& contributing_channel::
  affected_channel () const
  {
    return this->affected_channel_;
  }

  contributing_channel::affected_channel_sequence& contributing_channel::
  affected_channel ()
  {
    return this->affected_channel_;
  }

  void contributing_channel::
  affected_channel (const affected_channel_sequence& s)
  {
    this->affected_channel_ = s;
  }

  const contributing_channel::channel_type& contributing_channel::
  channel () const
  {
    return this->channel_.get ();
  }

  contributing_channel::channel_type& contributing_channel::
  channel ()
  {
    return this->channel_.get ();
  }

  void contributing_channel::
  channel (const channel_type& x)
  {
    this->channel_.set (x);
  }

  void contributing_channel::
  channel (::std::unique_ptr< channel_type > x)
  {
    this->channel_.set (std::move (x));
  }


  // specificity
  // 

  const specificity::sense_type& specificity::
  sense () const
  {
    return this->sense_.get ();
  }

  specificity::sense_type& specificity::
  sense ()
  {
    return this->sense_.get ();
  }

  void specificity::
  sense (const sense_type& x)
  {
    this->sense_.set (x);
  }

  void specificity::
  sense (::std::unique_ptr< sense_type > x)
  {
    this->sense_.set (std::move (x));
  }

  const specificity::min_spacing_type& specificity::
  min_spacing () const
  {
    return this->min_spacing_.get ();
  }

  specificity::min_spacing_type& specificity::
  min_spacing ()
  {
    return this->min_spacing_.get ();
  }

  void specificity::
  min_spacing (const min_spacing_type& x)
  {
    this->min_spacing_.set (x);
  }

  specificity::min_spacing_type specificity::
  min_spacing_default_value ()
  {
    return min_spacing_type (1ULL);
  }

  const specificity::cut_type& specificity::
  cut () const
  {
    return this->cut_.get ();
  }

  specificity::cut_type& specificity::
  cut ()
  {
    return this->cut_.get ();
  }

  void specificity::
  cut (const cut_type& x)
  {
    this->cut_.set (x);
  }

  void specificity::
  cut (::std::unique_ptr< cut_type > x)
  {
    this->cut_.set (std::move (x));
  }

  const specificity::no_cut_optional& specificity::
  no_cut () const
  {
    return this->no_cut_;
  }

  specificity::no_cut_optional& specificity::
  no_cut ()
  {
    return this->no_cut_;
  }

  void specificity::
  no_cut (const no_cut_type& x)
  {
    this->no_cut_.set (x);
  }

  void specificity::
  no_cut (const no_cut_optional& x)
  {
    this->no_cut_ = x;
  }

  void specificity::
  no_cut (::std::unique_ptr< no_cut_type > x)
  {
    this->no_cut_.set (std::move (x));
  }


  // name
  // 


  // fidelity
  // 

  fidelity::
  fidelity ()
  : ::xml_schema::string ()
  {
  }

  fidelity::
  fidelity (value v)
  : ::xml_schema::string (_xsd_fidelity_literals_[v])
  {
  }

  fidelity::
  fidelity (const char* v)
  : ::xml_schema::string (v)
  {
  }

  fidelity::
  fidelity (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  fidelity::
  fidelity (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  fidelity::
  fidelity (const fidelity& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  fidelity& fidelity::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_fidelity_literals_[v]);

    return *this;
  }


  // isotope_labeled
  // 

  isotope_labeled::
  isotope_labeled ()
  : ::xml_schema::string ()
  {
  }

  isotope_labeled::
  isotope_labeled (value v)
  : ::xml_schema::string (_xsd_isotope_labeled_literals_[v])
  {
  }

  isotope_labeled::
  isotope_labeled (const char* v)
  : ::xml_schema::string (v)
  {
  }

  isotope_labeled::
  isotope_labeled (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  isotope_labeled::
  isotope_labeled (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  isotope_labeled::
  isotope_labeled (const isotope_labeled& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  isotope_labeled& isotope_labeled::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_isotope_labeled_literals_[v]);

    return *this;
  }


  // search_database
  // 

  const search_database::local_path_type& search_database::
  local_path () const
  {
    return this->local_path_.get ();
  }

  search_database::local_path_type& search_database::
  local_path ()
  {
    return this->local_path_.get ();
  }

  void search_database::
  local_path (const local_path_type& x)
  {
    this->local_path_.set (x);
  }

  void search_database::
  local_path (::std::unique_ptr< local_path_type > x)
  {
    this->local_path_.set (std::move (x));
  }

  const search_database::URL_optional& search_database::
  URL () const
  {
    return this->URL_;
  }

  search_database::URL_optional& search_database::
  URL ()
  {
    return this->URL_;
  }

  void search_database::
  URL (const URL_type& x)
  {
    this->URL_.set (x);
  }

  void search_database::
  URL (const URL_optional& x)
  {
    this->URL_ = x;
  }

  void search_database::
  URL (::std::unique_ptr< URL_type > x)
  {
    this->URL_.set (std::move (x));
  }

  const search_database::database_name_optional& search_database::
  database_name () const
  {
    return this->database_name_;
  }

  search_database::database_name_optional& search_database::
  database_name ()
  {
    return this->database_name_;
  }

  void search_database::
  database_name (const database_name_type& x)
  {
    this->database_name_.set (x);
  }

  void search_database::
  database_name (const database_name_optional& x)
  {
    this->database_name_ = x;
  }

  void search_database::
  database_name (::std::unique_ptr< database_name_type > x)
  {
    this->database_name_.set (std::move (x));
  }

  const search_database::orig_database_url_optional& search_database::
  orig_database_url () const
  {
    return this->orig_database_url_;
  }

  search_database::orig_database_url_optional& search_database::
  orig_database_url ()
  {
    return this->orig_database_url_;
  }

  void search_database::
  orig_database_url (const orig_database_url_type& x)
  {
    this->orig_database_url_.set (x);
  }

  void search_database::
  orig_database_url (const orig_database_url_optional& x)
  {
    this->orig_database_url_ = x;
  }

  void search_database::
  orig_database_url (::std::unique_ptr< orig_database_url_type > x)
  {
    this->orig_database_url_.set (std::move (x));
  }

  const search_database::database_release_date_optional& search_database::
  database_release_date () const
  {
    return this->database_release_date_;
  }

  search_database::database_release_date_optional& search_database::
  database_release_date ()
  {
    return this->database_release_date_;
  }

  void search_database::
  database_release_date (const database_release_date_type& x)
  {
    this->database_release_date_.set (x);
  }

  void search_database::
  database_release_date (const database_release_date_optional& x)
  {
    this->database_release_date_ = x;
  }

  void search_database::
  database_release_date (::std::unique_ptr< database_release_date_type > x)
  {
    this->database_release_date_.set (std::move (x));
  }

  const search_database::database_release_identifier_optional& search_database::
  database_release_identifier () const
  {
    return this->database_release_identifier_;
  }

  search_database::database_release_identifier_optional& search_database::
  database_release_identifier ()
  {
    return this->database_release_identifier_;
  }

  void search_database::
  database_release_identifier (const database_release_identifier_type& x)
  {
    this->database_release_identifier_.set (x);
  }

  void search_database::
  database_release_identifier (const database_release_identifier_optional& x)
  {
    this->database_release_identifier_ = x;
  }

  void search_database::
  database_release_identifier (::std::unique_ptr< database_release_identifier_type > x)
  {
    this->database_release_identifier_.set (std::move (x));
  }

  const search_database::size_in_db_entries_optional& search_database::
  size_in_db_entries () const
  {
    return this->size_in_db_entries_;
  }

  search_database::size_in_db_entries_optional& search_database::
  size_in_db_entries ()
  {
    return this->size_in_db_entries_;
  }

  void search_database::
  size_in_db_entries (const size_in_db_entries_type& x)
  {
    this->size_in_db_entries_.set (x);
  }

  void search_database::
  size_in_db_entries (const size_in_db_entries_optional& x)
  {
    this->size_in_db_entries_ = x;
  }

  const search_database::size_of_residues_optional& search_database::
  size_of_residues () const
  {
    return this->size_of_residues_;
  }

  search_database::size_of_residues_optional& search_database::
  size_of_residues ()
  {
    return this->size_of_residues_;
  }

  void search_database::
  size_of_residues (const size_of_residues_type& x)
  {
    this->size_of_residues_.set (x);
  }

  void search_database::
  size_of_residues (const size_of_residues_optional& x)
  {
    this->size_of_residues_ = x;
  }

  const search_database::type_type& search_database::
  type () const
  {
    return this->type_.get ();
  }

  search_database::type_type& search_database::
  type ()
  {
    return this->type_.get ();
  }

  void search_database::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void search_database::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // enzymatic_search_constraint
  // 

  const enzymatic_search_constraint::enzyme_type& enzymatic_search_constraint::
  enzyme () const
  {
    return this->enzyme_.get ();
  }

  enzymatic_search_constraint::enzyme_type& enzymatic_search_constraint::
  enzyme ()
  {
    return this->enzyme_.get ();
  }

  void enzymatic_search_constraint::
  enzyme (const enzyme_type& x)
  {
    this->enzyme_.set (x);
  }

  void enzymatic_search_constraint::
  enzyme (::std::unique_ptr< enzyme_type > x)
  {
    this->enzyme_.set (std::move (x));
  }

  const enzymatic_search_constraint::max_num_internal_cleavages_type& enzymatic_search_constraint::
  max_num_internal_cleavages () const
  {
    return this->max_num_internal_cleavages_.get ();
  }

  enzymatic_search_constraint::max_num_internal_cleavages_type& enzymatic_search_constraint::
  max_num_internal_cleavages ()
  {
    return this->max_num_internal_cleavages_.get ();
  }

  void enzymatic_search_constraint::
  max_num_internal_cleavages (const max_num_internal_cleavages_type& x)
  {
    this->max_num_internal_cleavages_.set (x);
  }

  const enzymatic_search_constraint::min_number_termini_type& enzymatic_search_constraint::
  min_number_termini () const
  {
    return this->min_number_termini_.get ();
  }

  enzymatic_search_constraint::min_number_termini_type& enzymatic_search_constraint::
  min_number_termini ()
  {
    return this->min_number_termini_.get ();
  }

  void enzymatic_search_constraint::
  min_number_termini (const min_number_termini_type& x)
  {
    this->min_number_termini_.set (x);
  }


  // sequence_search_constraint
  // 

  const sequence_search_constraint::sequence_type& sequence_search_constraint::
  sequence () const
  {
    return this->sequence_.get ();
  }

  sequence_search_constraint::sequence_type& sequence_search_constraint::
  sequence ()
  {
    return this->sequence_.get ();
  }

  void sequence_search_constraint::
  sequence (const sequence_type& x)
  {
    this->sequence_.set (x);
  }

  void sequence_search_constraint::
  sequence (::std::unique_ptr< sequence_type > x)
  {
    this->sequence_.set (std::move (x));
  }


  // aminoacid_modification
  // 

  const aminoacid_modification::aminoacid_type& aminoacid_modification::
  aminoacid () const
  {
    return this->aminoacid_.get ();
  }

  aminoacid_modification::aminoacid_type& aminoacid_modification::
  aminoacid ()
  {
    return this->aminoacid_.get ();
  }

  void aminoacid_modification::
  aminoacid (const aminoacid_type& x)
  {
    this->aminoacid_.set (x);
  }

  void aminoacid_modification::
  aminoacid (::std::unique_ptr< aminoacid_type > x)
  {
    this->aminoacid_.set (std::move (x));
  }

  const aminoacid_modification::massdiff_type& aminoacid_modification::
  massdiff () const
  {
    return this->massdiff_.get ();
  }

  aminoacid_modification::massdiff_type& aminoacid_modification::
  massdiff ()
  {
    return this->massdiff_.get ();
  }

  void aminoacid_modification::
  massdiff (const massdiff_type& x)
  {
    this->massdiff_.set (x);
  }

  const aminoacid_modification::mass_type& aminoacid_modification::
  mass () const
  {
    return this->mass_.get ();
  }

  aminoacid_modification::mass_type& aminoacid_modification::
  mass ()
  {
    return this->mass_.get ();
  }

  void aminoacid_modification::
  mass (const mass_type& x)
  {
    this->mass_.set (x);
  }

  const aminoacid_modification::variable_type& aminoacid_modification::
  variable () const
  {
    return this->variable_.get ();
  }

  aminoacid_modification::variable_type& aminoacid_modification::
  variable ()
  {
    return this->variable_.get ();
  }

  void aminoacid_modification::
  variable (const variable_type& x)
  {
    this->variable_.set (x);
  }

  void aminoacid_modification::
  variable (::std::unique_ptr< variable_type > x)
  {
    this->variable_.set (std::move (x));
  }

  const aminoacid_modification::peptide_terminus_optional& aminoacid_modification::
  peptide_terminus () const
  {
    return this->peptide_terminus_;
  }

  aminoacid_modification::peptide_terminus_optional& aminoacid_modification::
  peptide_terminus ()
  {
    return this->peptide_terminus_;
  }

  void aminoacid_modification::
  peptide_terminus (const peptide_terminus_type& x)
  {
    this->peptide_terminus_.set (x);
  }

  void aminoacid_modification::
  peptide_terminus (const peptide_terminus_optional& x)
  {
    this->peptide_terminus_ = x;
  }

  void aminoacid_modification::
  peptide_terminus (::std::unique_ptr< peptide_terminus_type > x)
  {
    this->peptide_terminus_.set (std::move (x));
  }

  const aminoacid_modification::protein_terminus_optional& aminoacid_modification::
  protein_terminus () const
  {
    return this->protein_terminus_;
  }

  aminoacid_modification::protein_terminus_optional& aminoacid_modification::
  protein_terminus ()
  {
    return this->protein_terminus_;
  }

  void aminoacid_modification::
  protein_terminus (const protein_terminus_type& x)
  {
    this->protein_terminus_.set (x);
  }

  void aminoacid_modification::
  protein_terminus (const protein_terminus_optional& x)
  {
    this->protein_terminus_ = x;
  }

  void aminoacid_modification::
  protein_terminus (::std::unique_ptr< protein_terminus_type > x)
  {
    this->protein_terminus_.set (std::move (x));
  }

  const aminoacid_modification::symbol_optional& aminoacid_modification::
  symbol () const
  {
    return this->symbol_;
  }

  aminoacid_modification::symbol_optional& aminoacid_modification::
  symbol ()
  {
    return this->symbol_;
  }

  void aminoacid_modification::
  symbol (const symbol_type& x)
  {
    this->symbol_.set (x);
  }

  void aminoacid_modification::
  symbol (const symbol_optional& x)
  {
    this->symbol_ = x;
  }

  void aminoacid_modification::
  symbol (::std::unique_ptr< symbol_type > x)
  {
    this->symbol_.set (std::move (x));
  }

  const aminoacid_modification::binary_optional& aminoacid_modification::
  binary () const
  {
    return this->binary_;
  }

  aminoacid_modification::binary_optional& aminoacid_modification::
  binary ()
  {
    return this->binary_;
  }

  void aminoacid_modification::
  binary (const binary_type& x)
  {
    this->binary_.set (x);
  }

  void aminoacid_modification::
  binary (const binary_optional& x)
  {
    this->binary_ = x;
  }

  void aminoacid_modification::
  binary (::std::unique_ptr< binary_type > x)
  {
    this->binary_.set (std::move (x));
  }

  const aminoacid_modification::description_optional& aminoacid_modification::
  description () const
  {
    return this->description_;
  }

  aminoacid_modification::description_optional& aminoacid_modification::
  description ()
  {
    return this->description_;
  }

  void aminoacid_modification::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void aminoacid_modification::
  description (const description_optional& x)
  {
    this->description_ = x;
  }

  void aminoacid_modification::
  description (::std::unique_ptr< description_type > x)
  {
    this->description_.set (std::move (x));
  }


  // terminal_modification
  // 

  const terminal_modification::terminus_type& terminal_modification::
  terminus () const
  {
    return this->terminus_.get ();
  }

  terminal_modification::terminus_type& terminal_modification::
  terminus ()
  {
    return this->terminus_.get ();
  }

  void terminal_modification::
  terminus (const terminus_type& x)
  {
    this->terminus_.set (x);
  }

  void terminal_modification::
  terminus (::std::unique_ptr< terminus_type > x)
  {
    this->terminus_.set (std::move (x));
  }

  const terminal_modification::massdiff_type& terminal_modification::
  massdiff () const
  {
    return this->massdiff_.get ();
  }

  terminal_modification::massdiff_type& terminal_modification::
  massdiff ()
  {
    return this->massdiff_.get ();
  }

  void terminal_modification::
  massdiff (const massdiff_type& x)
  {
    this->massdiff_.set (x);
  }

  const terminal_modification::mass_type& terminal_modification::
  mass () const
  {
    return this->mass_.get ();
  }

  terminal_modification::mass_type& terminal_modification::
  mass ()
  {
    return this->mass_.get ();
  }

  void terminal_modification::
  mass (const mass_type& x)
  {
    this->mass_.set (x);
  }

  const terminal_modification::variable_type& terminal_modification::
  variable () const
  {
    return this->variable_.get ();
  }

  terminal_modification::variable_type& terminal_modification::
  variable ()
  {
    return this->variable_.get ();
  }

  void terminal_modification::
  variable (const variable_type& x)
  {
    this->variable_.set (x);
  }

  void terminal_modification::
  variable (::std::unique_ptr< variable_type > x)
  {
    this->variable_.set (std::move (x));
  }

  const terminal_modification::symbol_optional& terminal_modification::
  symbol () const
  {
    return this->symbol_;
  }

  terminal_modification::symbol_optional& terminal_modification::
  symbol ()
  {
    return this->symbol_;
  }

  void terminal_modification::
  symbol (const symbol_type& x)
  {
    this->symbol_.set (x);
  }

  void terminal_modification::
  symbol (const symbol_optional& x)
  {
    this->symbol_ = x;
  }

  void terminal_modification::
  symbol (::std::unique_ptr< symbol_type > x)
  {
    this->symbol_.set (std::move (x));
  }

  const terminal_modification::protein_terminus_type& terminal_modification::
  protein_terminus () const
  {
    return this->protein_terminus_.get ();
  }

  terminal_modification::protein_terminus_type& terminal_modification::
  protein_terminus ()
  {
    return this->protein_terminus_.get ();
  }

  void terminal_modification::
  protein_terminus (const protein_terminus_type& x)
  {
    this->protein_terminus_.set (x);
  }

  void terminal_modification::
  protein_terminus (::std::unique_ptr< protein_terminus_type > x)
  {
    this->protein_terminus_.set (std::move (x));
  }

  const terminal_modification::description_optional& terminal_modification::
  description () const
  {
    return this->description_;
  }

  terminal_modification::description_optional& terminal_modification::
  description ()
  {
    return this->description_;
  }

  void terminal_modification::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void terminal_modification::
  description (const description_optional& x)
  {
    this->description_ = x;
  }

  void terminal_modification::
  description (::std::unique_ptr< description_type > x)
  {
    this->description_.set (std::move (x));
  }


  // search_result
  // 

  const search_result::search_hit_sequence& search_result::
  search_hit () const
  {
    return this->search_hit_;
  }

  search_result::search_hit_sequence& search_result::
  search_hit ()
  {
    return this->search_hit_;
  }

  void search_result::
  search_hit (const search_hit_sequence& s)
  {
    this->search_hit_ = s;
  }

  const search_result::search_id_type& search_result::
  search_id () const
  {
    return this->search_id_.get ();
  }

  search_result::search_id_type& search_result::
  search_id ()
  {
    return this->search_id_.get ();
  }

  void search_result::
  search_id (const search_id_type& x)
  {
    this->search_id_.set (x);
  }

  void search_result::
  search_id (::std::unique_ptr< search_id_type > x)
  {
    this->search_id_.set (std::move (x));
  }

  search_result::search_id_type search_result::
  search_id_default_value ()
  {
    return search_id_type (1U);
  }


  // posmodel_distribution
  // 

  const posmodel_distribution::parameter_sequence& posmodel_distribution::
  parameter () const
  {
    return this->parameter_;
  }

  posmodel_distribution::parameter_sequence& posmodel_distribution::
  parameter ()
  {
    return this->parameter_;
  }

  void posmodel_distribution::
  parameter (const parameter_sequence& s)
  {
    this->parameter_ = s;
  }

  const posmodel_distribution::type_optional& posmodel_distribution::
  type () const
  {
    return this->type_;
  }

  posmodel_distribution::type_optional& posmodel_distribution::
  type ()
  {
    return this->type_;
  }

  void posmodel_distribution::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void posmodel_distribution::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void posmodel_distribution::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // negmodel_distribution
  // 

  const negmodel_distribution::parameter_sequence& negmodel_distribution::
  parameter () const
  {
    return this->parameter_;
  }

  negmodel_distribution::parameter_sequence& negmodel_distribution::
  parameter ()
  {
    return this->parameter_;
  }

  void negmodel_distribution::
  parameter (const parameter_sequence& s)
  {
    this->parameter_ = s;
  }

  const negmodel_distribution::type_optional& negmodel_distribution::
  type () const
  {
    return this->type_;
  }

  negmodel_distribution::type_optional& negmodel_distribution::
  type ()
  {
    return this->type_;
  }

  void negmodel_distribution::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void negmodel_distribution::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void negmodel_distribution::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // point1
  // 

  const point1::value_optional& point1::
  value () const
  {
    return this->value_;
  }

  point1::value_optional& point1::
  value ()
  {
    return this->value_;
  }

  void point1::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void point1::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  const point1::pos_dens_optional& point1::
  pos_dens () const
  {
    return this->pos_dens_;
  }

  point1::pos_dens_optional& point1::
  pos_dens ()
  {
    return this->pos_dens_;
  }

  void point1::
  pos_dens (const pos_dens_type& x)
  {
    this->pos_dens_.set (x);
  }

  void point1::
  pos_dens (const pos_dens_optional& x)
  {
    this->pos_dens_ = x;
  }

  const point1::neg_dens_optional& point1::
  neg_dens () const
  {
    return this->neg_dens_;
  }

  point1::neg_dens_optional& point1::
  neg_dens ()
  {
    return this->neg_dens_;
  }

  void point1::
  neg_dens (const neg_dens_type& x)
  {
    this->neg_dens_.set (x);
  }

  void point1::
  neg_dens (const neg_dens_optional& x)
  {
    this->neg_dens_ = x;
  }


  // affected_channel
  // 

  const affected_channel::channel_type& affected_channel::
  channel () const
  {
    return this->channel_.get ();
  }

  affected_channel::channel_type& affected_channel::
  channel ()
  {
    return this->channel_.get ();
  }

  void affected_channel::
  channel (const channel_type& x)
  {
    this->channel_.set (x);
  }

  void affected_channel::
  channel (::std::unique_ptr< channel_type > x)
  {
    this->channel_.set (std::move (x));
  }

  const affected_channel::correction_type& affected_channel::
  correction () const
  {
    return this->correction_.get ();
  }

  affected_channel::correction_type& affected_channel::
  correction ()
  {
    return this->correction_.get ();
  }

  void affected_channel::
  correction (const correction_type& x)
  {
    this->correction_.set (x);
  }


  // sense
  // 

  sense::
  sense ()
  : ::xml_schema::string ()
  {
  }

  sense::
  sense (value v)
  : ::xml_schema::string (_xsd_sense_literals_[v])
  {
  }

  sense::
  sense (const char* v)
  : ::xml_schema::string (v)
  {
  }

  sense::
  sense (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  sense::
  sense (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  sense::
  sense (const sense& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  sense& sense::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_sense_literals_[v]);

    return *this;
  }


  // cut
  // 


  // no_cut
  // 


  // type
  // 

  type::
  type ()
  : ::xml_schema::string ()
  {
  }

  type::
  type (value v)
  : ::xml_schema::string (_xsd_type_literals_[v])
  {
  }

  type::
  type (const char* v)
  : ::xml_schema::string (v)
  {
  }

  type::
  type (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  type::
  type (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  type::
  type (const type& v,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  type& type::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_type_literals_[v]);

    return *this;
  }


  // search_hit
  // 

  const search_hit::alternative_protein_sequence& search_hit::
  alternative_protein () const
  {
    return this->alternative_protein_;
  }

  search_hit::alternative_protein_sequence& search_hit::
  alternative_protein ()
  {
    return this->alternative_protein_;
  }

  void search_hit::
  alternative_protein (const alternative_protein_sequence& s)
  {
    this->alternative_protein_ = s;
  }

  const search_hit::modification_info_optional& search_hit::
  modification_info () const
  {
    return this->modification_info_;
  }

  search_hit::modification_info_optional& search_hit::
  modification_info ()
  {
    return this->modification_info_;
  }

  void search_hit::
  modification_info (const modification_info_type& x)
  {
    this->modification_info_.set (x);
  }

  void search_hit::
  modification_info (const modification_info_optional& x)
  {
    this->modification_info_ = x;
  }

  void search_hit::
  modification_info (::std::unique_ptr< modification_info_type > x)
  {
    this->modification_info_.set (std::move (x));
  }

  const search_hit::xlink_optional& search_hit::
  xlink () const
  {
    return this->xlink_;
  }

  search_hit::xlink_optional& search_hit::
  xlink ()
  {
    return this->xlink_;
  }

  void search_hit::
  xlink (const xlink_type& x)
  {
    this->xlink_.set (x);
  }

  void search_hit::
  xlink (const xlink_optional& x)
  {
    this->xlink_ = x;
  }

  void search_hit::
  xlink (::std::unique_ptr< xlink_type > x)
  {
    this->xlink_.set (std::move (x));
  }

  const search_hit::search_score_sequence& search_hit::
  search_score () const
  {
    return this->search_score_;
  }

  search_hit::search_score_sequence& search_hit::
  search_score ()
  {
    return this->search_score_;
  }

  void search_hit::
  search_score (const search_score_sequence& s)
  {
    this->search_score_ = s;
  }

  const search_hit::analysis_result_sequence& search_hit::
  analysis_result () const
  {
    return this->analysis_result_;
  }

  search_hit::analysis_result_sequence& search_hit::
  analysis_result ()
  {
    return this->analysis_result_;
  }

  void search_hit::
  analysis_result (const analysis_result_sequence& s)
  {
    this->analysis_result_ = s;
  }

  const search_hit::parameter_sequence& search_hit::
  parameter () const
  {
    return this->parameter_;
  }

  search_hit::parameter_sequence& search_hit::
  parameter ()
  {
    return this->parameter_;
  }

  void search_hit::
  parameter (const parameter_sequence& s)
  {
    this->parameter_ = s;
  }

  const search_hit::hit_rank_type& search_hit::
  hit_rank () const
  {
    return this->hit_rank_.get ();
  }

  search_hit::hit_rank_type& search_hit::
  hit_rank ()
  {
    return this->hit_rank_.get ();
  }

  void search_hit::
  hit_rank (const hit_rank_type& x)
  {
    this->hit_rank_.set (x);
  }

  void search_hit::
  hit_rank (::std::unique_ptr< hit_rank_type > x)
  {
    this->hit_rank_.set (std::move (x));
  }

  const search_hit::peptide_type& search_hit::
  peptide () const
  {
    return this->peptide_.get ();
  }

  search_hit::peptide_type& search_hit::
  peptide ()
  {
    return this->peptide_.get ();
  }

  void search_hit::
  peptide (const peptide_type& x)
  {
    this->peptide_.set (x);
  }

  void search_hit::
  peptide (::std::unique_ptr< peptide_type > x)
  {
    this->peptide_.set (std::move (x));
  }

  const search_hit::peptide_prev_aa_optional& search_hit::
  peptide_prev_aa () const
  {
    return this->peptide_prev_aa_;
  }

  search_hit::peptide_prev_aa_optional& search_hit::
  peptide_prev_aa ()
  {
    return this->peptide_prev_aa_;
  }

  void search_hit::
  peptide_prev_aa (const peptide_prev_aa_type& x)
  {
    this->peptide_prev_aa_.set (x);
  }

  void search_hit::
  peptide_prev_aa (const peptide_prev_aa_optional& x)
  {
    this->peptide_prev_aa_ = x;
  }

  void search_hit::
  peptide_prev_aa (::std::unique_ptr< peptide_prev_aa_type > x)
  {
    this->peptide_prev_aa_.set (std::move (x));
  }

  const search_hit::peptide_next_aa_optional& search_hit::
  peptide_next_aa () const
  {
    return this->peptide_next_aa_;
  }

  search_hit::peptide_next_aa_optional& search_hit::
  peptide_next_aa ()
  {
    return this->peptide_next_aa_;
  }

  void search_hit::
  peptide_next_aa (const peptide_next_aa_type& x)
  {
    this->peptide_next_aa_.set (x);
  }

  void search_hit::
  peptide_next_aa (const peptide_next_aa_optional& x)
  {
    this->peptide_next_aa_ = x;
  }

  void search_hit::
  peptide_next_aa (::std::unique_ptr< peptide_next_aa_type > x)
  {
    this->peptide_next_aa_.set (std::move (x));
  }

  const search_hit::protein_type& search_hit::
  protein () const
  {
    return this->protein_.get ();
  }

  search_hit::protein_type& search_hit::
  protein ()
  {
    return this->protein_.get ();
  }

  void search_hit::
  protein (const protein_type& x)
  {
    this->protein_.set (x);
  }

  void search_hit::
  protein (::std::unique_ptr< protein_type > x)
  {
    this->protein_.set (std::move (x));
  }

  const search_hit::num_tot_proteins_type& search_hit::
  num_tot_proteins () const
  {
    return this->num_tot_proteins_.get ();
  }

  search_hit::num_tot_proteins_type& search_hit::
  num_tot_proteins ()
  {
    return this->num_tot_proteins_.get ();
  }

  void search_hit::
  num_tot_proteins (const num_tot_proteins_type& x)
  {
    this->num_tot_proteins_.set (x);
  }

  const search_hit::num_matched_ions_optional& search_hit::
  num_matched_ions () const
  {
    return this->num_matched_ions_;
  }

  search_hit::num_matched_ions_optional& search_hit::
  num_matched_ions ()
  {
    return this->num_matched_ions_;
  }

  void search_hit::
  num_matched_ions (const num_matched_ions_type& x)
  {
    this->num_matched_ions_.set (x);
  }

  void search_hit::
  num_matched_ions (const num_matched_ions_optional& x)
  {
    this->num_matched_ions_ = x;
  }

  const search_hit::tot_num_ions_optional& search_hit::
  tot_num_ions () const
  {
    return this->tot_num_ions_;
  }

  search_hit::tot_num_ions_optional& search_hit::
  tot_num_ions ()
  {
    return this->tot_num_ions_;
  }

  void search_hit::
  tot_num_ions (const tot_num_ions_type& x)
  {
    this->tot_num_ions_.set (x);
  }

  void search_hit::
  tot_num_ions (const tot_num_ions_optional& x)
  {
    this->tot_num_ions_ = x;
  }

  const search_hit::calc_neutral_pep_mass_type& search_hit::
  calc_neutral_pep_mass () const
  {
    return this->calc_neutral_pep_mass_.get ();
  }

  search_hit::calc_neutral_pep_mass_type& search_hit::
  calc_neutral_pep_mass ()
  {
    return this->calc_neutral_pep_mass_.get ();
  }

  void search_hit::
  calc_neutral_pep_mass (const calc_neutral_pep_mass_type& x)
  {
    this->calc_neutral_pep_mass_.set (x);
  }

  const search_hit::massdiff_type& search_hit::
  massdiff () const
  {
    return this->massdiff_.get ();
  }

  search_hit::massdiff_type& search_hit::
  massdiff ()
  {
    return this->massdiff_.get ();
  }

  void search_hit::
  massdiff (const massdiff_type& x)
  {
    this->massdiff_.set (x);
  }

  const search_hit::num_tol_term_optional& search_hit::
  num_tol_term () const
  {
    return this->num_tol_term_;
  }

  search_hit::num_tol_term_optional& search_hit::
  num_tol_term ()
  {
    return this->num_tol_term_;
  }

  void search_hit::
  num_tol_term (const num_tol_term_type& x)
  {
    this->num_tol_term_.set (x);
  }

  void search_hit::
  num_tol_term (const num_tol_term_optional& x)
  {
    this->num_tol_term_ = x;
  }

  const search_hit::num_missed_cleavages_optional& search_hit::
  num_missed_cleavages () const
  {
    return this->num_missed_cleavages_;
  }

  search_hit::num_missed_cleavages_optional& search_hit::
  num_missed_cleavages ()
  {
    return this->num_missed_cleavages_;
  }

  void search_hit::
  num_missed_cleavages (const num_missed_cleavages_type& x)
  {
    this->num_missed_cleavages_.set (x);
  }

  void search_hit::
  num_missed_cleavages (const num_missed_cleavages_optional& x)
  {
    this->num_missed_cleavages_ = x;
  }

  const search_hit::num_matched_peptides_optional& search_hit::
  num_matched_peptides () const
  {
    return this->num_matched_peptides_;
  }

  search_hit::num_matched_peptides_optional& search_hit::
  num_matched_peptides ()
  {
    return this->num_matched_peptides_;
  }

  void search_hit::
  num_matched_peptides (const num_matched_peptides_type& x)
  {
    this->num_matched_peptides_.set (x);
  }

  void search_hit::
  num_matched_peptides (const num_matched_peptides_optional& x)
  {
    this->num_matched_peptides_ = x;
  }

  const search_hit::xlink_type_optional& search_hit::
  xlink_type1 () const
  {
    return this->xlink_type_;
  }

  search_hit::xlink_type_optional& search_hit::
  xlink_type1 ()
  {
    return this->xlink_type_;
  }

  void search_hit::
  xlink_type1 (const xlink_type_type& x)
  {
    this->xlink_type_.set (x);
  }

  void search_hit::
  xlink_type1 (const xlink_type_optional& x)
  {
    this->xlink_type_ = x;
  }

  void search_hit::
  xlink_type1 (::std::unique_ptr< xlink_type_type > x)
  {
    this->xlink_type_.set (std::move (x));
  }

  const search_hit::is_rejected_type& search_hit::
  is_rejected () const
  {
    return this->is_rejected_.get ();
  }

  search_hit::is_rejected_type& search_hit::
  is_rejected ()
  {
    return this->is_rejected_.get ();
  }

  void search_hit::
  is_rejected (const is_rejected_type& x)
  {
    this->is_rejected_.set (x);
  }

  void search_hit::
  is_rejected (::std::unique_ptr< is_rejected_type > x)
  {
    this->is_rejected_.set (std::move (x));
  }

  search_hit::is_rejected_type search_hit::
  is_rejected_default_value ()
  {
    return is_rejected_type (0ULL);
  }

  const search_hit::protein_descr_optional& search_hit::
  protein_descr () const
  {
    return this->protein_descr_;
  }

  search_hit::protein_descr_optional& search_hit::
  protein_descr ()
  {
    return this->protein_descr_;
  }

  void search_hit::
  protein_descr (const protein_descr_type& x)
  {
    this->protein_descr_.set (x);
  }

  void search_hit::
  protein_descr (const protein_descr_optional& x)
  {
    this->protein_descr_ = x;
  }

  void search_hit::
  protein_descr (::std::unique_ptr< protein_descr_type > x)
  {
    this->protein_descr_.set (std::move (x));
  }

  const search_hit::calc_pI_optional& search_hit::
  calc_pI () const
  {
    return this->calc_pI_;
  }

  search_hit::calc_pI_optional& search_hit::
  calc_pI ()
  {
    return this->calc_pI_;
  }

  void search_hit::
  calc_pI (const calc_pI_type& x)
  {
    this->calc_pI_.set (x);
  }

  void search_hit::
  calc_pI (const calc_pI_optional& x)
  {
    this->calc_pI_ = x;
  }

  void search_hit::
  calc_pI (::std::unique_ptr< calc_pI_type > x)
  {
    this->calc_pI_.set (std::move (x));
  }

  const search_hit::protein_mw_optional& search_hit::
  protein_mw () const
  {
    return this->protein_mw_;
  }

  search_hit::protein_mw_optional& search_hit::
  protein_mw ()
  {
    return this->protein_mw_;
  }

  void search_hit::
  protein_mw (const protein_mw_type& x)
  {
    this->protein_mw_.set (x);
  }

  void search_hit::
  protein_mw (const protein_mw_optional& x)
  {
    this->protein_mw_ = x;
  }


  // xlink
  // 

  const xlink::linked_peptide_sequence& xlink::
  linked_peptide () const
  {
    return this->linked_peptide_;
  }

  xlink::linked_peptide_sequence& xlink::
  linked_peptide ()
  {
    return this->linked_peptide_;
  }

  void xlink::
  linked_peptide (const linked_peptide_sequence& s)
  {
    this->linked_peptide_ = s;
  }

  const xlink::xlink_score_sequence& xlink::
  xlink_score () const
  {
    return this->xlink_score_;
  }

  xlink::xlink_score_sequence& xlink::
  xlink_score ()
  {
    return this->xlink_score_;
  }

  void xlink::
  xlink_score (const xlink_score_sequence& s)
  {
    this->xlink_score_ = s;
  }

  const xlink::identifier_type& xlink::
  identifier () const
  {
    return this->identifier_.get ();
  }

  xlink::identifier_type& xlink::
  identifier ()
  {
    return this->identifier_.get ();
  }

  void xlink::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void xlink::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const xlink::mass_type& xlink::
  mass () const
  {
    return this->mass_.get ();
  }

  xlink::mass_type& xlink::
  mass ()
  {
    return this->mass_.get ();
  }

  void xlink::
  mass (const mass_type& x)
  {
    this->mass_.set (x);
  }


  // analysis_result
  // 

  const analysis_result::analysis_type& analysis_result::
  analysis () const
  {
    return this->analysis_.get ();
  }

  analysis_result::analysis_type& analysis_result::
  analysis ()
  {
    return this->analysis_.get ();
  }

  void analysis_result::
  analysis (const analysis_type& x)
  {
    this->analysis_.set (x);
  }

  void analysis_result::
  analysis (::std::unique_ptr< analysis_type > x)
  {
    this->analysis_.set (std::move (x));
  }

  const analysis_result::id_type& analysis_result::
  id () const
  {
    return this->id_.get ();
  }

  analysis_result::id_type& analysis_result::
  id ()
  {
    return this->id_.get ();
  }

  void analysis_result::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void analysis_result::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  analysis_result::id_type analysis_result::
  id_default_value ()
  {
    return id_type (1U);
  }


  // xlink_type
  // 

  xlink_type::
  xlink_type ()
  : ::xml_schema::string ()
  {
  }

  xlink_type::
  xlink_type (value v)
  : ::xml_schema::string (_xsd_xlink_type_literals_[v])
  {
  }

  xlink_type::
  xlink_type (const char* v)
  : ::xml_schema::string (v)
  {
  }

  xlink_type::
  xlink_type (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  xlink_type::
  xlink_type (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  xlink_type::
  xlink_type (const xlink_type& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  xlink_type& xlink_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_xlink_type_literals_[v]);

    return *this;
  }


  // is_rejected
  // 

  is_rejected::
  is_rejected ()
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > ()
  {
  }

  is_rejected::
  is_rejected (::xml_schema::non_negative_integer v): ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (v)
  {
  }

  is_rejected::
  is_rejected (const is_rejected& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (v, f, c)
  {
  }


  // linked_peptide
  // 

  const linked_peptide::alternative_protein_sequence& linked_peptide::
  alternative_protein () const
  {
    return this->alternative_protein_;
  }

  linked_peptide::alternative_protein_sequence& linked_peptide::
  alternative_protein ()
  {
    return this->alternative_protein_;
  }

  void linked_peptide::
  alternative_protein (const alternative_protein_sequence& s)
  {
    this->alternative_protein_ = s;
  }

  const linked_peptide::modification_info_optional& linked_peptide::
  modification_info () const
  {
    return this->modification_info_;
  }

  linked_peptide::modification_info_optional& linked_peptide::
  modification_info ()
  {
    return this->modification_info_;
  }

  void linked_peptide::
  modification_info (const modification_info_type& x)
  {
    this->modification_info_.set (x);
  }

  void linked_peptide::
  modification_info (const modification_info_optional& x)
  {
    this->modification_info_ = x;
  }

  void linked_peptide::
  modification_info (::std::unique_ptr< modification_info_type > x)
  {
    this->modification_info_.set (std::move (x));
  }

  const linked_peptide::xlink_score_sequence& linked_peptide::
  xlink_score () const
  {
    return this->xlink_score_;
  }

  linked_peptide::xlink_score_sequence& linked_peptide::
  xlink_score ()
  {
    return this->xlink_score_;
  }

  void linked_peptide::
  xlink_score (const xlink_score_sequence& s)
  {
    this->xlink_score_ = s;
  }

  const linked_peptide::peptide_type& linked_peptide::
  peptide () const
  {
    return this->peptide_.get ();
  }

  linked_peptide::peptide_type& linked_peptide::
  peptide ()
  {
    return this->peptide_.get ();
  }

  void linked_peptide::
  peptide (const peptide_type& x)
  {
    this->peptide_.set (x);
  }

  void linked_peptide::
  peptide (::std::unique_ptr< peptide_type > x)
  {
    this->peptide_.set (std::move (x));
  }

  const linked_peptide::peptide_prev_aa_optional& linked_peptide::
  peptide_prev_aa () const
  {
    return this->peptide_prev_aa_;
  }

  linked_peptide::peptide_prev_aa_optional& linked_peptide::
  peptide_prev_aa ()
  {
    return this->peptide_prev_aa_;
  }

  void linked_peptide::
  peptide_prev_aa (const peptide_prev_aa_type& x)
  {
    this->peptide_prev_aa_.set (x);
  }

  void linked_peptide::
  peptide_prev_aa (const peptide_prev_aa_optional& x)
  {
    this->peptide_prev_aa_ = x;
  }

  void linked_peptide::
  peptide_prev_aa (::std::unique_ptr< peptide_prev_aa_type > x)
  {
    this->peptide_prev_aa_.set (std::move (x));
  }

  const linked_peptide::peptide_next_aa_optional& linked_peptide::
  peptide_next_aa () const
  {
    return this->peptide_next_aa_;
  }

  linked_peptide::peptide_next_aa_optional& linked_peptide::
  peptide_next_aa ()
  {
    return this->peptide_next_aa_;
  }

  void linked_peptide::
  peptide_next_aa (const peptide_next_aa_type& x)
  {
    this->peptide_next_aa_.set (x);
  }

  void linked_peptide::
  peptide_next_aa (const peptide_next_aa_optional& x)
  {
    this->peptide_next_aa_ = x;
  }

  void linked_peptide::
  peptide_next_aa (::std::unique_ptr< peptide_next_aa_type > x)
  {
    this->peptide_next_aa_.set (std::move (x));
  }

  const linked_peptide::protein_type& linked_peptide::
  protein () const
  {
    return this->protein_.get ();
  }

  linked_peptide::protein_type& linked_peptide::
  protein ()
  {
    return this->protein_.get ();
  }

  void linked_peptide::
  protein (const protein_type& x)
  {
    this->protein_.set (x);
  }

  void linked_peptide::
  protein (::std::unique_ptr< protein_type > x)
  {
    this->protein_.set (std::move (x));
  }

  const linked_peptide::num_tot_proteins_type& linked_peptide::
  num_tot_proteins () const
  {
    return this->num_tot_proteins_.get ();
  }

  linked_peptide::num_tot_proteins_type& linked_peptide::
  num_tot_proteins ()
  {
    return this->num_tot_proteins_.get ();
  }

  void linked_peptide::
  num_tot_proteins (const num_tot_proteins_type& x)
  {
    this->num_tot_proteins_.set (x);
  }

  const linked_peptide::calc_neutral_pep_mass_type& linked_peptide::
  calc_neutral_pep_mass () const
  {
    return this->calc_neutral_pep_mass_.get ();
  }

  linked_peptide::calc_neutral_pep_mass_type& linked_peptide::
  calc_neutral_pep_mass ()
  {
    return this->calc_neutral_pep_mass_.get ();
  }

  void linked_peptide::
  calc_neutral_pep_mass (const calc_neutral_pep_mass_type& x)
  {
    this->calc_neutral_pep_mass_.set (x);
  }

  const linked_peptide::complement_mass_type& linked_peptide::
  complement_mass () const
  {
    return this->complement_mass_.get ();
  }

  linked_peptide::complement_mass_type& linked_peptide::
  complement_mass ()
  {
    return this->complement_mass_.get ();
  }

  void linked_peptide::
  complement_mass (const complement_mass_type& x)
  {
    this->complement_mass_.set (x);
  }

  const linked_peptide::designation_optional& linked_peptide::
  designation () const
  {
    return this->designation_;
  }

  linked_peptide::designation_optional& linked_peptide::
  designation ()
  {
    return this->designation_;
  }

  void linked_peptide::
  designation (const designation_type& x)
  {
    this->designation_.set (x);
  }

  void linked_peptide::
  designation (const designation_optional& x)
  {
    this->designation_ = x;
  }

  void linked_peptide::
  designation (::std::unique_ptr< designation_type > x)
  {
    this->designation_.set (std::move (x));
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace pepXML
{
  // engineType
  //

  engineType::
  engineType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_engineType_convert ();
  }

  engineType::
  engineType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_engineType_convert ();
  }

  engineType::
  engineType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_engineType_convert ();
  }

  engineType* engineType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class engineType (*this, f, c);
  }

  engineType::value engineType::
  _xsd_engineType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_engineType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_engineType_indexes_,
                      _xsd_engineType_indexes_ + 22,
                      *this,
                      c));

    if (i == _xsd_engineType_indexes_ + 22 || _xsd_engineType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const engineType::
  _xsd_engineType_literals_[22] =
  {
    "SEQUEST",
    "MASCOT",
    "Comet",
    "SpectraST",
    "PROBID",
    "OMSSA",
    "YABSE",
    "MS-GFDB",
    "MS-GF+",
    "MyriMatch",
    "X! Tandem (k-score)",
    "X! Tandem",
    "InsPecT",
    "ProteinPilot",
    "ProteinLynx",
    "Spectrum Mill",
    "greylag",
    "Phenyx",
    "Proteios",
    "Crux",
    "Tide",
    "Kojak"
  };

  const engineType::value engineType::
  _xsd_engineType_indexes_[22] =
  {
    ::pepXML::engineType::Comet,
    ::pepXML::engineType::Crux,
    ::pepXML::engineType::InsPecT,
    ::pepXML::engineType::Kojak,
    ::pepXML::engineType::MASCOT,
    ::pepXML::engineType::MS_GF_,
    ::pepXML::engineType::MS_GFDB,
    ::pepXML::engineType::MyriMatch,
    ::pepXML::engineType::OMSSA,
    ::pepXML::engineType::PROBID,
    ::pepXML::engineType::Phenyx,
    ::pepXML::engineType::ProteinLynx,
    ::pepXML::engineType::ProteinPilot,
    ::pepXML::engineType::Proteios,
    ::pepXML::engineType::SEQUEST,
    ::pepXML::engineType::SpectraST,
    ::pepXML::engineType::Spectrum_Mill,
    ::pepXML::engineType::Tide,
    ::pepXML::engineType::X__Tandem,
    ::pepXML::engineType::X__Tandem__k_score_,
    ::pepXML::engineType::YABSE,
    ::pepXML::engineType::greylag
  };

  // activationMethodType
  //

  activationMethodType::
  activationMethodType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_activationMethodType_convert ();
  }

  activationMethodType::
  activationMethodType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_activationMethodType_convert ();
  }

  activationMethodType::
  activationMethodType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_activationMethodType_convert ();
  }

  activationMethodType* activationMethodType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class activationMethodType (*this, f, c);
  }

  activationMethodType::value activationMethodType::
  _xsd_activationMethodType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_activationMethodType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_activationMethodType_indexes_,
                      _xsd_activationMethodType_indexes_ + 7,
                      *this,
                      c));

    if (i == _xsd_activationMethodType_indexes_ + 7 || _xsd_activationMethodType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const activationMethodType::
  _xsd_activationMethodType_literals_[7] =
  {
    "ETD",
    "ECD",
    "CID",
    "ETD/CID",
    "HCD",
    "PQD",
    "IRMPD"
  };

  const activationMethodType::value activationMethodType::
  _xsd_activationMethodType_indexes_[7] =
  {
    ::pepXML::activationMethodType::CID,
    ::pepXML::activationMethodType::ECD,
    ::pepXML::activationMethodType::ETD,
    ::pepXML::activationMethodType::ETD_CID,
    ::pepXML::activationMethodType::HCD,
    ::pepXML::activationMethodType::IRMPD,
    ::pepXML::activationMethodType::PQD
  };

  // model_dis_type
  //

  model_dis_type::
  model_dis_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_model_dis_type_convert ();
  }

  model_dis_type::
  model_dis_type (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_model_dis_type_convert ();
  }

  model_dis_type::
  model_dis_type (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_model_dis_type_convert ();
  }

  model_dis_type* model_dis_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class model_dis_type (*this, f, c);
  }

  model_dis_type::value model_dis_type::
  _xsd_model_dis_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_model_dis_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_model_dis_type_indexes_,
                      _xsd_model_dis_type_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_model_dis_type_indexes_ + 6 || _xsd_model_dis_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const model_dis_type::
  _xsd_model_dis_type_literals_[6] =
  {
    "discrete",
    "gaussian",
    "extremevalue",
    "gamma",
    "evd",
    "non-parametric"
  };

  const model_dis_type::value model_dis_type::
  _xsd_model_dis_type_indexes_[6] =
  {
    ::pepXML::model_dis_type::discrete,
    ::pepXML::model_dis_type::evd,
    ::pepXML::model_dis_type::extremevalue,
    ::pepXML::model_dis_type::gamma,
    ::pepXML::model_dis_type::gaussian,
    ::pepXML::model_dis_type::non_parametric
  };

  // massType
  //

  massType::
  massType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_massType_convert ();
  }

  massType::
  massType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_massType_convert ();
  }

  massType::
  massType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_massType_convert ();
  }

  massType* massType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class massType (*this, f, c);
  }

  massType::value massType::
  _xsd_massType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_massType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_massType_indexes_,
                      _xsd_massType_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_massType_indexes_ + 2 || _xsd_massType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const massType::
  _xsd_massType_literals_[2] =
  {
    "monoisotopic",
    "average"
  };

  const massType::value massType::
  _xsd_massType_indexes_[2] =
  {
    ::pepXML::massType::average,
    ::pepXML::massType::monoisotopic
  };

  // aa_symbolType
  //

  aa_symbolType::
  aa_symbolType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_aa_symbolType_convert ();
  }

  aa_symbolType::
  aa_symbolType (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_aa_symbolType_convert ();
  }

  aa_symbolType::
  aa_symbolType (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_aa_symbolType_convert ();
  }

  aa_symbolType* aa_symbolType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class aa_symbolType (*this, f, c);
  }

  aa_symbolType::value aa_symbolType::
  _xsd_aa_symbolType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_aa_symbolType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_aa_symbolType_indexes_,
                      _xsd_aa_symbolType_indexes_ + 19,
                      *this,
                      c));

    if (i == _xsd_aa_symbolType_indexes_ + 19 || _xsd_aa_symbolType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const aa_symbolType::
  _xsd_aa_symbolType_literals_[19] =
  {
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "#",
    "@",
    "*",
    "~",
    "'",
    "''",
    "$",
    "!",
    "^",
    "?"
  };

  const aa_symbolType::value aa_symbolType::
  _xsd_aa_symbolType_indexes_[19] =
  {
    ::pepXML::aa_symbolType::cxx_15,
    ::pepXML::aa_symbolType::cxx_,
    ::pepXML::aa_symbolType::cxx_14,
    ::pepXML::aa_symbolType::cxx_13,
    ::pepXML::aa_symbolType::cxx__,
    ::pepXML::aa_symbolType::cxx_11,
    ::pepXML::aa_symbolType::cxx_1,
    ::pepXML::aa_symbolType::cxx_2,
    ::pepXML::aa_symbolType::cxx_3,
    ::pepXML::aa_symbolType::cxx_4,
    ::pepXML::aa_symbolType::cxx_5,
    ::pepXML::aa_symbolType::cxx_6,
    ::pepXML::aa_symbolType::cxx_7,
    ::pepXML::aa_symbolType::cxx_8,
    ::pepXML::aa_symbolType::cxx_9,
    ::pepXML::aa_symbolType::cxx_17,
    ::pepXML::aa_symbolType::cxx_10,
    ::pepXML::aa_symbolType::cxx_16,
    ::pepXML::aa_symbolType::cxx_12
  };

  // term_symbolType
  //

  term_symbolType::
  term_symbolType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_term_symbolType_convert ();
  }

  term_symbolType::
  term_symbolType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_term_symbolType_convert ();
  }

  term_symbolType::
  term_symbolType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_term_symbolType_convert ();
  }

  term_symbolType* term_symbolType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class term_symbolType (*this, f, c);
  }

  term_symbolType::value term_symbolType::
  _xsd_term_symbolType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_term_symbolType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_term_symbolType_indexes_,
                      _xsd_term_symbolType_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_term_symbolType_indexes_ + 4 || _xsd_term_symbolType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const term_symbolType::
  _xsd_term_symbolType_literals_[4] =
  {
    ",",
    ";",
    ":",
    "^"
  };

  const term_symbolType::value term_symbolType::
  _xsd_term_symbolType_indexes_[4] =
  {
    ::pepXML::term_symbolType::cxx_,
    ::pepXML::term_symbolType::cxx_2,
    ::pepXML::term_symbolType::cxx_1,
    ::pepXML::term_symbolType::cxx_3
  };

  // positiveInt
  //

  positiveInt::
  positiveInt ()
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > ()
  {
  }

  positiveInt::
  positiveInt (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (_xsd_unsigned_int_base)
  {
  }

  positiveInt::
  positiveInt (const positiveInt& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  positiveInt::
  positiveInt (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  positiveInt::
  positiveInt (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  positiveInt::
  positiveInt (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  positiveInt* positiveInt::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class positiveInt (*this, f, c);
  }

  positiveInt::
  ~positiveInt ()
  {
  }

  // nameValueType
  //

  nameValueType::
  nameValueType ()
  : ::xml_schema::simple_type (),
    name_ (this),
    value_ (this),
    type_ (this)
  {
  }

  nameValueType::
  nameValueType (const name_type& name,
                 const value_type& value)
  : ::xml_schema::simple_type (),
    name_ (name, this),
    value_ (value, this),
    type_ (this)
  {
  }

  nameValueType::
  nameValueType (const ::xml_schema::simple_type& _xsd_simple_type_base,
                 const name_type& name,
                 const value_type& value)
  : ::xml_schema::simple_type (_xsd_simple_type_base),
    name_ (name, this),
    value_ (value, this),
    type_ (this)
  {
  }

  nameValueType::
  nameValueType (const nameValueType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::simple_type (x, f, c),
    name_ (x.name_, f, this),
    value_ (x.value_, f, this),
    type_ (x.type_, f, this)
  {
  }

  nameValueType::
  nameValueType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    value_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void nameValueType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  nameValueType* nameValueType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class nameValueType (*this, f, c);
  }

  nameValueType& nameValueType::
  operator= (const nameValueType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::simple_type& > (*this) = x;
      this->name_ = x.name_;
      this->value_ = x.value_;
      this->type_ = x.type_;
    }

    return *this;
  }

  nameValueType::
  ~nameValueType ()
  {
  }

  // inputFileType
  //

  inputFileType::
  inputFileType ()
  : ::xml_schema::string (),
    name_ (this),
    directory_ (this)
  {
  }

  inputFileType::
  inputFileType (const name_type& name)
  : ::xml_schema::string (),
    name_ (name, this),
    directory_ (this)
  {
  }

  inputFileType::
  inputFileType (const char* _xsd_string_base,
                 const name_type& name)
  : ::xml_schema::string (_xsd_string_base),
    name_ (name, this),
    directory_ (this)
  {
  }

  inputFileType::
  inputFileType (const ::std::string& _xsd_string_base,
                 const name_type& name)
  : ::xml_schema::string (_xsd_string_base),
    name_ (name, this),
    directory_ (this)
  {
  }

  inputFileType::
  inputFileType (const ::xml_schema::string& _xsd_string_base,
                 const name_type& name)
  : ::xml_schema::string (_xsd_string_base),
    name_ (name, this),
    directory_ (this)
  {
  }

  inputFileType::
  inputFileType (const inputFileType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    name_ (x.name_, f, this),
    directory_ (x.directory_, f, this)
  {
  }

  inputFileType::
  inputFileType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    directory_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void inputFileType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "directory" && n.namespace_ ().empty ())
      {
        this->directory_.set (directory_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  inputFileType* inputFileType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class inputFileType (*this, f, c);
  }

  inputFileType& inputFileType::
  operator= (const inputFileType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->name_ = x.name_;
      this->directory_ = x.directory_;
    }

    return *this;
  }

  inputFileType::
  ~inputFileType ()
  {
  }

  // rocErrorDataType
  //

  rocErrorDataType::
  rocErrorDataType ()
  : ::xml_schema::type (),
    roc_data_point_ (this),
    error_point_ (this),
    charge_ (this),
    charge_est_correct_ (this)
  {
  }

  rocErrorDataType::
  rocErrorDataType (const charge_type& charge)
  : ::xml_schema::type (),
    roc_data_point_ (this),
    error_point_ (this),
    charge_ (charge, this),
    charge_est_correct_ (this)
  {
  }

  rocErrorDataType::
  rocErrorDataType (const rocErrorDataType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    roc_data_point_ (x.roc_data_point_, f, this),
    error_point_ (x.error_point_, f, this),
    charge_ (x.charge_, f, this),
    charge_est_correct_ (x.charge_est_correct_, f, this)
  {
  }

  rocErrorDataType::
  rocErrorDataType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    roc_data_point_ (this),
    error_point_ (this),
    charge_ (this),
    charge_est_correct_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void rocErrorDataType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // roc_data_point
      //
      if (n.name () == "roc_data_point" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< roc_data_point_type > r (
          roc_data_point_traits::create (i, f, this));

        this->roc_data_point_.push_back (::std::move (r));
        continue;
      }

      // error_point
      //
      if (n.name () == "error_point" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< error_point_type > r (
          error_point_traits::create (i, f, this));

        this->error_point_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "charge" && n.namespace_ ().empty ())
      {
        this->charge_.set (charge_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "charge_est_correct" && n.namespace_ ().empty ())
      {
        this->charge_est_correct_.set (charge_est_correct_traits::create (i, f, this));
        continue;
      }
    }

    if (!charge_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "charge",
        "");
    }
  }

  rocErrorDataType* rocErrorDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class rocErrorDataType (*this, f, c);
  }

  rocErrorDataType& rocErrorDataType::
  operator= (const rocErrorDataType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->roc_data_point_ = x.roc_data_point_;
      this->error_point_ = x.error_point_;
      this->charge_ = x.charge_;
      this->charge_est_correct_ = x.charge_est_correct_;
    }

    return *this;
  }

  rocErrorDataType::
  ~rocErrorDataType ()
  {
  }

  // mixtureModelType
  //

  mixtureModelType::
  mixtureModelType ()
  : ::xml_schema::type (),
    point_ (this),
    name_ (this),
    pos_bandwidth_ (this),
    neg_bandwidth_ (this)
  {
  }

  mixtureModelType::
  mixtureModelType (const name_type& name,
                    const pos_bandwidth_type& pos_bandwidth,
                    const neg_bandwidth_type& neg_bandwidth)
  : ::xml_schema::type (),
    point_ (this),
    name_ (name, this),
    pos_bandwidth_ (pos_bandwidth, this),
    neg_bandwidth_ (neg_bandwidth, this)
  {
  }

  mixtureModelType::
  mixtureModelType (const mixtureModelType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    point_ (x.point_, f, this),
    name_ (x.name_, f, this),
    pos_bandwidth_ (x.pos_bandwidth_, f, this),
    neg_bandwidth_ (x.neg_bandwidth_, f, this)
  {
  }

  mixtureModelType::
  mixtureModelType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    point_ (this),
    name_ (this),
    pos_bandwidth_ (this),
    neg_bandwidth_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void mixtureModelType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // point
      //
      if (n.name () == "point" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< point_type > r (
          point_traits::create (i, f, this));

        this->point_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "pos_bandwidth" && n.namespace_ ().empty ())
      {
        this->pos_bandwidth_.set (pos_bandwidth_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "neg_bandwidth" && n.namespace_ ().empty ())
      {
        this->neg_bandwidth_.set (neg_bandwidth_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!pos_bandwidth_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "pos_bandwidth",
        "");
    }

    if (!neg_bandwidth_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "neg_bandwidth",
        "");
    }
  }

  mixtureModelType* mixtureModelType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class mixtureModelType (*this, f, c);
  }

  mixtureModelType& mixtureModelType::
  operator= (const mixtureModelType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->point_ = x.point_;
      this->name_ = x.name_;
      this->pos_bandwidth_ = x.pos_bandwidth_;
      this->neg_bandwidth_ = x.neg_bandwidth_;
    }

    return *this;
  }

  mixtureModelType::
  ~mixtureModelType ()
  {
  }

  // modInfoDataType
  //

  modInfoDataType::
  modInfoDataType ()
  : ::xml_schema::type (),
    aminoacid_substitution_ (this),
    mod_aminoacid_mass_ (this),
    mod_nterm_mass_ (this),
    mod_cterm_mass_ (this),
    modified_peptide_ (this)
  {
  }

  modInfoDataType::
  modInfoDataType (const modInfoDataType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    aminoacid_substitution_ (x.aminoacid_substitution_, f, this),
    mod_aminoacid_mass_ (x.mod_aminoacid_mass_, f, this),
    mod_nterm_mass_ (x.mod_nterm_mass_, f, this),
    mod_cterm_mass_ (x.mod_cterm_mass_, f, this),
    modified_peptide_ (x.modified_peptide_, f, this)
  {
  }

  modInfoDataType::
  modInfoDataType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    aminoacid_substitution_ (this),
    mod_aminoacid_mass_ (this),
    mod_nterm_mass_ (this),
    mod_cterm_mass_ (this),
    modified_peptide_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void modInfoDataType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // aminoacid_substitution
      //
      if (n.name () == "aminoacid_substitution" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< aminoacid_substitution_type > r (
          aminoacid_substitution_traits::create (i, f, this));

        this->aminoacid_substitution_.push_back (::std::move (r));
        continue;
      }

      // mod_aminoacid_mass
      //
      if (n.name () == "mod_aminoacid_mass" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< mod_aminoacid_mass_type > r (
          mod_aminoacid_mass_traits::create (i, f, this));

        this->mod_aminoacid_mass_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "mod_nterm_mass" && n.namespace_ ().empty ())
      {
        this->mod_nterm_mass_.set (mod_nterm_mass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "mod_cterm_mass" && n.namespace_ ().empty ())
      {
        this->mod_cterm_mass_.set (mod_cterm_mass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "modified_peptide" && n.namespace_ ().empty ())
      {
        this->modified_peptide_.set (modified_peptide_traits::create (i, f, this));
        continue;
      }
    }
  }

  modInfoDataType* modInfoDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class modInfoDataType (*this, f, c);
  }

  modInfoDataType& modInfoDataType::
  operator= (const modInfoDataType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->aminoacid_substitution_ = x.aminoacid_substitution_;
      this->mod_aminoacid_mass_ = x.mod_aminoacid_mass_;
      this->mod_nterm_mass_ = x.mod_nterm_mass_;
      this->mod_cterm_mass_ = x.mod_cterm_mass_;
      this->modified_peptide_ = x.modified_peptide_;
    }

    return *this;
  }

  modInfoDataType::
  ~modInfoDataType ()
  {
  }

  // subInfoDataType
  //

  subInfoDataType::
  subInfoDataType ()
  : ::xml_schema::type (),
    position_ (this),
    orig_aa_ (this),
    num_tol_term_ (this),
    peptide_prev_aa_ (this),
    peptide_next_aa_ (this)
  {
  }

  subInfoDataType::
  subInfoDataType (const subInfoDataType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    position_ (x.position_, f, this),
    orig_aa_ (x.orig_aa_, f, this),
    num_tol_term_ (x.num_tol_term_, f, this),
    peptide_prev_aa_ (x.peptide_prev_aa_, f, this),
    peptide_next_aa_ (x.peptide_next_aa_, f, this)
  {
  }

  subInfoDataType::
  subInfoDataType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    position_ (this),
    orig_aa_ (this),
    num_tol_term_ (this),
    peptide_prev_aa_ (this),
    peptide_next_aa_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void subInfoDataType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "position" && n.namespace_ ().empty ())
      {
        this->position_.set (position_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "orig_aa" && n.namespace_ ().empty ())
      {
        this->orig_aa_.set (orig_aa_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "num_tol_term" && n.namespace_ ().empty ())
      {
        this->num_tol_term_.set (num_tol_term_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "peptide_prev_aa" && n.namespace_ ().empty ())
      {
        this->peptide_prev_aa_.set (peptide_prev_aa_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "peptide_next_aa" && n.namespace_ ().empty ())
      {
        this->peptide_next_aa_.set (peptide_next_aa_traits::create (i, f, this));
        continue;
      }
    }
  }

  subInfoDataType* subInfoDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class subInfoDataType (*this, f, c);
  }

  subInfoDataType& subInfoDataType::
  operator= (const subInfoDataType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->position_ = x.position_;
      this->orig_aa_ = x.orig_aa_;
      this->num_tol_term_ = x.num_tol_term_;
      this->peptide_prev_aa_ = x.peptide_prev_aa_;
      this->peptide_next_aa_ = x.peptide_next_aa_;
    }

    return *this;
  }

  subInfoDataType::
  ~subInfoDataType ()
  {
  }

  // altProteinDataType
  //

  altProteinDataType::
  altProteinDataType ()
  : ::xml_schema::type (),
    aminoacid_substitution_ (this),
    protein_ (this),
    protein_descr_ (this),
    num_tol_term_ (this),
    protein_mw_ (this),
    peptide_prev_aa_ (this),
    peptide_next_aa_ (this)
  {
  }

  altProteinDataType::
  altProteinDataType (const protein_type& protein)
  : ::xml_schema::type (),
    aminoacid_substitution_ (this),
    protein_ (protein, this),
    protein_descr_ (this),
    num_tol_term_ (this),
    protein_mw_ (this),
    peptide_prev_aa_ (this),
    peptide_next_aa_ (this)
  {
  }

  altProteinDataType::
  altProteinDataType (const altProteinDataType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    aminoacid_substitution_ (x.aminoacid_substitution_, f, this),
    protein_ (x.protein_, f, this),
    protein_descr_ (x.protein_descr_, f, this),
    num_tol_term_ (x.num_tol_term_, f, this),
    protein_mw_ (x.protein_mw_, f, this),
    peptide_prev_aa_ (x.peptide_prev_aa_, f, this),
    peptide_next_aa_ (x.peptide_next_aa_, f, this)
  {
  }

  altProteinDataType::
  altProteinDataType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    aminoacid_substitution_ (this),
    protein_ (this),
    protein_descr_ (this),
    num_tol_term_ (this),
    protein_mw_ (this),
    peptide_prev_aa_ (this),
    peptide_next_aa_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void altProteinDataType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // aminoacid_substitution
      //
      if (n.name () == "aminoacid_substitution" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< aminoacid_substitution_type > r (
          aminoacid_substitution_traits::create (i, f, this));

        this->aminoacid_substitution_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "protein" && n.namespace_ ().empty ())
      {
        this->protein_.set (protein_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "protein_descr" && n.namespace_ ().empty ())
      {
        this->protein_descr_.set (protein_descr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "num_tol_term" && n.namespace_ ().empty ())
      {
        this->num_tol_term_.set (num_tol_term_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "protein_mw" && n.namespace_ ().empty ())
      {
        this->protein_mw_.set (protein_mw_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "peptide_prev_aa" && n.namespace_ ().empty ())
      {
        this->peptide_prev_aa_.set (peptide_prev_aa_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "peptide_next_aa" && n.namespace_ ().empty ())
      {
        this->peptide_next_aa_.set (peptide_next_aa_traits::create (i, f, this));
        continue;
      }
    }

    if (!protein_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "protein",
        "");
    }
  }

  altProteinDataType* altProteinDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class altProteinDataType (*this, f, c);
  }

  altProteinDataType& altProteinDataType::
  operator= (const altProteinDataType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->aminoacid_substitution_ = x.aminoacid_substitution_;
      this->protein_ = x.protein_;
      this->protein_descr_ = x.protein_descr_;
      this->num_tol_term_ = x.num_tol_term_;
      this->protein_mw_ = x.protein_mw_;
      this->peptide_prev_aa_ = x.peptide_prev_aa_;
      this->peptide_next_aa_ = x.peptide_next_aa_;
    }

    return *this;
  }

  altProteinDataType::
  ~altProteinDataType ()
  {
  }

  // msms_pipeline_analysis
  //

  msms_pipeline_analysis::
  msms_pipeline_analysis ()
  : ::xml_schema::type (),
    analysis_summary_ (this),
    dataset_derivation_ (this),
    msms_run_summary_ (this),
    name_ (this),
    date_ (this),
    summary_xml_ (this)
  {
  }

  msms_pipeline_analysis::
  msms_pipeline_analysis (const date_type& date,
                          const summary_xml_type& summary_xml)
  : ::xml_schema::type (),
    analysis_summary_ (this),
    dataset_derivation_ (this),
    msms_run_summary_ (this),
    name_ (this),
    date_ (date, this),
    summary_xml_ (summary_xml, this)
  {
  }

  msms_pipeline_analysis::
  msms_pipeline_analysis (const msms_pipeline_analysis& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    analysis_summary_ (x.analysis_summary_, f, this),
    dataset_derivation_ (x.dataset_derivation_, f, this),
    msms_run_summary_ (x.msms_run_summary_, f, this),
    name_ (x.name_, f, this),
    date_ (x.date_, f, this),
    summary_xml_ (x.summary_xml_, f, this)
  {
  }

  msms_pipeline_analysis::
  msms_pipeline_analysis (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    analysis_summary_ (this),
    dataset_derivation_ (this),
    msms_run_summary_ (this),
    name_ (this),
    date_ (this),
    summary_xml_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void msms_pipeline_analysis::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // analysis_summary
      //
      if (n.name () == "analysis_summary" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< analysis_summary_type > r (
          analysis_summary_traits::create (i, f, this));

        this->analysis_summary_.push_back (::std::move (r));
        continue;
      }

      // dataset_derivation
      //
      if (n.name () == "dataset_derivation" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< dataset_derivation_type > r (
          dataset_derivation_traits::create (i, f, this));

        if (!this->dataset_derivation_)
        {
          this->dataset_derivation_.set (::std::move (r));
          continue;
        }
      }

      // msms_run_summary
      //
      if (n.name () == "msms_run_summary" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< msms_run_summary_type > r (
          msms_run_summary_traits::create (i, f, this));

        this->msms_run_summary_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "date" && n.namespace_ ().empty ())
      {
        this->date_.set (date_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "summary_xml" && n.namespace_ ().empty ())
      {
        this->summary_xml_.set (summary_xml_traits::create (i, f, this));
        continue;
      }
    }

    if (!date_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "date",
        "");
    }

    if (!summary_xml_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "summary_xml",
        "");
    }
  }

  msms_pipeline_analysis* msms_pipeline_analysis::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class msms_pipeline_analysis (*this, f, c);
  }

  msms_pipeline_analysis& msms_pipeline_analysis::
  operator= (const msms_pipeline_analysis& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->analysis_summary_ = x.analysis_summary_;
      this->dataset_derivation_ = x.dataset_derivation_;
      this->msms_run_summary_ = x.msms_run_summary_;
      this->name_ = x.name_;
      this->date_ = x.date_;
      this->summary_xml_ = x.summary_xml_;
    }

    return *this;
  }

  msms_pipeline_analysis::
  ~msms_pipeline_analysis ()
  {
  }

  // peptideprophet_summary
  //

  peptideprophet_summary::
  peptideprophet_summary ()
  : ::xml_schema::type (),
    inputfile_ (this),
    roc_error_data_ (this),
    distribution_point_ (this),
    mixture_model_ (this),
    version_ (this),
    author_ (this),
    min_prob_ (this),
    options_ (this),
    est_tot_num_correct_ (this)
  {
  }

  peptideprophet_summary::
  peptideprophet_summary (const version_type& version,
                          const author_type& author,
                          const min_prob_type& min_prob)
  : ::xml_schema::type (),
    inputfile_ (this),
    roc_error_data_ (this),
    distribution_point_ (this),
    mixture_model_ (this),
    version_ (version, this),
    author_ (author, this),
    min_prob_ (min_prob, this),
    options_ (this),
    est_tot_num_correct_ (this)
  {
  }

  peptideprophet_summary::
  peptideprophet_summary (const peptideprophet_summary& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    inputfile_ (x.inputfile_, f, this),
    roc_error_data_ (x.roc_error_data_, f, this),
    distribution_point_ (x.distribution_point_, f, this),
    mixture_model_ (x.mixture_model_, f, this),
    version_ (x.version_, f, this),
    author_ (x.author_, f, this),
    min_prob_ (x.min_prob_, f, this),
    options_ (x.options_, f, this),
    est_tot_num_correct_ (x.est_tot_num_correct_, f, this)
  {
  }

  peptideprophet_summary::
  peptideprophet_summary (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    inputfile_ (this),
    roc_error_data_ (this),
    distribution_point_ (this),
    mixture_model_ (this),
    version_ (this),
    author_ (this),
    min_prob_ (this),
    options_ (this),
    est_tot_num_correct_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void peptideprophet_summary::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // inputfile
      //
      if (n.name () == "inputfile" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< inputfile_type > r (
          inputfile_traits::create (i, f, this));

        this->inputfile_.push_back (::std::move (r));
        continue;
      }

      // roc_error_data
      //
      if (n.name () == "roc_error_data" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< roc_error_data_type > r (
          roc_error_data_traits::create (i, f, this));

        this->roc_error_data_.push_back (::std::move (r));
        continue;
      }

      // distribution_point
      //
      if (n.name () == "distribution_point" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< distribution_point_type > r (
          distribution_point_traits::create (i, f, this));

        this->distribution_point_.push_back (::std::move (r));
        continue;
      }

      // mixture_model
      //
      if (n.name () == "mixture_model" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< mixture_model_type > r (
          mixture_model_traits::create (i, f, this));

        this->mixture_model_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        this->version_.set (version_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "author" && n.namespace_ ().empty ())
      {
        this->author_.set (author_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "min_prob" && n.namespace_ ().empty ())
      {
        this->min_prob_.set (min_prob_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "options" && n.namespace_ ().empty ())
      {
        this->options_.set (options_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "est_tot_num_correct" && n.namespace_ ().empty ())
      {
        this->est_tot_num_correct_.set (est_tot_num_correct_traits::create (i, f, this));
        continue;
      }
    }

    if (!version_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "version",
        "");
    }

    if (!author_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "author",
        "");
    }

    if (!min_prob_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "min_prob",
        "");
    }
  }

  peptideprophet_summary* peptideprophet_summary::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class peptideprophet_summary (*this, f, c);
  }

  peptideprophet_summary& peptideprophet_summary::
  operator= (const peptideprophet_summary& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->inputfile_ = x.inputfile_;
      this->roc_error_data_ = x.roc_error_data_;
      this->distribution_point_ = x.distribution_point_;
      this->mixture_model_ = x.mixture_model_;
      this->version_ = x.version_;
      this->author_ = x.author_;
      this->min_prob_ = x.min_prob_;
      this->options_ = x.options_;
      this->est_tot_num_correct_ = x.est_tot_num_correct_;
    }

    return *this;
  }

  peptideprophet_summary::
  ~peptideprophet_summary ()
  {
  }

  // interprophet_summary
  //

  interprophet_summary::
  interprophet_summary ()
  : ::xml_schema::type (),
    inputfile_ (this),
    roc_error_data_ (this),
    mixturemodel_ (this),
    version_ (this),
    options_ (this),
    est_tot_num_correct_psm_ (this),
    est_tot_num_correct_pep_ (this)
  {
  }

  interprophet_summary::
  interprophet_summary (const version_type& version)
  : ::xml_schema::type (),
    inputfile_ (this),
    roc_error_data_ (this),
    mixturemodel_ (this),
    version_ (version, this),
    options_ (this),
    est_tot_num_correct_psm_ (this),
    est_tot_num_correct_pep_ (this)
  {
  }

  interprophet_summary::
  interprophet_summary (const interprophet_summary& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    inputfile_ (x.inputfile_, f, this),
    roc_error_data_ (x.roc_error_data_, f, this),
    mixturemodel_ (x.mixturemodel_, f, this),
    version_ (x.version_, f, this),
    options_ (x.options_, f, this),
    est_tot_num_correct_psm_ (x.est_tot_num_correct_psm_, f, this),
    est_tot_num_correct_pep_ (x.est_tot_num_correct_pep_, f, this)
  {
  }

  interprophet_summary::
  interprophet_summary (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    inputfile_ (this),
    roc_error_data_ (this),
    mixturemodel_ (this),
    version_ (this),
    options_ (this),
    est_tot_num_correct_psm_ (this),
    est_tot_num_correct_pep_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void interprophet_summary::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // inputfile
      //
      if (n.name () == "inputfile" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< inputfile_type > r (
          inputfile_traits::create (i, f, this));

        this->inputfile_.push_back (::std::move (r));
        continue;
      }

      // roc_error_data
      //
      if (n.name () == "roc_error_data" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< roc_error_data_type > r (
          roc_error_data_traits::create (i, f, this));

        this->roc_error_data_.push_back (::std::move (r));
        continue;
      }

      // mixturemodel
      //
      if (n.name () == "mixturemodel" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< mixturemodel_type > r (
          mixturemodel_traits::create (i, f, this));

        this->mixturemodel_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        this->version_.set (version_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "options" && n.namespace_ ().empty ())
      {
        this->options_.set (options_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "est_tot_num_correct_psm" && n.namespace_ ().empty ())
      {
        this->est_tot_num_correct_psm_.set (est_tot_num_correct_psm_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "est_tot_num_correct_pep" && n.namespace_ ().empty ())
      {
        this->est_tot_num_correct_pep_.set (est_tot_num_correct_pep_traits::create (i, f, this));
        continue;
      }
    }

    if (!version_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "version",
        "");
    }
  }

  interprophet_summary* interprophet_summary::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class interprophet_summary (*this, f, c);
  }

  interprophet_summary& interprophet_summary::
  operator= (const interprophet_summary& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->inputfile_ = x.inputfile_;
      this->roc_error_data_ = x.roc_error_data_;
      this->mixturemodel_ = x.mixturemodel_;
      this->version_ = x.version_;
      this->options_ = x.options_;
      this->est_tot_num_correct_psm_ = x.est_tot_num_correct_psm_;
      this->est_tot_num_correct_pep_ = x.est_tot_num_correct_pep_;
    }

    return *this;
  }

  interprophet_summary::
  ~interprophet_summary ()
  {
  }

  // ptmprophet_summary
  //

  ptmprophet_summary::
  ptmprophet_summary ()
  : ::xml_schema::type (),
    inputfile_ (this),
    mixturemodel_ (this),
    version_ (this),
    options_ (this)
  {
  }

  ptmprophet_summary::
  ptmprophet_summary (const version_type& version)
  : ::xml_schema::type (),
    inputfile_ (this),
    mixturemodel_ (this),
    version_ (version, this),
    options_ (this)
  {
  }

  ptmprophet_summary::
  ptmprophet_summary (const ptmprophet_summary& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    inputfile_ (x.inputfile_, f, this),
    mixturemodel_ (x.mixturemodel_, f, this),
    version_ (x.version_, f, this),
    options_ (x.options_, f, this)
  {
  }

  ptmprophet_summary::
  ptmprophet_summary (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    inputfile_ (this),
    mixturemodel_ (this),
    version_ (this),
    options_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ptmprophet_summary::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // inputfile
      //
      if (n.name () == "inputfile" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< inputfile_type > r (
          inputfile_traits::create (i, f, this));

        this->inputfile_.push_back (::std::move (r));
        continue;
      }

      // mixturemodel
      //
      if (n.name () == "mixturemodel" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< mixturemodel_type > r (
          mixturemodel_traits::create (i, f, this));

        this->mixturemodel_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        this->version_.set (version_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "options" && n.namespace_ ().empty ())
      {
        this->options_.set (options_traits::create (i, f, this));
        continue;
      }
    }

    if (!version_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "version",
        "");
    }
  }

  ptmprophet_summary* ptmprophet_summary::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ptmprophet_summary (*this, f, c);
  }

  ptmprophet_summary& ptmprophet_summary::
  operator= (const ptmprophet_summary& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->inputfile_ = x.inputfile_;
      this->mixturemodel_ = x.mixturemodel_;
      this->version_ = x.version_;
      this->options_ = x.options_;
    }

    return *this;
  }

  ptmprophet_summary::
  ~ptmprophet_summary ()
  {
  }

  // asapratio_summary
  //

  asapratio_summary::
  asapratio_summary ()
  : ::xml_schema::type (),
    version_ (this),
    author_ (this),
    elution_ (this),
    labeled_residues_ (this),
    area_flag_ (this),
    static_quant_ (this),
    specified_residue_masses_ (this)
  {
  }

  asapratio_summary::
  asapratio_summary (const version_type& version,
                     const author_type& author,
                     const elution_type& elution,
                     const labeled_residues_type& labeled_residues,
                     const area_flag_type& area_flag,
                     const static_quant_type& static_quant)
  : ::xml_schema::type (),
    version_ (version, this),
    author_ (author, this),
    elution_ (elution, this),
    labeled_residues_ (labeled_residues, this),
    area_flag_ (area_flag, this),
    static_quant_ (static_quant, this),
    specified_residue_masses_ (this)
  {
  }

  asapratio_summary::
  asapratio_summary (const asapratio_summary& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    version_ (x.version_, f, this),
    author_ (x.author_, f, this),
    elution_ (x.elution_, f, this),
    labeled_residues_ (x.labeled_residues_, f, this),
    area_flag_ (x.area_flag_, f, this),
    static_quant_ (x.static_quant_, f, this),
    specified_residue_masses_ (x.specified_residue_masses_, f, this)
  {
  }

  asapratio_summary::
  asapratio_summary (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    version_ (this),
    author_ (this),
    elution_ (this),
    labeled_residues_ (this),
    area_flag_ (this),
    static_quant_ (this),
    specified_residue_masses_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void asapratio_summary::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        this->version_.set (version_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "author" && n.namespace_ ().empty ())
      {
        this->author_.set (author_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "elution" && n.namespace_ ().empty ())
      {
        this->elution_.set (elution_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "labeled_residues" && n.namespace_ ().empty ())
      {
        this->labeled_residues_.set (labeled_residues_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "area_flag" && n.namespace_ ().empty ())
      {
        this->area_flag_.set (area_flag_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "static_quant" && n.namespace_ ().empty ())
      {
        this->static_quant_.set (static_quant_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "specified_residue_masses" && n.namespace_ ().empty ())
      {
        this->specified_residue_masses_.set (specified_residue_masses_traits::create (i, f, this));
        continue;
      }
    }

    if (!version_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "version",
        "");
    }

    if (!author_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "author",
        "");
    }

    if (!elution_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "elution",
        "");
    }

    if (!labeled_residues_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "labeled_residues",
        "");
    }

    if (!area_flag_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "area_flag",
        "");
    }

    if (!static_quant_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "static_quant",
        "");
    }
  }

  asapratio_summary* asapratio_summary::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class asapratio_summary (*this, f, c);
  }

  asapratio_summary& asapratio_summary::
  operator= (const asapratio_summary& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->version_ = x.version_;
      this->author_ = x.author_;
      this->elution_ = x.elution_;
      this->labeled_residues_ = x.labeled_residues_;
      this->area_flag_ = x.area_flag_;
      this->static_quant_ = x.static_quant_;
      this->specified_residue_masses_ = x.specified_residue_masses_;
    }

    return *this;
  }

  asapratio_summary::
  ~asapratio_summary ()
  {
  }

  // xpressratio_summary
  //

  xpressratio_summary::
  xpressratio_summary ()
  : ::xml_schema::type (),
    version_ (this),
    author_ (this),
    same_scan_range_ (this),
    labeled_residues_ (this),
    xpress_light_ (this),
    massdiff_ (this),
    masstol_ (this),
    ppmtol_ (this),
    min_num_chromatogram_points_ (this),
    min_num_isotope_peaks_ (this)
  {
  }

  xpressratio_summary::
  xpressratio_summary (const version_type& version,
                       const author_type& author,
                       const same_scan_range_type& same_scan_range,
                       const labeled_residues_type& labeled_residues,
                       const xpress_light_type& xpress_light,
                       const massdiff_type& massdiff,
                       const masstol_type& masstol,
                       const ppmtol_type& ppmtol,
                       const min_num_chromatogram_points_type& min_num_chromatogram_points,
                       const min_num_isotope_peaks_type& min_num_isotope_peaks)
  : ::xml_schema::type (),
    version_ (version, this),
    author_ (author, this),
    same_scan_range_ (same_scan_range, this),
    labeled_residues_ (labeled_residues, this),
    xpress_light_ (xpress_light, this),
    massdiff_ (massdiff, this),
    masstol_ (masstol, this),
    ppmtol_ (ppmtol, this),
    min_num_chromatogram_points_ (min_num_chromatogram_points, this),
    min_num_isotope_peaks_ (min_num_isotope_peaks, this)
  {
  }

  xpressratio_summary::
  xpressratio_summary (const xpressratio_summary& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    version_ (x.version_, f, this),
    author_ (x.author_, f, this),
    same_scan_range_ (x.same_scan_range_, f, this),
    labeled_residues_ (x.labeled_residues_, f, this),
    xpress_light_ (x.xpress_light_, f, this),
    massdiff_ (x.massdiff_, f, this),
    masstol_ (x.masstol_, f, this),
    ppmtol_ (x.ppmtol_, f, this),
    min_num_chromatogram_points_ (x.min_num_chromatogram_points_, f, this),
    min_num_isotope_peaks_ (x.min_num_isotope_peaks_, f, this)
  {
  }

  xpressratio_summary::
  xpressratio_summary (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    version_ (this),
    author_ (this),
    same_scan_range_ (this),
    labeled_residues_ (this),
    xpress_light_ (this),
    massdiff_ (this),
    masstol_ (this),
    ppmtol_ (this),
    min_num_chromatogram_points_ (this),
    min_num_isotope_peaks_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void xpressratio_summary::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        this->version_.set (version_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "author" && n.namespace_ ().empty ())
      {
        this->author_.set (author_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "same_scan_range" && n.namespace_ ().empty ())
      {
        this->same_scan_range_.set (same_scan_range_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "labeled_residues" && n.namespace_ ().empty ())
      {
        this->labeled_residues_.set (labeled_residues_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "xpress_light" && n.namespace_ ().empty ())
      {
        this->xpress_light_.set (xpress_light_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "massdiff" && n.namespace_ ().empty ())
      {
        this->massdiff_.set (massdiff_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "masstol" && n.namespace_ ().empty ())
      {
        this->masstol_.set (masstol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ppmtol" && n.namespace_ ().empty ())
      {
        this->ppmtol_.set (ppmtol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "min_num_chromatogram_points" && n.namespace_ ().empty ())
      {
        this->min_num_chromatogram_points_.set (min_num_chromatogram_points_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "min_num_isotope_peaks" && n.namespace_ ().empty ())
      {
        this->min_num_isotope_peaks_.set (min_num_isotope_peaks_traits::create (i, f, this));
        continue;
      }
    }

    if (!version_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "version",
        "");
    }

    if (!author_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "author",
        "");
    }

    if (!same_scan_range_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "same_scan_range",
        "");
    }

    if (!labeled_residues_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "labeled_residues",
        "");
    }

    if (!xpress_light_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "xpress_light",
        "");
    }

    if (!massdiff_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "massdiff",
        "");
    }

    if (!masstol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "masstol",
        "");
    }

    if (!ppmtol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ppmtol",
        "");
    }

    if (!min_num_chromatogram_points_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "min_num_chromatogram_points",
        "");
    }

    if (!min_num_isotope_peaks_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "min_num_isotope_peaks",
        "");
    }
  }

  xpressratio_summary* xpressratio_summary::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class xpressratio_summary (*this, f, c);
  }

  xpressratio_summary& xpressratio_summary::
  operator= (const xpressratio_summary& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->version_ = x.version_;
      this->author_ = x.author_;
      this->same_scan_range_ = x.same_scan_range_;
      this->labeled_residues_ = x.labeled_residues_;
      this->xpress_light_ = x.xpress_light_;
      this->massdiff_ = x.massdiff_;
      this->masstol_ = x.masstol_;
      this->ppmtol_ = x.ppmtol_;
      this->min_num_chromatogram_points_ = x.min_num_chromatogram_points_;
      this->min_num_isotope_peaks_ = x.min_num_isotope_peaks_;
    }

    return *this;
  }

  xpressratio_summary::
  ~xpressratio_summary ()
  {
  }

  // ptmprophet_result
  //

  ptmprophet_result::
  ptmprophet_result ()
  : ::xml_schema::type (),
    mod_aminoacid_probability_ (this),
    prior_ (this),
    ptm_ (this),
    ptm_peptide_ (this)
  {
  }

  ptmprophet_result::
  ptmprophet_result (const prior_type& prior,
                     const ptm_type& ptm,
                     const ptm_peptide_type& ptm_peptide)
  : ::xml_schema::type (),
    mod_aminoacid_probability_ (this),
    prior_ (prior, this),
    ptm_ (ptm, this),
    ptm_peptide_ (ptm_peptide, this)
  {
  }

  ptmprophet_result::
  ptmprophet_result (const ptmprophet_result& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    mod_aminoacid_probability_ (x.mod_aminoacid_probability_, f, this),
    prior_ (x.prior_, f, this),
    ptm_ (x.ptm_, f, this),
    ptm_peptide_ (x.ptm_peptide_, f, this)
  {
  }

  ptmprophet_result::
  ptmprophet_result (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    mod_aminoacid_probability_ (this),
    prior_ (this),
    ptm_ (this),
    ptm_peptide_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ptmprophet_result::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // mod_aminoacid_probability
      //
      if (n.name () == "mod_aminoacid_probability" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< mod_aminoacid_probability_type > r (
          mod_aminoacid_probability_traits::create (i, f, this));

        this->mod_aminoacid_probability_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "prior" && n.namespace_ ().empty ())
      {
        this->prior_.set (prior_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ptm" && n.namespace_ ().empty ())
      {
        this->ptm_.set (ptm_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ptm_peptide" && n.namespace_ ().empty ())
      {
        this->ptm_peptide_.set (ptm_peptide_traits::create (i, f, this));
        continue;
      }
    }

    if (!prior_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "prior",
        "");
    }

    if (!ptm_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ptm",
        "");
    }

    if (!ptm_peptide_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ptm_peptide",
        "");
    }
  }

  ptmprophet_result* ptmprophet_result::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ptmprophet_result (*this, f, c);
  }

  ptmprophet_result& ptmprophet_result::
  operator= (const ptmprophet_result& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->mod_aminoacid_probability_ = x.mod_aminoacid_probability_;
      this->prior_ = x.prior_;
      this->ptm_ = x.ptm_;
      this->ptm_peptide_ = x.ptm_peptide_;
    }

    return *this;
  }

  ptmprophet_result::
  ~ptmprophet_result ()
  {
  }

  // peptideprophet_result
  //

  peptideprophet_result::
  peptideprophet_result ()
  : ::xml_schema::type (),
    search_score_summary_ (this),
    probability_ (this),
    all_ntt_prob_ (this),
    analysis_ (this)
  {
  }

  peptideprophet_result::
  peptideprophet_result (const probability_type& probability)
  : ::xml_schema::type (),
    search_score_summary_ (this),
    probability_ (probability, this),
    all_ntt_prob_ (this),
    analysis_ (this)
  {
  }

  peptideprophet_result::
  peptideprophet_result (const peptideprophet_result& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    search_score_summary_ (x.search_score_summary_, f, this),
    probability_ (x.probability_, f, this),
    all_ntt_prob_ (x.all_ntt_prob_, f, this),
    analysis_ (x.analysis_, f, this)
  {
  }

  peptideprophet_result::
  peptideprophet_result (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    search_score_summary_ (this),
    probability_ (this),
    all_ntt_prob_ (this),
    analysis_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void peptideprophet_result::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // search_score_summary
      //
      if (n.name () == "search_score_summary" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< search_score_summary_type > r (
          search_score_summary_traits::create (i, f, this));

        if (!this->search_score_summary_)
        {
          this->search_score_summary_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "probability" && n.namespace_ ().empty ())
      {
        this->probability_.set (probability_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "all_ntt_prob" && n.namespace_ ().empty ())
      {
        this->all_ntt_prob_.set (all_ntt_prob_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "analysis" && n.namespace_ ().empty ())
      {
        this->analysis_.set (analysis_traits::create (i, f, this));
        continue;
      }
    }

    if (!probability_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "probability",
        "");
    }
  }

  peptideprophet_result* peptideprophet_result::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class peptideprophet_result (*this, f, c);
  }

  peptideprophet_result& peptideprophet_result::
  operator= (const peptideprophet_result& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->search_score_summary_ = x.search_score_summary_;
      this->probability_ = x.probability_;
      this->all_ntt_prob_ = x.all_ntt_prob_;
      this->analysis_ = x.analysis_;
    }

    return *this;
  }

  peptideprophet_result::
  ~peptideprophet_result ()
  {
  }

  // interprophet_result
  //

  interprophet_result::
  interprophet_result ()
  : ::xml_schema::type (),
    search_score_summary_ (this),
    probability_ (this),
    all_ntt_prob_ (this)
  {
  }

  interprophet_result::
  interprophet_result (const probability_type& probability)
  : ::xml_schema::type (),
    search_score_summary_ (this),
    probability_ (probability, this),
    all_ntt_prob_ (this)
  {
  }

  interprophet_result::
  interprophet_result (const interprophet_result& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    search_score_summary_ (x.search_score_summary_, f, this),
    probability_ (x.probability_, f, this),
    all_ntt_prob_ (x.all_ntt_prob_, f, this)
  {
  }

  interprophet_result::
  interprophet_result (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    search_score_summary_ (this),
    probability_ (this),
    all_ntt_prob_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void interprophet_result::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // search_score_summary
      //
      if (n.name () == "search_score_summary" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< search_score_summary_type > r (
          search_score_summary_traits::create (i, f, this));

        if (!this->search_score_summary_)
        {
          this->search_score_summary_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "probability" && n.namespace_ ().empty ())
      {
        this->probability_.set (probability_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "all_ntt_prob" && n.namespace_ ().empty ())
      {
        this->all_ntt_prob_.set (all_ntt_prob_traits::create (i, f, this));
        continue;
      }
    }

    if (!probability_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "probability",
        "");
    }
  }

  interprophet_result* interprophet_result::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class interprophet_result (*this, f, c);
  }

  interprophet_result& interprophet_result::
  operator= (const interprophet_result& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->search_score_summary_ = x.search_score_summary_;
      this->probability_ = x.probability_;
      this->all_ntt_prob_ = x.all_ntt_prob_;
    }

    return *this;
  }

  interprophet_result::
  ~interprophet_result ()
  {
  }

  // asapratio_result
  //

  asapratio_result::
  asapratio_result ()
  : ::xml_schema::type (),
    asapratio_peptide_data_ (this),
    mean_ (this),
    error_ (this),
    heavy2light_mean_ (this),
    heavy2light_error_ (this)
  {
  }

  asapratio_result::
  asapratio_result (const asapratio_peptide_data_type& asapratio_peptide_data,
                    const mean_type& mean,
                    const error_type& error,
                    const heavy2light_mean_type& heavy2light_mean,
                    const heavy2light_error_type& heavy2light_error)
  : ::xml_schema::type (),
    asapratio_peptide_data_ (asapratio_peptide_data, this),
    mean_ (mean, this),
    error_ (error, this),
    heavy2light_mean_ (heavy2light_mean, this),
    heavy2light_error_ (heavy2light_error, this)
  {
  }

  asapratio_result::
  asapratio_result (::std::unique_ptr< asapratio_peptide_data_type > asapratio_peptide_data,
                    const mean_type& mean,
                    const error_type& error,
                    const heavy2light_mean_type& heavy2light_mean,
                    const heavy2light_error_type& heavy2light_error)
  : ::xml_schema::type (),
    asapratio_peptide_data_ (std::move (asapratio_peptide_data), this),
    mean_ (mean, this),
    error_ (error, this),
    heavy2light_mean_ (heavy2light_mean, this),
    heavy2light_error_ (heavy2light_error, this)
  {
  }

  asapratio_result::
  asapratio_result (const asapratio_result& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    asapratio_peptide_data_ (x.asapratio_peptide_data_, f, this),
    mean_ (x.mean_, f, this),
    error_ (x.error_, f, this),
    heavy2light_mean_ (x.heavy2light_mean_, f, this),
    heavy2light_error_ (x.heavy2light_error_, f, this)
  {
  }

  asapratio_result::
  asapratio_result (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    asapratio_peptide_data_ (this),
    mean_ (this),
    error_ (this),
    heavy2light_mean_ (this),
    heavy2light_error_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void asapratio_result::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // asapratio_peptide_data
      //
      if (n.name () == "asapratio_peptide_data" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< asapratio_peptide_data_type > r (
          asapratio_peptide_data_traits::create (i, f, this));

        if (!asapratio_peptide_data_.present ())
        {
          this->asapratio_peptide_data_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!asapratio_peptide_data_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "asapratio_peptide_data",
        "http://regis-web.systemsbiology.net/pepXML");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "mean" && n.namespace_ ().empty ())
      {
        this->mean_.set (mean_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "error" && n.namespace_ ().empty ())
      {
        this->error_.set (error_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "heavy2light_mean" && n.namespace_ ().empty ())
      {
        this->heavy2light_mean_.set (heavy2light_mean_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "heavy2light_error" && n.namespace_ ().empty ())
      {
        this->heavy2light_error_.set (heavy2light_error_traits::create (i, f, this));
        continue;
      }
    }

    if (!mean_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mean",
        "");
    }

    if (!error_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "error",
        "");
    }

    if (!heavy2light_mean_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "heavy2light_mean",
        "");
    }

    if (!heavy2light_error_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "heavy2light_error",
        "");
    }
  }

  asapratio_result* asapratio_result::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class asapratio_result (*this, f, c);
  }

  asapratio_result& asapratio_result::
  operator= (const asapratio_result& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->asapratio_peptide_data_ = x.asapratio_peptide_data_;
      this->mean_ = x.mean_;
      this->error_ = x.error_;
      this->heavy2light_mean_ = x.heavy2light_mean_;
      this->heavy2light_error_ = x.heavy2light_error_;
    }

    return *this;
  }

  asapratio_result::
  ~asapratio_result ()
  {
  }

  // asapratio_peptide_data
  //

  asapratio_peptide_data::
  asapratio_peptide_data ()
  : ::xml_schema::type (),
    asapratio_contribution_ (this),
    status_ (this),
    cidIndex_ (this),
    light_mass_ (this),
    heavy_mass_ (this),
    area_flag_ (this)
  {
  }

  asapratio_peptide_data::
  asapratio_peptide_data (const status_type& status,
                          const cidIndex_type& cidIndex,
                          const light_mass_type& light_mass,
                          const heavy_mass_type& heavy_mass,
                          const area_flag_type& area_flag)
  : ::xml_schema::type (),
    asapratio_contribution_ (this),
    status_ (status, this),
    cidIndex_ (cidIndex, this),
    light_mass_ (light_mass, this),
    heavy_mass_ (heavy_mass, this),
    area_flag_ (area_flag, this)
  {
  }

  asapratio_peptide_data::
  asapratio_peptide_data (const asapratio_peptide_data& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    asapratio_contribution_ (x.asapratio_contribution_, f, this),
    status_ (x.status_, f, this),
    cidIndex_ (x.cidIndex_, f, this),
    light_mass_ (x.light_mass_, f, this),
    heavy_mass_ (x.heavy_mass_, f, this),
    area_flag_ (x.area_flag_, f, this)
  {
  }

  asapratio_peptide_data::
  asapratio_peptide_data (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    asapratio_contribution_ (this),
    status_ (this),
    cidIndex_ (this),
    light_mass_ (this),
    heavy_mass_ (this),
    area_flag_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void asapratio_peptide_data::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // asapratio_contribution
      //
      if (n.name () == "asapratio_contribution" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< asapratio_contribution_type > r (
          asapratio_contribution_traits::create (i, f, this));

        this->asapratio_contribution_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "status" && n.namespace_ ().empty ())
      {
        this->status_.set (status_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "cidIndex" && n.namespace_ ().empty ())
      {
        this->cidIndex_.set (cidIndex_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "light_mass" && n.namespace_ ().empty ())
      {
        this->light_mass_.set (light_mass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "heavy_mass" && n.namespace_ ().empty ())
      {
        this->heavy_mass_.set (heavy_mass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "area_flag" && n.namespace_ ().empty ())
      {
        this->area_flag_.set (area_flag_traits::create (i, f, this));
        continue;
      }
    }

    if (!status_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "status",
        "");
    }

    if (!cidIndex_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "cidIndex",
        "");
    }

    if (!light_mass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "light_mass",
        "");
    }

    if (!heavy_mass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "heavy_mass",
        "");
    }

    if (!area_flag_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "area_flag",
        "");
    }
  }

  asapratio_peptide_data* asapratio_peptide_data::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class asapratio_peptide_data (*this, f, c);
  }

  asapratio_peptide_data& asapratio_peptide_data::
  operator= (const asapratio_peptide_data& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->asapratio_contribution_ = x.asapratio_contribution_;
      this->status_ = x.status_;
      this->cidIndex_ = x.cidIndex_;
      this->light_mass_ = x.light_mass_;
      this->heavy_mass_ = x.heavy_mass_;
      this->area_flag_ = x.area_flag_;
    }

    return *this;
  }

  asapratio_peptide_data::
  ~asapratio_peptide_data ()
  {
  }

  // asapratio_contribution
  //

  asapratio_contribution::
  asapratio_contribution ()
  : ::xml_schema::type (),
    asapratio_lc_lightpeak_ (this),
    asapratio_lc_heavypeak_ (this),
    ratio_ (this),
    error_ (this),
    charge_ (this),
    use_ (this)
  {
  }

  asapratio_contribution::
  asapratio_contribution (const asapratio_lc_lightpeak_type& asapratio_lc_lightpeak,
                          const asapratio_lc_heavypeak_type& asapratio_lc_heavypeak,
                          const ratio_type& ratio,
                          const error_type& error,
                          const charge_type& charge,
                          const use_type& use)
  : ::xml_schema::type (),
    asapratio_lc_lightpeak_ (asapratio_lc_lightpeak, this),
    asapratio_lc_heavypeak_ (asapratio_lc_heavypeak, this),
    ratio_ (ratio, this),
    error_ (error, this),
    charge_ (charge, this),
    use_ (use, this)
  {
  }

  asapratio_contribution::
  asapratio_contribution (::std::unique_ptr< asapratio_lc_lightpeak_type > asapratio_lc_lightpeak,
                          ::std::unique_ptr< asapratio_lc_heavypeak_type > asapratio_lc_heavypeak,
                          const ratio_type& ratio,
                          const error_type& error,
                          const charge_type& charge,
                          const use_type& use)
  : ::xml_schema::type (),
    asapratio_lc_lightpeak_ (std::move (asapratio_lc_lightpeak), this),
    asapratio_lc_heavypeak_ (std::move (asapratio_lc_heavypeak), this),
    ratio_ (ratio, this),
    error_ (error, this),
    charge_ (charge, this),
    use_ (use, this)
  {
  }

  asapratio_contribution::
  asapratio_contribution (const asapratio_contribution& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    asapratio_lc_lightpeak_ (x.asapratio_lc_lightpeak_, f, this),
    asapratio_lc_heavypeak_ (x.asapratio_lc_heavypeak_, f, this),
    ratio_ (x.ratio_, f, this),
    error_ (x.error_, f, this),
    charge_ (x.charge_, f, this),
    use_ (x.use_, f, this)
  {
  }

  asapratio_contribution::
  asapratio_contribution (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    asapratio_lc_lightpeak_ (this),
    asapratio_lc_heavypeak_ (this),
    ratio_ (this),
    error_ (this),
    charge_ (this),
    use_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void asapratio_contribution::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // asapratio_lc_lightpeak
      //
      if (n.name () == "asapratio_lc_lightpeak" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< asapratio_lc_lightpeak_type > r (
          asapratio_lc_lightpeak_traits::create (i, f, this));

        if (!asapratio_lc_lightpeak_.present ())
        {
          this->asapratio_lc_lightpeak_.set (::std::move (r));
          continue;
        }
      }

      // asapratio_lc_heavypeak
      //
      if (n.name () == "asapratio_lc_heavypeak" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< asapratio_lc_heavypeak_type > r (
          asapratio_lc_heavypeak_traits::create (i, f, this));

        if (!asapratio_lc_heavypeak_.present ())
        {
          this->asapratio_lc_heavypeak_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!asapratio_lc_lightpeak_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "asapratio_lc_lightpeak",
        "http://regis-web.systemsbiology.net/pepXML");
    }

    if (!asapratio_lc_heavypeak_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "asapratio_lc_heavypeak",
        "http://regis-web.systemsbiology.net/pepXML");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ratio" && n.namespace_ ().empty ())
      {
        this->ratio_.set (ratio_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "error" && n.namespace_ ().empty ())
      {
        this->error_.set (error_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "charge" && n.namespace_ ().empty ())
      {
        this->charge_.set (charge_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "use" && n.namespace_ ().empty ())
      {
        this->use_.set (use_traits::create (i, f, this));
        continue;
      }
    }

    if (!ratio_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ratio",
        "");
    }

    if (!error_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "error",
        "");
    }

    if (!charge_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "charge",
        "");
    }

    if (!use_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "use",
        "");
    }
  }

  asapratio_contribution* asapratio_contribution::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class asapratio_contribution (*this, f, c);
  }

  asapratio_contribution& asapratio_contribution::
  operator= (const asapratio_contribution& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->asapratio_lc_lightpeak_ = x.asapratio_lc_lightpeak_;
      this->asapratio_lc_heavypeak_ = x.asapratio_lc_heavypeak_;
      this->ratio_ = x.ratio_;
      this->error_ = x.error_;
      this->charge_ = x.charge_;
      this->use_ = x.use_;
    }

    return *this;
  }

  asapratio_contribution::
  ~asapratio_contribution ()
  {
  }

  // asapratio_lc_lightpeak
  //

  asapratio_lc_lightpeak::
  asapratio_lc_lightpeak ()
  : ::xml_schema::type (),
    status_ (this),
    left_valley_ (this),
    right_valley_ (this),
    background_ (this),
    area_ (this),
    area_error_ (this),
    time_ (this),
    time_width_ (this),
    is_heavy_ (this)
  {
  }

  asapratio_lc_lightpeak::
  asapratio_lc_lightpeak (const status_type& status,
                          const left_valley_type& left_valley,
                          const right_valley_type& right_valley,
                          const background_type& background,
                          const area_type& area,
                          const area_error_type& area_error,
                          const time_type& time,
                          const time_width_type& time_width,
                          const is_heavy_type& is_heavy)
  : ::xml_schema::type (),
    status_ (status, this),
    left_valley_ (left_valley, this),
    right_valley_ (right_valley, this),
    background_ (background, this),
    area_ (area, this),
    area_error_ (area_error, this),
    time_ (time, this),
    time_width_ (time_width, this),
    is_heavy_ (is_heavy, this)
  {
  }

  asapratio_lc_lightpeak::
  asapratio_lc_lightpeak (const asapratio_lc_lightpeak& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    status_ (x.status_, f, this),
    left_valley_ (x.left_valley_, f, this),
    right_valley_ (x.right_valley_, f, this),
    background_ (x.background_, f, this),
    area_ (x.area_, f, this),
    area_error_ (x.area_error_, f, this),
    time_ (x.time_, f, this),
    time_width_ (x.time_width_, f, this),
    is_heavy_ (x.is_heavy_, f, this)
  {
  }

  asapratio_lc_lightpeak::
  asapratio_lc_lightpeak (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    status_ (this),
    left_valley_ (this),
    right_valley_ (this),
    background_ (this),
    area_ (this),
    area_error_ (this),
    time_ (this),
    time_width_ (this),
    is_heavy_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void asapratio_lc_lightpeak::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "status" && n.namespace_ ().empty ())
      {
        this->status_.set (status_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "left_valley" && n.namespace_ ().empty ())
      {
        this->left_valley_.set (left_valley_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "right_valley" && n.namespace_ ().empty ())
      {
        this->right_valley_.set (right_valley_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "background" && n.namespace_ ().empty ())
      {
        this->background_.set (background_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "area" && n.namespace_ ().empty ())
      {
        this->area_.set (area_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "area_error" && n.namespace_ ().empty ())
      {
        this->area_error_.set (area_error_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "time" && n.namespace_ ().empty ())
      {
        this->time_.set (time_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "time_width" && n.namespace_ ().empty ())
      {
        this->time_width_.set (time_width_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "is_heavy" && n.namespace_ ().empty ())
      {
        this->is_heavy_.set (is_heavy_traits::create (i, f, this));
        continue;
      }
    }

    if (!status_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "status",
        "");
    }

    if (!left_valley_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "left_valley",
        "");
    }

    if (!right_valley_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "right_valley",
        "");
    }

    if (!background_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "background",
        "");
    }

    if (!area_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "area",
        "");
    }

    if (!area_error_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "area_error",
        "");
    }

    if (!time_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "time",
        "");
    }

    if (!time_width_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "time_width",
        "");
    }

    if (!is_heavy_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "is_heavy",
        "");
    }
  }

  asapratio_lc_lightpeak* asapratio_lc_lightpeak::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class asapratio_lc_lightpeak (*this, f, c);
  }

  asapratio_lc_lightpeak& asapratio_lc_lightpeak::
  operator= (const asapratio_lc_lightpeak& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->status_ = x.status_;
      this->left_valley_ = x.left_valley_;
      this->right_valley_ = x.right_valley_;
      this->background_ = x.background_;
      this->area_ = x.area_;
      this->area_error_ = x.area_error_;
      this->time_ = x.time_;
      this->time_width_ = x.time_width_;
      this->is_heavy_ = x.is_heavy_;
    }

    return *this;
  }

  asapratio_lc_lightpeak::
  ~asapratio_lc_lightpeak ()
  {
  }

  // asapratio_lc_heavypeak
  //

  asapratio_lc_heavypeak::
  asapratio_lc_heavypeak ()
  : ::xml_schema::type (),
    status_ (this),
    left_valley_ (this),
    right_valley_ (this),
    background_ (this),
    area_ (this),
    area_error_ (this),
    time_ (this),
    time_width_ (this),
    is_heavy_ (this)
  {
  }

  asapratio_lc_heavypeak::
  asapratio_lc_heavypeak (const status_type& status,
                          const left_valley_type& left_valley,
                          const right_valley_type& right_valley,
                          const background_type& background,
                          const area_type& area,
                          const area_error_type& area_error,
                          const time_type& time,
                          const time_width_type& time_width,
                          const is_heavy_type& is_heavy)
  : ::xml_schema::type (),
    status_ (status, this),
    left_valley_ (left_valley, this),
    right_valley_ (right_valley, this),
    background_ (background, this),
    area_ (area, this),
    area_error_ (area_error, this),
    time_ (time, this),
    time_width_ (time_width, this),
    is_heavy_ (is_heavy, this)
  {
  }

  asapratio_lc_heavypeak::
  asapratio_lc_heavypeak (const asapratio_lc_heavypeak& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    status_ (x.status_, f, this),
    left_valley_ (x.left_valley_, f, this),
    right_valley_ (x.right_valley_, f, this),
    background_ (x.background_, f, this),
    area_ (x.area_, f, this),
    area_error_ (x.area_error_, f, this),
    time_ (x.time_, f, this),
    time_width_ (x.time_width_, f, this),
    is_heavy_ (x.is_heavy_, f, this)
  {
  }

  asapratio_lc_heavypeak::
  asapratio_lc_heavypeak (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    status_ (this),
    left_valley_ (this),
    right_valley_ (this),
    background_ (this),
    area_ (this),
    area_error_ (this),
    time_ (this),
    time_width_ (this),
    is_heavy_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void asapratio_lc_heavypeak::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "status" && n.namespace_ ().empty ())
      {
        this->status_.set (status_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "left_valley" && n.namespace_ ().empty ())
      {
        this->left_valley_.set (left_valley_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "right_valley" && n.namespace_ ().empty ())
      {
        this->right_valley_.set (right_valley_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "background" && n.namespace_ ().empty ())
      {
        this->background_.set (background_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "area" && n.namespace_ ().empty ())
      {
        this->area_.set (area_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "area_error" && n.namespace_ ().empty ())
      {
        this->area_error_.set (area_error_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "time" && n.namespace_ ().empty ())
      {
        this->time_.set (time_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "time_width" && n.namespace_ ().empty ())
      {
        this->time_width_.set (time_width_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "is_heavy" && n.namespace_ ().empty ())
      {
        this->is_heavy_.set (is_heavy_traits::create (i, f, this));
        continue;
      }
    }

    if (!status_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "status",
        "");
    }

    if (!left_valley_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "left_valley",
        "");
    }

    if (!right_valley_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "right_valley",
        "");
    }

    if (!background_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "background",
        "");
    }

    if (!area_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "area",
        "");
    }

    if (!area_error_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "area_error",
        "");
    }

    if (!time_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "time",
        "");
    }

    if (!time_width_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "time_width",
        "");
    }

    if (!is_heavy_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "is_heavy",
        "");
    }
  }

  asapratio_lc_heavypeak* asapratio_lc_heavypeak::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class asapratio_lc_heavypeak (*this, f, c);
  }

  asapratio_lc_heavypeak& asapratio_lc_heavypeak::
  operator= (const asapratio_lc_heavypeak& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->status_ = x.status_;
      this->left_valley_ = x.left_valley_;
      this->right_valley_ = x.right_valley_;
      this->background_ = x.background_;
      this->area_ = x.area_;
      this->area_error_ = x.area_error_;
      this->time_ = x.time_;
      this->time_width_ = x.time_width_;
      this->is_heavy_ = x.is_heavy_;
    }

    return *this;
  }

  asapratio_lc_heavypeak::
  ~asapratio_lc_heavypeak ()
  {
  }

  // database_refresh_timestamp
  //

  database_refresh_timestamp::
  database_refresh_timestamp ()
  : ::xml_schema::type (),
    database_ (this),
    min_num_enz_term_ (this)
  {
  }

  database_refresh_timestamp::
  database_refresh_timestamp (const database_type& database)
  : ::xml_schema::type (),
    database_ (database, this),
    min_num_enz_term_ (this)
  {
  }

  database_refresh_timestamp::
  database_refresh_timestamp (const database_refresh_timestamp& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    database_ (x.database_, f, this),
    min_num_enz_term_ (x.min_num_enz_term_, f, this)
  {
  }

  database_refresh_timestamp::
  database_refresh_timestamp (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    database_ (this),
    min_num_enz_term_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void database_refresh_timestamp::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "database" && n.namespace_ ().empty ())
      {
        this->database_.set (database_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "min_num_enz_term" && n.namespace_ ().empty ())
      {
        this->min_num_enz_term_.set (min_num_enz_term_traits::create (i, f, this));
        continue;
      }
    }

    if (!database_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "database",
        "");
    }
  }

  database_refresh_timestamp* database_refresh_timestamp::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class database_refresh_timestamp (*this, f, c);
  }

  database_refresh_timestamp& database_refresh_timestamp::
  operator= (const database_refresh_timestamp& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->database_ = x.database_;
      this->min_num_enz_term_ = x.min_num_enz_term_;
    }

    return *this;
  }

  database_refresh_timestamp::
  ~database_refresh_timestamp ()
  {
  }

  // xpressratio_timestamp
  //

  xpressratio_timestamp::
  xpressratio_timestamp ()
  : ::xml_schema::type (),
    xpress_light_ (this)
  {
  }

  xpressratio_timestamp::
  xpressratio_timestamp (const xpress_light_type& xpress_light)
  : ::xml_schema::type (),
    xpress_light_ (xpress_light, this)
  {
  }

  xpressratio_timestamp::
  xpressratio_timestamp (const xpressratio_timestamp& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    xpress_light_ (x.xpress_light_, f, this)
  {
  }

  xpressratio_timestamp::
  xpressratio_timestamp (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    xpress_light_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void xpressratio_timestamp::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "xpress_light" && n.namespace_ ().empty ())
      {
        this->xpress_light_.set (xpress_light_traits::create (i, f, this));
        continue;
      }
    }

    if (!xpress_light_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "xpress_light",
        "");
    }
  }

  xpressratio_timestamp* xpressratio_timestamp::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class xpressratio_timestamp (*this, f, c);
  }

  xpressratio_timestamp& xpressratio_timestamp::
  operator= (const xpressratio_timestamp& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->xpress_light_ = x.xpress_light_;
    }

    return *this;
  }

  xpressratio_timestamp::
  ~xpressratio_timestamp ()
  {
  }

  // asapratio_timestamp
  //

  asapratio_timestamp::
  asapratio_timestamp ()
  : ::xml_schema::type (),
    quant_label_masses_ (this),
    static_quant_label_ (this)
  {
  }

  asapratio_timestamp::
  asapratio_timestamp (const asapratio_timestamp& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    quant_label_masses_ (x.quant_label_masses_, f, this),
    static_quant_label_ (x.static_quant_label_, f, this)
  {
  }

  asapratio_timestamp::
  asapratio_timestamp (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    quant_label_masses_ (this),
    static_quant_label_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void asapratio_timestamp::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "quant_label_masses" && n.namespace_ ().empty ())
      {
        this->quant_label_masses_.set (quant_label_masses_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "static_quant_label" && n.namespace_ ().empty ())
      {
        this->static_quant_label_.set (static_quant_label_traits::create (i, f, this));
        continue;
      }
    }
  }

  asapratio_timestamp* asapratio_timestamp::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class asapratio_timestamp (*this, f, c);
  }

  asapratio_timestamp& asapratio_timestamp::
  operator= (const asapratio_timestamp& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->quant_label_masses_ = x.quant_label_masses_;
      this->static_quant_label_ = x.static_quant_label_;
    }

    return *this;
  }

  asapratio_timestamp::
  ~asapratio_timestamp ()
  {
  }

  // xpressratio_result
  //

  xpressratio_result::
  xpressratio_result ()
  : ::xml_schema::type (),
    light_firstscan_ (this),
    light_lastscan_ (this),
    light_mass_ (this),
    heavy_firstscan_ (this),
    heavy_lastscan_ (this),
    heavy_mass_ (this),
    mass_tol_ (this),
    ratio_ (this),
    heavy2light_ratio_ (this),
    light_area_ (this),
    heavy_area_ (this),
    decimal_ratio_ (this)
  {
  }

  xpressratio_result::
  xpressratio_result (const light_firstscan_type& light_firstscan,
                      const light_lastscan_type& light_lastscan,
                      const light_mass_type& light_mass,
                      const heavy_firstscan_type& heavy_firstscan,
                      const heavy_lastscan_type& heavy_lastscan,
                      const heavy_mass_type& heavy_mass,
                      const mass_tol_type& mass_tol,
                      const ratio_type& ratio,
                      const heavy2light_ratio_type& heavy2light_ratio,
                      const light_area_type& light_area,
                      const heavy_area_type& heavy_area,
                      const decimal_ratio_type& decimal_ratio)
  : ::xml_schema::type (),
    light_firstscan_ (light_firstscan, this),
    light_lastscan_ (light_lastscan, this),
    light_mass_ (light_mass, this),
    heavy_firstscan_ (heavy_firstscan, this),
    heavy_lastscan_ (heavy_lastscan, this),
    heavy_mass_ (heavy_mass, this),
    mass_tol_ (mass_tol, this),
    ratio_ (ratio, this),
    heavy2light_ratio_ (heavy2light_ratio, this),
    light_area_ (light_area, this),
    heavy_area_ (heavy_area, this),
    decimal_ratio_ (decimal_ratio, this)
  {
  }

  xpressratio_result::
  xpressratio_result (const xpressratio_result& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    light_firstscan_ (x.light_firstscan_, f, this),
    light_lastscan_ (x.light_lastscan_, f, this),
    light_mass_ (x.light_mass_, f, this),
    heavy_firstscan_ (x.heavy_firstscan_, f, this),
    heavy_lastscan_ (x.heavy_lastscan_, f, this),
    heavy_mass_ (x.heavy_mass_, f, this),
    mass_tol_ (x.mass_tol_, f, this),
    ratio_ (x.ratio_, f, this),
    heavy2light_ratio_ (x.heavy2light_ratio_, f, this),
    light_area_ (x.light_area_, f, this),
    heavy_area_ (x.heavy_area_, f, this),
    decimal_ratio_ (x.decimal_ratio_, f, this)
  {
  }

  xpressratio_result::
  xpressratio_result (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    light_firstscan_ (this),
    light_lastscan_ (this),
    light_mass_ (this),
    heavy_firstscan_ (this),
    heavy_lastscan_ (this),
    heavy_mass_ (this),
    mass_tol_ (this),
    ratio_ (this),
    heavy2light_ratio_ (this),
    light_area_ (this),
    heavy_area_ (this),
    decimal_ratio_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void xpressratio_result::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "light_firstscan" && n.namespace_ ().empty ())
      {
        this->light_firstscan_.set (light_firstscan_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "light_lastscan" && n.namespace_ ().empty ())
      {
        this->light_lastscan_.set (light_lastscan_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "light_mass" && n.namespace_ ().empty ())
      {
        this->light_mass_.set (light_mass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "heavy_firstscan" && n.namespace_ ().empty ())
      {
        this->heavy_firstscan_.set (heavy_firstscan_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "heavy_lastscan" && n.namespace_ ().empty ())
      {
        this->heavy_lastscan_.set (heavy_lastscan_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "heavy_mass" && n.namespace_ ().empty ())
      {
        this->heavy_mass_.set (heavy_mass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "mass_tol" && n.namespace_ ().empty ())
      {
        this->mass_tol_.set (mass_tol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ratio" && n.namespace_ ().empty ())
      {
        this->ratio_.set (ratio_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "heavy2light_ratio" && n.namespace_ ().empty ())
      {
        this->heavy2light_ratio_.set (heavy2light_ratio_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "light_area" && n.namespace_ ().empty ())
      {
        this->light_area_.set (light_area_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "heavy_area" && n.namespace_ ().empty ())
      {
        this->heavy_area_.set (heavy_area_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "decimal_ratio" && n.namespace_ ().empty ())
      {
        this->decimal_ratio_.set (decimal_ratio_traits::create (i, f, this));
        continue;
      }
    }

    if (!light_firstscan_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "light_firstscan",
        "");
    }

    if (!light_lastscan_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "light_lastscan",
        "");
    }

    if (!light_mass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "light_mass",
        "");
    }

    if (!heavy_firstscan_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "heavy_firstscan",
        "");
    }

    if (!heavy_lastscan_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "heavy_lastscan",
        "");
    }

    if (!heavy_mass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "heavy_mass",
        "");
    }

    if (!mass_tol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mass_tol",
        "");
    }

    if (!ratio_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ratio",
        "");
    }

    if (!heavy2light_ratio_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "heavy2light_ratio",
        "");
    }

    if (!light_area_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "light_area",
        "");
    }

    if (!heavy_area_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "heavy_area",
        "");
    }

    if (!decimal_ratio_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "decimal_ratio",
        "");
    }
  }

  xpressratio_result* xpressratio_result::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class xpressratio_result (*this, f, c);
  }

  xpressratio_result& xpressratio_result::
  operator= (const xpressratio_result& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->light_firstscan_ = x.light_firstscan_;
      this->light_lastscan_ = x.light_lastscan_;
      this->light_mass_ = x.light_mass_;
      this->heavy_firstscan_ = x.heavy_firstscan_;
      this->heavy_lastscan_ = x.heavy_lastscan_;
      this->heavy_mass_ = x.heavy_mass_;
      this->mass_tol_ = x.mass_tol_;
      this->ratio_ = x.ratio_;
      this->heavy2light_ratio_ = x.heavy2light_ratio_;
      this->light_area_ = x.light_area_;
      this->heavy_area_ = x.heavy_area_;
      this->decimal_ratio_ = x.decimal_ratio_;
    }

    return *this;
  }

  xpressratio_result::
  ~xpressratio_result ()
  {
  }

  // interact_summary
  //

  interact_summary::
  interact_summary ()
  : ::xml_schema::type (),
    inputfile_ (this),
    filename_ (this),
    directory_ (this)
  {
  }

  interact_summary::
  interact_summary (const filename_type& filename,
                    const directory_type& directory)
  : ::xml_schema::type (),
    inputfile_ (this),
    filename_ (filename, this),
    directory_ (directory, this)
  {
  }

  interact_summary::
  interact_summary (const interact_summary& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    inputfile_ (x.inputfile_, f, this),
    filename_ (x.filename_, f, this),
    directory_ (x.directory_, f, this)
  {
  }

  interact_summary::
  interact_summary (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    inputfile_ (this),
    filename_ (this),
    directory_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void interact_summary::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // inputfile
      //
      if (n.name () == "inputfile" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< inputfile_type > r (
          inputfile_traits::create (i, f, this));

        this->inputfile_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "filename" && n.namespace_ ().empty ())
      {
        this->filename_.set (filename_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "directory" && n.namespace_ ().empty ())
      {
        this->directory_.set (directory_traits::create (i, f, this));
        continue;
      }
    }

    if (!filename_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "filename",
        "");
    }

    if (!directory_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "directory",
        "");
    }
  }

  interact_summary* interact_summary::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class interact_summary (*this, f, c);
  }

  interact_summary& interact_summary::
  operator= (const interact_summary& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->inputfile_ = x.inputfile_;
      this->filename_ = x.filename_;
      this->directory_ = x.directory_;
    }

    return *this;
  }

  interact_summary::
  ~interact_summary ()
  {
  }

  // libra_result
  //

  libra_result::
  libra_result ()
  : ::xml_schema::type (),
    intensity_ (this),
    is_rejected_ (is_rejected_default_value (), this)
  {
  }

  libra_result::
  libra_result (const libra_result& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    intensity_ (x.intensity_, f, this),
    is_rejected_ (x.is_rejected_, f, this)
  {
  }

  libra_result::
  libra_result (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    intensity_ (this),
    is_rejected_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void libra_result::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // intensity
      //
      if (n.name () == "intensity" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< intensity_type > r (
          intensity_traits::create (i, f, this));

        this->intensity_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "is_rejected" && n.namespace_ ().empty ())
      {
        this->is_rejected_.set (is_rejected_traits::create (i, f, this));
        continue;
      }
    }

    if (!is_rejected_.present ())
    {
      this->is_rejected_.set (is_rejected_default_value ());
    }
  }

  libra_result* libra_result::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class libra_result (*this, f, c);
  }

  libra_result& libra_result::
  operator= (const libra_result& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->intensity_ = x.intensity_;
      this->is_rejected_ = x.is_rejected_;
    }

    return *this;
  }

  libra_result::
  ~libra_result ()
  {
  }

  // libra_summary
  //

  libra_summary::
  libra_summary ()
  : ::xml_schema::type (),
    fragment_masses_ (this),
    isotopic_contributions_ (this),
    mass_tolerance_ (this),
    centroiding_preference_ (this),
    normalization_ (this),
    output_type_ (this),
    channel_code_ (this)
  {
  }

  libra_summary::
  libra_summary (const mass_tolerance_type& mass_tolerance,
                 const centroiding_preference_type& centroiding_preference,
                 const normalization_type& normalization,
                 const output_type_type& output_type)
  : ::xml_schema::type (),
    fragment_masses_ (this),
    isotopic_contributions_ (this),
    mass_tolerance_ (mass_tolerance, this),
    centroiding_preference_ (centroiding_preference, this),
    normalization_ (normalization, this),
    output_type_ (output_type, this),
    channel_code_ (this)
  {
  }

  libra_summary::
  libra_summary (const libra_summary& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    fragment_masses_ (x.fragment_masses_, f, this),
    isotopic_contributions_ (x.isotopic_contributions_, f, this),
    mass_tolerance_ (x.mass_tolerance_, f, this),
    centroiding_preference_ (x.centroiding_preference_, f, this),
    normalization_ (x.normalization_, f, this),
    output_type_ (x.output_type_, f, this),
    channel_code_ (x.channel_code_, f, this)
  {
  }

  libra_summary::
  libra_summary (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    fragment_masses_ (this),
    isotopic_contributions_ (this),
    mass_tolerance_ (this),
    centroiding_preference_ (this),
    normalization_ (this),
    output_type_ (this),
    channel_code_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void libra_summary::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // fragment_masses
      //
      if (n.name () == "fragment_masses" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< fragment_masses_type > r (
          fragment_masses_traits::create (i, f, this));

        this->fragment_masses_.push_back (::std::move (r));
        continue;
      }

      // isotopic_contributions
      //
      if (n.name () == "isotopic_contributions" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< isotopic_contributions_type > r (
          isotopic_contributions_traits::create (i, f, this));

        if (!this->isotopic_contributions_)
        {
          this->isotopic_contributions_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "mass_tolerance" && n.namespace_ ().empty ())
      {
        this->mass_tolerance_.set (mass_tolerance_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "centroiding_preference" && n.namespace_ ().empty ())
      {
        this->centroiding_preference_.set (centroiding_preference_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "normalization" && n.namespace_ ().empty ())
      {
        this->normalization_.set (normalization_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "output_type" && n.namespace_ ().empty ())
      {
        this->output_type_.set (output_type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "channel_code" && n.namespace_ ().empty ())
      {
        this->channel_code_.set (channel_code_traits::create (i, f, this));
        continue;
      }
    }

    if (!mass_tolerance_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mass_tolerance",
        "");
    }

    if (!centroiding_preference_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "centroiding_preference",
        "");
    }

    if (!normalization_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "normalization",
        "");
    }

    if (!output_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "output_type",
        "");
    }
  }

  libra_summary* libra_summary::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class libra_summary (*this, f, c);
  }

  libra_summary& libra_summary::
  operator= (const libra_summary& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->fragment_masses_ = x.fragment_masses_;
      this->isotopic_contributions_ = x.isotopic_contributions_;
      this->mass_tolerance_ = x.mass_tolerance_;
      this->centroiding_preference_ = x.centroiding_preference_;
      this->normalization_ = x.normalization_;
      this->output_type_ = x.output_type_;
      this->channel_code_ = x.channel_code_;
    }

    return *this;
  }

  libra_summary::
  ~libra_summary ()
  {
  }

  // roc_data_point
  //

  roc_data_point::
  roc_data_point ()
  : ::xml_schema::type (),
    min_prob_ (this),
    sensitivity_ (this),
    error_ (this),
    num_corr_ (this),
    num_incorr_ (this)
  {
  }

  roc_data_point::
  roc_data_point (const min_prob_type& min_prob,
                  const sensitivity_type& sensitivity,
                  const error_type& error,
                  const num_corr_type& num_corr,
                  const num_incorr_type& num_incorr)
  : ::xml_schema::type (),
    min_prob_ (min_prob, this),
    sensitivity_ (sensitivity, this),
    error_ (error, this),
    num_corr_ (num_corr, this),
    num_incorr_ (num_incorr, this)
  {
  }

  roc_data_point::
  roc_data_point (const roc_data_point& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    min_prob_ (x.min_prob_, f, this),
    sensitivity_ (x.sensitivity_, f, this),
    error_ (x.error_, f, this),
    num_corr_ (x.num_corr_, f, this),
    num_incorr_ (x.num_incorr_, f, this)
  {
  }

  roc_data_point::
  roc_data_point (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    min_prob_ (this),
    sensitivity_ (this),
    error_ (this),
    num_corr_ (this),
    num_incorr_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void roc_data_point::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "min_prob" && n.namespace_ ().empty ())
      {
        this->min_prob_.set (min_prob_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sensitivity" && n.namespace_ ().empty ())
      {
        this->sensitivity_.set (sensitivity_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "error" && n.namespace_ ().empty ())
      {
        this->error_.set (error_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "num_corr" && n.namespace_ ().empty ())
      {
        this->num_corr_.set (num_corr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "num_incorr" && n.namespace_ ().empty ())
      {
        this->num_incorr_.set (num_incorr_traits::create (i, f, this));
        continue;
      }
    }

    if (!min_prob_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "min_prob",
        "");
    }

    if (!sensitivity_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "sensitivity",
        "");
    }

    if (!error_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "error",
        "");
    }

    if (!num_corr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "num_corr",
        "");
    }

    if (!num_incorr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "num_incorr",
        "");
    }
  }

  roc_data_point* roc_data_point::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class roc_data_point (*this, f, c);
  }

  roc_data_point& roc_data_point::
  operator= (const roc_data_point& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->min_prob_ = x.min_prob_;
      this->sensitivity_ = x.sensitivity_;
      this->error_ = x.error_;
      this->num_corr_ = x.num_corr_;
      this->num_incorr_ = x.num_incorr_;
    }

    return *this;
  }

  roc_data_point::
  ~roc_data_point ()
  {
  }

  // error_point
  //

  error_point::
  error_point ()
  : ::xml_schema::type (),
    error_ (this),
    min_prob_ (this),
    num_corr_ (this),
    num_incorr_ (this)
  {
  }

  error_point::
  error_point (const error_type& error,
               const min_prob_type& min_prob,
               const num_corr_type& num_corr,
               const num_incorr_type& num_incorr)
  : ::xml_schema::type (),
    error_ (error, this),
    min_prob_ (min_prob, this),
    num_corr_ (num_corr, this),
    num_incorr_ (num_incorr, this)
  {
  }

  error_point::
  error_point (const error_point& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    error_ (x.error_, f, this),
    min_prob_ (x.min_prob_, f, this),
    num_corr_ (x.num_corr_, f, this),
    num_incorr_ (x.num_incorr_, f, this)
  {
  }

  error_point::
  error_point (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    error_ (this),
    min_prob_ (this),
    num_corr_ (this),
    num_incorr_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void error_point::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "error" && n.namespace_ ().empty ())
      {
        this->error_.set (error_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "min_prob" && n.namespace_ ().empty ())
      {
        this->min_prob_.set (min_prob_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "num_corr" && n.namespace_ ().empty ())
      {
        this->num_corr_.set (num_corr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "num_incorr" && n.namespace_ ().empty ())
      {
        this->num_incorr_.set (num_incorr_traits::create (i, f, this));
        continue;
      }
    }

    if (!error_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "error",
        "");
    }

    if (!min_prob_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "min_prob",
        "");
    }

    if (!num_corr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "num_corr",
        "");
    }

    if (!num_incorr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "num_incorr",
        "");
    }
  }

  error_point* error_point::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class error_point (*this, f, c);
  }

  error_point& error_point::
  operator= (const error_point& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->error_ = x.error_;
      this->min_prob_ = x.min_prob_;
      this->num_corr_ = x.num_corr_;
      this->num_incorr_ = x.num_incorr_;
    }

    return *this;
  }

  error_point::
  ~error_point ()
  {
  }

  // point
  //

  point::
  point ()
  : ::xml_schema::type (),
    value_ (this),
    pos_dens_ (this),
    neg_dens_ (this),
    neg_obs_dens_ (this),
    pos_obs_dens_ (this)
  {
  }

  point::
  point (const point& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this),
    pos_dens_ (x.pos_dens_, f, this),
    neg_dens_ (x.neg_dens_, f, this),
    neg_obs_dens_ (x.neg_obs_dens_, f, this),
    pos_obs_dens_ (x.pos_obs_dens_, f, this)
  {
  }

  point::
  point (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this),
    pos_dens_ (this),
    neg_dens_ (this),
    neg_obs_dens_ (this),
    pos_obs_dens_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void point::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "pos_dens" && n.namespace_ ().empty ())
      {
        this->pos_dens_.set (pos_dens_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "neg_dens" && n.namespace_ ().empty ())
      {
        this->neg_dens_.set (neg_dens_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "neg_obs_dens" && n.namespace_ ().empty ())
      {
        this->neg_obs_dens_.set (neg_obs_dens_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "pos_obs_dens" && n.namespace_ ().empty ())
      {
        this->pos_obs_dens_.set (pos_obs_dens_traits::create (i, f, this));
        continue;
      }
    }
  }

  point* point::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class point (*this, f, c);
  }

  point& point::
  operator= (const point& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
      this->pos_dens_ = x.pos_dens_;
      this->neg_dens_ = x.neg_dens_;
      this->neg_obs_dens_ = x.neg_obs_dens_;
      this->pos_obs_dens_ = x.pos_obs_dens_;
    }

    return *this;
  }

  point::
  ~point ()
  {
  }

  // mod_aminoacid_mass
  //

  mod_aminoacid_mass::
  mod_aminoacid_mass ()
  : ::xml_schema::type (),
    position_ (this),
    mass_ (this),
    source_ (this)
  {
  }

  mod_aminoacid_mass::
  mod_aminoacid_mass (const position_type& position,
                      const mass_type& mass)
  : ::xml_schema::type (),
    position_ (position, this),
    mass_ (mass, this),
    source_ (this)
  {
  }

  mod_aminoacid_mass::
  mod_aminoacid_mass (const mod_aminoacid_mass& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    position_ (x.position_, f, this),
    mass_ (x.mass_, f, this),
    source_ (x.source_, f, this)
  {
  }

  mod_aminoacid_mass::
  mod_aminoacid_mass (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    position_ (this),
    mass_ (this),
    source_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void mod_aminoacid_mass::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "position" && n.namespace_ ().empty ())
      {
        this->position_.set (position_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "mass" && n.namespace_ ().empty ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "source" && n.namespace_ ().empty ())
      {
        this->source_.set (source_traits::create (i, f, this));
        continue;
      }
    }

    if (!position_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "position",
        "");
    }

    if (!mass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mass",
        "");
    }
  }

  mod_aminoacid_mass* mod_aminoacid_mass::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class mod_aminoacid_mass (*this, f, c);
  }

  mod_aminoacid_mass& mod_aminoacid_mass::
  operator= (const mod_aminoacid_mass& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->position_ = x.position_;
      this->mass_ = x.mass_;
      this->source_ = x.source_;
    }

    return *this;
  }

  mod_aminoacid_mass::
  ~mod_aminoacid_mass ()
  {
  }

  // analysis_summary
  //

  analysis_summary::
  analysis_summary ()
  : ::xml_schema::type (),
    parameter_ (this),
    time_ (this),
    analysis_ (this),
    version_ (this)
  {
  }

  analysis_summary::
  analysis_summary (const time_type& time,
                    const analysis_type& analysis)
  : ::xml_schema::type (),
    parameter_ (this),
    time_ (time, this),
    analysis_ (analysis, this),
    version_ (this)
  {
  }

  analysis_summary::
  analysis_summary (const analysis_summary& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    parameter_ (x.parameter_, f, this),
    time_ (x.time_, f, this),
    analysis_ (x.analysis_, f, this),
    version_ (x.version_, f, this)
  {
  }

  analysis_summary::
  analysis_summary (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    parameter_ (this),
    time_ (this),
    analysis_ (this),
    version_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void analysis_summary::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< parameter_type > r (
          parameter_traits::create (i, f, this));

        this->parameter_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "time" && n.namespace_ ().empty ())
      {
        this->time_.set (time_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "analysis" && n.namespace_ ().empty ())
      {
        this->analysis_.set (analysis_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        this->version_.set (version_traits::create (i, f, this));
        continue;
      }
    }

    if (!time_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "time",
        "");
    }

    if (!analysis_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "analysis",
        "");
    }
  }

  analysis_summary* analysis_summary::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class analysis_summary (*this, f, c);
  }

  analysis_summary& analysis_summary::
  operator= (const analysis_summary& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->parameter_ = x.parameter_;
      this->time_ = x.time_;
      this->analysis_ = x.analysis_;
      this->version_ = x.version_;
    }

    return *this;
  }

  analysis_summary::
  ~analysis_summary ()
  {
  }

  // dataset_derivation
  //

  dataset_derivation::
  dataset_derivation ()
  : ::xml_schema::type (),
    data_filter_ (this),
    generation_no_ (this)
  {
  }

  dataset_derivation::
  dataset_derivation (const generation_no_type& generation_no)
  : ::xml_schema::type (),
    data_filter_ (this),
    generation_no_ (generation_no, this)
  {
  }

  dataset_derivation::
  dataset_derivation (const dataset_derivation& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    data_filter_ (x.data_filter_, f, this),
    generation_no_ (x.generation_no_, f, this)
  {
  }

  dataset_derivation::
  dataset_derivation (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    data_filter_ (this),
    generation_no_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void dataset_derivation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // data_filter
      //
      if (n.name () == "data_filter" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< data_filter_type > r (
          data_filter_traits::create (i, f, this));

        this->data_filter_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "generation_no" && n.namespace_ ().empty ())
      {
        this->generation_no_.set (generation_no_traits::create (i, f, this));
        continue;
      }
    }

    if (!generation_no_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "generation_no",
        "");
    }
  }

  dataset_derivation* dataset_derivation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dataset_derivation (*this, f, c);
  }

  dataset_derivation& dataset_derivation::
  operator= (const dataset_derivation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->data_filter_ = x.data_filter_;
      this->generation_no_ = x.generation_no_;
    }

    return *this;
  }

  dataset_derivation::
  ~dataset_derivation ()
  {
  }

  // msms_run_summary
  //

  msms_run_summary::
  msms_run_summary ()
  : ::xml_schema::type (),
    sample_enzyme_ (this),
    cross_linker_ (this),
    search_summary_ (this),
    analysis_timestamp_ (this),
    spectrum_query_ (this),
    base_name_ (this),
    raw_data_type_ (this),
    raw_data_ (this),
    msManufacturer_ (this),
    msModel_ (this),
    msIonization_ (this),
    msMassAnalyzer_ (this),
    msDetector_ (this)
  {
  }

  msms_run_summary::
  msms_run_summary (const base_name_type& base_name,
                    const raw_data_type_type& raw_data_type,
                    const raw_data_type1& raw_data)
  : ::xml_schema::type (),
    sample_enzyme_ (this),
    cross_linker_ (this),
    search_summary_ (this),
    analysis_timestamp_ (this),
    spectrum_query_ (this),
    base_name_ (base_name, this),
    raw_data_type_ (raw_data_type, this),
    raw_data_ (raw_data, this),
    msManufacturer_ (this),
    msModel_ (this),
    msIonization_ (this),
    msMassAnalyzer_ (this),
    msDetector_ (this)
  {
  }

  msms_run_summary::
  msms_run_summary (const msms_run_summary& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sample_enzyme_ (x.sample_enzyme_, f, this),
    cross_linker_ (x.cross_linker_, f, this),
    search_summary_ (x.search_summary_, f, this),
    analysis_timestamp_ (x.analysis_timestamp_, f, this),
    spectrum_query_ (x.spectrum_query_, f, this),
    base_name_ (x.base_name_, f, this),
    raw_data_type_ (x.raw_data_type_, f, this),
    raw_data_ (x.raw_data_, f, this),
    msManufacturer_ (x.msManufacturer_, f, this),
    msModel_ (x.msModel_, f, this),
    msIonization_ (x.msIonization_, f, this),
    msMassAnalyzer_ (x.msMassAnalyzer_, f, this),
    msDetector_ (x.msDetector_, f, this)
  {
  }

  msms_run_summary::
  msms_run_summary (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sample_enzyme_ (this),
    cross_linker_ (this),
    search_summary_ (this),
    analysis_timestamp_ (this),
    spectrum_query_ (this),
    base_name_ (this),
    raw_data_type_ (this),
    raw_data_ (this),
    msManufacturer_ (this),
    msModel_ (this),
    msIonization_ (this),
    msMassAnalyzer_ (this),
    msDetector_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void msms_run_summary::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // sample_enzyme
      //
      if (n.name () == "sample_enzyme" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< sample_enzyme_type > r (
          sample_enzyme_traits::create (i, f, this));

        if (!this->sample_enzyme_)
        {
          this->sample_enzyme_.set (::std::move (r));
          continue;
        }
      }

      // cross_linker
      //
      if (n.name () == "cross_linker" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< cross_linker_type > r (
          cross_linker_traits::create (i, f, this));

        if (!this->cross_linker_)
        {
          this->cross_linker_.set (::std::move (r));
          continue;
        }
      }

      // search_summary
      //
      if (n.name () == "search_summary" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< search_summary_type > r (
          search_summary_traits::create (i, f, this));

        this->search_summary_.push_back (::std::move (r));
        continue;
      }

      // analysis_timestamp
      //
      if (n.name () == "analysis_timestamp" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< analysis_timestamp_type > r (
          analysis_timestamp_traits::create (i, f, this));

        this->analysis_timestamp_.push_back (::std::move (r));
        continue;
      }

      // spectrum_query
      //
      if (n.name () == "spectrum_query" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< spectrum_query_type > r (
          spectrum_query_traits::create (i, f, this));

        this->spectrum_query_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "base_name" && n.namespace_ ().empty ())
      {
        this->base_name_.set (base_name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "raw_data_type" && n.namespace_ ().empty ())
      {
        this->raw_data_type_.set (raw_data_type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "raw_data" && n.namespace_ ().empty ())
      {
        this->raw_data_.set (raw_data_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "msManufacturer" && n.namespace_ ().empty ())
      {
        this->msManufacturer_.set (msManufacturer_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "msModel" && n.namespace_ ().empty ())
      {
        this->msModel_.set (msModel_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "msIonization" && n.namespace_ ().empty ())
      {
        this->msIonization_.set (msIonization_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "msMassAnalyzer" && n.namespace_ ().empty ())
      {
        this->msMassAnalyzer_.set (msMassAnalyzer_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "msDetector" && n.namespace_ ().empty ())
      {
        this->msDetector_.set (msDetector_traits::create (i, f, this));
        continue;
      }
    }

    if (!base_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "base_name",
        "");
    }

    if (!raw_data_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "raw_data_type",
        "");
    }

    if (!raw_data_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "raw_data",
        "");
    }
  }

  msms_run_summary* msms_run_summary::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class msms_run_summary (*this, f, c);
  }

  msms_run_summary& msms_run_summary::
  operator= (const msms_run_summary& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->sample_enzyme_ = x.sample_enzyme_;
      this->cross_linker_ = x.cross_linker_;
      this->search_summary_ = x.search_summary_;
      this->analysis_timestamp_ = x.analysis_timestamp_;
      this->spectrum_query_ = x.spectrum_query_;
      this->base_name_ = x.base_name_;
      this->raw_data_type_ = x.raw_data_type_;
      this->raw_data_ = x.raw_data_;
      this->msManufacturer_ = x.msManufacturer_;
      this->msModel_ = x.msModel_;
      this->msIonization_ = x.msIonization_;
      this->msMassAnalyzer_ = x.msMassAnalyzer_;
      this->msDetector_ = x.msDetector_;
    }

    return *this;
  }

  msms_run_summary::
  ~msms_run_summary ()
  {
  }

  // distribution_point
  //

  distribution_point::
  distribution_point ()
  : ::xml_schema::type (),
    fvalue_ (this),
    obs_1_distr_ (this),
    model_1_pos_distr_ (this),
    model_1_neg_distr_ (this),
    obs_2_distr_ (this),
    model_2_pos_distr_ (this),
    model_2_neg_distr_ (this),
    obs_3_distr_ (this),
    model_3_pos_distr_ (this),
    model_3_neg_distr_ (this),
    obs_4_distr_ (this),
    model_4_pos_distr_ (this),
    model_4_neg_distr_ (this),
    obs_5_distr_ (this),
    model_5_pos_distr_ (this),
    model_5_neg_distr_ (this),
    obs_6_distr_ (this),
    model_6_pos_distr_ (this),
    model_6_neg_distr_ (this),
    obs_7_distr_ (this),
    model_7_pos_distr_ (this),
    model_7_neg_distr_ (this)
  {
  }

  distribution_point::
  distribution_point (const fvalue_type& fvalue,
                      const obs_1_distr_type& obs_1_distr,
                      const model_1_pos_distr_type& model_1_pos_distr,
                      const model_1_neg_distr_type& model_1_neg_distr,
                      const obs_2_distr_type& obs_2_distr,
                      const model_2_pos_distr_type& model_2_pos_distr,
                      const model_2_neg_distr_type& model_2_neg_distr,
                      const obs_3_distr_type& obs_3_distr,
                      const model_3_pos_distr_type& model_3_pos_distr,
                      const model_3_neg_distr_type& model_3_neg_distr,
                      const obs_4_distr_type& obs_4_distr,
                      const model_4_pos_distr_type& model_4_pos_distr,
                      const model_4_neg_distr_type& model_4_neg_distr,
                      const obs_5_distr_type& obs_5_distr,
                      const model_5_pos_distr_type& model_5_pos_distr,
                      const model_5_neg_distr_type& model_5_neg_distr,
                      const obs_6_distr_type& obs_6_distr,
                      const model_6_pos_distr_type& model_6_pos_distr,
                      const model_6_neg_distr_type& model_6_neg_distr,
                      const obs_7_distr_type& obs_7_distr,
                      const model_7_pos_distr_type& model_7_pos_distr,
                      const model_7_neg_distr_type& model_7_neg_distr)
  : ::xml_schema::type (),
    fvalue_ (fvalue, this),
    obs_1_distr_ (obs_1_distr, this),
    model_1_pos_distr_ (model_1_pos_distr, this),
    model_1_neg_distr_ (model_1_neg_distr, this),
    obs_2_distr_ (obs_2_distr, this),
    model_2_pos_distr_ (model_2_pos_distr, this),
    model_2_neg_distr_ (model_2_neg_distr, this),
    obs_3_distr_ (obs_3_distr, this),
    model_3_pos_distr_ (model_3_pos_distr, this),
    model_3_neg_distr_ (model_3_neg_distr, this),
    obs_4_distr_ (obs_4_distr, this),
    model_4_pos_distr_ (model_4_pos_distr, this),
    model_4_neg_distr_ (model_4_neg_distr, this),
    obs_5_distr_ (obs_5_distr, this),
    model_5_pos_distr_ (model_5_pos_distr, this),
    model_5_neg_distr_ (model_5_neg_distr, this),
    obs_6_distr_ (obs_6_distr, this),
    model_6_pos_distr_ (model_6_pos_distr, this),
    model_6_neg_distr_ (model_6_neg_distr, this),
    obs_7_distr_ (obs_7_distr, this),
    model_7_pos_distr_ (model_7_pos_distr, this),
    model_7_neg_distr_ (model_7_neg_distr, this)
  {
  }

  distribution_point::
  distribution_point (const distribution_point& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    fvalue_ (x.fvalue_, f, this),
    obs_1_distr_ (x.obs_1_distr_, f, this),
    model_1_pos_distr_ (x.model_1_pos_distr_, f, this),
    model_1_neg_distr_ (x.model_1_neg_distr_, f, this),
    obs_2_distr_ (x.obs_2_distr_, f, this),
    model_2_pos_distr_ (x.model_2_pos_distr_, f, this),
    model_2_neg_distr_ (x.model_2_neg_distr_, f, this),
    obs_3_distr_ (x.obs_3_distr_, f, this),
    model_3_pos_distr_ (x.model_3_pos_distr_, f, this),
    model_3_neg_distr_ (x.model_3_neg_distr_, f, this),
    obs_4_distr_ (x.obs_4_distr_, f, this),
    model_4_pos_distr_ (x.model_4_pos_distr_, f, this),
    model_4_neg_distr_ (x.model_4_neg_distr_, f, this),
    obs_5_distr_ (x.obs_5_distr_, f, this),
    model_5_pos_distr_ (x.model_5_pos_distr_, f, this),
    model_5_neg_distr_ (x.model_5_neg_distr_, f, this),
    obs_6_distr_ (x.obs_6_distr_, f, this),
    model_6_pos_distr_ (x.model_6_pos_distr_, f, this),
    model_6_neg_distr_ (x.model_6_neg_distr_, f, this),
    obs_7_distr_ (x.obs_7_distr_, f, this),
    model_7_pos_distr_ (x.model_7_pos_distr_, f, this),
    model_7_neg_distr_ (x.model_7_neg_distr_, f, this)
  {
  }

  distribution_point::
  distribution_point (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    fvalue_ (this),
    obs_1_distr_ (this),
    model_1_pos_distr_ (this),
    model_1_neg_distr_ (this),
    obs_2_distr_ (this),
    model_2_pos_distr_ (this),
    model_2_neg_distr_ (this),
    obs_3_distr_ (this),
    model_3_pos_distr_ (this),
    model_3_neg_distr_ (this),
    obs_4_distr_ (this),
    model_4_pos_distr_ (this),
    model_4_neg_distr_ (this),
    obs_5_distr_ (this),
    model_5_pos_distr_ (this),
    model_5_neg_distr_ (this),
    obs_6_distr_ (this),
    model_6_pos_distr_ (this),
    model_6_neg_distr_ (this),
    obs_7_distr_ (this),
    model_7_pos_distr_ (this),
    model_7_neg_distr_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void distribution_point::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "fvalue" && n.namespace_ ().empty ())
      {
        this->fvalue_.set (fvalue_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "obs_1_distr" && n.namespace_ ().empty ())
      {
        this->obs_1_distr_.set (obs_1_distr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "model_1_pos_distr" && n.namespace_ ().empty ())
      {
        this->model_1_pos_distr_.set (model_1_pos_distr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "model_1_neg_distr" && n.namespace_ ().empty ())
      {
        this->model_1_neg_distr_.set (model_1_neg_distr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "obs_2_distr" && n.namespace_ ().empty ())
      {
        this->obs_2_distr_.set (obs_2_distr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "model_2_pos_distr" && n.namespace_ ().empty ())
      {
        this->model_2_pos_distr_.set (model_2_pos_distr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "model_2_neg_distr" && n.namespace_ ().empty ())
      {
        this->model_2_neg_distr_.set (model_2_neg_distr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "obs_3_distr" && n.namespace_ ().empty ())
      {
        this->obs_3_distr_.set (obs_3_distr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "model_3_pos_distr" && n.namespace_ ().empty ())
      {
        this->model_3_pos_distr_.set (model_3_pos_distr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "model_3_neg_distr" && n.namespace_ ().empty ())
      {
        this->model_3_neg_distr_.set (model_3_neg_distr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "obs_4_distr" && n.namespace_ ().empty ())
      {
        this->obs_4_distr_.set (obs_4_distr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "model_4_pos_distr" && n.namespace_ ().empty ())
      {
        this->model_4_pos_distr_.set (model_4_pos_distr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "model_4_neg_distr" && n.namespace_ ().empty ())
      {
        this->model_4_neg_distr_.set (model_4_neg_distr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "obs_5_distr" && n.namespace_ ().empty ())
      {
        this->obs_5_distr_.set (obs_5_distr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "model_5_pos_distr" && n.namespace_ ().empty ())
      {
        this->model_5_pos_distr_.set (model_5_pos_distr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "model_5_neg_distr" && n.namespace_ ().empty ())
      {
        this->model_5_neg_distr_.set (model_5_neg_distr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "obs_6_distr" && n.namespace_ ().empty ())
      {
        this->obs_6_distr_.set (obs_6_distr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "model_6_pos_distr" && n.namespace_ ().empty ())
      {
        this->model_6_pos_distr_.set (model_6_pos_distr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "model_6_neg_distr" && n.namespace_ ().empty ())
      {
        this->model_6_neg_distr_.set (model_6_neg_distr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "obs_7_distr" && n.namespace_ ().empty ())
      {
        this->obs_7_distr_.set (obs_7_distr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "model_7_pos_distr" && n.namespace_ ().empty ())
      {
        this->model_7_pos_distr_.set (model_7_pos_distr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "model_7_neg_distr" && n.namespace_ ().empty ())
      {
        this->model_7_neg_distr_.set (model_7_neg_distr_traits::create (i, f, this));
        continue;
      }
    }

    if (!fvalue_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "fvalue",
        "");
    }

    if (!obs_1_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "obs_1_distr",
        "");
    }

    if (!model_1_pos_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "model_1_pos_distr",
        "");
    }

    if (!model_1_neg_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "model_1_neg_distr",
        "");
    }

    if (!obs_2_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "obs_2_distr",
        "");
    }

    if (!model_2_pos_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "model_2_pos_distr",
        "");
    }

    if (!model_2_neg_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "model_2_neg_distr",
        "");
    }

    if (!obs_3_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "obs_3_distr",
        "");
    }

    if (!model_3_pos_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "model_3_pos_distr",
        "");
    }

    if (!model_3_neg_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "model_3_neg_distr",
        "");
    }

    if (!obs_4_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "obs_4_distr",
        "");
    }

    if (!model_4_pos_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "model_4_pos_distr",
        "");
    }

    if (!model_4_neg_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "model_4_neg_distr",
        "");
    }

    if (!obs_5_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "obs_5_distr",
        "");
    }

    if (!model_5_pos_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "model_5_pos_distr",
        "");
    }

    if (!model_5_neg_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "model_5_neg_distr",
        "");
    }

    if (!obs_6_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "obs_6_distr",
        "");
    }

    if (!model_6_pos_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "model_6_pos_distr",
        "");
    }

    if (!model_6_neg_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "model_6_neg_distr",
        "");
    }

    if (!obs_7_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "obs_7_distr",
        "");
    }

    if (!model_7_pos_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "model_7_pos_distr",
        "");
    }

    if (!model_7_neg_distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "model_7_neg_distr",
        "");
    }
  }

  distribution_point* distribution_point::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class distribution_point (*this, f, c);
  }

  distribution_point& distribution_point::
  operator= (const distribution_point& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->fvalue_ = x.fvalue_;
      this->obs_1_distr_ = x.obs_1_distr_;
      this->model_1_pos_distr_ = x.model_1_pos_distr_;
      this->model_1_neg_distr_ = x.model_1_neg_distr_;
      this->obs_2_distr_ = x.obs_2_distr_;
      this->model_2_pos_distr_ = x.model_2_pos_distr_;
      this->model_2_neg_distr_ = x.model_2_neg_distr_;
      this->obs_3_distr_ = x.obs_3_distr_;
      this->model_3_pos_distr_ = x.model_3_pos_distr_;
      this->model_3_neg_distr_ = x.model_3_neg_distr_;
      this->obs_4_distr_ = x.obs_4_distr_;
      this->model_4_pos_distr_ = x.model_4_pos_distr_;
      this->model_4_neg_distr_ = x.model_4_neg_distr_;
      this->obs_5_distr_ = x.obs_5_distr_;
      this->model_5_pos_distr_ = x.model_5_pos_distr_;
      this->model_5_neg_distr_ = x.model_5_neg_distr_;
      this->obs_6_distr_ = x.obs_6_distr_;
      this->model_6_pos_distr_ = x.model_6_pos_distr_;
      this->model_6_neg_distr_ = x.model_6_neg_distr_;
      this->obs_7_distr_ = x.obs_7_distr_;
      this->model_7_pos_distr_ = x.model_7_pos_distr_;
      this->model_7_neg_distr_ = x.model_7_neg_distr_;
    }

    return *this;
  }

  distribution_point::
  ~distribution_point ()
  {
  }

  // mixture_model
  //

  mixture_model::
  mixture_model ()
  : ::xml_schema::type (),
    mixturemodel_distribution_ (this),
    mixturemodel_ (this),
    precursor_ion_charge_ (this),
    comments_ (this),
    prior_probability_ (this),
    est_tot_correct_ (this),
    tot_num_spectra_ (this),
    num_iterations_ (this)
  {
  }

  mixture_model::
  mixture_model (const precursor_ion_charge_type& precursor_ion_charge,
                 const comments_type& comments,
                 const prior_probability_type& prior_probability,
                 const est_tot_correct_type& est_tot_correct,
                 const tot_num_spectra_type& tot_num_spectra,
                 const num_iterations_type& num_iterations)
  : ::xml_schema::type (),
    mixturemodel_distribution_ (this),
    mixturemodel_ (this),
    precursor_ion_charge_ (precursor_ion_charge, this),
    comments_ (comments, this),
    prior_probability_ (prior_probability, this),
    est_tot_correct_ (est_tot_correct, this),
    tot_num_spectra_ (tot_num_spectra, this),
    num_iterations_ (num_iterations, this)
  {
  }

  mixture_model::
  mixture_model (const mixture_model& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    mixturemodel_distribution_ (x.mixturemodel_distribution_, f, this),
    mixturemodel_ (x.mixturemodel_, f, this),
    precursor_ion_charge_ (x.precursor_ion_charge_, f, this),
    comments_ (x.comments_, f, this),
    prior_probability_ (x.prior_probability_, f, this),
    est_tot_correct_ (x.est_tot_correct_, f, this),
    tot_num_spectra_ (x.tot_num_spectra_, f, this),
    num_iterations_ (x.num_iterations_, f, this)
  {
  }

  mixture_model::
  mixture_model (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    mixturemodel_distribution_ (this),
    mixturemodel_ (this),
    precursor_ion_charge_ (this),
    comments_ (this),
    prior_probability_ (this),
    est_tot_correct_ (this),
    tot_num_spectra_ (this),
    num_iterations_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void mixture_model::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // mixturemodel_distribution
      //
      if (n.name () == "mixturemodel_distribution" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< mixturemodel_distribution_type > r (
          mixturemodel_distribution_traits::create (i, f, this));

        this->mixturemodel_distribution_.push_back (::std::move (r));
        continue;
      }

      // mixturemodel
      //
      if (n.name () == "mixturemodel" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< mixturemodel_type > r (
          mixturemodel_traits::create (i, f, this));

        this->mixturemodel_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "precursor_ion_charge" && n.namespace_ ().empty ())
      {
        this->precursor_ion_charge_.set (precursor_ion_charge_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "comments" && n.namespace_ ().empty ())
      {
        this->comments_.set (comments_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "prior_probability" && n.namespace_ ().empty ())
      {
        this->prior_probability_.set (prior_probability_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "est_tot_correct" && n.namespace_ ().empty ())
      {
        this->est_tot_correct_.set (est_tot_correct_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "tot_num_spectra" && n.namespace_ ().empty ())
      {
        this->tot_num_spectra_.set (tot_num_spectra_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "num_iterations" && n.namespace_ ().empty ())
      {
        this->num_iterations_.set (num_iterations_traits::create (i, f, this));
        continue;
      }
    }

    if (!precursor_ion_charge_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "precursor_ion_charge",
        "");
    }

    if (!comments_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "comments",
        "");
    }

    if (!prior_probability_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "prior_probability",
        "");
    }

    if (!est_tot_correct_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "est_tot_correct",
        "");
    }

    if (!tot_num_spectra_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "tot_num_spectra",
        "");
    }

    if (!num_iterations_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "num_iterations",
        "");
    }
  }

  mixture_model* mixture_model::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class mixture_model (*this, f, c);
  }

  mixture_model& mixture_model::
  operator= (const mixture_model& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->mixturemodel_distribution_ = x.mixturemodel_distribution_;
      this->mixturemodel_ = x.mixturemodel_;
      this->precursor_ion_charge_ = x.precursor_ion_charge_;
      this->comments_ = x.comments_;
      this->prior_probability_ = x.prior_probability_;
      this->est_tot_correct_ = x.est_tot_correct_;
      this->tot_num_spectra_ = x.tot_num_spectra_;
      this->num_iterations_ = x.num_iterations_;
    }

    return *this;
  }

  mixture_model::
  ~mixture_model ()
  {
  }

  // mod_aminoacid_probability
  //

  mod_aminoacid_probability::
  mod_aminoacid_probability ()
  : ::xml_schema::type (),
    position_ (this),
    probability_ (this)
  {
  }

  mod_aminoacid_probability::
  mod_aminoacid_probability (const position_type& position,
                             const probability_type& probability)
  : ::xml_schema::type (),
    position_ (position, this),
    probability_ (probability, this)
  {
  }

  mod_aminoacid_probability::
  mod_aminoacid_probability (const mod_aminoacid_probability& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    position_ (x.position_, f, this),
    probability_ (x.probability_, f, this)
  {
  }

  mod_aminoacid_probability::
  mod_aminoacid_probability (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    position_ (this),
    probability_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void mod_aminoacid_probability::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "position" && n.namespace_ ().empty ())
      {
        this->position_.set (position_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "probability" && n.namespace_ ().empty ())
      {
        this->probability_.set (probability_traits::create (i, f, this));
        continue;
      }
    }

    if (!position_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "position",
        "");
    }

    if (!probability_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "probability",
        "");
    }
  }

  mod_aminoacid_probability* mod_aminoacid_probability::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class mod_aminoacid_probability (*this, f, c);
  }

  mod_aminoacid_probability& mod_aminoacid_probability::
  operator= (const mod_aminoacid_probability& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->position_ = x.position_;
      this->probability_ = x.probability_;
    }

    return *this;
  }

  mod_aminoacid_probability::
  ~mod_aminoacid_probability ()
  {
  }

  // search_score_summary
  //

  search_score_summary::
  search_score_summary ()
  : ::xml_schema::type (),
    parameter_ (this)
  {
  }

  search_score_summary::
  search_score_summary (const search_score_summary& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    parameter_ (x.parameter_, f, this)
  {
  }

  search_score_summary::
  search_score_summary (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    parameter_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void search_score_summary::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< parameter_type > r (
          parameter_traits::create (i, f, this));

        this->parameter_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  search_score_summary* search_score_summary::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class search_score_summary (*this, f, c);
  }

  search_score_summary& search_score_summary::
  operator= (const search_score_summary& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->parameter_ = x.parameter_;
    }

    return *this;
  }

  search_score_summary::
  ~search_score_summary ()
  {
  }

  // intensity
  //

  intensity::
  intensity ()
  : ::xml_schema::type (),
    channel_ (this),
    target_mass_ (this),
    absolute_ (this),
    normalized_ (this),
    reject_ (reject_default_value (), this)
  {
  }

  intensity::
  intensity (const channel_type& channel,
             const target_mass_type& target_mass,
             const absolute_type& absolute,
             const normalized_type& normalized)
  : ::xml_schema::type (),
    channel_ (channel, this),
    target_mass_ (target_mass, this),
    absolute_ (absolute, this),
    normalized_ (normalized, this),
    reject_ (reject_default_value (), this)
  {
  }

  intensity::
  intensity (const intensity& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    channel_ (x.channel_, f, this),
    target_mass_ (x.target_mass_, f, this),
    absolute_ (x.absolute_, f, this),
    normalized_ (x.normalized_, f, this),
    reject_ (x.reject_, f, this)
  {
  }

  intensity::
  intensity (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    channel_ (this),
    target_mass_ (this),
    absolute_ (this),
    normalized_ (this),
    reject_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void intensity::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "channel" && n.namespace_ ().empty ())
      {
        this->channel_.set (channel_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "target_mass" && n.namespace_ ().empty ())
      {
        this->target_mass_.set (target_mass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "absolute" && n.namespace_ ().empty ())
      {
        this->absolute_.set (absolute_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "normalized" && n.namespace_ ().empty ())
      {
        this->normalized_.set (normalized_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "reject" && n.namespace_ ().empty ())
      {
        this->reject_.set (reject_traits::create (i, f, this));
        continue;
      }
    }

    if (!channel_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "channel",
        "");
    }

    if (!target_mass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "target_mass",
        "");
    }

    if (!absolute_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "absolute",
        "");
    }

    if (!normalized_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "normalized",
        "");
    }

    if (!reject_.present ())
    {
      this->reject_.set (reject_default_value ());
    }
  }

  intensity* intensity::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class intensity (*this, f, c);
  }

  intensity& intensity::
  operator= (const intensity& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->channel_ = x.channel_;
      this->target_mass_ = x.target_mass_;
      this->absolute_ = x.absolute_;
      this->normalized_ = x.normalized_;
      this->reject_ = x.reject_;
    }

    return *this;
  }

  intensity::
  ~intensity ()
  {
  }

  // fragment_masses
  //

  fragment_masses::
  fragment_masses ()
  : ::xml_schema::type (),
    channel_ (this),
    mz_ (this),
    offset_ (this)
  {
  }

  fragment_masses::
  fragment_masses (const channel_type& channel,
                   const mz_type& mz)
  : ::xml_schema::type (),
    channel_ (channel, this),
    mz_ (mz, this),
    offset_ (this)
  {
  }

  fragment_masses::
  fragment_masses (const fragment_masses& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    channel_ (x.channel_, f, this),
    mz_ (x.mz_, f, this),
    offset_ (x.offset_, f, this)
  {
  }

  fragment_masses::
  fragment_masses (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    channel_ (this),
    mz_ (this),
    offset_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void fragment_masses::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "channel" && n.namespace_ ().empty ())
      {
        this->channel_.set (channel_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "mz" && n.namespace_ ().empty ())
      {
        this->mz_.set (mz_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "offset" && n.namespace_ ().empty ())
      {
        this->offset_.set (offset_traits::create (i, f, this));
        continue;
      }
    }

    if (!channel_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "channel",
        "");
    }

    if (!mz_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mz",
        "");
    }
  }

  fragment_masses* fragment_masses::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class fragment_masses (*this, f, c);
  }

  fragment_masses& fragment_masses::
  operator= (const fragment_masses& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->channel_ = x.channel_;
      this->mz_ = x.mz_;
      this->offset_ = x.offset_;
    }

    return *this;
  }

  fragment_masses::
  ~fragment_masses ()
  {
  }

  // isotopic_contributions
  //

  isotopic_contributions::
  isotopic_contributions ()
  : ::xml_schema::type (),
    contributing_channel_ (this)
  {
  }

  isotopic_contributions::
  isotopic_contributions (const isotopic_contributions& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    contributing_channel_ (x.contributing_channel_, f, this)
  {
  }

  isotopic_contributions::
  isotopic_contributions (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    contributing_channel_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void isotopic_contributions::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // contributing_channel
      //
      if (n.name () == "contributing_channel" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< contributing_channel_type > r (
          contributing_channel_traits::create (i, f, this));

        this->contributing_channel_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  isotopic_contributions* isotopic_contributions::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class isotopic_contributions (*this, f, c);
  }

  isotopic_contributions& isotopic_contributions::
  operator= (const isotopic_contributions& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->contributing_channel_ = x.contributing_channel_;
    }

    return *this;
  }

  isotopic_contributions::
  ~isotopic_contributions ()
  {
  }

  // data_filter
  //

  data_filter::
  data_filter ()
  : ::xml_schema::type (),
    number_ (this),
    parent_file_ (this),
    windows_parent_ (this),
    description_ (this)
  {
  }

  data_filter::
  data_filter (const number_type& number,
               const parent_file_type& parent_file,
               const description_type& description)
  : ::xml_schema::type (),
    number_ (number, this),
    parent_file_ (parent_file, this),
    windows_parent_ (this),
    description_ (description, this)
  {
  }

  data_filter::
  data_filter (const data_filter& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    number_ (x.number_, f, this),
    parent_file_ (x.parent_file_, f, this),
    windows_parent_ (x.windows_parent_, f, this),
    description_ (x.description_, f, this)
  {
  }

  data_filter::
  data_filter (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    number_ (this),
    parent_file_ (this),
    windows_parent_ (this),
    description_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void data_filter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "parent_file" && n.namespace_ ().empty ())
      {
        this->parent_file_.set (parent_file_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "windows_parent" && n.namespace_ ().empty ())
      {
        this->windows_parent_.set (windows_parent_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "description" && n.namespace_ ().empty ())
      {
        this->description_.set (description_traits::create (i, f, this));
        continue;
      }
    }

    if (!number_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "number",
        "");
    }

    if (!parent_file_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "parent_file",
        "");
    }

    if (!description_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "description",
        "");
    }
  }

  data_filter* data_filter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class data_filter (*this, f, c);
  }

  data_filter& data_filter::
  operator= (const data_filter& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->number_ = x.number_;
      this->parent_file_ = x.parent_file_;
      this->windows_parent_ = x.windows_parent_;
      this->description_ = x.description_;
    }

    return *this;
  }

  data_filter::
  ~data_filter ()
  {
  }

  // sample_enzyme
  //

  const sample_enzyme::fidelity_type sample_enzyme::fidelity_default_value_ (
    "specific");

  sample_enzyme::
  sample_enzyme ()
  : ::xml_schema::type (),
    specificity_ (this),
    name_ (this),
    description_ (this),
    fidelity_ (fidelity_default_value (), this),
    independent_ (independent_default_value (), this)
  {
  }

  sample_enzyme::
  sample_enzyme (const name_type& name)
  : ::xml_schema::type (),
    specificity_ (this),
    name_ (name, this),
    description_ (this),
    fidelity_ (fidelity_default_value (), this),
    independent_ (independent_default_value (), this)
  {
  }

  sample_enzyme::
  sample_enzyme (const sample_enzyme& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    specificity_ (x.specificity_, f, this),
    name_ (x.name_, f, this),
    description_ (x.description_, f, this),
    fidelity_ (x.fidelity_, f, this),
    independent_ (x.independent_, f, this)
  {
  }

  sample_enzyme::
  sample_enzyme (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    specificity_ (this),
    name_ (this),
    description_ (this),
    fidelity_ (this),
    independent_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void sample_enzyme::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // specificity
      //
      if (n.name () == "specificity" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< specificity_type > r (
          specificity_traits::create (i, f, this));

        this->specificity_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "description" && n.namespace_ ().empty ())
      {
        this->description_.set (description_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "fidelity" && n.namespace_ ().empty ())
      {
        this->fidelity_.set (fidelity_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "independent" && n.namespace_ ().empty ())
      {
        this->independent_.set (independent_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!fidelity_.present ())
    {
      this->fidelity_.set (fidelity_default_value ());
    }

    if (!independent_.present ())
    {
      this->independent_.set (independent_default_value ());
    }
  }

  sample_enzyme* sample_enzyme::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class sample_enzyme (*this, f, c);
  }

  sample_enzyme& sample_enzyme::
  operator= (const sample_enzyme& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->specificity_ = x.specificity_;
      this->name_ = x.name_;
      this->description_ = x.description_;
      this->fidelity_ = x.fidelity_;
      this->independent_ = x.independent_;
    }

    return *this;
  }

  sample_enzyme::
  ~sample_enzyme ()
  {
  }

  // cross_linker
  //

  cross_linker::
  cross_linker ()
  : ::xml_schema::type (),
    cross_linker_info_ (this),
    identifier_ (this),
    mass_ (this),
    link_sites_ (this),
    isotope_labeled_ (this)
  {
  }

  cross_linker::
  cross_linker (const identifier_type& identifier,
                const mass_type& mass,
                const link_sites_type& link_sites,
                const isotope_labeled_type& isotope_labeled)
  : ::xml_schema::type (),
    cross_linker_info_ (this),
    identifier_ (identifier, this),
    mass_ (mass, this),
    link_sites_ (link_sites, this),
    isotope_labeled_ (isotope_labeled, this)
  {
  }

  cross_linker::
  cross_linker (const cross_linker& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    cross_linker_info_ (x.cross_linker_info_, f, this),
    identifier_ (x.identifier_, f, this),
    mass_ (x.mass_, f, this),
    link_sites_ (x.link_sites_, f, this),
    isotope_labeled_ (x.isotope_labeled_, f, this)
  {
  }

  cross_linker::
  cross_linker (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    cross_linker_info_ (this),
    identifier_ (this),
    mass_ (this),
    link_sites_ (this),
    isotope_labeled_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void cross_linker::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // cross_linker_info
      //
      if (n.name () == "cross_linker_info" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< cross_linker_info_type > r (
          cross_linker_info_traits::create (i, f, this));

        this->cross_linker_info_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "identifier" && n.namespace_ ().empty ())
      {
        this->identifier_.set (identifier_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "mass" && n.namespace_ ().empty ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "link_sites" && n.namespace_ ().empty ())
      {
        this->link_sites_.set (link_sites_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isotope_labeled" && n.namespace_ ().empty ())
      {
        this->isotope_labeled_.set (isotope_labeled_traits::create (i, f, this));
        continue;
      }
    }

    if (!identifier_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "identifier",
        "");
    }

    if (!mass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mass",
        "");
    }

    if (!link_sites_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "link_sites",
        "");
    }

    if (!isotope_labeled_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "isotope_labeled",
        "");
    }
  }

  cross_linker* cross_linker::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class cross_linker (*this, f, c);
  }

  cross_linker& cross_linker::
  operator= (const cross_linker& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->cross_linker_info_ = x.cross_linker_info_;
      this->identifier_ = x.identifier_;
      this->mass_ = x.mass_;
      this->link_sites_ = x.link_sites_;
      this->isotope_labeled_ = x.isotope_labeled_;
    }

    return *this;
  }

  cross_linker::
  ~cross_linker ()
  {
  }

  // search_summary
  //

  search_summary::
  search_summary ()
  : ::xml_schema::type (),
    search_database_ (this),
    enzymatic_search_constraint_ (this),
    sequence_search_constraint_ (this),
    aminoacid_modification_ (this),
    terminal_modification_ (this),
    parameter_ (this),
    base_name_ (this),
    search_engine_ (this),
    search_engine_version_ (this),
    precursor_mass_type_ (this),
    fragment_mass_type_ (this),
    out_data_type_ (this),
    out_data_ (this),
    search_id_ (this)
  {
  }

  search_summary::
  search_summary (const base_name_type& base_name,
                  const search_engine_type& search_engine,
                  const precursor_mass_type_type& precursor_mass_type,
                  const fragment_mass_type_type& fragment_mass_type,
                  const search_id_type& search_id)
  : ::xml_schema::type (),
    search_database_ (this),
    enzymatic_search_constraint_ (this),
    sequence_search_constraint_ (this),
    aminoacid_modification_ (this),
    terminal_modification_ (this),
    parameter_ (this),
    base_name_ (base_name, this),
    search_engine_ (search_engine, this),
    search_engine_version_ (this),
    precursor_mass_type_ (precursor_mass_type, this),
    fragment_mass_type_ (fragment_mass_type, this),
    out_data_type_ (this),
    out_data_ (this),
    search_id_ (search_id, this)
  {
  }

  search_summary::
  search_summary (const search_summary& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    search_database_ (x.search_database_, f, this),
    enzymatic_search_constraint_ (x.enzymatic_search_constraint_, f, this),
    sequence_search_constraint_ (x.sequence_search_constraint_, f, this),
    aminoacid_modification_ (x.aminoacid_modification_, f, this),
    terminal_modification_ (x.terminal_modification_, f, this),
    parameter_ (x.parameter_, f, this),
    base_name_ (x.base_name_, f, this),
    search_engine_ (x.search_engine_, f, this),
    search_engine_version_ (x.search_engine_version_, f, this),
    precursor_mass_type_ (x.precursor_mass_type_, f, this),
    fragment_mass_type_ (x.fragment_mass_type_, f, this),
    out_data_type_ (x.out_data_type_, f, this),
    out_data_ (x.out_data_, f, this),
    search_id_ (x.search_id_, f, this)
  {
  }

  search_summary::
  search_summary (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    search_database_ (this),
    enzymatic_search_constraint_ (this),
    sequence_search_constraint_ (this),
    aminoacid_modification_ (this),
    terminal_modification_ (this),
    parameter_ (this),
    base_name_ (this),
    search_engine_ (this),
    search_engine_version_ (this),
    precursor_mass_type_ (this),
    fragment_mass_type_ (this),
    out_data_type_ (this),
    out_data_ (this),
    search_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void search_summary::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // search_database
      //
      if (n.name () == "search_database" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< search_database_type > r (
          search_database_traits::create (i, f, this));

        if (!this->search_database_)
        {
          this->search_database_.set (::std::move (r));
          continue;
        }
      }

      // enzymatic_search_constraint
      //
      if (n.name () == "enzymatic_search_constraint" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< enzymatic_search_constraint_type > r (
          enzymatic_search_constraint_traits::create (i, f, this));

        if (!this->enzymatic_search_constraint_)
        {
          this->enzymatic_search_constraint_.set (::std::move (r));
          continue;
        }
      }

      // sequence_search_constraint
      //
      if (n.name () == "sequence_search_constraint" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< sequence_search_constraint_type > r (
          sequence_search_constraint_traits::create (i, f, this));

        this->sequence_search_constraint_.push_back (::std::move (r));
        continue;
      }

      // aminoacid_modification
      //
      if (n.name () == "aminoacid_modification" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< aminoacid_modification_type > r (
          aminoacid_modification_traits::create (i, f, this));

        this->aminoacid_modification_.push_back (::std::move (r));
        continue;
      }

      // terminal_modification
      //
      if (n.name () == "terminal_modification" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< terminal_modification_type > r (
          terminal_modification_traits::create (i, f, this));

        this->terminal_modification_.push_back (::std::move (r));
        continue;
      }

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< parameter_type > r (
          parameter_traits::create (i, f, this));

        this->parameter_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "base_name" && n.namespace_ ().empty ())
      {
        this->base_name_.set (base_name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "search_engine" && n.namespace_ ().empty ())
      {
        this->search_engine_.set (search_engine_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "search_engine_version" && n.namespace_ ().empty ())
      {
        this->search_engine_version_.set (search_engine_version_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "precursor_mass_type" && n.namespace_ ().empty ())
      {
        this->precursor_mass_type_.set (precursor_mass_type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "fragment_mass_type" && n.namespace_ ().empty ())
      {
        this->fragment_mass_type_.set (fragment_mass_type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "out_data_type" && n.namespace_ ().empty ())
      {
        this->out_data_type_.set (out_data_type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "out_data" && n.namespace_ ().empty ())
      {
        this->out_data_.set (out_data_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "search_id" && n.namespace_ ().empty ())
      {
        this->search_id_.set (search_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!base_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "base_name",
        "");
    }

    if (!search_engine_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "search_engine",
        "");
    }

    if (!precursor_mass_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "precursor_mass_type",
        "");
    }

    if (!fragment_mass_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "fragment_mass_type",
        "");
    }

    if (!search_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "search_id",
        "");
    }
  }

  search_summary* search_summary::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class search_summary (*this, f, c);
  }

  search_summary& search_summary::
  operator= (const search_summary& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->search_database_ = x.search_database_;
      this->enzymatic_search_constraint_ = x.enzymatic_search_constraint_;
      this->sequence_search_constraint_ = x.sequence_search_constraint_;
      this->aminoacid_modification_ = x.aminoacid_modification_;
      this->terminal_modification_ = x.terminal_modification_;
      this->parameter_ = x.parameter_;
      this->base_name_ = x.base_name_;
      this->search_engine_ = x.search_engine_;
      this->search_engine_version_ = x.search_engine_version_;
      this->precursor_mass_type_ = x.precursor_mass_type_;
      this->fragment_mass_type_ = x.fragment_mass_type_;
      this->out_data_type_ = x.out_data_type_;
      this->out_data_ = x.out_data_;
      this->search_id_ = x.search_id_;
    }

    return *this;
  }

  search_summary::
  ~search_summary ()
  {
  }

  // analysis_timestamp
  //

  analysis_timestamp::
  analysis_timestamp ()
  : ::xml_schema::type (),
    time_ (this),
    analysis_ (this),
    id_ (this)
  {
  }

  analysis_timestamp::
  analysis_timestamp (const time_type& time,
                      const analysis_type& analysis,
                      const id_type& id)
  : ::xml_schema::type (),
    time_ (time, this),
    analysis_ (analysis, this),
    id_ (id, this)
  {
  }

  analysis_timestamp::
  analysis_timestamp (const analysis_timestamp& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    time_ (x.time_, f, this),
    analysis_ (x.analysis_, f, this),
    id_ (x.id_, f, this)
  {
  }

  analysis_timestamp::
  analysis_timestamp (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    time_ (this),
    analysis_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void analysis_timestamp::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "time" && n.namespace_ ().empty ())
      {
        this->time_.set (time_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "analysis" && n.namespace_ ().empty ())
      {
        this->analysis_.set (analysis_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!time_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "time",
        "");
    }

    if (!analysis_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "analysis",
        "");
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  analysis_timestamp* analysis_timestamp::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class analysis_timestamp (*this, f, c);
  }

  analysis_timestamp& analysis_timestamp::
  operator= (const analysis_timestamp& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->time_ = x.time_;
      this->analysis_ = x.analysis_;
      this->id_ = x.id_;
    }

    return *this;
  }

  analysis_timestamp::
  ~analysis_timestamp ()
  {
  }

  // spectrum_query
  //

  spectrum_query::
  spectrum_query ()
  : ::xml_schema::type (),
    search_result_ (this),
    spectrum_ (this),
    spectrumNativeID_ (this),
    start_scan_ (this),
    end_scan_ (this),
    retention_time_sec_ (this),
    collision_energy_ (this),
    compensation_voltage_ (this),
    precursor_intensity_ (this),
    activation_method_ (this),
    precursor_neutral_mass_ (this),
    assumed_charge_ (this),
    search_specification_ (this),
    index_ (this)
  {
  }

  spectrum_query::
  spectrum_query (const spectrum_type& spectrum,
                  const start_scan_type& start_scan,
                  const end_scan_type& end_scan,
                  const precursor_neutral_mass_type& precursor_neutral_mass,
                  const assumed_charge_type& assumed_charge,
                  const index_type& index)
  : ::xml_schema::type (),
    search_result_ (this),
    spectrum_ (spectrum, this),
    spectrumNativeID_ (this),
    start_scan_ (start_scan, this),
    end_scan_ (end_scan, this),
    retention_time_sec_ (this),
    collision_energy_ (this),
    compensation_voltage_ (this),
    precursor_intensity_ (this),
    activation_method_ (this),
    precursor_neutral_mass_ (precursor_neutral_mass, this),
    assumed_charge_ (assumed_charge, this),
    search_specification_ (this),
    index_ (index, this)
  {
  }

  spectrum_query::
  spectrum_query (const spectrum_query& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    search_result_ (x.search_result_, f, this),
    spectrum_ (x.spectrum_, f, this),
    spectrumNativeID_ (x.spectrumNativeID_, f, this),
    start_scan_ (x.start_scan_, f, this),
    end_scan_ (x.end_scan_, f, this),
    retention_time_sec_ (x.retention_time_sec_, f, this),
    collision_energy_ (x.collision_energy_, f, this),
    compensation_voltage_ (x.compensation_voltage_, f, this),
    precursor_intensity_ (x.precursor_intensity_, f, this),
    activation_method_ (x.activation_method_, f, this),
    precursor_neutral_mass_ (x.precursor_neutral_mass_, f, this),
    assumed_charge_ (x.assumed_charge_, f, this),
    search_specification_ (x.search_specification_, f, this),
    index_ (x.index_, f, this)
  {
  }

  spectrum_query::
  spectrum_query (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    search_result_ (this),
    spectrum_ (this),
    spectrumNativeID_ (this),
    start_scan_ (this),
    end_scan_ (this),
    retention_time_sec_ (this),
    collision_energy_ (this),
    compensation_voltage_ (this),
    precursor_intensity_ (this),
    activation_method_ (this),
    precursor_neutral_mass_ (this),
    assumed_charge_ (this),
    search_specification_ (this),
    index_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void spectrum_query::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // search_result
      //
      if (n.name () == "search_result" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< search_result_type > r (
          search_result_traits::create (i, f, this));

        this->search_result_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "spectrum" && n.namespace_ ().empty ())
      {
        this->spectrum_.set (spectrum_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "spectrumNativeID" && n.namespace_ ().empty ())
      {
        this->spectrumNativeID_.set (spectrumNativeID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "start_scan" && n.namespace_ ().empty ())
      {
        this->start_scan_.set (start_scan_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "end_scan" && n.namespace_ ().empty ())
      {
        this->end_scan_.set (end_scan_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "retention_time_sec" && n.namespace_ ().empty ())
      {
        this->retention_time_sec_.set (retention_time_sec_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "collision_energy" && n.namespace_ ().empty ())
      {
        this->collision_energy_.set (collision_energy_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "compensation_voltage" && n.namespace_ ().empty ())
      {
        this->compensation_voltage_.set (compensation_voltage_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "precursor_intensity" && n.namespace_ ().empty ())
      {
        this->precursor_intensity_.set (precursor_intensity_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "activation_method" && n.namespace_ ().empty ())
      {
        this->activation_method_.set (activation_method_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "precursor_neutral_mass" && n.namespace_ ().empty ())
      {
        this->precursor_neutral_mass_.set (precursor_neutral_mass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "assumed_charge" && n.namespace_ ().empty ())
      {
        this->assumed_charge_.set (assumed_charge_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "search_specification" && n.namespace_ ().empty ())
      {
        this->search_specification_.set (search_specification_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "index" && n.namespace_ ().empty ())
      {
        this->index_.set (index_traits::create (i, f, this));
        continue;
      }
    }

    if (!spectrum_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "spectrum",
        "");
    }

    if (!start_scan_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "start_scan",
        "");
    }

    if (!end_scan_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "end_scan",
        "");
    }

    if (!precursor_neutral_mass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "precursor_neutral_mass",
        "");
    }

    if (!assumed_charge_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "assumed_charge",
        "");
    }

    if (!index_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "index",
        "");
    }
  }

  spectrum_query* spectrum_query::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class spectrum_query (*this, f, c);
  }

  spectrum_query& spectrum_query::
  operator= (const spectrum_query& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->search_result_ = x.search_result_;
      this->spectrum_ = x.spectrum_;
      this->spectrumNativeID_ = x.spectrumNativeID_;
      this->start_scan_ = x.start_scan_;
      this->end_scan_ = x.end_scan_;
      this->retention_time_sec_ = x.retention_time_sec_;
      this->collision_energy_ = x.collision_energy_;
      this->compensation_voltage_ = x.compensation_voltage_;
      this->precursor_intensity_ = x.precursor_intensity_;
      this->activation_method_ = x.activation_method_;
      this->precursor_neutral_mass_ = x.precursor_neutral_mass_;
      this->assumed_charge_ = x.assumed_charge_;
      this->search_specification_ = x.search_specification_;
      this->index_ = x.index_;
    }

    return *this;
  }

  spectrum_query::
  ~spectrum_query ()
  {
  }

  // mixturemodel_distribution
  //

  mixturemodel_distribution::
  mixturemodel_distribution ()
  : ::xml_schema::type (),
    posmodel_distribution_ (this),
    negmodel_distribution_ (this),
    name_ (this)
  {
  }

  mixturemodel_distribution::
  mixturemodel_distribution (const posmodel_distribution_type& posmodel_distribution,
                             const negmodel_distribution_type& negmodel_distribution,
                             const name_type& name)
  : ::xml_schema::type (),
    posmodel_distribution_ (posmodel_distribution, this),
    negmodel_distribution_ (negmodel_distribution, this),
    name_ (name, this)
  {
  }

  mixturemodel_distribution::
  mixturemodel_distribution (::std::unique_ptr< posmodel_distribution_type > posmodel_distribution,
                             ::std::unique_ptr< negmodel_distribution_type > negmodel_distribution,
                             const name_type& name)
  : ::xml_schema::type (),
    posmodel_distribution_ (std::move (posmodel_distribution), this),
    negmodel_distribution_ (std::move (negmodel_distribution), this),
    name_ (name, this)
  {
  }

  mixturemodel_distribution::
  mixturemodel_distribution (const mixturemodel_distribution& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    posmodel_distribution_ (x.posmodel_distribution_, f, this),
    negmodel_distribution_ (x.negmodel_distribution_, f, this),
    name_ (x.name_, f, this)
  {
  }

  mixturemodel_distribution::
  mixturemodel_distribution (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    posmodel_distribution_ (this),
    negmodel_distribution_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void mixturemodel_distribution::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // posmodel_distribution
      //
      if (n.name () == "posmodel_distribution" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< posmodel_distribution_type > r (
          posmodel_distribution_traits::create (i, f, this));

        if (!posmodel_distribution_.present ())
        {
          this->posmodel_distribution_.set (::std::move (r));
          continue;
        }
      }

      // negmodel_distribution
      //
      if (n.name () == "negmodel_distribution" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< negmodel_distribution_type > r (
          negmodel_distribution_traits::create (i, f, this));

        if (!negmodel_distribution_.present ())
        {
          this->negmodel_distribution_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!posmodel_distribution_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "posmodel_distribution",
        "http://regis-web.systemsbiology.net/pepXML");
    }

    if (!negmodel_distribution_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "negmodel_distribution",
        "http://regis-web.systemsbiology.net/pepXML");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  mixturemodel_distribution* mixturemodel_distribution::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class mixturemodel_distribution (*this, f, c);
  }

  mixturemodel_distribution& mixturemodel_distribution::
  operator= (const mixturemodel_distribution& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->posmodel_distribution_ = x.posmodel_distribution_;
      this->negmodel_distribution_ = x.negmodel_distribution_;
      this->name_ = x.name_;
    }

    return *this;
  }

  mixturemodel_distribution::
  ~mixturemodel_distribution ()
  {
  }

  // mixturemodel
  //

  mixturemodel::
  mixturemodel ()
  : ::xml_schema::type (),
    point_ (this),
    name_ (this),
    pos_bandwidth_ (this),
    neg_bandwidth_ (this)
  {
  }

  mixturemodel::
  mixturemodel (const name_type& name,
                const pos_bandwidth_type& pos_bandwidth,
                const neg_bandwidth_type& neg_bandwidth)
  : ::xml_schema::type (),
    point_ (this),
    name_ (name, this),
    pos_bandwidth_ (pos_bandwidth, this),
    neg_bandwidth_ (neg_bandwidth, this)
  {
  }

  mixturemodel::
  mixturemodel (const mixturemodel& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    point_ (x.point_, f, this),
    name_ (x.name_, f, this),
    pos_bandwidth_ (x.pos_bandwidth_, f, this),
    neg_bandwidth_ (x.neg_bandwidth_, f, this)
  {
  }

  mixturemodel::
  mixturemodel (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    point_ (this),
    name_ (this),
    pos_bandwidth_ (this),
    neg_bandwidth_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void mixturemodel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // point
      //
      if (n.name () == "point" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< point_type > r (
          point_traits::create (i, f, this));

        this->point_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "pos_bandwidth" && n.namespace_ ().empty ())
      {
        this->pos_bandwidth_.set (pos_bandwidth_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "neg_bandwidth" && n.namespace_ ().empty ())
      {
        this->neg_bandwidth_.set (neg_bandwidth_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!pos_bandwidth_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "pos_bandwidth",
        "");
    }

    if (!neg_bandwidth_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "neg_bandwidth",
        "");
    }
  }

  mixturemodel* mixturemodel::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class mixturemodel (*this, f, c);
  }

  mixturemodel& mixturemodel::
  operator= (const mixturemodel& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->point_ = x.point_;
      this->name_ = x.name_;
      this->pos_bandwidth_ = x.pos_bandwidth_;
      this->neg_bandwidth_ = x.neg_bandwidth_;
    }

    return *this;
  }

  mixturemodel::
  ~mixturemodel ()
  {
  }

  // contributing_channel
  //

  contributing_channel::
  contributing_channel ()
  : ::xml_schema::type (),
    affected_channel_ (this),
    channel_ (this)
  {
  }

  contributing_channel::
  contributing_channel (const channel_type& channel)
  : ::xml_schema::type (),
    affected_channel_ (this),
    channel_ (channel, this)
  {
  }

  contributing_channel::
  contributing_channel (const contributing_channel& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    affected_channel_ (x.affected_channel_, f, this),
    channel_ (x.channel_, f, this)
  {
  }

  contributing_channel::
  contributing_channel (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    affected_channel_ (this),
    channel_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void contributing_channel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // affected_channel
      //
      if (n.name () == "affected_channel" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< affected_channel_type > r (
          affected_channel_traits::create (i, f, this));

        this->affected_channel_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "channel" && n.namespace_ ().empty ())
      {
        this->channel_.set (channel_traits::create (i, f, this));
        continue;
      }
    }

    if (!channel_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "channel",
        "");
    }
  }

  contributing_channel* contributing_channel::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class contributing_channel (*this, f, c);
  }

  contributing_channel& contributing_channel::
  operator= (const contributing_channel& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->affected_channel_ = x.affected_channel_;
      this->channel_ = x.channel_;
    }

    return *this;
  }

  contributing_channel::
  ~contributing_channel ()
  {
  }

  // specificity
  //

  specificity::
  specificity ()
  : ::xml_schema::type (),
    sense_ (this),
    min_spacing_ (min_spacing_default_value (), this),
    cut_ (this),
    no_cut_ (this)
  {
  }

  specificity::
  specificity (const sense_type& sense,
               const cut_type& cut)
  : ::xml_schema::type (),
    sense_ (sense, this),
    min_spacing_ (min_spacing_default_value (), this),
    cut_ (cut, this),
    no_cut_ (this)
  {
  }

  specificity::
  specificity (const specificity& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sense_ (x.sense_, f, this),
    min_spacing_ (x.min_spacing_, f, this),
    cut_ (x.cut_, f, this),
    no_cut_ (x.no_cut_, f, this)
  {
  }

  specificity::
  specificity (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sense_ (this),
    min_spacing_ (this),
    cut_ (this),
    no_cut_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void specificity::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "sense" && n.namespace_ ().empty ())
      {
        this->sense_.set (sense_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "min_spacing" && n.namespace_ ().empty ())
      {
        this->min_spacing_.set (min_spacing_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "cut" && n.namespace_ ().empty ())
      {
        this->cut_.set (cut_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "no_cut" && n.namespace_ ().empty ())
      {
        this->no_cut_.set (no_cut_traits::create (i, f, this));
        continue;
      }
    }

    if (!sense_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "sense",
        "");
    }

    if (!min_spacing_.present ())
    {
      this->min_spacing_.set (min_spacing_default_value ());
    }

    if (!cut_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "cut",
        "");
    }
  }

  specificity* specificity::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class specificity (*this, f, c);
  }

  specificity& specificity::
  operator= (const specificity& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->sense_ = x.sense_;
      this->min_spacing_ = x.min_spacing_;
      this->cut_ = x.cut_;
      this->no_cut_ = x.no_cut_;
    }

    return *this;
  }

  specificity::
  ~specificity ()
  {
  }

  // name
  //

  name::
  name ()
  : ::xml_schema::string ()
  {
  }

  name::
  name (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  name::
  name (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  name::
  name (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  name::
  name (const name& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  name::
  name (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  name::
  name (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  name::
  name (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  name* name::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class name (*this, f, c);
  }

  name::
  ~name ()
  {
  }

  // fidelity
  //

  fidelity::
  fidelity (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_fidelity_convert ();
  }

  fidelity::
  fidelity (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_fidelity_convert ();
  }

  fidelity::
  fidelity (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_fidelity_convert ();
  }

  fidelity* fidelity::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class fidelity (*this, f, c);
  }

  fidelity::value fidelity::
  _xsd_fidelity_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_fidelity_literals_);
    const value* i (::std::lower_bound (
                      _xsd_fidelity_indexes_,
                      _xsd_fidelity_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_fidelity_indexes_ + 3 || _xsd_fidelity_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const fidelity::
  _xsd_fidelity_literals_[3] =
  {
    "specific",
    "semispecific",
    "nonspecific"
  };

  const fidelity::value fidelity::
  _xsd_fidelity_indexes_[3] =
  {
    ::pepXML::fidelity::nonspecific,
    ::pepXML::fidelity::semispecific,
    ::pepXML::fidelity::specific
  };

  // isotope_labeled
  //

  isotope_labeled::
  isotope_labeled (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_isotope_labeled_convert ();
  }

  isotope_labeled::
  isotope_labeled (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_isotope_labeled_convert ();
  }

  isotope_labeled::
  isotope_labeled (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_isotope_labeled_convert ();
  }

  isotope_labeled* isotope_labeled::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class isotope_labeled (*this, f, c);
  }

  isotope_labeled::value isotope_labeled::
  _xsd_isotope_labeled_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_isotope_labeled_literals_);
    const value* i (::std::lower_bound (
                      _xsd_isotope_labeled_indexes_,
                      _xsd_isotope_labeled_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_isotope_labeled_indexes_ + 2 || _xsd_isotope_labeled_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const isotope_labeled::
  _xsd_isotope_labeled_literals_[2] =
  {
    "Y",
    "N"
  };

  const isotope_labeled::value isotope_labeled::
  _xsd_isotope_labeled_indexes_[2] =
  {
    ::pepXML::isotope_labeled::N,
    ::pepXML::isotope_labeled::Y
  };

  // search_database
  //

  search_database::
  search_database ()
  : ::xml_schema::type (),
    local_path_ (this),
    URL_ (this),
    database_name_ (this),
    orig_database_url_ (this),
    database_release_date_ (this),
    database_release_identifier_ (this),
    size_in_db_entries_ (this),
    size_of_residues_ (this),
    type_ (this)
  {
  }

  search_database::
  search_database (const local_path_type& local_path,
                   const type_type& type)
  : ::xml_schema::type (),
    local_path_ (local_path, this),
    URL_ (this),
    database_name_ (this),
    orig_database_url_ (this),
    database_release_date_ (this),
    database_release_identifier_ (this),
    size_in_db_entries_ (this),
    size_of_residues_ (this),
    type_ (type, this)
  {
  }

  search_database::
  search_database (const search_database& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    local_path_ (x.local_path_, f, this),
    URL_ (x.URL_, f, this),
    database_name_ (x.database_name_, f, this),
    orig_database_url_ (x.orig_database_url_, f, this),
    database_release_date_ (x.database_release_date_, f, this),
    database_release_identifier_ (x.database_release_identifier_, f, this),
    size_in_db_entries_ (x.size_in_db_entries_, f, this),
    size_of_residues_ (x.size_of_residues_, f, this),
    type_ (x.type_, f, this)
  {
  }

  search_database::
  search_database (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    local_path_ (this),
    URL_ (this),
    database_name_ (this),
    orig_database_url_ (this),
    database_release_date_ (this),
    database_release_identifier_ (this),
    size_in_db_entries_ (this),
    size_of_residues_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void search_database::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "local_path" && n.namespace_ ().empty ())
      {
        this->local_path_.set (local_path_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "URL" && n.namespace_ ().empty ())
      {
        this->URL_.set (URL_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "database_name" && n.namespace_ ().empty ())
      {
        this->database_name_.set (database_name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "orig_database_url" && n.namespace_ ().empty ())
      {
        this->orig_database_url_.set (orig_database_url_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "database_release_date" && n.namespace_ ().empty ())
      {
        this->database_release_date_.set (database_release_date_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "database_release_identifier" && n.namespace_ ().empty ())
      {
        this->database_release_identifier_.set (database_release_identifier_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "size_in_db_entries" && n.namespace_ ().empty ())
      {
        this->size_in_db_entries_.set (size_in_db_entries_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "size_of_residues" && n.namespace_ ().empty ())
      {
        this->size_of_residues_.set (size_of_residues_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!local_path_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "local_path",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  search_database* search_database::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class search_database (*this, f, c);
  }

  search_database& search_database::
  operator= (const search_database& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->local_path_ = x.local_path_;
      this->URL_ = x.URL_;
      this->database_name_ = x.database_name_;
      this->orig_database_url_ = x.orig_database_url_;
      this->database_release_date_ = x.database_release_date_;
      this->database_release_identifier_ = x.database_release_identifier_;
      this->size_in_db_entries_ = x.size_in_db_entries_;
      this->size_of_residues_ = x.size_of_residues_;
      this->type_ = x.type_;
    }

    return *this;
  }

  search_database::
  ~search_database ()
  {
  }

  // enzymatic_search_constraint
  //

  enzymatic_search_constraint::
  enzymatic_search_constraint ()
  : ::xml_schema::type (),
    enzyme_ (this),
    max_num_internal_cleavages_ (this),
    min_number_termini_ (this)
  {
  }

  enzymatic_search_constraint::
  enzymatic_search_constraint (const enzyme_type& enzyme,
                               const max_num_internal_cleavages_type& max_num_internal_cleavages,
                               const min_number_termini_type& min_number_termini)
  : ::xml_schema::type (),
    enzyme_ (enzyme, this),
    max_num_internal_cleavages_ (max_num_internal_cleavages, this),
    min_number_termini_ (min_number_termini, this)
  {
  }

  enzymatic_search_constraint::
  enzymatic_search_constraint (const enzymatic_search_constraint& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    enzyme_ (x.enzyme_, f, this),
    max_num_internal_cleavages_ (x.max_num_internal_cleavages_, f, this),
    min_number_termini_ (x.min_number_termini_, f, this)
  {
  }

  enzymatic_search_constraint::
  enzymatic_search_constraint (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    enzyme_ (this),
    max_num_internal_cleavages_ (this),
    min_number_termini_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void enzymatic_search_constraint::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "enzyme" && n.namespace_ ().empty ())
      {
        this->enzyme_.set (enzyme_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "max_num_internal_cleavages" && n.namespace_ ().empty ())
      {
        this->max_num_internal_cleavages_.set (max_num_internal_cleavages_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "min_number_termini" && n.namespace_ ().empty ())
      {
        this->min_number_termini_.set (min_number_termini_traits::create (i, f, this));
        continue;
      }
    }

    if (!enzyme_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "enzyme",
        "");
    }

    if (!max_num_internal_cleavages_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "max_num_internal_cleavages",
        "");
    }

    if (!min_number_termini_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "min_number_termini",
        "");
    }
  }

  enzymatic_search_constraint* enzymatic_search_constraint::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class enzymatic_search_constraint (*this, f, c);
  }

  enzymatic_search_constraint& enzymatic_search_constraint::
  operator= (const enzymatic_search_constraint& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->enzyme_ = x.enzyme_;
      this->max_num_internal_cleavages_ = x.max_num_internal_cleavages_;
      this->min_number_termini_ = x.min_number_termini_;
    }

    return *this;
  }

  enzymatic_search_constraint::
  ~enzymatic_search_constraint ()
  {
  }

  // sequence_search_constraint
  //

  sequence_search_constraint::
  sequence_search_constraint ()
  : ::xml_schema::type (),
    sequence_ (this)
  {
  }

  sequence_search_constraint::
  sequence_search_constraint (const sequence_type& sequence)
  : ::xml_schema::type (),
    sequence_ (sequence, this)
  {
  }

  sequence_search_constraint::
  sequence_search_constraint (const sequence_search_constraint& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sequence_ (x.sequence_, f, this)
  {
  }

  sequence_search_constraint::
  sequence_search_constraint (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sequence_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void sequence_search_constraint::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "sequence" && n.namespace_ ().empty ())
      {
        this->sequence_.set (sequence_traits::create (i, f, this));
        continue;
      }
    }

    if (!sequence_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "sequence",
        "");
    }
  }

  sequence_search_constraint* sequence_search_constraint::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class sequence_search_constraint (*this, f, c);
  }

  sequence_search_constraint& sequence_search_constraint::
  operator= (const sequence_search_constraint& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->sequence_ = x.sequence_;
    }

    return *this;
  }

  sequence_search_constraint::
  ~sequence_search_constraint ()
  {
  }

  // aminoacid_modification
  //

  aminoacid_modification::
  aminoacid_modification ()
  : ::xml_schema::type (),
    aminoacid_ (this),
    massdiff_ (this),
    mass_ (this),
    variable_ (this),
    peptide_terminus_ (this),
    protein_terminus_ (this),
    symbol_ (this),
    binary_ (this),
    description_ (this)
  {
  }

  aminoacid_modification::
  aminoacid_modification (const aminoacid_type& aminoacid,
                          const massdiff_type& massdiff,
                          const mass_type& mass,
                          const variable_type& variable)
  : ::xml_schema::type (),
    aminoacid_ (aminoacid, this),
    massdiff_ (massdiff, this),
    mass_ (mass, this),
    variable_ (variable, this),
    peptide_terminus_ (this),
    protein_terminus_ (this),
    symbol_ (this),
    binary_ (this),
    description_ (this)
  {
  }

  aminoacid_modification::
  aminoacid_modification (const aminoacid_modification& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    aminoacid_ (x.aminoacid_, f, this),
    massdiff_ (x.massdiff_, f, this),
    mass_ (x.mass_, f, this),
    variable_ (x.variable_, f, this),
    peptide_terminus_ (x.peptide_terminus_, f, this),
    protein_terminus_ (x.protein_terminus_, f, this),
    symbol_ (x.symbol_, f, this),
    binary_ (x.binary_, f, this),
    description_ (x.description_, f, this)
  {
  }

  aminoacid_modification::
  aminoacid_modification (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    aminoacid_ (this),
    massdiff_ (this),
    mass_ (this),
    variable_ (this),
    peptide_terminus_ (this),
    protein_terminus_ (this),
    symbol_ (this),
    binary_ (this),
    description_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void aminoacid_modification::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "aminoacid" && n.namespace_ ().empty ())
      {
        this->aminoacid_.set (aminoacid_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "massdiff" && n.namespace_ ().empty ())
      {
        this->massdiff_.set (massdiff_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "mass" && n.namespace_ ().empty ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "variable" && n.namespace_ ().empty ())
      {
        this->variable_.set (variable_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "peptide_terminus" && n.namespace_ ().empty ())
      {
        this->peptide_terminus_.set (peptide_terminus_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "protein_terminus" && n.namespace_ ().empty ())
      {
        this->protein_terminus_.set (protein_terminus_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "symbol" && n.namespace_ ().empty ())
      {
        this->symbol_.set (symbol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "binary" && n.namespace_ ().empty ())
      {
        this->binary_.set (binary_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "description" && n.namespace_ ().empty ())
      {
        this->description_.set (description_traits::create (i, f, this));
        continue;
      }
    }

    if (!aminoacid_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "aminoacid",
        "");
    }

    if (!massdiff_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "massdiff",
        "");
    }

    if (!mass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mass",
        "");
    }

    if (!variable_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "variable",
        "");
    }
  }

  aminoacid_modification* aminoacid_modification::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class aminoacid_modification (*this, f, c);
  }

  aminoacid_modification& aminoacid_modification::
  operator= (const aminoacid_modification& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->aminoacid_ = x.aminoacid_;
      this->massdiff_ = x.massdiff_;
      this->mass_ = x.mass_;
      this->variable_ = x.variable_;
      this->peptide_terminus_ = x.peptide_terminus_;
      this->protein_terminus_ = x.protein_terminus_;
      this->symbol_ = x.symbol_;
      this->binary_ = x.binary_;
      this->description_ = x.description_;
    }

    return *this;
  }

  aminoacid_modification::
  ~aminoacid_modification ()
  {
  }

  // terminal_modification
  //

  terminal_modification::
  terminal_modification ()
  : ::xml_schema::type (),
    terminus_ (this),
    massdiff_ (this),
    mass_ (this),
    variable_ (this),
    symbol_ (this),
    protein_terminus_ (this),
    description_ (this)
  {
  }

  terminal_modification::
  terminal_modification (const terminus_type& terminus,
                         const massdiff_type& massdiff,
                         const mass_type& mass,
                         const variable_type& variable,
                         const protein_terminus_type& protein_terminus)
  : ::xml_schema::type (),
    terminus_ (terminus, this),
    massdiff_ (massdiff, this),
    mass_ (mass, this),
    variable_ (variable, this),
    symbol_ (this),
    protein_terminus_ (protein_terminus, this),
    description_ (this)
  {
  }

  terminal_modification::
  terminal_modification (const terminal_modification& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    terminus_ (x.terminus_, f, this),
    massdiff_ (x.massdiff_, f, this),
    mass_ (x.mass_, f, this),
    variable_ (x.variable_, f, this),
    symbol_ (x.symbol_, f, this),
    protein_terminus_ (x.protein_terminus_, f, this),
    description_ (x.description_, f, this)
  {
  }

  terminal_modification::
  terminal_modification (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    terminus_ (this),
    massdiff_ (this),
    mass_ (this),
    variable_ (this),
    symbol_ (this),
    protein_terminus_ (this),
    description_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void terminal_modification::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "terminus" && n.namespace_ ().empty ())
      {
        this->terminus_.set (terminus_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "massdiff" && n.namespace_ ().empty ())
      {
        this->massdiff_.set (massdiff_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "mass" && n.namespace_ ().empty ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "variable" && n.namespace_ ().empty ())
      {
        this->variable_.set (variable_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "symbol" && n.namespace_ ().empty ())
      {
        this->symbol_.set (symbol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "protein_terminus" && n.namespace_ ().empty ())
      {
        this->protein_terminus_.set (protein_terminus_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "description" && n.namespace_ ().empty ())
      {
        this->description_.set (description_traits::create (i, f, this));
        continue;
      }
    }

    if (!terminus_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "terminus",
        "");
    }

    if (!massdiff_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "massdiff",
        "");
    }

    if (!mass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mass",
        "");
    }

    if (!variable_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "variable",
        "");
    }

    if (!protein_terminus_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "protein_terminus",
        "");
    }
  }

  terminal_modification* terminal_modification::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class terminal_modification (*this, f, c);
  }

  terminal_modification& terminal_modification::
  operator= (const terminal_modification& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->terminus_ = x.terminus_;
      this->massdiff_ = x.massdiff_;
      this->mass_ = x.mass_;
      this->variable_ = x.variable_;
      this->symbol_ = x.symbol_;
      this->protein_terminus_ = x.protein_terminus_;
      this->description_ = x.description_;
    }

    return *this;
  }

  terminal_modification::
  ~terminal_modification ()
  {
  }

  // search_result
  //

  search_result::
  search_result ()
  : ::xml_schema::type (),
    search_hit_ (this),
    search_id_ (search_id_default_value (), this)
  {
  }

  search_result::
  search_result (const search_result& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    search_hit_ (x.search_hit_, f, this),
    search_id_ (x.search_id_, f, this)
  {
  }

  search_result::
  search_result (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    search_hit_ (this),
    search_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void search_result::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // search_hit
      //
      if (n.name () == "search_hit" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< search_hit_type > r (
          search_hit_traits::create (i, f, this));

        this->search_hit_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "search_id" && n.namespace_ ().empty ())
      {
        this->search_id_.set (search_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!search_id_.present ())
    {
      this->search_id_.set (search_id_default_value ());
    }
  }

  search_result* search_result::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class search_result (*this, f, c);
  }

  search_result& search_result::
  operator= (const search_result& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->search_hit_ = x.search_hit_;
      this->search_id_ = x.search_id_;
    }

    return *this;
  }

  search_result::
  ~search_result ()
  {
  }

  // posmodel_distribution
  //

  posmodel_distribution::
  posmodel_distribution ()
  : ::xml_schema::type (),
    parameter_ (this),
    type_ (this)
  {
  }

  posmodel_distribution::
  posmodel_distribution (const posmodel_distribution& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    parameter_ (x.parameter_, f, this),
    type_ (x.type_, f, this)
  {
  }

  posmodel_distribution::
  posmodel_distribution (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    parameter_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void posmodel_distribution::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< parameter_type > r (
          parameter_traits::create (i, f, this));

        this->parameter_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }
  }

  posmodel_distribution* posmodel_distribution::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class posmodel_distribution (*this, f, c);
  }

  posmodel_distribution& posmodel_distribution::
  operator= (const posmodel_distribution& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->parameter_ = x.parameter_;
      this->type_ = x.type_;
    }

    return *this;
  }

  posmodel_distribution::
  ~posmodel_distribution ()
  {
  }

  // negmodel_distribution
  //

  negmodel_distribution::
  negmodel_distribution ()
  : ::xml_schema::type (),
    parameter_ (this),
    type_ (this)
  {
  }

  negmodel_distribution::
  negmodel_distribution (const negmodel_distribution& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    parameter_ (x.parameter_, f, this),
    type_ (x.type_, f, this)
  {
  }

  negmodel_distribution::
  negmodel_distribution (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    parameter_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void negmodel_distribution::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< parameter_type > r (
          parameter_traits::create (i, f, this));

        this->parameter_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }
  }

  negmodel_distribution* negmodel_distribution::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class negmodel_distribution (*this, f, c);
  }

  negmodel_distribution& negmodel_distribution::
  operator= (const negmodel_distribution& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->parameter_ = x.parameter_;
      this->type_ = x.type_;
    }

    return *this;
  }

  negmodel_distribution::
  ~negmodel_distribution ()
  {
  }

  // point1
  //

  point1::
  point1 ()
  : ::xml_schema::type (),
    value_ (this),
    pos_dens_ (this),
    neg_dens_ (this)
  {
  }

  point1::
  point1 (const point1& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this),
    pos_dens_ (x.pos_dens_, f, this),
    neg_dens_ (x.neg_dens_, f, this)
  {
  }

  point1::
  point1 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this),
    pos_dens_ (this),
    neg_dens_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void point1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "pos_dens" && n.namespace_ ().empty ())
      {
        this->pos_dens_.set (pos_dens_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "neg_dens" && n.namespace_ ().empty ())
      {
        this->neg_dens_.set (neg_dens_traits::create (i, f, this));
        continue;
      }
    }
  }

  point1* point1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class point1 (*this, f, c);
  }

  point1& point1::
  operator= (const point1& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
      this->pos_dens_ = x.pos_dens_;
      this->neg_dens_ = x.neg_dens_;
    }

    return *this;
  }

  point1::
  ~point1 ()
  {
  }

  // affected_channel
  //

  affected_channel::
  affected_channel ()
  : ::xml_schema::type (),
    channel_ (this),
    correction_ (this)
  {
  }

  affected_channel::
  affected_channel (const channel_type& channel,
                    const correction_type& correction)
  : ::xml_schema::type (),
    channel_ (channel, this),
    correction_ (correction, this)
  {
  }

  affected_channel::
  affected_channel (const affected_channel& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    channel_ (x.channel_, f, this),
    correction_ (x.correction_, f, this)
  {
  }

  affected_channel::
  affected_channel (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    channel_ (this),
    correction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void affected_channel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "channel" && n.namespace_ ().empty ())
      {
        this->channel_.set (channel_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "correction" && n.namespace_ ().empty ())
      {
        this->correction_.set (correction_traits::create (i, f, this));
        continue;
      }
    }

    if (!channel_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "channel",
        "");
    }

    if (!correction_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "correction",
        "");
    }
  }

  affected_channel* affected_channel::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class affected_channel (*this, f, c);
  }

  affected_channel& affected_channel::
  operator= (const affected_channel& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->channel_ = x.channel_;
      this->correction_ = x.correction_;
    }

    return *this;
  }

  affected_channel::
  ~affected_channel ()
  {
  }

  // sense
  //

  sense::
  sense (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_sense_convert ();
  }

  sense::
  sense (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_sense_convert ();
  }

  sense::
  sense (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_sense_convert ();
  }

  sense* sense::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class sense (*this, f, c);
  }

  sense::value sense::
  _xsd_sense_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_sense_literals_);
    const value* i (::std::lower_bound (
                      _xsd_sense_indexes_,
                      _xsd_sense_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_sense_indexes_ + 2 || _xsd_sense_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const sense::
  _xsd_sense_literals_[2] =
  {
    "C",
    "N"
  };

  const sense::value sense::
  _xsd_sense_indexes_[2] =
  {
    ::pepXML::sense::C,
    ::pepXML::sense::N
  };

  // cut
  //

  cut::
  cut ()
  : ::xml_schema::string ()
  {
  }

  cut::
  cut (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  cut::
  cut (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  cut::
  cut (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  cut::
  cut (const cut& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  cut::
  cut (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  cut::
  cut (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  cut::
  cut (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  cut* cut::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class cut (*this, f, c);
  }

  cut::
  ~cut ()
  {
  }

  // no_cut
  //

  no_cut::
  no_cut ()
  : ::xml_schema::string ()
  {
  }

  no_cut::
  no_cut (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  no_cut::
  no_cut (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  no_cut::
  no_cut (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  no_cut::
  no_cut (const no_cut& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  no_cut::
  no_cut (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  no_cut::
  no_cut (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  no_cut::
  no_cut (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  no_cut* no_cut::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class no_cut (*this, f, c);
  }

  no_cut::
  ~no_cut ()
  {
  }

  // type
  //

  type::
  type (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_type_convert ();
  }

  type::
  type (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_type_convert ();
  }

  type::
  type (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_type_convert ();
  }

  type* type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type (*this, f, c);
  }

  type::value type::
  _xsd_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_type_indexes_,
                      _xsd_type_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_type_indexes_ + 2 || _xsd_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const type::
  _xsd_type_literals_[2] =
  {
    "AA",
    "NA"
  };

  const type::value type::
  _xsd_type_indexes_[2] =
  {
    ::pepXML::type::AA,
    ::pepXML::type::NA
  };

  // search_hit
  //

  search_hit::
  search_hit ()
  : ::xml_schema::type (),
    alternative_protein_ (this),
    modification_info_ (this),
    xlink_ (this),
    search_score_ (this),
    analysis_result_ (this),
    parameter_ (this),
    hit_rank_ (this),
    peptide_ (this),
    peptide_prev_aa_ (this),
    peptide_next_aa_ (this),
    protein_ (this),
    num_tot_proteins_ (this),
    num_matched_ions_ (this),
    tot_num_ions_ (this),
    calc_neutral_pep_mass_ (this),
    massdiff_ (this),
    num_tol_term_ (this),
    num_missed_cleavages_ (this),
    num_matched_peptides_ (this),
    xlink_type_ (this),
    is_rejected_ (is_rejected_default_value (), this),
    protein_descr_ (this),
    calc_pI_ (this),
    protein_mw_ (this)
  {
  }

  search_hit::
  search_hit (const hit_rank_type& hit_rank,
              const peptide_type& peptide,
              const protein_type& protein,
              const num_tot_proteins_type& num_tot_proteins,
              const calc_neutral_pep_mass_type& calc_neutral_pep_mass,
              const massdiff_type& massdiff)
  : ::xml_schema::type (),
    alternative_protein_ (this),
    modification_info_ (this),
    xlink_ (this),
    search_score_ (this),
    analysis_result_ (this),
    parameter_ (this),
    hit_rank_ (hit_rank, this),
    peptide_ (peptide, this),
    peptide_prev_aa_ (this),
    peptide_next_aa_ (this),
    protein_ (protein, this),
    num_tot_proteins_ (num_tot_proteins, this),
    num_matched_ions_ (this),
    tot_num_ions_ (this),
    calc_neutral_pep_mass_ (calc_neutral_pep_mass, this),
    massdiff_ (massdiff, this),
    num_tol_term_ (this),
    num_missed_cleavages_ (this),
    num_matched_peptides_ (this),
    xlink_type_ (this),
    is_rejected_ (is_rejected_default_value (), this),
    protein_descr_ (this),
    calc_pI_ (this),
    protein_mw_ (this)
  {
  }

  search_hit::
  search_hit (const search_hit& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    alternative_protein_ (x.alternative_protein_, f, this),
    modification_info_ (x.modification_info_, f, this),
    xlink_ (x.xlink_, f, this),
    search_score_ (x.search_score_, f, this),
    analysis_result_ (x.analysis_result_, f, this),
    parameter_ (x.parameter_, f, this),
    hit_rank_ (x.hit_rank_, f, this),
    peptide_ (x.peptide_, f, this),
    peptide_prev_aa_ (x.peptide_prev_aa_, f, this),
    peptide_next_aa_ (x.peptide_next_aa_, f, this),
    protein_ (x.protein_, f, this),
    num_tot_proteins_ (x.num_tot_proteins_, f, this),
    num_matched_ions_ (x.num_matched_ions_, f, this),
    tot_num_ions_ (x.tot_num_ions_, f, this),
    calc_neutral_pep_mass_ (x.calc_neutral_pep_mass_, f, this),
    massdiff_ (x.massdiff_, f, this),
    num_tol_term_ (x.num_tol_term_, f, this),
    num_missed_cleavages_ (x.num_missed_cleavages_, f, this),
    num_matched_peptides_ (x.num_matched_peptides_, f, this),
    xlink_type_ (x.xlink_type_, f, this),
    is_rejected_ (x.is_rejected_, f, this),
    protein_descr_ (x.protein_descr_, f, this),
    calc_pI_ (x.calc_pI_, f, this),
    protein_mw_ (x.protein_mw_, f, this)
  {
  }

  search_hit::
  search_hit (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    alternative_protein_ (this),
    modification_info_ (this),
    xlink_ (this),
    search_score_ (this),
    analysis_result_ (this),
    parameter_ (this),
    hit_rank_ (this),
    peptide_ (this),
    peptide_prev_aa_ (this),
    peptide_next_aa_ (this),
    protein_ (this),
    num_tot_proteins_ (this),
    num_matched_ions_ (this),
    tot_num_ions_ (this),
    calc_neutral_pep_mass_ (this),
    massdiff_ (this),
    num_tol_term_ (this),
    num_missed_cleavages_ (this),
    num_matched_peptides_ (this),
    xlink_type_ (this),
    is_rejected_ (this),
    protein_descr_ (this),
    calc_pI_ (this),
    protein_mw_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void search_hit::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // alternative_protein
      //
      if (n.name () == "alternative_protein" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< alternative_protein_type > r (
          alternative_protein_traits::create (i, f, this));

        this->alternative_protein_.push_back (::std::move (r));
        continue;
      }

      // modification_info
      //
      if (n.name () == "modification_info" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< modification_info_type > r (
          modification_info_traits::create (i, f, this));

        if (!this->modification_info_)
        {
          this->modification_info_.set (::std::move (r));
          continue;
        }
      }

      // xlink
      //
      if (n.name () == "xlink" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< xlink_type > r (
          xlink_traits::create (i, f, this));

        if (!this->xlink_)
        {
          this->xlink_.set (::std::move (r));
          continue;
        }
      }

      // search_score
      //
      if (n.name () == "search_score" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< search_score_type > r (
          search_score_traits::create (i, f, this));

        this->search_score_.push_back (::std::move (r));
        continue;
      }

      // analysis_result
      //
      if (n.name () == "analysis_result" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< analysis_result_type > r (
          analysis_result_traits::create (i, f, this));

        this->analysis_result_.push_back (::std::move (r));
        continue;
      }

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< parameter_type > r (
          parameter_traits::create (i, f, this));

        this->parameter_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "hit_rank" && n.namespace_ ().empty ())
      {
        this->hit_rank_.set (hit_rank_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "peptide" && n.namespace_ ().empty ())
      {
        this->peptide_.set (peptide_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "peptide_prev_aa" && n.namespace_ ().empty ())
      {
        this->peptide_prev_aa_.set (peptide_prev_aa_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "peptide_next_aa" && n.namespace_ ().empty ())
      {
        this->peptide_next_aa_.set (peptide_next_aa_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "protein" && n.namespace_ ().empty ())
      {
        this->protein_.set (protein_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "num_tot_proteins" && n.namespace_ ().empty ())
      {
        this->num_tot_proteins_.set (num_tot_proteins_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "num_matched_ions" && n.namespace_ ().empty ())
      {
        this->num_matched_ions_.set (num_matched_ions_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "tot_num_ions" && n.namespace_ ().empty ())
      {
        this->tot_num_ions_.set (tot_num_ions_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "calc_neutral_pep_mass" && n.namespace_ ().empty ())
      {
        this->calc_neutral_pep_mass_.set (calc_neutral_pep_mass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "massdiff" && n.namespace_ ().empty ())
      {
        this->massdiff_.set (massdiff_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "num_tol_term" && n.namespace_ ().empty ())
      {
        this->num_tol_term_.set (num_tol_term_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "num_missed_cleavages" && n.namespace_ ().empty ())
      {
        this->num_missed_cleavages_.set (num_missed_cleavages_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "num_matched_peptides" && n.namespace_ ().empty ())
      {
        this->num_matched_peptides_.set (num_matched_peptides_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "xlink_type" && n.namespace_ ().empty ())
      {
        this->xlink_type_.set (xlink_type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "is_rejected" && n.namespace_ ().empty ())
      {
        this->is_rejected_.set (is_rejected_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "protein_descr" && n.namespace_ ().empty ())
      {
        this->protein_descr_.set (protein_descr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "calc_pI" && n.namespace_ ().empty ())
      {
        this->calc_pI_.set (calc_pI_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "protein_mw" && n.namespace_ ().empty ())
      {
        this->protein_mw_.set (protein_mw_traits::create (i, f, this));
        continue;
      }
    }

    if (!hit_rank_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "hit_rank",
        "");
    }

    if (!peptide_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "peptide",
        "");
    }

    if (!protein_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "protein",
        "");
    }

    if (!num_tot_proteins_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "num_tot_proteins",
        "");
    }

    if (!calc_neutral_pep_mass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "calc_neutral_pep_mass",
        "");
    }

    if (!massdiff_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "massdiff",
        "");
    }

    if (!is_rejected_.present ())
    {
      this->is_rejected_.set (is_rejected_default_value ());
    }
  }

  search_hit* search_hit::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class search_hit (*this, f, c);
  }

  search_hit& search_hit::
  operator= (const search_hit& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->alternative_protein_ = x.alternative_protein_;
      this->modification_info_ = x.modification_info_;
      this->xlink_ = x.xlink_;
      this->search_score_ = x.search_score_;
      this->analysis_result_ = x.analysis_result_;
      this->parameter_ = x.parameter_;
      this->hit_rank_ = x.hit_rank_;
      this->peptide_ = x.peptide_;
      this->peptide_prev_aa_ = x.peptide_prev_aa_;
      this->peptide_next_aa_ = x.peptide_next_aa_;
      this->protein_ = x.protein_;
      this->num_tot_proteins_ = x.num_tot_proteins_;
      this->num_matched_ions_ = x.num_matched_ions_;
      this->tot_num_ions_ = x.tot_num_ions_;
      this->calc_neutral_pep_mass_ = x.calc_neutral_pep_mass_;
      this->massdiff_ = x.massdiff_;
      this->num_tol_term_ = x.num_tol_term_;
      this->num_missed_cleavages_ = x.num_missed_cleavages_;
      this->num_matched_peptides_ = x.num_matched_peptides_;
      this->xlink_type_ = x.xlink_type_;
      this->is_rejected_ = x.is_rejected_;
      this->protein_descr_ = x.protein_descr_;
      this->calc_pI_ = x.calc_pI_;
      this->protein_mw_ = x.protein_mw_;
    }

    return *this;
  }

  search_hit::
  ~search_hit ()
  {
  }

  // xlink
  //

  xlink::
  xlink ()
  : ::xml_schema::type (),
    linked_peptide_ (this),
    xlink_score_ (this),
    identifier_ (this),
    mass_ (this)
  {
  }

  xlink::
  xlink (const identifier_type& identifier,
         const mass_type& mass)
  : ::xml_schema::type (),
    linked_peptide_ (this),
    xlink_score_ (this),
    identifier_ (identifier, this),
    mass_ (mass, this)
  {
  }

  xlink::
  xlink (const xlink& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    linked_peptide_ (x.linked_peptide_, f, this),
    xlink_score_ (x.xlink_score_, f, this),
    identifier_ (x.identifier_, f, this),
    mass_ (x.mass_, f, this)
  {
  }

  xlink::
  xlink (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    linked_peptide_ (this),
    xlink_score_ (this),
    identifier_ (this),
    mass_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void xlink::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // linked_peptide
      //
      if (n.name () == "linked_peptide" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< linked_peptide_type > r (
          linked_peptide_traits::create (i, f, this));

        this->linked_peptide_.push_back (::std::move (r));
        continue;
      }

      // xlink_score
      //
      if (n.name () == "xlink_score" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< xlink_score_type > r (
          xlink_score_traits::create (i, f, this));

        this->xlink_score_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "identifier" && n.namespace_ ().empty ())
      {
        this->identifier_.set (identifier_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "mass" && n.namespace_ ().empty ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    if (!identifier_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "identifier",
        "");
    }

    if (!mass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mass",
        "");
    }
  }

  xlink* xlink::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class xlink (*this, f, c);
  }

  xlink& xlink::
  operator= (const xlink& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->linked_peptide_ = x.linked_peptide_;
      this->xlink_score_ = x.xlink_score_;
      this->identifier_ = x.identifier_;
      this->mass_ = x.mass_;
    }

    return *this;
  }

  xlink::
  ~xlink ()
  {
  }

  // analysis_result
  //

  analysis_result::
  analysis_result ()
  : ::xml_schema::type (),
    analysis_ (this),
    id_ (id_default_value (), this)
  {
  }

  analysis_result::
  analysis_result (const analysis_type& analysis)
  : ::xml_schema::type (),
    analysis_ (analysis, this),
    id_ (id_default_value (), this)
  {
  }

  analysis_result::
  analysis_result (const analysis_result& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    analysis_ (x.analysis_, f, this),
    id_ (x.id_, f, this)
  {
  }

  analysis_result::
  analysis_result (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    analysis_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void analysis_result::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "analysis" && n.namespace_ ().empty ())
      {
        this->analysis_.set (analysis_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!analysis_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "analysis",
        "");
    }

    if (!id_.present ())
    {
      this->id_.set (id_default_value ());
    }
  }

  analysis_result* analysis_result::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class analysis_result (*this, f, c);
  }

  analysis_result& analysis_result::
  operator= (const analysis_result& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->analysis_ = x.analysis_;
      this->id_ = x.id_;
    }

    return *this;
  }

  analysis_result::
  ~analysis_result ()
  {
  }

  // xlink_type
  //

  xlink_type::
  xlink_type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_xlink_type_convert ();
  }

  xlink_type::
  xlink_type (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_xlink_type_convert ();
  }

  xlink_type::
  xlink_type (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_xlink_type_convert ();
  }

  xlink_type* xlink_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class xlink_type (*this, f, c);
  }

  xlink_type::value xlink_type::
  _xsd_xlink_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_xlink_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_xlink_type_indexes_,
                      _xsd_xlink_type_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_xlink_type_indexes_ + 3 || _xsd_xlink_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const xlink_type::
  _xsd_xlink_type_literals_[3] =
  {
    "na",
    "xl",
    "loop"
  };

  const xlink_type::value xlink_type::
  _xsd_xlink_type_indexes_[3] =
  {
    ::pepXML::xlink_type::loop,
    ::pepXML::xlink_type::na,
    ::pepXML::xlink_type::xl
  };

  // is_rejected
  //

  is_rejected::
  is_rejected (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  is_rejected::
  is_rejected (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  is_rejected::
  is_rejected (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  is_rejected* is_rejected::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class is_rejected (*this, f, c);
  }

  // linked_peptide
  //

  linked_peptide::
  linked_peptide ()
  : ::xml_schema::type (),
    alternative_protein_ (this),
    modification_info_ (this),
    xlink_score_ (this),
    peptide_ (this),
    peptide_prev_aa_ (this),
    peptide_next_aa_ (this),
    protein_ (this),
    num_tot_proteins_ (this),
    calc_neutral_pep_mass_ (this),
    complement_mass_ (this),
    designation_ (this)
  {
  }

  linked_peptide::
  linked_peptide (const peptide_type& peptide,
                  const protein_type& protein,
                  const num_tot_proteins_type& num_tot_proteins,
                  const calc_neutral_pep_mass_type& calc_neutral_pep_mass,
                  const complement_mass_type& complement_mass)
  : ::xml_schema::type (),
    alternative_protein_ (this),
    modification_info_ (this),
    xlink_score_ (this),
    peptide_ (peptide, this),
    peptide_prev_aa_ (this),
    peptide_next_aa_ (this),
    protein_ (protein, this),
    num_tot_proteins_ (num_tot_proteins, this),
    calc_neutral_pep_mass_ (calc_neutral_pep_mass, this),
    complement_mass_ (complement_mass, this),
    designation_ (this)
  {
  }

  linked_peptide::
  linked_peptide (const linked_peptide& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    alternative_protein_ (x.alternative_protein_, f, this),
    modification_info_ (x.modification_info_, f, this),
    xlink_score_ (x.xlink_score_, f, this),
    peptide_ (x.peptide_, f, this),
    peptide_prev_aa_ (x.peptide_prev_aa_, f, this),
    peptide_next_aa_ (x.peptide_next_aa_, f, this),
    protein_ (x.protein_, f, this),
    num_tot_proteins_ (x.num_tot_proteins_, f, this),
    calc_neutral_pep_mass_ (x.calc_neutral_pep_mass_, f, this),
    complement_mass_ (x.complement_mass_, f, this),
    designation_ (x.designation_, f, this)
  {
  }

  linked_peptide::
  linked_peptide (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    alternative_protein_ (this),
    modification_info_ (this),
    xlink_score_ (this),
    peptide_ (this),
    peptide_prev_aa_ (this),
    peptide_next_aa_ (this),
    protein_ (this),
    num_tot_proteins_ (this),
    calc_neutral_pep_mass_ (this),
    complement_mass_ (this),
    designation_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void linked_peptide::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // alternative_protein
      //
      if (n.name () == "alternative_protein" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< alternative_protein_type > r (
          alternative_protein_traits::create (i, f, this));

        this->alternative_protein_.push_back (::std::move (r));
        continue;
      }

      // modification_info
      //
      if (n.name () == "modification_info" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< modification_info_type > r (
          modification_info_traits::create (i, f, this));

        if (!this->modification_info_)
        {
          this->modification_info_.set (::std::move (r));
          continue;
        }
      }

      // xlink_score
      //
      if (n.name () == "xlink_score" && n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
      {
        ::std::unique_ptr< xlink_score_type > r (
          xlink_score_traits::create (i, f, this));

        this->xlink_score_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "peptide" && n.namespace_ ().empty ())
      {
        this->peptide_.set (peptide_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "peptide_prev_aa" && n.namespace_ ().empty ())
      {
        this->peptide_prev_aa_.set (peptide_prev_aa_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "peptide_next_aa" && n.namespace_ ().empty ())
      {
        this->peptide_next_aa_.set (peptide_next_aa_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "protein" && n.namespace_ ().empty ())
      {
        this->protein_.set (protein_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "num_tot_proteins" && n.namespace_ ().empty ())
      {
        this->num_tot_proteins_.set (num_tot_proteins_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "calc_neutral_pep_mass" && n.namespace_ ().empty ())
      {
        this->calc_neutral_pep_mass_.set (calc_neutral_pep_mass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "complement_mass" && n.namespace_ ().empty ())
      {
        this->complement_mass_.set (complement_mass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "designation" && n.namespace_ ().empty ())
      {
        this->designation_.set (designation_traits::create (i, f, this));
        continue;
      }
    }

    if (!peptide_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "peptide",
        "");
    }

    if (!protein_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "protein",
        "");
    }

    if (!num_tot_proteins_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "num_tot_proteins",
        "");
    }

    if (!calc_neutral_pep_mass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "calc_neutral_pep_mass",
        "");
    }

    if (!complement_mass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "complement_mass",
        "");
    }
  }

  linked_peptide* linked_peptide::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class linked_peptide (*this, f, c);
  }

  linked_peptide& linked_peptide::
  operator= (const linked_peptide& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->alternative_protein_ = x.alternative_protein_;
      this->modification_info_ = x.modification_info_;
      this->xlink_score_ = x.xlink_score_;
      this->peptide_ = x.peptide_;
      this->peptide_prev_aa_ = x.peptide_prev_aa_;
      this->peptide_next_aa_ = x.peptide_next_aa_;
      this->protein_ = x.protein_;
      this->num_tot_proteins_ = x.num_tot_proteins_;
      this->calc_neutral_pep_mass_ = x.calc_neutral_pep_mass_;
      this->complement_mass_ = x.complement_mass_;
      this->designation_ = x.designation_;
    }

    return *this;
  }

  linked_peptide::
  ~linked_peptide ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace pepXML
{
  ::std::unique_ptr< ::pepXML::msms_pipeline_analysis >
  msms_pipeline_analysis_ (const ::std::string& u,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::msms_pipeline_analysis > (
      ::pepXML::msms_pipeline_analysis_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::msms_pipeline_analysis >
  msms_pipeline_analysis_ (const ::std::string& u,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::msms_pipeline_analysis > (
      ::pepXML::msms_pipeline_analysis_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::msms_pipeline_analysis >
  msms_pipeline_analysis_ (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::msms_pipeline_analysis > (
      ::pepXML::msms_pipeline_analysis_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::msms_pipeline_analysis >
  msms_pipeline_analysis_ (::std::istream& is,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::msms_pipeline_analysis_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::msms_pipeline_analysis >
  msms_pipeline_analysis_ (::std::istream& is,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::msms_pipeline_analysis_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::msms_pipeline_analysis >
  msms_pipeline_analysis_ (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::msms_pipeline_analysis_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::msms_pipeline_analysis >
  msms_pipeline_analysis_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::msms_pipeline_analysis_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::msms_pipeline_analysis >
  msms_pipeline_analysis_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::msms_pipeline_analysis_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::msms_pipeline_analysis >
  msms_pipeline_analysis_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::msms_pipeline_analysis_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::msms_pipeline_analysis >
  msms_pipeline_analysis_ (::xercesc::InputSource& i,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::msms_pipeline_analysis > (
      ::pepXML::msms_pipeline_analysis_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::msms_pipeline_analysis >
  msms_pipeline_analysis_ (::xercesc::InputSource& i,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::msms_pipeline_analysis > (
      ::pepXML::msms_pipeline_analysis_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::msms_pipeline_analysis >
  msms_pipeline_analysis_ (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::msms_pipeline_analysis > (
      ::pepXML::msms_pipeline_analysis_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::msms_pipeline_analysis >
  msms_pipeline_analysis_ (const ::xercesc::DOMDocument& doc,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::msms_pipeline_analysis > (
        ::pepXML::msms_pipeline_analysis_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "msms_pipeline_analysis" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::msms_pipeline_analysis > r (
        ::xsd::cxx::tree::traits< ::pepXML::msms_pipeline_analysis, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "msms_pipeline_analysis",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::msms_pipeline_analysis >
  msms_pipeline_analysis_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "msms_pipeline_analysis" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::msms_pipeline_analysis > r (
        ::xsd::cxx::tree::traits< ::pepXML::msms_pipeline_analysis, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "msms_pipeline_analysis",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_summary >
  peptideprophet_summary_ (const ::std::string& u,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::peptideprophet_summary > (
      ::pepXML::peptideprophet_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_summary >
  peptideprophet_summary_ (const ::std::string& u,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::peptideprophet_summary > (
      ::pepXML::peptideprophet_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_summary >
  peptideprophet_summary_ (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::peptideprophet_summary > (
      ::pepXML::peptideprophet_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_summary >
  peptideprophet_summary_ (::std::istream& is,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::peptideprophet_summary_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_summary >
  peptideprophet_summary_ (::std::istream& is,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::peptideprophet_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_summary >
  peptideprophet_summary_ (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::peptideprophet_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_summary >
  peptideprophet_summary_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::peptideprophet_summary_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_summary >
  peptideprophet_summary_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::peptideprophet_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_summary >
  peptideprophet_summary_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::peptideprophet_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_summary >
  peptideprophet_summary_ (::xercesc::InputSource& i,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::peptideprophet_summary > (
      ::pepXML::peptideprophet_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_summary >
  peptideprophet_summary_ (::xercesc::InputSource& i,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::peptideprophet_summary > (
      ::pepXML::peptideprophet_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_summary >
  peptideprophet_summary_ (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::peptideprophet_summary > (
      ::pepXML::peptideprophet_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_summary >
  peptideprophet_summary_ (const ::xercesc::DOMDocument& doc,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::peptideprophet_summary > (
        ::pepXML::peptideprophet_summary_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "peptideprophet_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::peptideprophet_summary > r (
        ::xsd::cxx::tree::traits< ::pepXML::peptideprophet_summary, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "peptideprophet_summary",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_summary >
  peptideprophet_summary_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "peptideprophet_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::peptideprophet_summary > r (
        ::xsd::cxx::tree::traits< ::pepXML::peptideprophet_summary, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "peptideprophet_summary",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::interprophet_summary >
  interprophet_summary_ (const ::std::string& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::interprophet_summary > (
      ::pepXML::interprophet_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::interprophet_summary >
  interprophet_summary_ (const ::std::string& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::interprophet_summary > (
      ::pepXML::interprophet_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::interprophet_summary >
  interprophet_summary_ (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::interprophet_summary > (
      ::pepXML::interprophet_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::interprophet_summary >
  interprophet_summary_ (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::interprophet_summary_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::interprophet_summary >
  interprophet_summary_ (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::interprophet_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::interprophet_summary >
  interprophet_summary_ (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::interprophet_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::interprophet_summary >
  interprophet_summary_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::interprophet_summary_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::interprophet_summary >
  interprophet_summary_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::interprophet_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::interprophet_summary >
  interprophet_summary_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::interprophet_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::interprophet_summary >
  interprophet_summary_ (::xercesc::InputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::interprophet_summary > (
      ::pepXML::interprophet_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::interprophet_summary >
  interprophet_summary_ (::xercesc::InputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::interprophet_summary > (
      ::pepXML::interprophet_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::interprophet_summary >
  interprophet_summary_ (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::interprophet_summary > (
      ::pepXML::interprophet_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::interprophet_summary >
  interprophet_summary_ (const ::xercesc::DOMDocument& doc,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::interprophet_summary > (
        ::pepXML::interprophet_summary_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "interprophet_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::interprophet_summary > r (
        ::xsd::cxx::tree::traits< ::pepXML::interprophet_summary, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "interprophet_summary",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::interprophet_summary >
  interprophet_summary_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "interprophet_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::interprophet_summary > r (
        ::xsd::cxx::tree::traits< ::pepXML::interprophet_summary, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "interprophet_summary",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_summary >
  ptmprophet_summary_ (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::ptmprophet_summary > (
      ::pepXML::ptmprophet_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_summary >
  ptmprophet_summary_ (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::ptmprophet_summary > (
      ::pepXML::ptmprophet_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_summary >
  ptmprophet_summary_ (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::ptmprophet_summary > (
      ::pepXML::ptmprophet_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_summary >
  ptmprophet_summary_ (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::ptmprophet_summary_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_summary >
  ptmprophet_summary_ (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::ptmprophet_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_summary >
  ptmprophet_summary_ (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::ptmprophet_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_summary >
  ptmprophet_summary_ (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::ptmprophet_summary_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_summary >
  ptmprophet_summary_ (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::ptmprophet_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_summary >
  ptmprophet_summary_ (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::ptmprophet_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_summary >
  ptmprophet_summary_ (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::ptmprophet_summary > (
      ::pepXML::ptmprophet_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_summary >
  ptmprophet_summary_ (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::ptmprophet_summary > (
      ::pepXML::ptmprophet_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_summary >
  ptmprophet_summary_ (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::ptmprophet_summary > (
      ::pepXML::ptmprophet_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_summary >
  ptmprophet_summary_ (const ::xercesc::DOMDocument& doc,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::ptmprophet_summary > (
        ::pepXML::ptmprophet_summary_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ptmprophet_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::ptmprophet_summary > r (
        ::xsd::cxx::tree::traits< ::pepXML::ptmprophet_summary, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ptmprophet_summary",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_summary >
  ptmprophet_summary_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ptmprophet_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::ptmprophet_summary > r (
        ::xsd::cxx::tree::traits< ::pepXML::ptmprophet_summary, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ptmprophet_summary",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::asapratio_summary >
  asapratio_summary_ (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::asapratio_summary > (
      ::pepXML::asapratio_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_summary >
  asapratio_summary_ (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_summary > (
      ::pepXML::asapratio_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_summary >
  asapratio_summary_ (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_summary > (
      ::pepXML::asapratio_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_summary >
  asapratio_summary_ (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_summary_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_summary >
  asapratio_summary_ (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_summary >
  asapratio_summary_ (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_summary >
  asapratio_summary_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_summary_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_summary >
  asapratio_summary_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_summary >
  asapratio_summary_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_summary >
  asapratio_summary_ (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::asapratio_summary > (
      ::pepXML::asapratio_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_summary >
  asapratio_summary_ (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_summary > (
      ::pepXML::asapratio_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_summary >
  asapratio_summary_ (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_summary > (
      ::pepXML::asapratio_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_summary >
  asapratio_summary_ (const ::xercesc::DOMDocument& doc,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::asapratio_summary > (
        ::pepXML::asapratio_summary_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "asapratio_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::asapratio_summary > r (
        ::xsd::cxx::tree::traits< ::pepXML::asapratio_summary, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "asapratio_summary",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::asapratio_summary >
  asapratio_summary_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "asapratio_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::asapratio_summary > r (
        ::xsd::cxx::tree::traits< ::pepXML::asapratio_summary, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "asapratio_summary",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::xpressratio_summary >
  xpressratio_summary_ (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::xpressratio_summary > (
      ::pepXML::xpressratio_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::xpressratio_summary >
  xpressratio_summary_ (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::xpressratio_summary > (
      ::pepXML::xpressratio_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::xpressratio_summary >
  xpressratio_summary_ (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::xpressratio_summary > (
      ::pepXML::xpressratio_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::xpressratio_summary >
  xpressratio_summary_ (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::xpressratio_summary_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::xpressratio_summary >
  xpressratio_summary_ (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::xpressratio_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::xpressratio_summary >
  xpressratio_summary_ (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::xpressratio_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::xpressratio_summary >
  xpressratio_summary_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::xpressratio_summary_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::xpressratio_summary >
  xpressratio_summary_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::xpressratio_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::xpressratio_summary >
  xpressratio_summary_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::xpressratio_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::xpressratio_summary >
  xpressratio_summary_ (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::xpressratio_summary > (
      ::pepXML::xpressratio_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::xpressratio_summary >
  xpressratio_summary_ (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::xpressratio_summary > (
      ::pepXML::xpressratio_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::xpressratio_summary >
  xpressratio_summary_ (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::xpressratio_summary > (
      ::pepXML::xpressratio_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::xpressratio_summary >
  xpressratio_summary_ (const ::xercesc::DOMDocument& doc,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::xpressratio_summary > (
        ::pepXML::xpressratio_summary_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "xpressratio_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::xpressratio_summary > r (
        ::xsd::cxx::tree::traits< ::pepXML::xpressratio_summary, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "xpressratio_summary",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::xpressratio_summary >
  xpressratio_summary_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "xpressratio_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::xpressratio_summary > r (
        ::xsd::cxx::tree::traits< ::pepXML::xpressratio_summary, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "xpressratio_summary",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_result >
  ptmprophet_result_ (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::ptmprophet_result > (
      ::pepXML::ptmprophet_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_result >
  ptmprophet_result_ (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::ptmprophet_result > (
      ::pepXML::ptmprophet_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_result >
  ptmprophet_result_ (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::ptmprophet_result > (
      ::pepXML::ptmprophet_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_result >
  ptmprophet_result_ (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::ptmprophet_result_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_result >
  ptmprophet_result_ (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::ptmprophet_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_result >
  ptmprophet_result_ (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::ptmprophet_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_result >
  ptmprophet_result_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::ptmprophet_result_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_result >
  ptmprophet_result_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::ptmprophet_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_result >
  ptmprophet_result_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::ptmprophet_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_result >
  ptmprophet_result_ (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::ptmprophet_result > (
      ::pepXML::ptmprophet_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_result >
  ptmprophet_result_ (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::ptmprophet_result > (
      ::pepXML::ptmprophet_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_result >
  ptmprophet_result_ (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::ptmprophet_result > (
      ::pepXML::ptmprophet_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_result >
  ptmprophet_result_ (const ::xercesc::DOMDocument& doc,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::ptmprophet_result > (
        ::pepXML::ptmprophet_result_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ptmprophet_result" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::ptmprophet_result > r (
        ::xsd::cxx::tree::traits< ::pepXML::ptmprophet_result, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ptmprophet_result",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::ptmprophet_result >
  ptmprophet_result_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ptmprophet_result" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::ptmprophet_result > r (
        ::xsd::cxx::tree::traits< ::pepXML::ptmprophet_result, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ptmprophet_result",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_result >
  peptideprophet_result_ (const ::std::string& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::peptideprophet_result > (
      ::pepXML::peptideprophet_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_result >
  peptideprophet_result_ (const ::std::string& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::peptideprophet_result > (
      ::pepXML::peptideprophet_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_result >
  peptideprophet_result_ (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::peptideprophet_result > (
      ::pepXML::peptideprophet_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_result >
  peptideprophet_result_ (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::peptideprophet_result_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_result >
  peptideprophet_result_ (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::peptideprophet_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_result >
  peptideprophet_result_ (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::peptideprophet_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_result >
  peptideprophet_result_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::peptideprophet_result_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_result >
  peptideprophet_result_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::peptideprophet_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_result >
  peptideprophet_result_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::peptideprophet_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_result >
  peptideprophet_result_ (::xercesc::InputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::peptideprophet_result > (
      ::pepXML::peptideprophet_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_result >
  peptideprophet_result_ (::xercesc::InputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::peptideprophet_result > (
      ::pepXML::peptideprophet_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_result >
  peptideprophet_result_ (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::peptideprophet_result > (
      ::pepXML::peptideprophet_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_result >
  peptideprophet_result_ (const ::xercesc::DOMDocument& doc,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::peptideprophet_result > (
        ::pepXML::peptideprophet_result_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "peptideprophet_result" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::peptideprophet_result > r (
        ::xsd::cxx::tree::traits< ::pepXML::peptideprophet_result, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "peptideprophet_result",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::peptideprophet_result >
  peptideprophet_result_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "peptideprophet_result" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::peptideprophet_result > r (
        ::xsd::cxx::tree::traits< ::pepXML::peptideprophet_result, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "peptideprophet_result",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::interprophet_result >
  interprophet_result_ (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::interprophet_result > (
      ::pepXML::interprophet_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::interprophet_result >
  interprophet_result_ (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::interprophet_result > (
      ::pepXML::interprophet_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::interprophet_result >
  interprophet_result_ (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::interprophet_result > (
      ::pepXML::interprophet_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::interprophet_result >
  interprophet_result_ (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::interprophet_result_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::interprophet_result >
  interprophet_result_ (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::interprophet_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::interprophet_result >
  interprophet_result_ (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::interprophet_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::interprophet_result >
  interprophet_result_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::interprophet_result_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::interprophet_result >
  interprophet_result_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::interprophet_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::interprophet_result >
  interprophet_result_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::interprophet_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::interprophet_result >
  interprophet_result_ (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::interprophet_result > (
      ::pepXML::interprophet_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::interprophet_result >
  interprophet_result_ (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::interprophet_result > (
      ::pepXML::interprophet_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::interprophet_result >
  interprophet_result_ (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::interprophet_result > (
      ::pepXML::interprophet_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::interprophet_result >
  interprophet_result_ (const ::xercesc::DOMDocument& doc,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::interprophet_result > (
        ::pepXML::interprophet_result_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "interprophet_result" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::interprophet_result > r (
        ::xsd::cxx::tree::traits< ::pepXML::interprophet_result, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "interprophet_result",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::interprophet_result >
  interprophet_result_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "interprophet_result" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::interprophet_result > r (
        ::xsd::cxx::tree::traits< ::pepXML::interprophet_result, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "interprophet_result",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::asapratio_result >
  asapratio_result_ (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::asapratio_result > (
      ::pepXML::asapratio_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_result >
  asapratio_result_ (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_result > (
      ::pepXML::asapratio_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_result >
  asapratio_result_ (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_result > (
      ::pepXML::asapratio_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_result >
  asapratio_result_ (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_result_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_result >
  asapratio_result_ (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_result >
  asapratio_result_ (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_result >
  asapratio_result_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_result_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_result >
  asapratio_result_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_result >
  asapratio_result_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_result >
  asapratio_result_ (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::asapratio_result > (
      ::pepXML::asapratio_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_result >
  asapratio_result_ (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_result > (
      ::pepXML::asapratio_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_result >
  asapratio_result_ (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_result > (
      ::pepXML::asapratio_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_result >
  asapratio_result_ (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::asapratio_result > (
        ::pepXML::asapratio_result_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "asapratio_result" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::asapratio_result > r (
        ::xsd::cxx::tree::traits< ::pepXML::asapratio_result, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "asapratio_result",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::asapratio_result >
  asapratio_result_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "asapratio_result" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::asapratio_result > r (
        ::xsd::cxx::tree::traits< ::pepXML::asapratio_result, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "asapratio_result",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::asapratio_peptide_data >
  asapratio_peptide_data_ (const ::std::string& u,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::asapratio_peptide_data > (
      ::pepXML::asapratio_peptide_data_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_peptide_data >
  asapratio_peptide_data_ (const ::std::string& u,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_peptide_data > (
      ::pepXML::asapratio_peptide_data_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_peptide_data >
  asapratio_peptide_data_ (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_peptide_data > (
      ::pepXML::asapratio_peptide_data_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_peptide_data >
  asapratio_peptide_data_ (::std::istream& is,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_peptide_data_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_peptide_data >
  asapratio_peptide_data_ (::std::istream& is,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_peptide_data_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_peptide_data >
  asapratio_peptide_data_ (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_peptide_data_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_peptide_data >
  asapratio_peptide_data_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_peptide_data_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_peptide_data >
  asapratio_peptide_data_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_peptide_data_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_peptide_data >
  asapratio_peptide_data_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_peptide_data_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_peptide_data >
  asapratio_peptide_data_ (::xercesc::InputSource& i,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::asapratio_peptide_data > (
      ::pepXML::asapratio_peptide_data_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_peptide_data >
  asapratio_peptide_data_ (::xercesc::InputSource& i,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_peptide_data > (
      ::pepXML::asapratio_peptide_data_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_peptide_data >
  asapratio_peptide_data_ (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_peptide_data > (
      ::pepXML::asapratio_peptide_data_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_peptide_data >
  asapratio_peptide_data_ (const ::xercesc::DOMDocument& doc,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::asapratio_peptide_data > (
        ::pepXML::asapratio_peptide_data_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "asapratio_peptide_data" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::asapratio_peptide_data > r (
        ::xsd::cxx::tree::traits< ::pepXML::asapratio_peptide_data, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "asapratio_peptide_data",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::asapratio_peptide_data >
  asapratio_peptide_data_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "asapratio_peptide_data" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::asapratio_peptide_data > r (
        ::xsd::cxx::tree::traits< ::pepXML::asapratio_peptide_data, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "asapratio_peptide_data",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::asapratio_contribution >
  asapratio_contribution_ (const ::std::string& u,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::asapratio_contribution > (
      ::pepXML::asapratio_contribution_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_contribution >
  asapratio_contribution_ (const ::std::string& u,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_contribution > (
      ::pepXML::asapratio_contribution_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_contribution >
  asapratio_contribution_ (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_contribution > (
      ::pepXML::asapratio_contribution_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_contribution >
  asapratio_contribution_ (::std::istream& is,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_contribution_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_contribution >
  asapratio_contribution_ (::std::istream& is,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_contribution_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_contribution >
  asapratio_contribution_ (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_contribution_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_contribution >
  asapratio_contribution_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_contribution_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_contribution >
  asapratio_contribution_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_contribution_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_contribution >
  asapratio_contribution_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_contribution_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_contribution >
  asapratio_contribution_ (::xercesc::InputSource& i,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::asapratio_contribution > (
      ::pepXML::asapratio_contribution_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_contribution >
  asapratio_contribution_ (::xercesc::InputSource& i,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_contribution > (
      ::pepXML::asapratio_contribution_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_contribution >
  asapratio_contribution_ (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_contribution > (
      ::pepXML::asapratio_contribution_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_contribution >
  asapratio_contribution_ (const ::xercesc::DOMDocument& doc,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::asapratio_contribution > (
        ::pepXML::asapratio_contribution_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "asapratio_contribution" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::asapratio_contribution > r (
        ::xsd::cxx::tree::traits< ::pepXML::asapratio_contribution, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "asapratio_contribution",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::asapratio_contribution >
  asapratio_contribution_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "asapratio_contribution" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::asapratio_contribution > r (
        ::xsd::cxx::tree::traits< ::pepXML::asapratio_contribution, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "asapratio_contribution",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak >
  asapratio_lc_lightpeak_ (const ::std::string& u,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak > (
      ::pepXML::asapratio_lc_lightpeak_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak >
  asapratio_lc_lightpeak_ (const ::std::string& u,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak > (
      ::pepXML::asapratio_lc_lightpeak_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak >
  asapratio_lc_lightpeak_ (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak > (
      ::pepXML::asapratio_lc_lightpeak_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak >
  asapratio_lc_lightpeak_ (::std::istream& is,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_lc_lightpeak_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak >
  asapratio_lc_lightpeak_ (::std::istream& is,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_lc_lightpeak_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak >
  asapratio_lc_lightpeak_ (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_lc_lightpeak_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak >
  asapratio_lc_lightpeak_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_lc_lightpeak_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak >
  asapratio_lc_lightpeak_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_lc_lightpeak_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak >
  asapratio_lc_lightpeak_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_lc_lightpeak_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak >
  asapratio_lc_lightpeak_ (::xercesc::InputSource& i,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak > (
      ::pepXML::asapratio_lc_lightpeak_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak >
  asapratio_lc_lightpeak_ (::xercesc::InputSource& i,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak > (
      ::pepXML::asapratio_lc_lightpeak_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak >
  asapratio_lc_lightpeak_ (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak > (
      ::pepXML::asapratio_lc_lightpeak_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak >
  asapratio_lc_lightpeak_ (const ::xercesc::DOMDocument& doc,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak > (
        ::pepXML::asapratio_lc_lightpeak_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "asapratio_lc_lightpeak" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak > r (
        ::xsd::cxx::tree::traits< ::pepXML::asapratio_lc_lightpeak, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "asapratio_lc_lightpeak",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak >
  asapratio_lc_lightpeak_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "asapratio_lc_lightpeak" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::asapratio_lc_lightpeak > r (
        ::xsd::cxx::tree::traits< ::pepXML::asapratio_lc_lightpeak, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "asapratio_lc_lightpeak",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak >
  asapratio_lc_heavypeak_ (const ::std::string& u,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak > (
      ::pepXML::asapratio_lc_heavypeak_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak >
  asapratio_lc_heavypeak_ (const ::std::string& u,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak > (
      ::pepXML::asapratio_lc_heavypeak_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak >
  asapratio_lc_heavypeak_ (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak > (
      ::pepXML::asapratio_lc_heavypeak_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak >
  asapratio_lc_heavypeak_ (::std::istream& is,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_lc_heavypeak_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak >
  asapratio_lc_heavypeak_ (::std::istream& is,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_lc_heavypeak_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak >
  asapratio_lc_heavypeak_ (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_lc_heavypeak_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak >
  asapratio_lc_heavypeak_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_lc_heavypeak_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak >
  asapratio_lc_heavypeak_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_lc_heavypeak_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak >
  asapratio_lc_heavypeak_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_lc_heavypeak_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak >
  asapratio_lc_heavypeak_ (::xercesc::InputSource& i,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak > (
      ::pepXML::asapratio_lc_heavypeak_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak >
  asapratio_lc_heavypeak_ (::xercesc::InputSource& i,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak > (
      ::pepXML::asapratio_lc_heavypeak_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak >
  asapratio_lc_heavypeak_ (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak > (
      ::pepXML::asapratio_lc_heavypeak_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak >
  asapratio_lc_heavypeak_ (const ::xercesc::DOMDocument& doc,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak > (
        ::pepXML::asapratio_lc_heavypeak_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "asapratio_lc_heavypeak" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak > r (
        ::xsd::cxx::tree::traits< ::pepXML::asapratio_lc_heavypeak, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "asapratio_lc_heavypeak",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak >
  asapratio_lc_heavypeak_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "asapratio_lc_heavypeak" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::asapratio_lc_heavypeak > r (
        ::xsd::cxx::tree::traits< ::pepXML::asapratio_lc_heavypeak, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "asapratio_lc_heavypeak",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::database_refresh_timestamp >
  database_refresh_timestamp_ (const ::std::string& u,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::database_refresh_timestamp > (
      ::pepXML::database_refresh_timestamp_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::database_refresh_timestamp >
  database_refresh_timestamp_ (const ::std::string& u,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::database_refresh_timestamp > (
      ::pepXML::database_refresh_timestamp_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::database_refresh_timestamp >
  database_refresh_timestamp_ (const ::std::string& u,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::database_refresh_timestamp > (
      ::pepXML::database_refresh_timestamp_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::database_refresh_timestamp >
  database_refresh_timestamp_ (::std::istream& is,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::database_refresh_timestamp_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::database_refresh_timestamp >
  database_refresh_timestamp_ (::std::istream& is,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::database_refresh_timestamp_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::database_refresh_timestamp >
  database_refresh_timestamp_ (::std::istream& is,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::database_refresh_timestamp_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::database_refresh_timestamp >
  database_refresh_timestamp_ (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::database_refresh_timestamp_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::database_refresh_timestamp >
  database_refresh_timestamp_ (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::database_refresh_timestamp_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::database_refresh_timestamp >
  database_refresh_timestamp_ (::std::istream& is,
                               const ::std::string& sid,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::database_refresh_timestamp_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::database_refresh_timestamp >
  database_refresh_timestamp_ (::xercesc::InputSource& i,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::database_refresh_timestamp > (
      ::pepXML::database_refresh_timestamp_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::database_refresh_timestamp >
  database_refresh_timestamp_ (::xercesc::InputSource& i,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::database_refresh_timestamp > (
      ::pepXML::database_refresh_timestamp_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::database_refresh_timestamp >
  database_refresh_timestamp_ (::xercesc::InputSource& i,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::database_refresh_timestamp > (
      ::pepXML::database_refresh_timestamp_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::database_refresh_timestamp >
  database_refresh_timestamp_ (const ::xercesc::DOMDocument& doc,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::database_refresh_timestamp > (
        ::pepXML::database_refresh_timestamp_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "database_refresh_timestamp" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::database_refresh_timestamp > r (
        ::xsd::cxx::tree::traits< ::pepXML::database_refresh_timestamp, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "database_refresh_timestamp",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::database_refresh_timestamp >
  database_refresh_timestamp_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "database_refresh_timestamp" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::database_refresh_timestamp > r (
        ::xsd::cxx::tree::traits< ::pepXML::database_refresh_timestamp, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "database_refresh_timestamp",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::xpressratio_timestamp >
  xpressratio_timestamp_ (const ::std::string& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::xpressratio_timestamp > (
      ::pepXML::xpressratio_timestamp_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::xpressratio_timestamp >
  xpressratio_timestamp_ (const ::std::string& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::xpressratio_timestamp > (
      ::pepXML::xpressratio_timestamp_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::xpressratio_timestamp >
  xpressratio_timestamp_ (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::xpressratio_timestamp > (
      ::pepXML::xpressratio_timestamp_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::xpressratio_timestamp >
  xpressratio_timestamp_ (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::xpressratio_timestamp_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::xpressratio_timestamp >
  xpressratio_timestamp_ (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::xpressratio_timestamp_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::xpressratio_timestamp >
  xpressratio_timestamp_ (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::xpressratio_timestamp_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::xpressratio_timestamp >
  xpressratio_timestamp_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::xpressratio_timestamp_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::xpressratio_timestamp >
  xpressratio_timestamp_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::xpressratio_timestamp_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::xpressratio_timestamp >
  xpressratio_timestamp_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::xpressratio_timestamp_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::xpressratio_timestamp >
  xpressratio_timestamp_ (::xercesc::InputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::xpressratio_timestamp > (
      ::pepXML::xpressratio_timestamp_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::xpressratio_timestamp >
  xpressratio_timestamp_ (::xercesc::InputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::xpressratio_timestamp > (
      ::pepXML::xpressratio_timestamp_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::xpressratio_timestamp >
  xpressratio_timestamp_ (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::xpressratio_timestamp > (
      ::pepXML::xpressratio_timestamp_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::xpressratio_timestamp >
  xpressratio_timestamp_ (const ::xercesc::DOMDocument& doc,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::xpressratio_timestamp > (
        ::pepXML::xpressratio_timestamp_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "xpressratio_timestamp" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::xpressratio_timestamp > r (
        ::xsd::cxx::tree::traits< ::pepXML::xpressratio_timestamp, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "xpressratio_timestamp",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::xpressratio_timestamp >
  xpressratio_timestamp_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "xpressratio_timestamp" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::xpressratio_timestamp > r (
        ::xsd::cxx::tree::traits< ::pepXML::xpressratio_timestamp, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "xpressratio_timestamp",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::asapratio_timestamp >
  asapratio_timestamp_ (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::asapratio_timestamp > (
      ::pepXML::asapratio_timestamp_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_timestamp >
  asapratio_timestamp_ (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_timestamp > (
      ::pepXML::asapratio_timestamp_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_timestamp >
  asapratio_timestamp_ (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_timestamp > (
      ::pepXML::asapratio_timestamp_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_timestamp >
  asapratio_timestamp_ (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_timestamp_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_timestamp >
  asapratio_timestamp_ (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_timestamp_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_timestamp >
  asapratio_timestamp_ (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::asapratio_timestamp_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_timestamp >
  asapratio_timestamp_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_timestamp_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_timestamp >
  asapratio_timestamp_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_timestamp_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_timestamp >
  asapratio_timestamp_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::asapratio_timestamp_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::asapratio_timestamp >
  asapratio_timestamp_ (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::asapratio_timestamp > (
      ::pepXML::asapratio_timestamp_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_timestamp >
  asapratio_timestamp_ (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_timestamp > (
      ::pepXML::asapratio_timestamp_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_timestamp >
  asapratio_timestamp_ (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::asapratio_timestamp > (
      ::pepXML::asapratio_timestamp_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::asapratio_timestamp >
  asapratio_timestamp_ (const ::xercesc::DOMDocument& doc,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::asapratio_timestamp > (
        ::pepXML::asapratio_timestamp_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "asapratio_timestamp" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::asapratio_timestamp > r (
        ::xsd::cxx::tree::traits< ::pepXML::asapratio_timestamp, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "asapratio_timestamp",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::asapratio_timestamp >
  asapratio_timestamp_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "asapratio_timestamp" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::asapratio_timestamp > r (
        ::xsd::cxx::tree::traits< ::pepXML::asapratio_timestamp, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "asapratio_timestamp",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::xpressratio_result >
  xpressratio_result_ (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::xpressratio_result > (
      ::pepXML::xpressratio_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::xpressratio_result >
  xpressratio_result_ (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::xpressratio_result > (
      ::pepXML::xpressratio_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::xpressratio_result >
  xpressratio_result_ (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::xpressratio_result > (
      ::pepXML::xpressratio_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::xpressratio_result >
  xpressratio_result_ (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::xpressratio_result_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::xpressratio_result >
  xpressratio_result_ (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::xpressratio_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::xpressratio_result >
  xpressratio_result_ (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::xpressratio_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::xpressratio_result >
  xpressratio_result_ (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::xpressratio_result_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::xpressratio_result >
  xpressratio_result_ (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::xpressratio_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::xpressratio_result >
  xpressratio_result_ (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::xpressratio_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::xpressratio_result >
  xpressratio_result_ (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::xpressratio_result > (
      ::pepXML::xpressratio_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::xpressratio_result >
  xpressratio_result_ (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::xpressratio_result > (
      ::pepXML::xpressratio_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::xpressratio_result >
  xpressratio_result_ (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::xpressratio_result > (
      ::pepXML::xpressratio_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::xpressratio_result >
  xpressratio_result_ (const ::xercesc::DOMDocument& doc,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::xpressratio_result > (
        ::pepXML::xpressratio_result_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "xpressratio_result" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::xpressratio_result > r (
        ::xsd::cxx::tree::traits< ::pepXML::xpressratio_result, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "xpressratio_result",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::xpressratio_result >
  xpressratio_result_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "xpressratio_result" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::xpressratio_result > r (
        ::xsd::cxx::tree::traits< ::pepXML::xpressratio_result, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "xpressratio_result",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::interact_summary >
  interact_summary_ (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::interact_summary > (
      ::pepXML::interact_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::interact_summary >
  interact_summary_ (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::interact_summary > (
      ::pepXML::interact_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::interact_summary >
  interact_summary_ (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::interact_summary > (
      ::pepXML::interact_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::interact_summary >
  interact_summary_ (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::interact_summary_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::interact_summary >
  interact_summary_ (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::interact_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::interact_summary >
  interact_summary_ (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::interact_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::interact_summary >
  interact_summary_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::interact_summary_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::interact_summary >
  interact_summary_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::interact_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::interact_summary >
  interact_summary_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::interact_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::interact_summary >
  interact_summary_ (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::interact_summary > (
      ::pepXML::interact_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::interact_summary >
  interact_summary_ (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::interact_summary > (
      ::pepXML::interact_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::interact_summary >
  interact_summary_ (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::interact_summary > (
      ::pepXML::interact_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::interact_summary >
  interact_summary_ (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::interact_summary > (
        ::pepXML::interact_summary_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "interact_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::interact_summary > r (
        ::xsd::cxx::tree::traits< ::pepXML::interact_summary, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "interact_summary",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::interact_summary >
  interact_summary_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "interact_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::interact_summary > r (
        ::xsd::cxx::tree::traits< ::pepXML::interact_summary, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "interact_summary",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::libra_result >
  libra_result_ (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::libra_result > (
      ::pepXML::libra_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::libra_result >
  libra_result_ (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::libra_result > (
      ::pepXML::libra_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::libra_result >
  libra_result_ (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::libra_result > (
      ::pepXML::libra_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::libra_result >
  libra_result_ (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::libra_result_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::libra_result >
  libra_result_ (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::libra_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::libra_result >
  libra_result_ (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::libra_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::libra_result >
  libra_result_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::libra_result_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::libra_result >
  libra_result_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::libra_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::libra_result >
  libra_result_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::libra_result_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::libra_result >
  libra_result_ (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::libra_result > (
      ::pepXML::libra_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::libra_result >
  libra_result_ (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::libra_result > (
      ::pepXML::libra_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::libra_result >
  libra_result_ (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::libra_result > (
      ::pepXML::libra_result_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::libra_result >
  libra_result_ (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::libra_result > (
        ::pepXML::libra_result_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "libra_result" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::libra_result > r (
        ::xsd::cxx::tree::traits< ::pepXML::libra_result, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "libra_result",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::libra_result >
  libra_result_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "libra_result" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::libra_result > r (
        ::xsd::cxx::tree::traits< ::pepXML::libra_result, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "libra_result",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::libra_summary >
  libra_summary_ (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::libra_summary > (
      ::pepXML::libra_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::libra_summary >
  libra_summary_ (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::libra_summary > (
      ::pepXML::libra_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::libra_summary >
  libra_summary_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::libra_summary > (
      ::pepXML::libra_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::libra_summary >
  libra_summary_ (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::libra_summary_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::libra_summary >
  libra_summary_ (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::libra_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::libra_summary >
  libra_summary_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pepXML::libra_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::libra_summary >
  libra_summary_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::libra_summary_ (isrc, f, p);
  }

  ::std::unique_ptr< ::pepXML::libra_summary >
  libra_summary_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::libra_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::libra_summary >
  libra_summary_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pepXML::libra_summary_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pepXML::libra_summary >
  libra_summary_ (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pepXML::libra_summary > (
      ::pepXML::libra_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::libra_summary >
  libra_summary_ (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::libra_summary > (
      ::pepXML::libra_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::libra_summary >
  libra_summary_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pepXML::libra_summary > (
      ::pepXML::libra_summary_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pepXML::libra_summary >
  libra_summary_ (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pepXML::libra_summary > (
        ::pepXML::libra_summary_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "libra_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::libra_summary > r (
        ::xsd::cxx::tree::traits< ::pepXML::libra_summary, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "libra_summary",
      "http://regis-web.systemsbiology.net/pepXML");
  }

  ::std::unique_ptr< ::pepXML::libra_summary >
  libra_summary_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "libra_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      ::std::unique_ptr< ::pepXML::libra_summary > r (
        ::xsd::cxx::tree::traits< ::pepXML::libra_summary, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "libra_summary",
      "http://regis-web.systemsbiology.net/pepXML");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace pepXML
{
  void
  msms_pipeline_analysis_ (::std::ostream& o,
                           const ::pepXML::msms_pipeline_analysis& s,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::msms_pipeline_analysis_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  msms_pipeline_analysis_ (::std::ostream& o,
                           const ::pepXML::msms_pipeline_analysis& s,
                           ::xml_schema::error_handler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::msms_pipeline_analysis_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  msms_pipeline_analysis_ (::std::ostream& o,
                           const ::pepXML::msms_pipeline_analysis& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::msms_pipeline_analysis_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  msms_pipeline_analysis_ (::xercesc::XMLFormatTarget& t,
                           const ::pepXML::msms_pipeline_analysis& s,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::msms_pipeline_analysis_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  msms_pipeline_analysis_ (::xercesc::XMLFormatTarget& t,
                           const ::pepXML::msms_pipeline_analysis& s,
                           ::xml_schema::error_handler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::msms_pipeline_analysis_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  msms_pipeline_analysis_ (::xercesc::XMLFormatTarget& t,
                           const ::pepXML::msms_pipeline_analysis& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::msms_pipeline_analysis_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  msms_pipeline_analysis_ (::xercesc::DOMDocument& d,
                           const ::pepXML::msms_pipeline_analysis& s,
                           ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "msms_pipeline_analysis" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "msms_pipeline_analysis",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  msms_pipeline_analysis_ (const ::pepXML::msms_pipeline_analysis& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "msms_pipeline_analysis",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::msms_pipeline_analysis_ (*d, s, f);
    return d;
  }

  void
  peptideprophet_summary_ (::std::ostream& o,
                           const ::pepXML::peptideprophet_summary& s,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::peptideprophet_summary_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  peptideprophet_summary_ (::std::ostream& o,
                           const ::pepXML::peptideprophet_summary& s,
                           ::xml_schema::error_handler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::peptideprophet_summary_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  peptideprophet_summary_ (::std::ostream& o,
                           const ::pepXML::peptideprophet_summary& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::peptideprophet_summary_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  peptideprophet_summary_ (::xercesc::XMLFormatTarget& t,
                           const ::pepXML::peptideprophet_summary& s,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::peptideprophet_summary_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  peptideprophet_summary_ (::xercesc::XMLFormatTarget& t,
                           const ::pepXML::peptideprophet_summary& s,
                           ::xml_schema::error_handler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::peptideprophet_summary_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  peptideprophet_summary_ (::xercesc::XMLFormatTarget& t,
                           const ::pepXML::peptideprophet_summary& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::peptideprophet_summary_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  peptideprophet_summary_ (::xercesc::DOMDocument& d,
                           const ::pepXML::peptideprophet_summary& s,
                           ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "peptideprophet_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "peptideprophet_summary",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  peptideprophet_summary_ (const ::pepXML::peptideprophet_summary& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "peptideprophet_summary",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::peptideprophet_summary_ (*d, s, f);
    return d;
  }

  void
  interprophet_summary_ (::std::ostream& o,
                         const ::pepXML::interprophet_summary& s,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::string& e,
                         ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::interprophet_summary_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  interprophet_summary_ (::std::ostream& o,
                         const ::pepXML::interprophet_summary& s,
                         ::xml_schema::error_handler& h,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::string& e,
                         ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::interprophet_summary_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  interprophet_summary_ (::std::ostream& o,
                         const ::pepXML::interprophet_summary& s,
                         ::xercesc::DOMErrorHandler& h,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::string& e,
                         ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::interprophet_summary_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  interprophet_summary_ (::xercesc::XMLFormatTarget& t,
                         const ::pepXML::interprophet_summary& s,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::string& e,
                         ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::interprophet_summary_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  interprophet_summary_ (::xercesc::XMLFormatTarget& t,
                         const ::pepXML::interprophet_summary& s,
                         ::xml_schema::error_handler& h,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::string& e,
                         ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::interprophet_summary_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  interprophet_summary_ (::xercesc::XMLFormatTarget& t,
                         const ::pepXML::interprophet_summary& s,
                         ::xercesc::DOMErrorHandler& h,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::string& e,
                         ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::interprophet_summary_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  interprophet_summary_ (::xercesc::DOMDocument& d,
                         const ::pepXML::interprophet_summary& s,
                         ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "interprophet_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "interprophet_summary",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  interprophet_summary_ (const ::pepXML::interprophet_summary& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "interprophet_summary",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::interprophet_summary_ (*d, s, f);
    return d;
  }

  void
  ptmprophet_summary_ (::std::ostream& o,
                       const ::pepXML::ptmprophet_summary& s,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::ptmprophet_summary_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ptmprophet_summary_ (::std::ostream& o,
                       const ::pepXML::ptmprophet_summary& s,
                       ::xml_schema::error_handler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::ptmprophet_summary_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ptmprophet_summary_ (::std::ostream& o,
                       const ::pepXML::ptmprophet_summary& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::ptmprophet_summary_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ptmprophet_summary_ (::xercesc::XMLFormatTarget& t,
                       const ::pepXML::ptmprophet_summary& s,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::ptmprophet_summary_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ptmprophet_summary_ (::xercesc::XMLFormatTarget& t,
                       const ::pepXML::ptmprophet_summary& s,
                       ::xml_schema::error_handler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::ptmprophet_summary_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ptmprophet_summary_ (::xercesc::XMLFormatTarget& t,
                       const ::pepXML::ptmprophet_summary& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::ptmprophet_summary_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ptmprophet_summary_ (::xercesc::DOMDocument& d,
                       const ::pepXML::ptmprophet_summary& s,
                       ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ptmprophet_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ptmprophet_summary",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  ptmprophet_summary_ (const ::pepXML::ptmprophet_summary& s,
                       const ::xml_schema::namespace_infomap& m,
                       ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "ptmprophet_summary",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::ptmprophet_summary_ (*d, s, f);
    return d;
  }

  void
  asapratio_summary_ (::std::ostream& o,
                      const ::pepXML::asapratio_summary& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_summary_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  asapratio_summary_ (::std::ostream& o,
                      const ::pepXML::asapratio_summary& s,
                      ::xml_schema::error_handler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_summary_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_summary_ (::std::ostream& o,
                      const ::pepXML::asapratio_summary& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_summary_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_summary_ (::xercesc::XMLFormatTarget& t,
                      const ::pepXML::asapratio_summary& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_summary_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  asapratio_summary_ (::xercesc::XMLFormatTarget& t,
                      const ::pepXML::asapratio_summary& s,
                      ::xml_schema::error_handler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_summary_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_summary_ (::xercesc::XMLFormatTarget& t,
                      const ::pepXML::asapratio_summary& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_summary_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_summary_ (::xercesc::DOMDocument& d,
                      const ::pepXML::asapratio_summary& s,
                      ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "asapratio_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "asapratio_summary",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  asapratio_summary_ (const ::pepXML::asapratio_summary& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "asapratio_summary",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::asapratio_summary_ (*d, s, f);
    return d;
  }

  void
  xpressratio_summary_ (::std::ostream& o,
                        const ::pepXML::xpressratio_summary& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::xpressratio_summary_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  xpressratio_summary_ (::std::ostream& o,
                        const ::pepXML::xpressratio_summary& s,
                        ::xml_schema::error_handler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::xpressratio_summary_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  xpressratio_summary_ (::std::ostream& o,
                        const ::pepXML::xpressratio_summary& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::xpressratio_summary_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  xpressratio_summary_ (::xercesc::XMLFormatTarget& t,
                        const ::pepXML::xpressratio_summary& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::xpressratio_summary_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  xpressratio_summary_ (::xercesc::XMLFormatTarget& t,
                        const ::pepXML::xpressratio_summary& s,
                        ::xml_schema::error_handler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::xpressratio_summary_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  xpressratio_summary_ (::xercesc::XMLFormatTarget& t,
                        const ::pepXML::xpressratio_summary& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::xpressratio_summary_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  xpressratio_summary_ (::xercesc::DOMDocument& d,
                        const ::pepXML::xpressratio_summary& s,
                        ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "xpressratio_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "xpressratio_summary",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  xpressratio_summary_ (const ::pepXML::xpressratio_summary& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "xpressratio_summary",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::xpressratio_summary_ (*d, s, f);
    return d;
  }

  void
  ptmprophet_result_ (::std::ostream& o,
                      const ::pepXML::ptmprophet_result& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::ptmprophet_result_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ptmprophet_result_ (::std::ostream& o,
                      const ::pepXML::ptmprophet_result& s,
                      ::xml_schema::error_handler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::ptmprophet_result_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ptmprophet_result_ (::std::ostream& o,
                      const ::pepXML::ptmprophet_result& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::ptmprophet_result_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ptmprophet_result_ (::xercesc::XMLFormatTarget& t,
                      const ::pepXML::ptmprophet_result& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::ptmprophet_result_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ptmprophet_result_ (::xercesc::XMLFormatTarget& t,
                      const ::pepXML::ptmprophet_result& s,
                      ::xml_schema::error_handler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::ptmprophet_result_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ptmprophet_result_ (::xercesc::XMLFormatTarget& t,
                      const ::pepXML::ptmprophet_result& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::ptmprophet_result_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ptmprophet_result_ (::xercesc::DOMDocument& d,
                      const ::pepXML::ptmprophet_result& s,
                      ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ptmprophet_result" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ptmprophet_result",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  ptmprophet_result_ (const ::pepXML::ptmprophet_result& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "ptmprophet_result",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::ptmprophet_result_ (*d, s, f);
    return d;
  }

  void
  peptideprophet_result_ (::std::ostream& o,
                          const ::pepXML::peptideprophet_result& s,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::peptideprophet_result_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  peptideprophet_result_ (::std::ostream& o,
                          const ::pepXML::peptideprophet_result& s,
                          ::xml_schema::error_handler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::peptideprophet_result_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  peptideprophet_result_ (::std::ostream& o,
                          const ::pepXML::peptideprophet_result& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::peptideprophet_result_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  peptideprophet_result_ (::xercesc::XMLFormatTarget& t,
                          const ::pepXML::peptideprophet_result& s,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::peptideprophet_result_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  peptideprophet_result_ (::xercesc::XMLFormatTarget& t,
                          const ::pepXML::peptideprophet_result& s,
                          ::xml_schema::error_handler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::peptideprophet_result_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  peptideprophet_result_ (::xercesc::XMLFormatTarget& t,
                          const ::pepXML::peptideprophet_result& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::peptideprophet_result_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  peptideprophet_result_ (::xercesc::DOMDocument& d,
                          const ::pepXML::peptideprophet_result& s,
                          ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "peptideprophet_result" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "peptideprophet_result",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  peptideprophet_result_ (const ::pepXML::peptideprophet_result& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "peptideprophet_result",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::peptideprophet_result_ (*d, s, f);
    return d;
  }

  void
  interprophet_result_ (::std::ostream& o,
                        const ::pepXML::interprophet_result& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::interprophet_result_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  interprophet_result_ (::std::ostream& o,
                        const ::pepXML::interprophet_result& s,
                        ::xml_schema::error_handler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::interprophet_result_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  interprophet_result_ (::std::ostream& o,
                        const ::pepXML::interprophet_result& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::interprophet_result_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  interprophet_result_ (::xercesc::XMLFormatTarget& t,
                        const ::pepXML::interprophet_result& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::interprophet_result_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  interprophet_result_ (::xercesc::XMLFormatTarget& t,
                        const ::pepXML::interprophet_result& s,
                        ::xml_schema::error_handler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::interprophet_result_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  interprophet_result_ (::xercesc::XMLFormatTarget& t,
                        const ::pepXML::interprophet_result& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::interprophet_result_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  interprophet_result_ (::xercesc::DOMDocument& d,
                        const ::pepXML::interprophet_result& s,
                        ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "interprophet_result" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "interprophet_result",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  interprophet_result_ (const ::pepXML::interprophet_result& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "interprophet_result",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::interprophet_result_ (*d, s, f);
    return d;
  }

  void
  asapratio_result_ (::std::ostream& o,
                     const ::pepXML::asapratio_result& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_result_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  asapratio_result_ (::std::ostream& o,
                     const ::pepXML::asapratio_result& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_result_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_result_ (::std::ostream& o,
                     const ::pepXML::asapratio_result& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_result_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_result_ (::xercesc::XMLFormatTarget& t,
                     const ::pepXML::asapratio_result& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_result_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  asapratio_result_ (::xercesc::XMLFormatTarget& t,
                     const ::pepXML::asapratio_result& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_result_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_result_ (::xercesc::XMLFormatTarget& t,
                     const ::pepXML::asapratio_result& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_result_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_result_ (::xercesc::DOMDocument& d,
                     const ::pepXML::asapratio_result& s,
                     ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "asapratio_result" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "asapratio_result",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  asapratio_result_ (const ::pepXML::asapratio_result& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "asapratio_result",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::asapratio_result_ (*d, s, f);
    return d;
  }

  void
  asapratio_peptide_data_ (::std::ostream& o,
                           const ::pepXML::asapratio_peptide_data& s,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_peptide_data_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  asapratio_peptide_data_ (::std::ostream& o,
                           const ::pepXML::asapratio_peptide_data& s,
                           ::xml_schema::error_handler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_peptide_data_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_peptide_data_ (::std::ostream& o,
                           const ::pepXML::asapratio_peptide_data& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_peptide_data_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_peptide_data_ (::xercesc::XMLFormatTarget& t,
                           const ::pepXML::asapratio_peptide_data& s,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_peptide_data_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  asapratio_peptide_data_ (::xercesc::XMLFormatTarget& t,
                           const ::pepXML::asapratio_peptide_data& s,
                           ::xml_schema::error_handler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_peptide_data_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_peptide_data_ (::xercesc::XMLFormatTarget& t,
                           const ::pepXML::asapratio_peptide_data& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_peptide_data_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_peptide_data_ (::xercesc::DOMDocument& d,
                           const ::pepXML::asapratio_peptide_data& s,
                           ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "asapratio_peptide_data" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "asapratio_peptide_data",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  asapratio_peptide_data_ (const ::pepXML::asapratio_peptide_data& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "asapratio_peptide_data",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::asapratio_peptide_data_ (*d, s, f);
    return d;
  }

  void
  asapratio_contribution_ (::std::ostream& o,
                           const ::pepXML::asapratio_contribution& s,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_contribution_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  asapratio_contribution_ (::std::ostream& o,
                           const ::pepXML::asapratio_contribution& s,
                           ::xml_schema::error_handler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_contribution_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_contribution_ (::std::ostream& o,
                           const ::pepXML::asapratio_contribution& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_contribution_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_contribution_ (::xercesc::XMLFormatTarget& t,
                           const ::pepXML::asapratio_contribution& s,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_contribution_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  asapratio_contribution_ (::xercesc::XMLFormatTarget& t,
                           const ::pepXML::asapratio_contribution& s,
                           ::xml_schema::error_handler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_contribution_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_contribution_ (::xercesc::XMLFormatTarget& t,
                           const ::pepXML::asapratio_contribution& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_contribution_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_contribution_ (::xercesc::DOMDocument& d,
                           const ::pepXML::asapratio_contribution& s,
                           ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "asapratio_contribution" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "asapratio_contribution",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  asapratio_contribution_ (const ::pepXML::asapratio_contribution& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "asapratio_contribution",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::asapratio_contribution_ (*d, s, f);
    return d;
  }

  void
  asapratio_lc_lightpeak_ (::std::ostream& o,
                           const ::pepXML::asapratio_lc_lightpeak& s,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_lc_lightpeak_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  asapratio_lc_lightpeak_ (::std::ostream& o,
                           const ::pepXML::asapratio_lc_lightpeak& s,
                           ::xml_schema::error_handler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_lc_lightpeak_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_lc_lightpeak_ (::std::ostream& o,
                           const ::pepXML::asapratio_lc_lightpeak& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_lc_lightpeak_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_lc_lightpeak_ (::xercesc::XMLFormatTarget& t,
                           const ::pepXML::asapratio_lc_lightpeak& s,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_lc_lightpeak_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  asapratio_lc_lightpeak_ (::xercesc::XMLFormatTarget& t,
                           const ::pepXML::asapratio_lc_lightpeak& s,
                           ::xml_schema::error_handler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_lc_lightpeak_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_lc_lightpeak_ (::xercesc::XMLFormatTarget& t,
                           const ::pepXML::asapratio_lc_lightpeak& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_lc_lightpeak_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_lc_lightpeak_ (::xercesc::DOMDocument& d,
                           const ::pepXML::asapratio_lc_lightpeak& s,
                           ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "asapratio_lc_lightpeak" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "asapratio_lc_lightpeak",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  asapratio_lc_lightpeak_ (const ::pepXML::asapratio_lc_lightpeak& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "asapratio_lc_lightpeak",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::asapratio_lc_lightpeak_ (*d, s, f);
    return d;
  }

  void
  asapratio_lc_heavypeak_ (::std::ostream& o,
                           const ::pepXML::asapratio_lc_heavypeak& s,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_lc_heavypeak_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  asapratio_lc_heavypeak_ (::std::ostream& o,
                           const ::pepXML::asapratio_lc_heavypeak& s,
                           ::xml_schema::error_handler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_lc_heavypeak_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_lc_heavypeak_ (::std::ostream& o,
                           const ::pepXML::asapratio_lc_heavypeak& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_lc_heavypeak_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_lc_heavypeak_ (::xercesc::XMLFormatTarget& t,
                           const ::pepXML::asapratio_lc_heavypeak& s,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_lc_heavypeak_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  asapratio_lc_heavypeak_ (::xercesc::XMLFormatTarget& t,
                           const ::pepXML::asapratio_lc_heavypeak& s,
                           ::xml_schema::error_handler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_lc_heavypeak_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_lc_heavypeak_ (::xercesc::XMLFormatTarget& t,
                           const ::pepXML::asapratio_lc_heavypeak& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_lc_heavypeak_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_lc_heavypeak_ (::xercesc::DOMDocument& d,
                           const ::pepXML::asapratio_lc_heavypeak& s,
                           ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "asapratio_lc_heavypeak" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "asapratio_lc_heavypeak",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  asapratio_lc_heavypeak_ (const ::pepXML::asapratio_lc_heavypeak& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "asapratio_lc_heavypeak",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::asapratio_lc_heavypeak_ (*d, s, f);
    return d;
  }

  void
  database_refresh_timestamp_ (::std::ostream& o,
                               const ::pepXML::database_refresh_timestamp& s,
                               const ::xml_schema::namespace_infomap& m,
                               const ::std::string& e,
                               ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::database_refresh_timestamp_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  database_refresh_timestamp_ (::std::ostream& o,
                               const ::pepXML::database_refresh_timestamp& s,
                               ::xml_schema::error_handler& h,
                               const ::xml_schema::namespace_infomap& m,
                               const ::std::string& e,
                               ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::database_refresh_timestamp_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  database_refresh_timestamp_ (::std::ostream& o,
                               const ::pepXML::database_refresh_timestamp& s,
                               ::xercesc::DOMErrorHandler& h,
                               const ::xml_schema::namespace_infomap& m,
                               const ::std::string& e,
                               ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::database_refresh_timestamp_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  database_refresh_timestamp_ (::xercesc::XMLFormatTarget& t,
                               const ::pepXML::database_refresh_timestamp& s,
                               const ::xml_schema::namespace_infomap& m,
                               const ::std::string& e,
                               ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::database_refresh_timestamp_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  database_refresh_timestamp_ (::xercesc::XMLFormatTarget& t,
                               const ::pepXML::database_refresh_timestamp& s,
                               ::xml_schema::error_handler& h,
                               const ::xml_schema::namespace_infomap& m,
                               const ::std::string& e,
                               ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::database_refresh_timestamp_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  database_refresh_timestamp_ (::xercesc::XMLFormatTarget& t,
                               const ::pepXML::database_refresh_timestamp& s,
                               ::xercesc::DOMErrorHandler& h,
                               const ::xml_schema::namespace_infomap& m,
                               const ::std::string& e,
                               ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::database_refresh_timestamp_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  database_refresh_timestamp_ (::xercesc::DOMDocument& d,
                               const ::pepXML::database_refresh_timestamp& s,
                               ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "database_refresh_timestamp" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "database_refresh_timestamp",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  database_refresh_timestamp_ (const ::pepXML::database_refresh_timestamp& s,
                               const ::xml_schema::namespace_infomap& m,
                               ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "database_refresh_timestamp",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::database_refresh_timestamp_ (*d, s, f);
    return d;
  }

  void
  xpressratio_timestamp_ (::std::ostream& o,
                          const ::pepXML::xpressratio_timestamp& s,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::xpressratio_timestamp_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  xpressratio_timestamp_ (::std::ostream& o,
                          const ::pepXML::xpressratio_timestamp& s,
                          ::xml_schema::error_handler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::xpressratio_timestamp_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  xpressratio_timestamp_ (::std::ostream& o,
                          const ::pepXML::xpressratio_timestamp& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::xpressratio_timestamp_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  xpressratio_timestamp_ (::xercesc::XMLFormatTarget& t,
                          const ::pepXML::xpressratio_timestamp& s,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::xpressratio_timestamp_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  xpressratio_timestamp_ (::xercesc::XMLFormatTarget& t,
                          const ::pepXML::xpressratio_timestamp& s,
                          ::xml_schema::error_handler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::xpressratio_timestamp_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  xpressratio_timestamp_ (::xercesc::XMLFormatTarget& t,
                          const ::pepXML::xpressratio_timestamp& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::xpressratio_timestamp_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  xpressratio_timestamp_ (::xercesc::DOMDocument& d,
                          const ::pepXML::xpressratio_timestamp& s,
                          ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "xpressratio_timestamp" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "xpressratio_timestamp",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  xpressratio_timestamp_ (const ::pepXML::xpressratio_timestamp& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "xpressratio_timestamp",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::xpressratio_timestamp_ (*d, s, f);
    return d;
  }

  void
  asapratio_timestamp_ (::std::ostream& o,
                        const ::pepXML::asapratio_timestamp& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_timestamp_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  asapratio_timestamp_ (::std::ostream& o,
                        const ::pepXML::asapratio_timestamp& s,
                        ::xml_schema::error_handler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_timestamp_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_timestamp_ (::std::ostream& o,
                        const ::pepXML::asapratio_timestamp& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_timestamp_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_timestamp_ (::xercesc::XMLFormatTarget& t,
                        const ::pepXML::asapratio_timestamp& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_timestamp_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  asapratio_timestamp_ (::xercesc::XMLFormatTarget& t,
                        const ::pepXML::asapratio_timestamp& s,
                        ::xml_schema::error_handler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_timestamp_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_timestamp_ (::xercesc::XMLFormatTarget& t,
                        const ::pepXML::asapratio_timestamp& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::asapratio_timestamp_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  asapratio_timestamp_ (::xercesc::DOMDocument& d,
                        const ::pepXML::asapratio_timestamp& s,
                        ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "asapratio_timestamp" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "asapratio_timestamp",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  asapratio_timestamp_ (const ::pepXML::asapratio_timestamp& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "asapratio_timestamp",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::asapratio_timestamp_ (*d, s, f);
    return d;
  }

  void
  xpressratio_result_ (::std::ostream& o,
                       const ::pepXML::xpressratio_result& s,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::xpressratio_result_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  xpressratio_result_ (::std::ostream& o,
                       const ::pepXML::xpressratio_result& s,
                       ::xml_schema::error_handler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::xpressratio_result_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  xpressratio_result_ (::std::ostream& o,
                       const ::pepXML::xpressratio_result& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::xpressratio_result_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  xpressratio_result_ (::xercesc::XMLFormatTarget& t,
                       const ::pepXML::xpressratio_result& s,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::xpressratio_result_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  xpressratio_result_ (::xercesc::XMLFormatTarget& t,
                       const ::pepXML::xpressratio_result& s,
                       ::xml_schema::error_handler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::xpressratio_result_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  xpressratio_result_ (::xercesc::XMLFormatTarget& t,
                       const ::pepXML::xpressratio_result& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::xpressratio_result_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  xpressratio_result_ (::xercesc::DOMDocument& d,
                       const ::pepXML::xpressratio_result& s,
                       ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "xpressratio_result" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "xpressratio_result",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  xpressratio_result_ (const ::pepXML::xpressratio_result& s,
                       const ::xml_schema::namespace_infomap& m,
                       ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "xpressratio_result",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::xpressratio_result_ (*d, s, f);
    return d;
  }

  void
  interact_summary_ (::std::ostream& o,
                     const ::pepXML::interact_summary& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::interact_summary_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  interact_summary_ (::std::ostream& o,
                     const ::pepXML::interact_summary& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::interact_summary_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  interact_summary_ (::std::ostream& o,
                     const ::pepXML::interact_summary& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::interact_summary_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  interact_summary_ (::xercesc::XMLFormatTarget& t,
                     const ::pepXML::interact_summary& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::interact_summary_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  interact_summary_ (::xercesc::XMLFormatTarget& t,
                     const ::pepXML::interact_summary& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::interact_summary_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  interact_summary_ (::xercesc::XMLFormatTarget& t,
                     const ::pepXML::interact_summary& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::interact_summary_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  interact_summary_ (::xercesc::DOMDocument& d,
                     const ::pepXML::interact_summary& s,
                     ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "interact_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "interact_summary",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  interact_summary_ (const ::pepXML::interact_summary& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "interact_summary",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::interact_summary_ (*d, s, f);
    return d;
  }

  void
  libra_result_ (::std::ostream& o,
                 const ::pepXML::libra_result& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::libra_result_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  libra_result_ (::std::ostream& o,
                 const ::pepXML::libra_result& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::libra_result_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  libra_result_ (::std::ostream& o,
                 const ::pepXML::libra_result& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::libra_result_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  libra_result_ (::xercesc::XMLFormatTarget& t,
                 const ::pepXML::libra_result& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::libra_result_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  libra_result_ (::xercesc::XMLFormatTarget& t,
                 const ::pepXML::libra_result& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::libra_result_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  libra_result_ (::xercesc::XMLFormatTarget& t,
                 const ::pepXML::libra_result& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::libra_result_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  libra_result_ (::xercesc::DOMDocument& d,
                 const ::pepXML::libra_result& s,
                 ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "libra_result" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "libra_result",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  libra_result_ (const ::pepXML::libra_result& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "libra_result",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::libra_result_ (*d, s, f);
    return d;
  }

  void
  libra_summary_ (::std::ostream& o,
                  const ::pepXML::libra_summary& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::libra_summary_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  libra_summary_ (::std::ostream& o,
                  const ::pepXML::libra_summary& s,
                  ::xml_schema::error_handler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::libra_summary_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  libra_summary_ (::std::ostream& o,
                  const ::pepXML::libra_summary& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::libra_summary_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  libra_summary_ (::xercesc::XMLFormatTarget& t,
                  const ::pepXML::libra_summary& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::libra_summary_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  libra_summary_ (::xercesc::XMLFormatTarget& t,
                  const ::pepXML::libra_summary& s,
                  ::xml_schema::error_handler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::libra_summary_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  libra_summary_ (::xercesc::XMLFormatTarget& t,
                  const ::pepXML::libra_summary& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pepXML::libra_summary_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  libra_summary_ (::xercesc::DOMDocument& d,
                  const ::pepXML::libra_summary& s,
                  ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "libra_summary" &&
        n.namespace_ () == "http://regis-web.systemsbiology.net/pepXML")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "libra_summary",
        "http://regis-web.systemsbiology.net/pepXML");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  libra_summary_ (const ::pepXML::libra_summary& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "libra_summary",
        "http://regis-web.systemsbiology.net/pepXML",
        m, f));

    ::pepXML::libra_summary_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const engineType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const engineType& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const engineType& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const activationMethodType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const activationMethodType& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const activationMethodType& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const model_dis_type& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const model_dis_type& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const model_dis_type& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const massType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const massType& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const massType& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const aa_symbolType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const aa_symbolType& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const aa_symbolType& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const term_symbolType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const term_symbolType& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const term_symbolType& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const positiveInt& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const positiveInt& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const positiveInt& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const nameValueType& i)
  {
    e << static_cast< const ::xml_schema::simple_type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.value ();
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << *i.type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const inputFileType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // directory
    //
    if (i.directory ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "directory",
          e));

      a << *i.directory ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const rocErrorDataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // roc_data_point
    //
    for (rocErrorDataType::roc_data_point_const_iterator
         b (i.roc_data_point ().begin ()), n (i.roc_data_point ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "roc_data_point",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // error_point
    //
    for (rocErrorDataType::error_point_const_iterator
         b (i.error_point ().begin ()), n (i.error_point ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "error_point",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // charge
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "charge",
          e));

      a << i.charge ();
    }

    // charge_est_correct
    //
    if (i.charge_est_correct ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "charge_est_correct",
          e));

      a << ::xml_schema::as_double(*i.charge_est_correct ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const mixtureModelType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // point
    //
    for (mixtureModelType::point_const_iterator
         b (i.point ().begin ()), n (i.point ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "point",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // pos_bandwidth
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "pos_bandwidth",
          e));

      a << ::xml_schema::as_double(i.pos_bandwidth ());
    }

    // neg_bandwidth
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "neg_bandwidth",
          e));

      a << ::xml_schema::as_double(i.neg_bandwidth ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const modInfoDataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // aminoacid_substitution
    //
    for (modInfoDataType::aminoacid_substitution_const_iterator
         b (i.aminoacid_substitution ().begin ()), n (i.aminoacid_substitution ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "aminoacid_substitution",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // mod_aminoacid_mass
    //
    for (modInfoDataType::mod_aminoacid_mass_const_iterator
         b (i.mod_aminoacid_mass ().begin ()), n (i.mod_aminoacid_mass ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mod_aminoacid_mass",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // mod_nterm_mass
    //
    if (i.mod_nterm_mass ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "mod_nterm_mass",
          e));

      a << ::xml_schema::as_double(*i.mod_nterm_mass ());
    }

    // mod_cterm_mass
    //
    if (i.mod_cterm_mass ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "mod_cterm_mass",
          e));

      a << ::xml_schema::as_double(*i.mod_cterm_mass ());
    }

    // modified_peptide
    //
    if (i.modified_peptide ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "modified_peptide",
          e));

      a << *i.modified_peptide ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const subInfoDataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // position
    //
    if (i.position ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "position",
          e));

      a << *i.position ();
    }

    // orig_aa
    //
    if (i.orig_aa ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "orig_aa",
          e));

      a << *i.orig_aa ();
    }

    // num_tol_term
    //
    if (i.num_tol_term ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "num_tol_term",
          e));

      a << *i.num_tol_term ();
    }

    // peptide_prev_aa
    //
    if (i.peptide_prev_aa ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "peptide_prev_aa",
          e));

      a << *i.peptide_prev_aa ();
    }

    // peptide_next_aa
    //
    if (i.peptide_next_aa ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "peptide_next_aa",
          e));

      a << *i.peptide_next_aa ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const altProteinDataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // aminoacid_substitution
    //
    for (altProteinDataType::aminoacid_substitution_const_iterator
         b (i.aminoacid_substitution ().begin ()), n (i.aminoacid_substitution ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "aminoacid_substitution",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // protein
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "protein",
          e));

      a << i.protein ();
    }

    // protein_descr
    //
    if (i.protein_descr ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "protein_descr",
          e));

      a << *i.protein_descr ();
    }

    // num_tol_term
    //
    if (i.num_tol_term ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "num_tol_term",
          e));

      a << *i.num_tol_term ();
    }

    // protein_mw
    //
    if (i.protein_mw ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "protein_mw",
          e));

      a << ::xml_schema::as_double(*i.protein_mw ());
    }

    // peptide_prev_aa
    //
    if (i.peptide_prev_aa ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "peptide_prev_aa",
          e));

      a << *i.peptide_prev_aa ();
    }

    // peptide_next_aa
    //
    if (i.peptide_next_aa ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "peptide_next_aa",
          e));

      a << *i.peptide_next_aa ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const msms_pipeline_analysis& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // analysis_summary
    //
    for (msms_pipeline_analysis::analysis_summary_const_iterator
         b (i.analysis_summary ().begin ()), n (i.analysis_summary ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "analysis_summary",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // dataset_derivation
    //
    if (i.dataset_derivation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dataset_derivation",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *i.dataset_derivation ();
    }

    // msms_run_summary
    //
    for (msms_pipeline_analysis::msms_run_summary_const_iterator
         b (i.msms_run_summary ().begin ()), n (i.msms_run_summary ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "msms_run_summary",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // name
    //
    if (i.name ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.name ();
    }

    // date
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "date",
          e));

      a << i.date ();
    }

    // summary_xml
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "summary_xml",
          e));

      a << i.summary_xml ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const peptideprophet_summary& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // inputfile
    //
    for (peptideprophet_summary::inputfile_const_iterator
         b (i.inputfile ().begin ()), n (i.inputfile ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inputfile",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // roc_error_data
    //
    for (peptideprophet_summary::roc_error_data_const_iterator
         b (i.roc_error_data ().begin ()), n (i.roc_error_data ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "roc_error_data",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // distribution_point
    //
    for (peptideprophet_summary::distribution_point_const_iterator
         b (i.distribution_point ().begin ()), n (i.distribution_point ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "distribution_point",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // mixture_model
    //
    for (peptideprophet_summary::mixture_model_const_iterator
         b (i.mixture_model ().begin ()), n (i.mixture_model ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mixture_model",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // version
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "version",
          e));

      a << i.version ();
    }

    // author
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "author",
          e));

      a << i.author ();
    }

    // min_prob
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "min_prob",
          e));

      a << ::xml_schema::as_double(i.min_prob ());
    }

    // options
    //
    if (i.options ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "options",
          e));

      a << *i.options ();
    }

    // est_tot_num_correct
    //
    if (i.est_tot_num_correct ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "est_tot_num_correct",
          e));

      a << ::xml_schema::as_double(*i.est_tot_num_correct ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const interprophet_summary& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // inputfile
    //
    for (interprophet_summary::inputfile_const_iterator
         b (i.inputfile ().begin ()), n (i.inputfile ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inputfile",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // roc_error_data
    //
    for (interprophet_summary::roc_error_data_const_iterator
         b (i.roc_error_data ().begin ()), n (i.roc_error_data ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "roc_error_data",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // mixturemodel
    //
    for (interprophet_summary::mixturemodel_const_iterator
         b (i.mixturemodel ().begin ()), n (i.mixturemodel ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mixturemodel",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // version
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "version",
          e));

      a << i.version ();
    }

    // options
    //
    if (i.options ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "options",
          e));

      a << *i.options ();
    }

    // est_tot_num_correct_psm
    //
    if (i.est_tot_num_correct_psm ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "est_tot_num_correct_psm",
          e));

      a << ::xml_schema::as_double(*i.est_tot_num_correct_psm ());
    }

    // est_tot_num_correct_pep
    //
    if (i.est_tot_num_correct_pep ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "est_tot_num_correct_pep",
          e));

      a << ::xml_schema::as_double(*i.est_tot_num_correct_pep ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ptmprophet_summary& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // inputfile
    //
    for (ptmprophet_summary::inputfile_const_iterator
         b (i.inputfile ().begin ()), n (i.inputfile ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inputfile",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // mixturemodel
    //
    for (ptmprophet_summary::mixturemodel_const_iterator
         b (i.mixturemodel ().begin ()), n (i.mixturemodel ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mixturemodel",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // version
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "version",
          e));

      a << i.version ();
    }

    // options
    //
    if (i.options ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "options",
          e));

      a << *i.options ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const asapratio_summary& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // version
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "version",
          e));

      a << i.version ();
    }

    // author
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "author",
          e));

      a << i.author ();
    }

    // elution
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "elution",
          e));

      a << i.elution ();
    }

    // labeled_residues
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "labeled_residues",
          e));

      a << i.labeled_residues ();
    }

    // area_flag
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "area_flag",
          e));

      a << i.area_flag ();
    }

    // static_quant
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "static_quant",
          e));

      a << i.static_quant ();
    }

    // specified_residue_masses
    //
    if (i.specified_residue_masses ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "specified_residue_masses",
          e));

      a << *i.specified_residue_masses ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const xpressratio_summary& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // version
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "version",
          e));

      a << i.version ();
    }

    // author
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "author",
          e));

      a << i.author ();
    }

    // same_scan_range
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "same_scan_range",
          e));

      a << i.same_scan_range ();
    }

    // labeled_residues
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "labeled_residues",
          e));

      a << i.labeled_residues ();
    }

    // xpress_light
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "xpress_light",
          e));

      a << i.xpress_light ();
    }

    // massdiff
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "massdiff",
          e));

      a << ::xml_schema::as_double(i.massdiff ());
    }

    // masstol
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "masstol",
          e));

      a << ::xml_schema::as_double(i.masstol ());
    }

    // ppmtol
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ppmtol",
          e));

      a << ::xml_schema::as_double(i.ppmtol ());
    }

    // min_num_chromatogram_points
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "min_num_chromatogram_points",
          e));

      a << i.min_num_chromatogram_points ();
    }

    // min_num_isotope_peaks
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "min_num_isotope_peaks",
          e));

      a << i.min_num_isotope_peaks ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ptmprophet_result& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // mod_aminoacid_probability
    //
    for (ptmprophet_result::mod_aminoacid_probability_const_iterator
         b (i.mod_aminoacid_probability ().begin ()), n (i.mod_aminoacid_probability ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mod_aminoacid_probability",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // prior
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "prior",
          e));

      a << ::xml_schema::as_double(i.prior ());
    }

    // ptm
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ptm",
          e));

      a << i.ptm ();
    }

    // ptm_peptide
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ptm_peptide",
          e));

      a << i.ptm_peptide ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const peptideprophet_result& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // search_score_summary
    //
    if (i.search_score_summary ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "search_score_summary",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *i.search_score_summary ();
    }

    // probability
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "probability",
          e));

      a << ::xml_schema::as_double(i.probability ());
    }

    // all_ntt_prob
    //
    if (i.all_ntt_prob ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "all_ntt_prob",
          e));

      a << *i.all_ntt_prob ();
    }

    // analysis
    //
    if (i.analysis ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "analysis",
          e));

      a << *i.analysis ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const interprophet_result& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // search_score_summary
    //
    if (i.search_score_summary ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "search_score_summary",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *i.search_score_summary ();
    }

    // probability
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "probability",
          e));

      a << ::xml_schema::as_double(i.probability ());
    }

    // all_ntt_prob
    //
    if (i.all_ntt_prob ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "all_ntt_prob",
          e));

      a << *i.all_ntt_prob ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const asapratio_result& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // asapratio_peptide_data
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "asapratio_peptide_data",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << i.asapratio_peptide_data ();
    }

    // mean
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "mean",
          e));

      a << ::xml_schema::as_double(i.mean ());
    }

    // error
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "error",
          e));

      a << ::xml_schema::as_double(i.error ());
    }

    // heavy2light_mean
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "heavy2light_mean",
          e));

      a << ::xml_schema::as_double(i.heavy2light_mean ());
    }

    // heavy2light_error
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "heavy2light_error",
          e));

      a << ::xml_schema::as_double(i.heavy2light_error ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const asapratio_peptide_data& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // asapratio_contribution
    //
    for (asapratio_peptide_data::asapratio_contribution_const_iterator
         b (i.asapratio_contribution ().begin ()), n (i.asapratio_contribution ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "asapratio_contribution",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // status
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "status",
          e));

      a << i.status ();
    }

    // cidIndex
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "cidIndex",
          e));

      a << i.cidIndex ();
    }

    // light_mass
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "light_mass",
          e));

      a << ::xml_schema::as_double(i.light_mass ());
    }

    // heavy_mass
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "heavy_mass",
          e));

      a << ::xml_schema::as_double(i.heavy_mass ());
    }

    // area_flag
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "area_flag",
          e));

      a << i.area_flag ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const asapratio_contribution& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // asapratio_lc_lightpeak
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "asapratio_lc_lightpeak",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << i.asapratio_lc_lightpeak ();
    }

    // asapratio_lc_heavypeak
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "asapratio_lc_heavypeak",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << i.asapratio_lc_heavypeak ();
    }

    // ratio
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ratio",
          e));

      a << ::xml_schema::as_double(i.ratio ());
    }

    // error
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "error",
          e));

      a << ::xml_schema::as_double(i.error ());
    }

    // charge
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "charge",
          e));

      a << i.charge ();
    }

    // use
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "use",
          e));

      a << i.use ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const asapratio_lc_lightpeak& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // status
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "status",
          e));

      a << i.status ();
    }

    // left_valley
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "left_valley",
          e));

      a << i.left_valley ();
    }

    // right_valley
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "right_valley",
          e));

      a << i.right_valley ();
    }

    // background
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "background",
          e));

      a << ::xml_schema::as_double(i.background ());
    }

    // area
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "area",
          e));

      a << ::xml_schema::as_double(i.area ());
    }

    // area_error
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "area_error",
          e));

      a << ::xml_schema::as_double(i.area_error ());
    }

    // time
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "time",
          e));

      a << ::xml_schema::as_double(i.time ());
    }

    // time_width
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "time_width",
          e));

      a << ::xml_schema::as_double(i.time_width ());
    }

    // is_heavy
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "is_heavy",
          e));

      a << i.is_heavy ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const asapratio_lc_heavypeak& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // status
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "status",
          e));

      a << i.status ();
    }

    // left_valley
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "left_valley",
          e));

      a << i.left_valley ();
    }

    // right_valley
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "right_valley",
          e));

      a << i.right_valley ();
    }

    // background
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "background",
          e));

      a << ::xml_schema::as_double(i.background ());
    }

    // area
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "area",
          e));

      a << ::xml_schema::as_double(i.area ());
    }

    // area_error
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "area_error",
          e));

      a << ::xml_schema::as_double(i.area_error ());
    }

    // time
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "time",
          e));

      a << ::xml_schema::as_double(i.time ());
    }

    // time_width
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "time_width",
          e));

      a << ::xml_schema::as_double(i.time_width ());
    }

    // is_heavy
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "is_heavy",
          e));

      a << i.is_heavy ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const database_refresh_timestamp& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // database
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "database",
          e));

      a << i.database ();
    }

    // min_num_enz_term
    //
    if (i.min_num_enz_term ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "min_num_enz_term",
          e));

      a << *i.min_num_enz_term ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const xpressratio_timestamp& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // xpress_light
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "xpress_light",
          e));

      a << i.xpress_light ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const asapratio_timestamp& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // quant_label_masses
    //
    if (i.quant_label_masses ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "quant_label_masses",
          e));

      a << *i.quant_label_masses ();
    }

    // static_quant_label
    //
    if (i.static_quant_label ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "static_quant_label",
          e));

      a << *i.static_quant_label ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const xpressratio_result& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // light_firstscan
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "light_firstscan",
          e));

      a << i.light_firstscan ();
    }

    // light_lastscan
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "light_lastscan",
          e));

      a << i.light_lastscan ();
    }

    // light_mass
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "light_mass",
          e));

      a << ::xml_schema::as_double(i.light_mass ());
    }

    // heavy_firstscan
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "heavy_firstscan",
          e));

      a << i.heavy_firstscan ();
    }

    // heavy_lastscan
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "heavy_lastscan",
          e));

      a << i.heavy_lastscan ();
    }

    // heavy_mass
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "heavy_mass",
          e));

      a << ::xml_schema::as_double(i.heavy_mass ());
    }

    // mass_tol
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "mass_tol",
          e));

      a << ::xml_schema::as_double(i.mass_tol ());
    }

    // ratio
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ratio",
          e));

      a << i.ratio ();
    }

    // heavy2light_ratio
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "heavy2light_ratio",
          e));

      a << i.heavy2light_ratio ();
    }

    // light_area
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "light_area",
          e));

      a << ::xml_schema::as_double(i.light_area ());
    }

    // heavy_area
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "heavy_area",
          e));

      a << ::xml_schema::as_double(i.heavy_area ());
    }

    // decimal_ratio
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "decimal_ratio",
          e));

      a << ::xml_schema::as_decimal(i.decimal_ratio ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const interact_summary& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // inputfile
    //
    for (interact_summary::inputfile_const_iterator
         b (i.inputfile ().begin ()), n (i.inputfile ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inputfile",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // filename
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "filename",
          e));

      a << i.filename ();
    }

    // directory
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "directory",
          e));

      a << i.directory ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const libra_result& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // intensity
    //
    for (libra_result::intensity_const_iterator
         b (i.intensity ().begin ()), n (i.intensity ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "intensity",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // is_rejected
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "is_rejected",
          e));

      a << i.is_rejected ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const libra_summary& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // fragment_masses
    //
    for (libra_summary::fragment_masses_const_iterator
         b (i.fragment_masses ().begin ()), n (i.fragment_masses ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "fragment_masses",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // isotopic_contributions
    //
    if (i.isotopic_contributions ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "isotopic_contributions",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *i.isotopic_contributions ();
    }

    // mass_tolerance
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "mass_tolerance",
          e));

      a << ::xml_schema::as_double(i.mass_tolerance ());
    }

    // centroiding_preference
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "centroiding_preference",
          e));

      a << i.centroiding_preference ();
    }

    // normalization
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "normalization",
          e));

      a << i.normalization ();
    }

    // output_type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "output_type",
          e));

      a << i.output_type ();
    }

    // channel_code
    //
    if (i.channel_code ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "channel_code",
          e));

      a << *i.channel_code ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const roc_data_point& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // min_prob
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "min_prob",
          e));

      a << ::xml_schema::as_double(i.min_prob ());
    }

    // sensitivity
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sensitivity",
          e));

      a << ::xml_schema::as_double(i.sensitivity ());
    }

    // error
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "error",
          e));

      a << ::xml_schema::as_double(i.error ());
    }

    // num_corr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "num_corr",
          e));

      a << i.num_corr ();
    }

    // num_incorr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "num_incorr",
          e));

      a << i.num_incorr ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const error_point& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // error
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "error",
          e));

      a << ::xml_schema::as_double(i.error ());
    }

    // min_prob
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "min_prob",
          e));

      a << ::xml_schema::as_double(i.min_prob ());
    }

    // num_corr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "num_corr",
          e));

      a << i.num_corr ();
    }

    // num_incorr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "num_incorr",
          e));

      a << i.num_incorr ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const point& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // value
    //
    if (i.value ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << ::xml_schema::as_double(*i.value ());
    }

    // pos_dens
    //
    if (i.pos_dens ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "pos_dens",
          e));

      a << ::xml_schema::as_double(*i.pos_dens ());
    }

    // neg_dens
    //
    if (i.neg_dens ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "neg_dens",
          e));

      a << ::xml_schema::as_double(*i.neg_dens ());
    }

    // neg_obs_dens
    //
    if (i.neg_obs_dens ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "neg_obs_dens",
          e));

      a << ::xml_schema::as_double(*i.neg_obs_dens ());
    }

    // pos_obs_dens
    //
    if (i.pos_obs_dens ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "pos_obs_dens",
          e));

      a << ::xml_schema::as_double(*i.pos_obs_dens ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const mod_aminoacid_mass& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // position
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "position",
          e));

      a << i.position ();
    }

    // mass
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "mass",
          e));

      a << ::xml_schema::as_double(i.mass ());
    }

    // source
    //
    if (i.source ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "source",
          e));

      a << *i.source ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const analysis_summary& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // parameter
    //
    for (analysis_summary::parameter_const_iterator
         b (i.parameter ().begin ()), n (i.parameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // time
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "time",
          e));

      a << i.time ();
    }

    // analysis
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "analysis",
          e));

      a << i.analysis ();
    }

    // version
    //
    if (i.version ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "version",
          e));

      a << *i.version ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const dataset_derivation& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // data_filter
    //
    for (dataset_derivation::data_filter_const_iterator
         b (i.data_filter ().begin ()), n (i.data_filter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "data_filter",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // generation_no
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "generation_no",
          e));

      a << i.generation_no ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const msms_run_summary& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // sample_enzyme
    //
    if (i.sample_enzyme ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sample_enzyme",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *i.sample_enzyme ();
    }

    // cross_linker
    //
    if (i.cross_linker ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cross_linker",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *i.cross_linker ();
    }

    // search_summary
    //
    for (msms_run_summary::search_summary_const_iterator
         b (i.search_summary ().begin ()), n (i.search_summary ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "search_summary",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // analysis_timestamp
    //
    for (msms_run_summary::analysis_timestamp_const_iterator
         b (i.analysis_timestamp ().begin ()), n (i.analysis_timestamp ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "analysis_timestamp",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // spectrum_query
    //
    for (msms_run_summary::spectrum_query_const_iterator
         b (i.spectrum_query ().begin ()), n (i.spectrum_query ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "spectrum_query",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // base_name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "base_name",
          e));

      a << i.base_name ();
    }

    // raw_data_type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "raw_data_type",
          e));

      a << i.raw_data_type ();
    }

    // raw_data
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "raw_data",
          e));

      a << i.raw_data ();
    }

    // msManufacturer
    //
    if (i.msManufacturer ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "msManufacturer",
          e));

      a << *i.msManufacturer ();
    }

    // msModel
    //
    if (i.msModel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "msModel",
          e));

      a << *i.msModel ();
    }

    // msIonization
    //
    if (i.msIonization ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "msIonization",
          e));

      a << *i.msIonization ();
    }

    // msMassAnalyzer
    //
    if (i.msMassAnalyzer ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "msMassAnalyzer",
          e));

      a << *i.msMassAnalyzer ();
    }

    // msDetector
    //
    if (i.msDetector ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "msDetector",
          e));

      a << *i.msDetector ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const distribution_point& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // fvalue
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "fvalue",
          e));

      a << ::xml_schema::as_double(i.fvalue ());
    }

    // obs_1_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "obs_1_distr",
          e));

      a << i.obs_1_distr ();
    }

    // model_1_pos_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "model_1_pos_distr",
          e));

      a << ::xml_schema::as_double(i.model_1_pos_distr ());
    }

    // model_1_neg_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "model_1_neg_distr",
          e));

      a << ::xml_schema::as_double(i.model_1_neg_distr ());
    }

    // obs_2_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "obs_2_distr",
          e));

      a << i.obs_2_distr ();
    }

    // model_2_pos_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "model_2_pos_distr",
          e));

      a << ::xml_schema::as_double(i.model_2_pos_distr ());
    }

    // model_2_neg_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "model_2_neg_distr",
          e));

      a << ::xml_schema::as_double(i.model_2_neg_distr ());
    }

    // obs_3_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "obs_3_distr",
          e));

      a << i.obs_3_distr ();
    }

    // model_3_pos_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "model_3_pos_distr",
          e));

      a << ::xml_schema::as_double(i.model_3_pos_distr ());
    }

    // model_3_neg_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "model_3_neg_distr",
          e));

      a << ::xml_schema::as_double(i.model_3_neg_distr ());
    }

    // obs_4_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "obs_4_distr",
          e));

      a << i.obs_4_distr ();
    }

    // model_4_pos_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "model_4_pos_distr",
          e));

      a << ::xml_schema::as_double(i.model_4_pos_distr ());
    }

    // model_4_neg_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "model_4_neg_distr",
          e));

      a << ::xml_schema::as_double(i.model_4_neg_distr ());
    }

    // obs_5_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "obs_5_distr",
          e));

      a << i.obs_5_distr ();
    }

    // model_5_pos_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "model_5_pos_distr",
          e));

      a << ::xml_schema::as_double(i.model_5_pos_distr ());
    }

    // model_5_neg_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "model_5_neg_distr",
          e));

      a << ::xml_schema::as_double(i.model_5_neg_distr ());
    }

    // obs_6_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "obs_6_distr",
          e));

      a << i.obs_6_distr ();
    }

    // model_6_pos_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "model_6_pos_distr",
          e));

      a << ::xml_schema::as_double(i.model_6_pos_distr ());
    }

    // model_6_neg_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "model_6_neg_distr",
          e));

      a << ::xml_schema::as_double(i.model_6_neg_distr ());
    }

    // obs_7_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "obs_7_distr",
          e));

      a << i.obs_7_distr ();
    }

    // model_7_pos_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "model_7_pos_distr",
          e));

      a << ::xml_schema::as_double(i.model_7_pos_distr ());
    }

    // model_7_neg_distr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "model_7_neg_distr",
          e));

      a << ::xml_schema::as_double(i.model_7_neg_distr ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const mixture_model& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // mixturemodel_distribution
    //
    for (mixture_model::mixturemodel_distribution_const_iterator
         b (i.mixturemodel_distribution ().begin ()), n (i.mixturemodel_distribution ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mixturemodel_distribution",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // mixturemodel
    //
    for (mixture_model::mixturemodel_const_iterator
         b (i.mixturemodel ().begin ()), n (i.mixturemodel ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mixturemodel",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // precursor_ion_charge
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "precursor_ion_charge",
          e));

      a << i.precursor_ion_charge ();
    }

    // comments
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "comments",
          e));

      a << i.comments ();
    }

    // prior_probability
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "prior_probability",
          e));

      a << ::xml_schema::as_double(i.prior_probability ());
    }

    // est_tot_correct
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "est_tot_correct",
          e));

      a << ::xml_schema::as_double(i.est_tot_correct ());
    }

    // tot_num_spectra
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tot_num_spectra",
          e));

      a << i.tot_num_spectra ();
    }

    // num_iterations
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "num_iterations",
          e));

      a << i.num_iterations ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const mod_aminoacid_probability& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // position
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "position",
          e));

      a << i.position ();
    }

    // probability
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "probability",
          e));

      a << ::xml_schema::as_double(i.probability ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const search_score_summary& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // parameter
    //
    for (search_score_summary::parameter_const_iterator
         b (i.parameter ().begin ()), n (i.parameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const intensity& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // channel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "channel",
          e));

      a << i.channel ();
    }

    // target_mass
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "target_mass",
          e));

      a << ::xml_schema::as_double(i.target_mass ());
    }

    // absolute
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "absolute",
          e));

      a << ::xml_schema::as_double(i.absolute ());
    }

    // normalized
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "normalized",
          e));

      a << ::xml_schema::as_double(i.normalized ());
    }

    // reject
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "reject",
          e));

      a << i.reject ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const fragment_masses& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // channel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "channel",
          e));

      a << i.channel ();
    }

    // mz
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "mz",
          e));

      a << ::xml_schema::as_double(i.mz ());
    }

    // offset
    //
    if (i.offset ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "offset",
          e));

      a << ::xml_schema::as_double(*i.offset ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const isotopic_contributions& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // contributing_channel
    //
    for (isotopic_contributions::contributing_channel_const_iterator
         b (i.contributing_channel ().begin ()), n (i.contributing_channel ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "contributing_channel",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const data_filter& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // number
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "number",
          e));

      a << i.number ();
    }

    // parent_file
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "parent_file",
          e));

      a << i.parent_file ();
    }

    // windows_parent
    //
    if (i.windows_parent ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "windows_parent",
          e));

      a << *i.windows_parent ();
    }

    // description
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "description",
          e));

      a << i.description ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const sample_enzyme& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // specificity
    //
    for (sample_enzyme::specificity_const_iterator
         b (i.specificity ().begin ()), n (i.specificity ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "specificity",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // description
    //
    if (i.description ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "description",
          e));

      a << *i.description ();
    }

    // fidelity
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "fidelity",
          e));

      a << i.fidelity ();
    }

    // independent
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "independent",
          e));

      a << i.independent ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const cross_linker& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // cross_linker_info
    //
    for (cross_linker::cross_linker_info_const_iterator
         b (i.cross_linker_info ().begin ()), n (i.cross_linker_info ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cross_linker_info",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // identifier
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "identifier",
          e));

      a << i.identifier ();
    }

    // mass
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "mass",
          e));

      a << ::xml_schema::as_double(i.mass ());
    }

    // link_sites
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "link_sites",
          e));

      a << i.link_sites ();
    }

    // isotope_labeled
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isotope_labeled",
          e));

      a << i.isotope_labeled ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const search_summary& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // search_database
    //
    if (i.search_database ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "search_database",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *i.search_database ();
    }

    // enzymatic_search_constraint
    //
    if (i.enzymatic_search_constraint ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "enzymatic_search_constraint",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *i.enzymatic_search_constraint ();
    }

    // sequence_search_constraint
    //
    for (search_summary::sequence_search_constraint_const_iterator
         b (i.sequence_search_constraint ().begin ()), n (i.sequence_search_constraint ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sequence_search_constraint",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // aminoacid_modification
    //
    for (search_summary::aminoacid_modification_const_iterator
         b (i.aminoacid_modification ().begin ()), n (i.aminoacid_modification ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "aminoacid_modification",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // terminal_modification
    //
    for (search_summary::terminal_modification_const_iterator
         b (i.terminal_modification ().begin ()), n (i.terminal_modification ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "terminal_modification",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // parameter
    //
    for (search_summary::parameter_const_iterator
         b (i.parameter ().begin ()), n (i.parameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // base_name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "base_name",
          e));

      a << i.base_name ();
    }

    // search_engine
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "search_engine",
          e));

      a << i.search_engine ();
    }

    // search_engine_version
    //
    if (i.search_engine_version ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "search_engine_version",
          e));

      a << *i.search_engine_version ();
    }

    // precursor_mass_type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "precursor_mass_type",
          e));

      a << i.precursor_mass_type ();
    }

    // fragment_mass_type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "fragment_mass_type",
          e));

      a << i.fragment_mass_type ();
    }

    // out_data_type
    //
    if (i.out_data_type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "out_data_type",
          e));

      a << *i.out_data_type ();
    }

    // out_data
    //
    if (i.out_data ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "out_data",
          e));

      a << *i.out_data ();
    }

    // search_id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "search_id",
          e));

      a << i.search_id ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const analysis_timestamp& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // time
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "time",
          e));

      a << i.time ();
    }

    // analysis
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "analysis",
          e));

      a << i.analysis ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const spectrum_query& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // search_result
    //
    for (spectrum_query::search_result_const_iterator
         b (i.search_result ().begin ()), n (i.search_result ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "search_result",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // spectrum
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "spectrum",
          e));

      a << i.spectrum ();
    }

    // spectrumNativeID
    //
    if (i.spectrumNativeID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "spectrumNativeID",
          e));

      a << *i.spectrumNativeID ();
    }

    // start_scan
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "start_scan",
          e));

      a << i.start_scan ();
    }

    // end_scan
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "end_scan",
          e));

      a << i.end_scan ();
    }

    // retention_time_sec
    //
    if (i.retention_time_sec ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "retention_time_sec",
          e));

      a << ::xml_schema::as_double(*i.retention_time_sec ());
    }

    // collision_energy
    //
    if (i.collision_energy ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "collision_energy",
          e));

      a << ::xml_schema::as_double(*i.collision_energy ());
    }

    // compensation_voltage
    //
    if (i.compensation_voltage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "compensation_voltage",
          e));

      a << ::xml_schema::as_double(*i.compensation_voltage ());
    }

    // precursor_intensity
    //
    if (i.precursor_intensity ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "precursor_intensity",
          e));

      a << ::xml_schema::as_double(*i.precursor_intensity ());
    }

    // activation_method
    //
    if (i.activation_method ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "activation_method",
          e));

      a << *i.activation_method ();
    }

    // precursor_neutral_mass
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "precursor_neutral_mass",
          e));

      a << ::xml_schema::as_double(i.precursor_neutral_mass ());
    }

    // assumed_charge
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "assumed_charge",
          e));

      a << i.assumed_charge ();
    }

    // search_specification
    //
    if (i.search_specification ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "search_specification",
          e));

      a << *i.search_specification ();
    }

    // index
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "index",
          e));

      a << i.index ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const mixturemodel_distribution& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // posmodel_distribution
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "posmodel_distribution",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << i.posmodel_distribution ();
    }

    // negmodel_distribution
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "negmodel_distribution",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << i.negmodel_distribution ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const mixturemodel& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // point
    //
    for (mixturemodel::point_const_iterator
         b (i.point ().begin ()), n (i.point ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "point",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // pos_bandwidth
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "pos_bandwidth",
          e));

      a << ::xml_schema::as_double(i.pos_bandwidth ());
    }

    // neg_bandwidth
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "neg_bandwidth",
          e));

      a << ::xml_schema::as_double(i.neg_bandwidth ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const contributing_channel& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // affected_channel
    //
    for (contributing_channel::affected_channel_const_iterator
         b (i.affected_channel ().begin ()), n (i.affected_channel ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "affected_channel",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // channel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "channel",
          e));

      a << i.channel ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const specificity& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // sense
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sense",
          e));

      a << i.sense ();
    }

    // min_spacing
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "min_spacing",
          e));

      a << i.min_spacing ();
    }

    // cut
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "cut",
          e));

      a << i.cut ();
    }

    // no_cut
    //
    if (i.no_cut ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "no_cut",
          e));

      a << *i.no_cut ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const name& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const name& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const name& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const fidelity& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const fidelity& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const fidelity& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const isotope_labeled& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const isotope_labeled& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const isotope_labeled& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const search_database& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // local_path
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "local_path",
          e));

      a << i.local_path ();
    }

    // URL
    //
    if (i.URL ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "URL",
          e));

      a << *i.URL ();
    }

    // database_name
    //
    if (i.database_name ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "database_name",
          e));

      a << *i.database_name ();
    }

    // orig_database_url
    //
    if (i.orig_database_url ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "orig_database_url",
          e));

      a << *i.orig_database_url ();
    }

    // database_release_date
    //
    if (i.database_release_date ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "database_release_date",
          e));

      a << *i.database_release_date ();
    }

    // database_release_identifier
    //
    if (i.database_release_identifier ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "database_release_identifier",
          e));

      a << *i.database_release_identifier ();
    }

    // size_in_db_entries
    //
    if (i.size_in_db_entries ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "size_in_db_entries",
          e));

      a << *i.size_in_db_entries ();
    }

    // size_of_residues
    //
    if (i.size_of_residues ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "size_of_residues",
          e));

      a << *i.size_of_residues ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const enzymatic_search_constraint& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // enzyme
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "enzyme",
          e));

      a << i.enzyme ();
    }

    // max_num_internal_cleavages
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "max_num_internal_cleavages",
          e));

      a << i.max_num_internal_cleavages ();
    }

    // min_number_termini
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "min_number_termini",
          e));

      a << i.min_number_termini ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const sequence_search_constraint& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // sequence
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sequence",
          e));

      a << i.sequence ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const aminoacid_modification& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // aminoacid
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "aminoacid",
          e));

      a << i.aminoacid ();
    }

    // massdiff
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "massdiff",
          e));

      a << ::xml_schema::as_double(i.massdiff ());
    }

    // mass
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "mass",
          e));

      a << ::xml_schema::as_double(i.mass ());
    }

    // variable
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "variable",
          e));

      a << i.variable ();
    }

    // peptide_terminus
    //
    if (i.peptide_terminus ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "peptide_terminus",
          e));

      a << *i.peptide_terminus ();
    }

    // protein_terminus
    //
    if (i.protein_terminus ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "protein_terminus",
          e));

      a << *i.protein_terminus ();
    }

    // symbol
    //
    if (i.symbol ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "symbol",
          e));

      a << *i.symbol ();
    }

    // binary
    //
    if (i.binary ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "binary",
          e));

      a << *i.binary ();
    }

    // description
    //
    if (i.description ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "description",
          e));

      a << *i.description ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const terminal_modification& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // terminus
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "terminus",
          e));

      a << i.terminus ();
    }

    // massdiff
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "massdiff",
          e));

      a << ::xml_schema::as_double(i.massdiff ());
    }

    // mass
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "mass",
          e));

      a << ::xml_schema::as_double(i.mass ());
    }

    // variable
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "variable",
          e));

      a << i.variable ();
    }

    // symbol
    //
    if (i.symbol ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "symbol",
          e));

      a << *i.symbol ();
    }

    // protein_terminus
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "protein_terminus",
          e));

      a << i.protein_terminus ();
    }

    // description
    //
    if (i.description ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "description",
          e));

      a << *i.description ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const search_result& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // search_hit
    //
    for (search_result::search_hit_const_iterator
         b (i.search_hit ().begin ()), n (i.search_hit ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "search_hit",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // search_id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "search_id",
          e));

      a << i.search_id ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const posmodel_distribution& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // parameter
    //
    for (posmodel_distribution::parameter_const_iterator
         b (i.parameter ().begin ()), n (i.parameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << *i.type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const negmodel_distribution& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // parameter
    //
    for (negmodel_distribution::parameter_const_iterator
         b (i.parameter ().begin ()), n (i.parameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << *i.type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const point1& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // value
    //
    if (i.value ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << ::xml_schema::as_double(*i.value ());
    }

    // pos_dens
    //
    if (i.pos_dens ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "pos_dens",
          e));

      a << ::xml_schema::as_double(*i.pos_dens ());
    }

    // neg_dens
    //
    if (i.neg_dens ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "neg_dens",
          e));

      a << ::xml_schema::as_double(*i.neg_dens ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const affected_channel& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // channel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "channel",
          e));

      a << i.channel ();
    }

    // correction
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "correction",
          e));

      a << ::xml_schema::as_double(i.correction ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const sense& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const sense& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const sense& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const cut& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const cut& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const cut& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const no_cut& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const no_cut& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const no_cut& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const type& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const type& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const type& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const search_hit& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // alternative_protein
    //
    for (search_hit::alternative_protein_const_iterator
         b (i.alternative_protein ().begin ()), n (i.alternative_protein ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "alternative_protein",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // modification_info
    //
    if (i.modification_info ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "modification_info",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *i.modification_info ();
    }

    // xlink
    //
    if (i.xlink ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "xlink",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *i.xlink ();
    }

    // search_score
    //
    for (search_hit::search_score_const_iterator
         b (i.search_score ().begin ()), n (i.search_score ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "search_score",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // analysis_result
    //
    for (search_hit::analysis_result_const_iterator
         b (i.analysis_result ().begin ()), n (i.analysis_result ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "analysis_result",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // parameter
    //
    for (search_hit::parameter_const_iterator
         b (i.parameter ().begin ()), n (i.parameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // hit_rank
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "hit_rank",
          e));

      a << i.hit_rank ();
    }

    // peptide
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "peptide",
          e));

      a << i.peptide ();
    }

    // peptide_prev_aa
    //
    if (i.peptide_prev_aa ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "peptide_prev_aa",
          e));

      a << *i.peptide_prev_aa ();
    }

    // peptide_next_aa
    //
    if (i.peptide_next_aa ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "peptide_next_aa",
          e));

      a << *i.peptide_next_aa ();
    }

    // protein
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "protein",
          e));

      a << i.protein ();
    }

    // num_tot_proteins
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "num_tot_proteins",
          e));

      a << i.num_tot_proteins ();
    }

    // num_matched_ions
    //
    if (i.num_matched_ions ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "num_matched_ions",
          e));

      a << *i.num_matched_ions ();
    }

    // tot_num_ions
    //
    if (i.tot_num_ions ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "tot_num_ions",
          e));

      a << *i.tot_num_ions ();
    }

    // calc_neutral_pep_mass
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "calc_neutral_pep_mass",
          e));

      a << ::xml_schema::as_double(i.calc_neutral_pep_mass ());
    }

    // massdiff
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "massdiff",
          e));

      a << ::xml_schema::as_double(i.massdiff ());
    }

    // num_tol_term
    //
    if (i.num_tol_term ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "num_tol_term",
          e));

      a << *i.num_tol_term ();
    }

    // num_missed_cleavages
    //
    if (i.num_missed_cleavages ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "num_missed_cleavages",
          e));

      a << *i.num_missed_cleavages ();
    }

    // num_matched_peptides
    //
    if (i.num_matched_peptides ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "num_matched_peptides",
          e));

      a << *i.num_matched_peptides ();
    }

    // xlink_type
    //
    if (i.xlink_type1 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "xlink_type",
          e));

      a << *i.xlink_type1 ();
    }

    // is_rejected
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "is_rejected",
          e));

      a << i.is_rejected ();
    }

    // protein_descr
    //
    if (i.protein_descr ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "protein_descr",
          e));

      a << *i.protein_descr ();
    }

    // calc_pI
    //
    if (i.calc_pI ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "calc_pI",
          e));

      a << *i.calc_pI ();
    }

    // protein_mw
    //
    if (i.protein_mw ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "protein_mw",
          e));

      a << ::xml_schema::as_double(*i.protein_mw ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const xlink& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // linked_peptide
    //
    for (xlink::linked_peptide_const_iterator
         b (i.linked_peptide ().begin ()), n (i.linked_peptide ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "linked_peptide",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // xlink_score
    //
    for (xlink::xlink_score_const_iterator
         b (i.xlink_score ().begin ()), n (i.xlink_score ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "xlink_score",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // identifier
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "identifier",
          e));

      a << i.identifier ();
    }

    // mass
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "mass",
          e));

      a << ::xml_schema::as_double(i.mass ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const analysis_result& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // analysis
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "analysis",
          e));

      a << i.analysis ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const xlink_type& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const xlink_type& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const xlink_type& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const is_rejected& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const is_rejected& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const is_rejected& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const linked_peptide& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // alternative_protein
    //
    for (linked_peptide::alternative_protein_const_iterator
         b (i.alternative_protein ().begin ()), n (i.alternative_protein ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "alternative_protein",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // modification_info
    //
    if (i.modification_info ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "modification_info",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *i.modification_info ();
    }

    // xlink_score
    //
    for (linked_peptide::xlink_score_const_iterator
         b (i.xlink_score ().begin ()), n (i.xlink_score ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "xlink_score",
          "http://regis-web.systemsbiology.net/pepXML",
          e));

      s << *b;
    }

    // peptide
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "peptide",
          e));

      a << i.peptide ();
    }

    // peptide_prev_aa
    //
    if (i.peptide_prev_aa ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "peptide_prev_aa",
          e));

      a << *i.peptide_prev_aa ();
    }

    // peptide_next_aa
    //
    if (i.peptide_next_aa ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "peptide_next_aa",
          e));

      a << *i.peptide_next_aa ();
    }

    // protein
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "protein",
          e));

      a << i.protein ();
    }

    // num_tot_proteins
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "num_tot_proteins",
          e));

      a << i.num_tot_proteins ();
    }

    // calc_neutral_pep_mass
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "calc_neutral_pep_mass",
          e));

      a << ::xml_schema::as_double(i.calc_neutral_pep_mass ());
    }

    // complement_mass
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "complement_mass",
          e));

      a << ::xml_schema::as_double(i.complement_mass ());
    }

    // designation
    //
    if (i.designation ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "designation",
          e));

      a << *i.designation ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

