// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef MZ_ML1_1_0_H
#define MZ_ML1_1_0_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// #ifdef ORIG
namespace ms
{
  namespace mzml
  {
    class mzMLType;
    class FileDescriptionType;
    class SourceFileListType;
    class ParamGroupType;
    class SourceFileType;
    class CVType;
    class CVListType;
    class ReferenceableParamGroupListType;
    class ReferenceableParamGroupType;
    class CVParamType;
    class UserParamType;
    class ReferenceableParamGroupRefType;
    class SampleListType;
    class SampleType;
    class InstrumentConfigurationListType;
    class ComponentType;
    class SourceComponentType;
    class DetectorComponentType;
    class AnalyzerComponentType;
    class ComponentListType;
    class InstrumentConfigurationType;
    class SoftwareRefType;
    class SoftwareListType;
    class SoftwareType;
    class DataProcessingListType;
    class DataProcessingType;
    class ProcessingMethodType;
    class ScanSettingsListType;
    class ScanSettingsType;
    class TargetListType;
    class RunType;
    class SourceFileRefType;
    class SourceFileRefListType;
    class SpectrumListType;
    class ScanWindowListType;
    class ScanListType;
    class ScanType;
    class PrecursorListType;
    class PrecursorType;
    class SelectedIonListType;
    class ProductListType;
    class ProductType;
    class BinaryDataArrayListType;
    class BinaryDataArrayType;
    class SpectrumType;
    class ChromatogramListType;
    class ChromatogramType;
    class id;
  }
}
// #endif

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

namespace ms
{
  namespace mzml
  {
    class mzMLType: public ::xml_schema::type
    {
      public:
      // cvList
      //
      typedef ::ms::mzml::CVListType cvList_type;
      typedef ::xsd::cxx::tree::traits< cvList_type, char > cvList_traits;

      const cvList_type&
      cvList () const;

      cvList_type&
      cvList ();

      void
      cvList (const cvList_type& x);

      void
      cvList (::std::unique_ptr< cvList_type > p);

      // fileDescription
      //
      typedef ::ms::mzml::FileDescriptionType fileDescription_type;
      typedef ::xsd::cxx::tree::traits< fileDescription_type, char > fileDescription_traits;

      const fileDescription_type&
      fileDescription () const;

      fileDescription_type&
      fileDescription ();

      void
      fileDescription (const fileDescription_type& x);

      void
      fileDescription (::std::unique_ptr< fileDescription_type > p);

      // referenceableParamGroupList
      //
      typedef ::ms::mzml::ReferenceableParamGroupListType referenceableParamGroupList_type;
      typedef ::xsd::cxx::tree::optional< referenceableParamGroupList_type > referenceableParamGroupList_optional;
      typedef ::xsd::cxx::tree::traits< referenceableParamGroupList_type, char > referenceableParamGroupList_traits;

      const referenceableParamGroupList_optional&
      referenceableParamGroupList () const;

      referenceableParamGroupList_optional&
      referenceableParamGroupList ();

      void
      referenceableParamGroupList (const referenceableParamGroupList_type& x);

      void
      referenceableParamGroupList (const referenceableParamGroupList_optional& x);

      void
      referenceableParamGroupList (::std::unique_ptr< referenceableParamGroupList_type > p);

      // sampleList
      //
      typedef ::ms::mzml::SampleListType sampleList_type;
      typedef ::xsd::cxx::tree::optional< sampleList_type > sampleList_optional;
      typedef ::xsd::cxx::tree::traits< sampleList_type, char > sampleList_traits;

      const sampleList_optional&
      sampleList () const;

      sampleList_optional&
      sampleList ();

      void
      sampleList (const sampleList_type& x);

      void
      sampleList (const sampleList_optional& x);

      void
      sampleList (::std::unique_ptr< sampleList_type > p);

      // softwareList
      //
      typedef ::ms::mzml::SoftwareListType softwareList_type;
      typedef ::xsd::cxx::tree::traits< softwareList_type, char > softwareList_traits;

      const softwareList_type&
      softwareList () const;

      softwareList_type&
      softwareList ();

      void
      softwareList (const softwareList_type& x);

      void
      softwareList (::std::unique_ptr< softwareList_type > p);

      // scanSettingsList
      //
      typedef ::ms::mzml::ScanSettingsListType scanSettingsList_type;
      typedef ::xsd::cxx::tree::optional< scanSettingsList_type > scanSettingsList_optional;
      typedef ::xsd::cxx::tree::traits< scanSettingsList_type, char > scanSettingsList_traits;

      const scanSettingsList_optional&
      scanSettingsList () const;

      scanSettingsList_optional&
      scanSettingsList ();

      void
      scanSettingsList (const scanSettingsList_type& x);

      void
      scanSettingsList (const scanSettingsList_optional& x);

      void
      scanSettingsList (::std::unique_ptr< scanSettingsList_type > p);

      // instrumentConfigurationList
      //
      typedef ::ms::mzml::InstrumentConfigurationListType instrumentConfigurationList_type;
      typedef ::xsd::cxx::tree::traits< instrumentConfigurationList_type, char > instrumentConfigurationList_traits;

      const instrumentConfigurationList_type&
      instrumentConfigurationList () const;

      instrumentConfigurationList_type&
      instrumentConfigurationList ();

      void
      instrumentConfigurationList (const instrumentConfigurationList_type& x);

      void
      instrumentConfigurationList (::std::unique_ptr< instrumentConfigurationList_type > p);

      // dataProcessingList
      //
      typedef ::ms::mzml::DataProcessingListType dataProcessingList_type;
      typedef ::xsd::cxx::tree::traits< dataProcessingList_type, char > dataProcessingList_traits;

      const dataProcessingList_type&
      dataProcessingList () const;

      dataProcessingList_type&
      dataProcessingList ();

      void
      dataProcessingList (const dataProcessingList_type& x);

      void
      dataProcessingList (::std::unique_ptr< dataProcessingList_type > p);

      // run
      //
      typedef ::ms::mzml::RunType run_type;
      typedef ::xsd::cxx::tree::traits< run_type, char > run_traits;

      const run_type&
      run () const;

      run_type&
      run ();

      void
      run (const run_type& x);

      void
      run (::std::unique_ptr< run_type > p);

      // accession
      //
      typedef ::xml_schema::string accession_type;
      typedef ::xsd::cxx::tree::optional< accession_type > accession_optional;
      typedef ::xsd::cxx::tree::traits< accession_type, char > accession_traits;

      const accession_optional&
      accession () const;

      accession_optional&
      accession ();

      void
      accession (const accession_type& x);

      void
      accession (const accession_optional& x);

      void
      accession (::std::unique_ptr< accession_type > p);

      // version
      //
      typedef ::xml_schema::string version_type;
      typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

      const version_type&
      version () const;

      version_type&
      version ();

      void
      version (const version_type& x);

      void
      version (::std::unique_ptr< version_type > p);

      // id
      //
      typedef ::xml_schema::string id_type;
      typedef ::xsd::cxx::tree::optional< id_type > id_optional;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_optional&
      id () const;

      id_optional&
      id ();

      void
      id (const id_type& x);

      void
      id (const id_optional& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      mzMLType (const cvList_type&,
                const fileDescription_type&,
                const softwareList_type&,
                const instrumentConfigurationList_type&,
                const dataProcessingList_type&,
                const run_type&,
                const version_type&);

      mzMLType (::std::unique_ptr< cvList_type >,
                ::std::unique_ptr< fileDescription_type >,
                ::std::unique_ptr< softwareList_type >,
                ::std::unique_ptr< instrumentConfigurationList_type >,
                ::std::unique_ptr< dataProcessingList_type >,
                ::std::unique_ptr< run_type >,
                const version_type&);

      mzMLType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      mzMLType (const mzMLType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual mzMLType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      mzMLType&
      operator= (const mzMLType& x);

      virtual 
      ~mzMLType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< cvList_type > cvList_;
      ::xsd::cxx::tree::one< fileDescription_type > fileDescription_;
      referenceableParamGroupList_optional referenceableParamGroupList_;
      sampleList_optional sampleList_;
      ::xsd::cxx::tree::one< softwareList_type > softwareList_;
      scanSettingsList_optional scanSettingsList_;
      ::xsd::cxx::tree::one< instrumentConfigurationList_type > instrumentConfigurationList_;
      ::xsd::cxx::tree::one< dataProcessingList_type > dataProcessingList_;
      ::xsd::cxx::tree::one< run_type > run_;
      accession_optional accession_;
      ::xsd::cxx::tree::one< version_type > version_;
      id_optional id_;
    };

    class FileDescriptionType: public ::xml_schema::type
    {
      public:
      // fileContent
      //
      typedef ::ms::mzml::ParamGroupType fileContent_type;
      typedef ::xsd::cxx::tree::traits< fileContent_type, char > fileContent_traits;

      const fileContent_type&
      fileContent () const;

      fileContent_type&
      fileContent ();

      void
      fileContent (const fileContent_type& x);

      void
      fileContent (::std::unique_ptr< fileContent_type > p);

      // sourceFileList
      //
      typedef ::ms::mzml::SourceFileListType sourceFileList_type;
      typedef ::xsd::cxx::tree::optional< sourceFileList_type > sourceFileList_optional;
      typedef ::xsd::cxx::tree::traits< sourceFileList_type, char > sourceFileList_traits;

      const sourceFileList_optional&
      sourceFileList () const;

      sourceFileList_optional&
      sourceFileList ();

      void
      sourceFileList (const sourceFileList_type& x);

      void
      sourceFileList (const sourceFileList_optional& x);

      void
      sourceFileList (::std::unique_ptr< sourceFileList_type > p);

      // contact
      //
      typedef ::ms::mzml::ParamGroupType contact_type;
      typedef ::xsd::cxx::tree::sequence< contact_type > contact_sequence;
      typedef contact_sequence::iterator contact_iterator;
      typedef contact_sequence::const_iterator contact_const_iterator;
      typedef ::xsd::cxx::tree::traits< contact_type, char > contact_traits;

      const contact_sequence&
      contact () const;

      contact_sequence&
      contact ();

      void
      contact (const contact_sequence& s);

      // Constructors.
      //
      FileDescriptionType (const fileContent_type&);

      FileDescriptionType (::std::unique_ptr< fileContent_type >);

      FileDescriptionType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      FileDescriptionType (const FileDescriptionType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual FileDescriptionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FileDescriptionType&
      operator= (const FileDescriptionType& x);

      virtual 
      ~FileDescriptionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< fileContent_type > fileContent_;
      sourceFileList_optional sourceFileList_;
      contact_sequence contact_;
    };

    class SourceFileListType: public ::xml_schema::type
    {
      public:
      // sourceFile
      //
      typedef ::ms::mzml::SourceFileType sourceFile_type;
      typedef ::xsd::cxx::tree::sequence< sourceFile_type > sourceFile_sequence;
      typedef sourceFile_sequence::iterator sourceFile_iterator;
      typedef sourceFile_sequence::const_iterator sourceFile_const_iterator;
      typedef ::xsd::cxx::tree::traits< sourceFile_type, char > sourceFile_traits;

      const sourceFile_sequence&
      sourceFile () const;

      sourceFile_sequence&
      sourceFile ();

      void
      sourceFile (const sourceFile_sequence& s);

      // count
      //
      typedef ::xml_schema::non_negative_integer count_type;
      typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      // Constructors.
      //
      SourceFileListType (const count_type&);

      SourceFileListType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      SourceFileListType (const SourceFileListType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual SourceFileListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SourceFileListType&
      operator= (const SourceFileListType& x);

      virtual 
      ~SourceFileListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      sourceFile_sequence sourceFile_;
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class ParamGroupType: public ::xml_schema::type
    {
      public:
      // referenceableParamGroupRef
      //
      typedef ::ms::mzml::ReferenceableParamGroupRefType referenceableParamGroupRef_type;
      typedef ::xsd::cxx::tree::sequence< referenceableParamGroupRef_type > referenceableParamGroupRef_sequence;
      typedef referenceableParamGroupRef_sequence::iterator referenceableParamGroupRef_iterator;
      typedef referenceableParamGroupRef_sequence::const_iterator referenceableParamGroupRef_const_iterator;
      typedef ::xsd::cxx::tree::traits< referenceableParamGroupRef_type, char > referenceableParamGroupRef_traits;

      const referenceableParamGroupRef_sequence&
      referenceableParamGroupRef () const;

      referenceableParamGroupRef_sequence&
      referenceableParamGroupRef ();

      void
      referenceableParamGroupRef (const referenceableParamGroupRef_sequence& s);

      // cvParam
      //
      typedef ::ms::mzml::CVParamType cvParam_type;
      typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
      typedef cvParam_sequence::iterator cvParam_iterator;
      typedef cvParam_sequence::const_iterator cvParam_const_iterator;
      typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

      const cvParam_sequence&
      cvParam () const;

      cvParam_sequence&
      cvParam ();

      void
      cvParam (const cvParam_sequence& s);

      // userParam
      //
      typedef ::ms::mzml::UserParamType userParam_type;
      typedef ::xsd::cxx::tree::sequence< userParam_type > userParam_sequence;
      typedef userParam_sequence::iterator userParam_iterator;
      typedef userParam_sequence::const_iterator userParam_const_iterator;
      typedef ::xsd::cxx::tree::traits< userParam_type, char > userParam_traits;

      const userParam_sequence&
      userParam () const;

      userParam_sequence&
      userParam ();

      void
      userParam (const userParam_sequence& s);

      // Constructors.
      //
      ParamGroupType ();

      ParamGroupType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ParamGroupType (const ParamGroupType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual ParamGroupType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ParamGroupType&
      operator= (const ParamGroupType& x);

      virtual 
      ~ParamGroupType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      referenceableParamGroupRef_sequence referenceableParamGroupRef_;
      cvParam_sequence cvParam_;
      userParam_sequence userParam_;
    };

    class SourceFileType: public ::ms::mzml::ParamGroupType
    {
      public:
      // id
      //
      typedef ::xml_schema::id id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // name
      //
      typedef ::xml_schema::string name_type;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::unique_ptr< name_type > p);

      // location
      //
      typedef ::xml_schema::uri location_type;
      typedef ::xsd::cxx::tree::traits< location_type, char > location_traits;

      const location_type&
      location () const;

      location_type&
      location ();

      void
      location (const location_type& x);

      void
      location (::std::unique_ptr< location_type > p);

      // Constructors.
      //
      SourceFileType (const id_type&,
                      const name_type&,
                      const location_type&);

      SourceFileType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      SourceFileType (const SourceFileType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual SourceFileType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SourceFileType&
      operator= (const SourceFileType& x);

      virtual 
      ~SourceFileType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      ::xsd::cxx::tree::one< name_type > name_;
      ::xsd::cxx::tree::one< location_type > location_;
    };

    class CVType: public ::xml_schema::type
    {
      public:
      // id
      //
      typedef ::xml_schema::id id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // fullName
      //
      typedef ::xml_schema::string fullName_type;
      typedef ::xsd::cxx::tree::traits< fullName_type, char > fullName_traits;

      const fullName_type&
      fullName () const;

      fullName_type&
      fullName ();

      void
      fullName (const fullName_type& x);

      void
      fullName (::std::unique_ptr< fullName_type > p);

      // version
      //
      typedef ::xml_schema::string version_type;
      typedef ::xsd::cxx::tree::optional< version_type > version_optional;
      typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

      const version_optional&
      version () const;

      version_optional&
      version ();

      void
      version (const version_type& x);

      void
      version (const version_optional& x);

      void
      version (::std::unique_ptr< version_type > p);

      // URI
      //
      typedef ::xml_schema::uri URI_type;
      typedef ::xsd::cxx::tree::traits< URI_type, char > URI_traits;

      const URI_type&
      URI () const;

      URI_type&
      URI ();

      void
      URI (const URI_type& x);

      void
      URI (::std::unique_ptr< URI_type > p);

      // Constructors.
      //
      CVType (const id_type&,
              const fullName_type&,
              const URI_type&);

      CVType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      CVType (const CVType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      virtual CVType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CVType&
      operator= (const CVType& x);

      virtual 
      ~CVType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      ::xsd::cxx::tree::one< fullName_type > fullName_;
      version_optional version_;
      ::xsd::cxx::tree::one< URI_type > URI_;
    };

    class CVListType: public ::xml_schema::type
    {
      public:
      // cv
      //
      typedef ::ms::mzml::CVType cv_type;
      typedef ::xsd::cxx::tree::sequence< cv_type > cv_sequence;
      typedef cv_sequence::iterator cv_iterator;
      typedef cv_sequence::const_iterator cv_const_iterator;
      typedef ::xsd::cxx::tree::traits< cv_type, char > cv_traits;

      const cv_sequence&
      cv () const;

      cv_sequence&
      cv ();

      void
      cv (const cv_sequence& s);

      // count
      //
      typedef ::xml_schema::non_negative_integer count_type;
      typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      // Constructors.
      //
      CVListType (const count_type&);

      CVListType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      CVListType (const CVListType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual CVListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CVListType&
      operator= (const CVListType& x);

      virtual 
      ~CVListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      cv_sequence cv_;
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class ReferenceableParamGroupListType: public ::xml_schema::type
    {
      public:
      // referenceableParamGroup
      //
      typedef ::ms::mzml::ReferenceableParamGroupType referenceableParamGroup_type;
      typedef ::xsd::cxx::tree::sequence< referenceableParamGroup_type > referenceableParamGroup_sequence;
      typedef referenceableParamGroup_sequence::iterator referenceableParamGroup_iterator;
      typedef referenceableParamGroup_sequence::const_iterator referenceableParamGroup_const_iterator;
      typedef ::xsd::cxx::tree::traits< referenceableParamGroup_type, char > referenceableParamGroup_traits;

      const referenceableParamGroup_sequence&
      referenceableParamGroup () const;

      referenceableParamGroup_sequence&
      referenceableParamGroup ();

      void
      referenceableParamGroup (const referenceableParamGroup_sequence& s);

      // count
      //
      typedef ::xml_schema::non_negative_integer count_type;
      typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      // Constructors.
      //
      ReferenceableParamGroupListType (const count_type&);

      ReferenceableParamGroupListType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      ReferenceableParamGroupListType (const ReferenceableParamGroupListType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual ReferenceableParamGroupListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ReferenceableParamGroupListType&
      operator= (const ReferenceableParamGroupListType& x);

      virtual 
      ~ReferenceableParamGroupListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      referenceableParamGroup_sequence referenceableParamGroup_;
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class ReferenceableParamGroupType: public ::xml_schema::type
    {
      public:
      // cvParam
      //
      typedef ::ms::mzml::CVParamType cvParam_type;
      typedef ::xsd::cxx::tree::sequence< cvParam_type > cvParam_sequence;
      typedef cvParam_sequence::iterator cvParam_iterator;
      typedef cvParam_sequence::const_iterator cvParam_const_iterator;
      typedef ::xsd::cxx::tree::traits< cvParam_type, char > cvParam_traits;

      const cvParam_sequence&
      cvParam () const;

      cvParam_sequence&
      cvParam ();

      void
      cvParam (const cvParam_sequence& s);

      // userParam
      //
      typedef ::ms::mzml::UserParamType userParam_type;
      typedef ::xsd::cxx::tree::sequence< userParam_type > userParam_sequence;
      typedef userParam_sequence::iterator userParam_iterator;
      typedef userParam_sequence::const_iterator userParam_const_iterator;
      typedef ::xsd::cxx::tree::traits< userParam_type, char > userParam_traits;

      const userParam_sequence&
      userParam () const;

      userParam_sequence&
      userParam ();

      void
      userParam (const userParam_sequence& s);

      // id
      //
      typedef ::xml_schema::id id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      ReferenceableParamGroupType (const id_type&);

      ReferenceableParamGroupType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ReferenceableParamGroupType (const ReferenceableParamGroupType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual ReferenceableParamGroupType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ReferenceableParamGroupType&
      operator= (const ReferenceableParamGroupType& x);

      virtual 
      ~ReferenceableParamGroupType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      cvParam_sequence cvParam_;
      userParam_sequence userParam_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class CVParamType: public ::xml_schema::type
    {
      public:
      // cvRef
      //
      typedef ::xml_schema::idref cvRef_type;
      typedef ::xsd::cxx::tree::traits< cvRef_type, char > cvRef_traits;

      const cvRef_type&
      cvRef () const;

      cvRef_type&
      cvRef ();

      void
      cvRef (const cvRef_type& x);

      void
      cvRef (::std::unique_ptr< cvRef_type > p);

      // accession
      //
      typedef ::xml_schema::string accession_type;
      typedef ::xsd::cxx::tree::traits< accession_type, char > accession_traits;

      const accession_type&
      accession () const;

      accession_type&
      accession ();

      void
      accession (const accession_type& x);

      void
      accession (::std::unique_ptr< accession_type > p);

      // value
      //
      typedef ::xml_schema::string value_type;
      typedef ::xsd::cxx::tree::optional< value_type > value_optional;
      typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

      const value_optional&
      value () const;

      value_optional&
      value ();

      void
      value (const value_type& x);

      void
      value (const value_optional& x);

      void
      value (::std::unique_ptr< value_type > p);

      // name
      //
      typedef ::xml_schema::string name_type;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::unique_ptr< name_type > p);

      // unitAccession
      //
      typedef ::xml_schema::string unitAccession_type;
      typedef ::xsd::cxx::tree::optional< unitAccession_type > unitAccession_optional;
      typedef ::xsd::cxx::tree::traits< unitAccession_type, char > unitAccession_traits;

      const unitAccession_optional&
      unitAccession () const;

      unitAccession_optional&
      unitAccession ();

      void
      unitAccession (const unitAccession_type& x);

      void
      unitAccession (const unitAccession_optional& x);

      void
      unitAccession (::std::unique_ptr< unitAccession_type > p);

      // unitName
      //
      typedef ::xml_schema::string unitName_type;
      typedef ::xsd::cxx::tree::optional< unitName_type > unitName_optional;
      typedef ::xsd::cxx::tree::traits< unitName_type, char > unitName_traits;

      const unitName_optional&
      unitName () const;

      unitName_optional&
      unitName ();

      void
      unitName (const unitName_type& x);

      void
      unitName (const unitName_optional& x);

      void
      unitName (::std::unique_ptr< unitName_type > p);

      // unitCvRef
      //
      typedef ::xml_schema::idref unitCvRef_type;
      typedef ::xsd::cxx::tree::optional< unitCvRef_type > unitCvRef_optional;
      typedef ::xsd::cxx::tree::traits< unitCvRef_type, char > unitCvRef_traits;

      const unitCvRef_optional&
      unitCvRef () const;

      unitCvRef_optional&
      unitCvRef ();

      void
      unitCvRef (const unitCvRef_type& x);

      void
      unitCvRef (const unitCvRef_optional& x);

      void
      unitCvRef (::std::unique_ptr< unitCvRef_type > p);

      // Constructors.
      //
      CVParamType (const cvRef_type&,
                   const accession_type&,
                   const name_type&);

      CVParamType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      CVParamType (const CVParamType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual CVParamType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CVParamType&
      operator= (const CVParamType& x);

      virtual 
      ~CVParamType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< cvRef_type > cvRef_;
      ::xsd::cxx::tree::one< accession_type > accession_;
      value_optional value_;
      ::xsd::cxx::tree::one< name_type > name_;
      unitAccession_optional unitAccession_;
      unitName_optional unitName_;
      unitCvRef_optional unitCvRef_;
    };

    class UserParamType: public ::xml_schema::type
    {
      public:
      // name
      //
      typedef ::xml_schema::string name_type;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::unique_ptr< name_type > p);

      // type
      //
      typedef ::xml_schema::string type_type;
      typedef ::xsd::cxx::tree::optional< type_type > type_optional;
      typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

      const type_optional&
      type () const;

      type_optional&
      type ();

      void
      type (const type_type& x);

      void
      type (const type_optional& x);

      void
      type (::std::unique_ptr< type_type > p);

      // value
      //
      typedef ::xml_schema::string value_type;
      typedef ::xsd::cxx::tree::optional< value_type > value_optional;
      typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

      const value_optional&
      value () const;

      value_optional&
      value ();

      void
      value (const value_type& x);

      void
      value (const value_optional& x);

      void
      value (::std::unique_ptr< value_type > p);

      // unitAccession
      //
      typedef ::xml_schema::string unitAccession_type;
      typedef ::xsd::cxx::tree::optional< unitAccession_type > unitAccession_optional;
      typedef ::xsd::cxx::tree::traits< unitAccession_type, char > unitAccession_traits;

      const unitAccession_optional&
      unitAccession () const;

      unitAccession_optional&
      unitAccession ();

      void
      unitAccession (const unitAccession_type& x);

      void
      unitAccession (const unitAccession_optional& x);

      void
      unitAccession (::std::unique_ptr< unitAccession_type > p);

      // unitName
      //
      typedef ::xml_schema::string unitName_type;
      typedef ::xsd::cxx::tree::optional< unitName_type > unitName_optional;
      typedef ::xsd::cxx::tree::traits< unitName_type, char > unitName_traits;

      const unitName_optional&
      unitName () const;

      unitName_optional&
      unitName ();

      void
      unitName (const unitName_type& x);

      void
      unitName (const unitName_optional& x);

      void
      unitName (::std::unique_ptr< unitName_type > p);

      // unitCvRef
      //
      typedef ::xml_schema::idref unitCvRef_type;
      typedef ::xsd::cxx::tree::optional< unitCvRef_type > unitCvRef_optional;
      typedef ::xsd::cxx::tree::traits< unitCvRef_type, char > unitCvRef_traits;

      const unitCvRef_optional&
      unitCvRef () const;

      unitCvRef_optional&
      unitCvRef ();

      void
      unitCvRef (const unitCvRef_type& x);

      void
      unitCvRef (const unitCvRef_optional& x);

      void
      unitCvRef (::std::unique_ptr< unitCvRef_type > p);

      // Constructors.
      //
      UserParamType (const name_type&);

      UserParamType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      UserParamType (const UserParamType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual UserParamType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserParamType&
      operator= (const UserParamType& x);

      virtual 
      ~UserParamType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< name_type > name_;
      type_optional type_;
      value_optional value_;
      unitAccession_optional unitAccession_;
      unitName_optional unitName_;
      unitCvRef_optional unitCvRef_;
    };

    class ReferenceableParamGroupRefType: public ::xml_schema::type
    {
      public:
      // ref
      //
      typedef ::xml_schema::idref ref_type;
      typedef ::xsd::cxx::tree::traits< ref_type, char > ref_traits;

      const ref_type&
      ref () const;

      ref_type&
      ref ();

      void
      ref (const ref_type& x);

      void
      ref (::std::unique_ptr< ref_type > p);

      // Constructors.
      //
      ReferenceableParamGroupRefType (const ref_type&);

      ReferenceableParamGroupRefType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      ReferenceableParamGroupRefType (const ReferenceableParamGroupRefType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual ReferenceableParamGroupRefType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ReferenceableParamGroupRefType&
      operator= (const ReferenceableParamGroupRefType& x);

      virtual 
      ~ReferenceableParamGroupRefType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ref_type > ref_;
    };

    class SampleListType: public ::xml_schema::type
    {
      public:
      // sample
      //
      typedef ::ms::mzml::SampleType sample_type;
      typedef ::xsd::cxx::tree::sequence< sample_type > sample_sequence;
      typedef sample_sequence::iterator sample_iterator;
      typedef sample_sequence::const_iterator sample_const_iterator;
      typedef ::xsd::cxx::tree::traits< sample_type, char > sample_traits;

      const sample_sequence&
      sample () const;

      sample_sequence&
      sample ();

      void
      sample (const sample_sequence& s);

      // count
      //
      typedef ::xml_schema::non_negative_integer count_type;
      typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      // Constructors.
      //
      SampleListType (const count_type&);

      SampleListType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      SampleListType (const SampleListType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual SampleListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SampleListType&
      operator= (const SampleListType& x);

      virtual 
      ~SampleListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      sample_sequence sample_;
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class SampleType: public ::ms::mzml::ParamGroupType
    {
      public:
      // id
      //
      typedef ::xml_schema::id id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // name
      //
      typedef ::xml_schema::string name_type;
      typedef ::xsd::cxx::tree::optional< name_type > name_optional;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_optional&
      name () const;

      name_optional&
      name ();

      void
      name (const name_type& x);

      void
      name (const name_optional& x);

      void
      name (::std::unique_ptr< name_type > p);

      // Constructors.
      //
      SampleType (const id_type&);

      SampleType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      SampleType (const SampleType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual SampleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SampleType&
      operator= (const SampleType& x);

      virtual 
      ~SampleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      name_optional name_;
    };

    class InstrumentConfigurationListType: public ::xml_schema::type
    {
      public:
      // instrumentConfiguration
      //
      typedef ::ms::mzml::InstrumentConfigurationType instrumentConfiguration_type;
      typedef ::xsd::cxx::tree::sequence< instrumentConfiguration_type > instrumentConfiguration_sequence;
      typedef instrumentConfiguration_sequence::iterator instrumentConfiguration_iterator;
      typedef instrumentConfiguration_sequence::const_iterator instrumentConfiguration_const_iterator;
      typedef ::xsd::cxx::tree::traits< instrumentConfiguration_type, char > instrumentConfiguration_traits;

      const instrumentConfiguration_sequence&
      instrumentConfiguration () const;

      instrumentConfiguration_sequence&
      instrumentConfiguration ();

      void
      instrumentConfiguration (const instrumentConfiguration_sequence& s);

      // count
      //
      typedef ::xml_schema::non_negative_integer count_type;
      typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      // Constructors.
      //
      InstrumentConfigurationListType (const count_type&);

      InstrumentConfigurationListType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      InstrumentConfigurationListType (const InstrumentConfigurationListType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual InstrumentConfigurationListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      InstrumentConfigurationListType&
      operator= (const InstrumentConfigurationListType& x);

      virtual 
      ~InstrumentConfigurationListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      instrumentConfiguration_sequence instrumentConfiguration_;
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class ComponentType: public ::ms::mzml::ParamGroupType
    {
      public:
      // order
      //
      typedef ::xml_schema::int_ order_type;
      typedef ::xsd::cxx::tree::traits< order_type, char > order_traits;

      const order_type&
      order () const;

      order_type&
      order ();

      void
      order (const order_type& x);

      // Constructors.
      //
      ComponentType (const order_type&);

      ComponentType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      ComponentType (const ComponentType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual ComponentType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ComponentType&
      operator= (const ComponentType& x);

      virtual 
      ~ComponentType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< order_type > order_;
    };

    class SourceComponentType: public ::ms::mzml::ComponentType
    {
      public:
      // Constructors.
      //
      SourceComponentType (const order_type&);

      SourceComponentType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      SourceComponentType (const SourceComponentType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual SourceComponentType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~SourceComponentType ();
    };

    class DetectorComponentType: public ::ms::mzml::ComponentType
    {
      public:
      // Constructors.
      //
      DetectorComponentType (const order_type&);

      DetectorComponentType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      DetectorComponentType (const DetectorComponentType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual DetectorComponentType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~DetectorComponentType ();
    };

    class AnalyzerComponentType: public ::ms::mzml::ComponentType
    {
      public:
      // Constructors.
      //
      AnalyzerComponentType (const order_type&);

      AnalyzerComponentType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      AnalyzerComponentType (const AnalyzerComponentType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual AnalyzerComponentType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~AnalyzerComponentType ();
    };

    class ComponentListType: public ::xml_schema::type
    {
      public:
      // source
      //
      typedef ::ms::mzml::SourceComponentType source_type;
      typedef ::xsd::cxx::tree::sequence< source_type > source_sequence;
      typedef source_sequence::iterator source_iterator;
      typedef source_sequence::const_iterator source_const_iterator;
      typedef ::xsd::cxx::tree::traits< source_type, char > source_traits;

      const source_sequence&
      source () const;

      source_sequence&
      source ();

      void
      source (const source_sequence& s);

      // analyzer
      //
      typedef ::ms::mzml::AnalyzerComponentType analyzer_type;
      typedef ::xsd::cxx::tree::sequence< analyzer_type > analyzer_sequence;
      typedef analyzer_sequence::iterator analyzer_iterator;
      typedef analyzer_sequence::const_iterator analyzer_const_iterator;
      typedef ::xsd::cxx::tree::traits< analyzer_type, char > analyzer_traits;

      const analyzer_sequence&
      analyzer () const;

      analyzer_sequence&
      analyzer ();

      void
      analyzer (const analyzer_sequence& s);

      // detector
      //
      typedef ::ms::mzml::DetectorComponentType detector_type;
      typedef ::xsd::cxx::tree::sequence< detector_type > detector_sequence;
      typedef detector_sequence::iterator detector_iterator;
      typedef detector_sequence::const_iterator detector_const_iterator;
      typedef ::xsd::cxx::tree::traits< detector_type, char > detector_traits;

      const detector_sequence&
      detector () const;

      detector_sequence&
      detector ();

      void
      detector (const detector_sequence& s);

      // count
      //
      typedef ::xml_schema::non_negative_integer count_type;
      typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      // Constructors.
      //
      ComponentListType (const count_type&);

      ComponentListType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      ComponentListType (const ComponentListType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual ComponentListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ComponentListType&
      operator= (const ComponentListType& x);

      virtual 
      ~ComponentListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      source_sequence source_;
      analyzer_sequence analyzer_;
      detector_sequence detector_;
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class InstrumentConfigurationType: public ::ms::mzml::ParamGroupType
    {
      public:
      // componentList
      //
      typedef ::ms::mzml::ComponentListType componentList_type;
      typedef ::xsd::cxx::tree::optional< componentList_type > componentList_optional;
      typedef ::xsd::cxx::tree::traits< componentList_type, char > componentList_traits;

      const componentList_optional&
      componentList () const;

      componentList_optional&
      componentList ();

      void
      componentList (const componentList_type& x);

      void
      componentList (const componentList_optional& x);

      void
      componentList (::std::unique_ptr< componentList_type > p);

      // softwareRef
      //
      typedef ::ms::mzml::SoftwareRefType softwareRef_type;
      typedef ::xsd::cxx::tree::optional< softwareRef_type > softwareRef_optional;
      typedef ::xsd::cxx::tree::traits< softwareRef_type, char > softwareRef_traits;

      const softwareRef_optional&
      softwareRef () const;

      softwareRef_optional&
      softwareRef ();

      void
      softwareRef (const softwareRef_type& x);

      void
      softwareRef (const softwareRef_optional& x);

      void
      softwareRef (::std::unique_ptr< softwareRef_type > p);

      // id
      //
      typedef ::xml_schema::id id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // scanSettingsRef
      //
      typedef ::xml_schema::idref scanSettingsRef_type;
      typedef ::xsd::cxx::tree::optional< scanSettingsRef_type > scanSettingsRef_optional;
      typedef ::xsd::cxx::tree::traits< scanSettingsRef_type, char > scanSettingsRef_traits;

      const scanSettingsRef_optional&
      scanSettingsRef () const;

      scanSettingsRef_optional&
      scanSettingsRef ();

      void
      scanSettingsRef (const scanSettingsRef_type& x);

      void
      scanSettingsRef (const scanSettingsRef_optional& x);

      void
      scanSettingsRef (::std::unique_ptr< scanSettingsRef_type > p);

      // Constructors.
      //
      InstrumentConfigurationType (const id_type&);

      InstrumentConfigurationType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      InstrumentConfigurationType (const InstrumentConfigurationType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual InstrumentConfigurationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      InstrumentConfigurationType&
      operator= (const InstrumentConfigurationType& x);

      virtual 
      ~InstrumentConfigurationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      componentList_optional componentList_;
      softwareRef_optional softwareRef_;
      ::xsd::cxx::tree::one< id_type > id_;
      scanSettingsRef_optional scanSettingsRef_;
    };

    class SoftwareRefType: public ::xml_schema::type
    {
      public:
      // ref
      //
      typedef ::xml_schema::idref ref_type;
      typedef ::xsd::cxx::tree::traits< ref_type, char > ref_traits;

      const ref_type&
      ref () const;

      ref_type&
      ref ();

      void
      ref (const ref_type& x);

      void
      ref (::std::unique_ptr< ref_type > p);

      // Constructors.
      //
      SoftwareRefType (const ref_type&);

      SoftwareRefType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      SoftwareRefType (const SoftwareRefType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual SoftwareRefType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SoftwareRefType&
      operator= (const SoftwareRefType& x);

      virtual 
      ~SoftwareRefType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ref_type > ref_;
    };

    class SoftwareListType: public ::xml_schema::type
    {
      public:
      // software
      //
      typedef ::ms::mzml::SoftwareType software_type;
      typedef ::xsd::cxx::tree::sequence< software_type > software_sequence;
      typedef software_sequence::iterator software_iterator;
      typedef software_sequence::const_iterator software_const_iterator;
      typedef ::xsd::cxx::tree::traits< software_type, char > software_traits;

      const software_sequence&
      software () const;

      software_sequence&
      software ();

      void
      software (const software_sequence& s);

      // count
      //
      typedef ::xml_schema::non_negative_integer count_type;
      typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      // Constructors.
      //
      SoftwareListType (const count_type&);

      SoftwareListType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      SoftwareListType (const SoftwareListType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual SoftwareListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SoftwareListType&
      operator= (const SoftwareListType& x);

      virtual 
      ~SoftwareListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      software_sequence software_;
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class SoftwareType: public ::ms::mzml::ParamGroupType
    {
      public:
      // id
      //
      typedef ::xml_schema::id id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // version
      //
      typedef ::xml_schema::string version_type;
      typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

      const version_type&
      version () const;

      version_type&
      version ();

      void
      version (const version_type& x);

      void
      version (::std::unique_ptr< version_type > p);

      // Constructors.
      //
      SoftwareType (const id_type&,
                    const version_type&);

      SoftwareType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      SoftwareType (const SoftwareType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual SoftwareType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SoftwareType&
      operator= (const SoftwareType& x);

      virtual 
      ~SoftwareType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      ::xsd::cxx::tree::one< version_type > version_;
    };

    class DataProcessingListType: public ::xml_schema::type
    {
      public:
      // dataProcessing
      //
      typedef ::ms::mzml::DataProcessingType dataProcessing_type;
      typedef ::xsd::cxx::tree::sequence< dataProcessing_type > dataProcessing_sequence;
      typedef dataProcessing_sequence::iterator dataProcessing_iterator;
      typedef dataProcessing_sequence::const_iterator dataProcessing_const_iterator;
      typedef ::xsd::cxx::tree::traits< dataProcessing_type, char > dataProcessing_traits;

      const dataProcessing_sequence&
      dataProcessing () const;

      dataProcessing_sequence&
      dataProcessing ();

      void
      dataProcessing (const dataProcessing_sequence& s);

      // count
      //
      typedef ::xml_schema::non_negative_integer count_type;
      typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      // Constructors.
      //
      DataProcessingListType (const count_type&);

      DataProcessingListType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      DataProcessingListType (const DataProcessingListType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual DataProcessingListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DataProcessingListType&
      operator= (const DataProcessingListType& x);

      virtual 
      ~DataProcessingListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      dataProcessing_sequence dataProcessing_;
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class DataProcessingType: public ::xml_schema::type
    {
      public:
      // processingMethod
      //
      typedef ::ms::mzml::ProcessingMethodType processingMethod_type;
      typedef ::xsd::cxx::tree::sequence< processingMethod_type > processingMethod_sequence;
      typedef processingMethod_sequence::iterator processingMethod_iterator;
      typedef processingMethod_sequence::const_iterator processingMethod_const_iterator;
      typedef ::xsd::cxx::tree::traits< processingMethod_type, char > processingMethod_traits;

      const processingMethod_sequence&
      processingMethod () const;

      processingMethod_sequence&
      processingMethod ();

      void
      processingMethod (const processingMethod_sequence& s);

      // id
      //
      typedef ::xml_schema::id id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      DataProcessingType (const id_type&);

      DataProcessingType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      DataProcessingType (const DataProcessingType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual DataProcessingType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DataProcessingType&
      operator= (const DataProcessingType& x);

      virtual 
      ~DataProcessingType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      processingMethod_sequence processingMethod_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class ProcessingMethodType: public ::ms::mzml::ParamGroupType
    {
      public:
      // order
      //
      typedef ::xml_schema::non_negative_integer order_type;
      typedef ::xsd::cxx::tree::traits< order_type, char > order_traits;

      const order_type&
      order () const;

      order_type&
      order ();

      void
      order (const order_type& x);

      // softwareRef
      //
      typedef ::xml_schema::idref softwareRef_type;
      typedef ::xsd::cxx::tree::traits< softwareRef_type, char > softwareRef_traits;

      const softwareRef_type&
      softwareRef () const;

      softwareRef_type&
      softwareRef ();

      void
      softwareRef (const softwareRef_type& x);

      void
      softwareRef (::std::unique_ptr< softwareRef_type > p);

      // Constructors.
      //
      ProcessingMethodType (const order_type&,
                            const softwareRef_type&);

      ProcessingMethodType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ProcessingMethodType (const ProcessingMethodType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual ProcessingMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ProcessingMethodType&
      operator= (const ProcessingMethodType& x);

      virtual 
      ~ProcessingMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< order_type > order_;
      ::xsd::cxx::tree::one< softwareRef_type > softwareRef_;
    };

    class ScanSettingsListType: public ::xml_schema::type
    {
      public:
      // scanSettings
      //
      typedef ::ms::mzml::ScanSettingsType scanSettings_type;
      typedef ::xsd::cxx::tree::sequence< scanSettings_type > scanSettings_sequence;
      typedef scanSettings_sequence::iterator scanSettings_iterator;
      typedef scanSettings_sequence::const_iterator scanSettings_const_iterator;
      typedef ::xsd::cxx::tree::traits< scanSettings_type, char > scanSettings_traits;

      const scanSettings_sequence&
      scanSettings () const;

      scanSettings_sequence&
      scanSettings ();

      void
      scanSettings (const scanSettings_sequence& s);

      // count
      //
      typedef ::xml_schema::non_negative_integer count_type;
      typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      // Constructors.
      //
      ScanSettingsListType (const count_type&);

      ScanSettingsListType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ScanSettingsListType (const ScanSettingsListType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual ScanSettingsListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ScanSettingsListType&
      operator= (const ScanSettingsListType& x);

      virtual 
      ~ScanSettingsListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      scanSettings_sequence scanSettings_;
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class ScanSettingsType: public ::ms::mzml::ParamGroupType
    {
      public:
      // sourceFileRefList
      //
      typedef ::ms::mzml::SourceFileRefListType sourceFileRefList_type;
      typedef ::xsd::cxx::tree::optional< sourceFileRefList_type > sourceFileRefList_optional;
      typedef ::xsd::cxx::tree::traits< sourceFileRefList_type, char > sourceFileRefList_traits;

      const sourceFileRefList_optional&
      sourceFileRefList () const;

      sourceFileRefList_optional&
      sourceFileRefList ();

      void
      sourceFileRefList (const sourceFileRefList_type& x);

      void
      sourceFileRefList (const sourceFileRefList_optional& x);

      void
      sourceFileRefList (::std::unique_ptr< sourceFileRefList_type > p);

      // targetList
      //
      typedef ::ms::mzml::TargetListType targetList_type;
      typedef ::xsd::cxx::tree::optional< targetList_type > targetList_optional;
      typedef ::xsd::cxx::tree::traits< targetList_type, char > targetList_traits;

      const targetList_optional&
      targetList () const;

      targetList_optional&
      targetList ();

      void
      targetList (const targetList_type& x);

      void
      targetList (const targetList_optional& x);

      void
      targetList (::std::unique_ptr< targetList_type > p);

      // id
      //
      typedef ::xml_schema::id id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      ScanSettingsType (const id_type&);

      ScanSettingsType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ScanSettingsType (const ScanSettingsType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual ScanSettingsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ScanSettingsType&
      operator= (const ScanSettingsType& x);

      virtual 
      ~ScanSettingsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      sourceFileRefList_optional sourceFileRefList_;
      targetList_optional targetList_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class TargetListType: public ::xml_schema::type
    {
      public:
      // target
      //
      typedef ::ms::mzml::ParamGroupType target_type;
      typedef ::xsd::cxx::tree::sequence< target_type > target_sequence;
      typedef target_sequence::iterator target_iterator;
      typedef target_sequence::const_iterator target_const_iterator;
      typedef ::xsd::cxx::tree::traits< target_type, char > target_traits;

      const target_sequence&
      target () const;

      target_sequence&
      target ();

      void
      target (const target_sequence& s);

      // count
      //
      typedef ::xml_schema::non_negative_integer count_type;
      typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      // Constructors.
      //
      TargetListType (const count_type&);

      TargetListType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      TargetListType (const TargetListType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual TargetListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TargetListType&
      operator= (const TargetListType& x);

      virtual 
      ~TargetListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      target_sequence target_;
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class RunType: public ::ms::mzml::ParamGroupType
    {
      public:
      // spectrumList
      //
      typedef ::ms::mzml::SpectrumListType spectrumList_type;
      typedef ::xsd::cxx::tree::optional< spectrumList_type > spectrumList_optional;
      typedef ::xsd::cxx::tree::traits< spectrumList_type, char > spectrumList_traits;

      const spectrumList_optional&
      spectrumList () const;

      spectrumList_optional&
      spectrumList ();

      void
      spectrumList (const spectrumList_type& x);

      void
      spectrumList (const spectrumList_optional& x);

      void
      spectrumList (::std::unique_ptr< spectrumList_type > p);

      // chromatogramList
      //
      typedef ::ms::mzml::ChromatogramListType chromatogramList_type;
      typedef ::xsd::cxx::tree::optional< chromatogramList_type > chromatogramList_optional;
      typedef ::xsd::cxx::tree::traits< chromatogramList_type, char > chromatogramList_traits;

      const chromatogramList_optional&
      chromatogramList () const;

      chromatogramList_optional&
      chromatogramList ();

      void
      chromatogramList (const chromatogramList_type& x);

      void
      chromatogramList (const chromatogramList_optional& x);

      void
      chromatogramList (::std::unique_ptr< chromatogramList_type > p);

      // id
      //
      typedef ::xml_schema::id id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // defaultInstrumentConfigurationRef
      //
      typedef ::xml_schema::idref defaultInstrumentConfigurationRef_type;
      typedef ::xsd::cxx::tree::traits< defaultInstrumentConfigurationRef_type, char > defaultInstrumentConfigurationRef_traits;

      const defaultInstrumentConfigurationRef_type&
      defaultInstrumentConfigurationRef () const;

      defaultInstrumentConfigurationRef_type&
      defaultInstrumentConfigurationRef ();

      void
      defaultInstrumentConfigurationRef (const defaultInstrumentConfigurationRef_type& x);

      void
      defaultInstrumentConfigurationRef (::std::unique_ptr< defaultInstrumentConfigurationRef_type > p);

      // defaultSourceFileRef
      //
      typedef ::xml_schema::idref defaultSourceFileRef_type;
      typedef ::xsd::cxx::tree::optional< defaultSourceFileRef_type > defaultSourceFileRef_optional;
      typedef ::xsd::cxx::tree::traits< defaultSourceFileRef_type, char > defaultSourceFileRef_traits;

      const defaultSourceFileRef_optional&
      defaultSourceFileRef () const;

      defaultSourceFileRef_optional&
      defaultSourceFileRef ();

      void
      defaultSourceFileRef (const defaultSourceFileRef_type& x);

      void
      defaultSourceFileRef (const defaultSourceFileRef_optional& x);

      void
      defaultSourceFileRef (::std::unique_ptr< defaultSourceFileRef_type > p);

      // sampleRef
      //
      typedef ::xml_schema::idref sampleRef_type;
      typedef ::xsd::cxx::tree::optional< sampleRef_type > sampleRef_optional;
      typedef ::xsd::cxx::tree::traits< sampleRef_type, char > sampleRef_traits;

      const sampleRef_optional&
      sampleRef () const;

      sampleRef_optional&
      sampleRef ();

      void
      sampleRef (const sampleRef_type& x);

      void
      sampleRef (const sampleRef_optional& x);

      void
      sampleRef (::std::unique_ptr< sampleRef_type > p);

      // startTimeStamp
      //
      typedef ::xml_schema::date_time startTimeStamp_type;
      typedef ::xsd::cxx::tree::optional< startTimeStamp_type > startTimeStamp_optional;
      typedef ::xsd::cxx::tree::traits< startTimeStamp_type, char > startTimeStamp_traits;

      const startTimeStamp_optional&
      startTimeStamp () const;

      startTimeStamp_optional&
      startTimeStamp ();

      void
      startTimeStamp (const startTimeStamp_type& x);

      void
      startTimeStamp (const startTimeStamp_optional& x);

      void
      startTimeStamp (::std::unique_ptr< startTimeStamp_type > p);

      // Constructors.
      //
      RunType (const id_type&,
               const defaultInstrumentConfigurationRef_type&);

      RunType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      RunType (const RunType& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      virtual RunType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RunType&
      operator= (const RunType& x);

      virtual 
      ~RunType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      spectrumList_optional spectrumList_;
      chromatogramList_optional chromatogramList_;
      ::xsd::cxx::tree::one< id_type > id_;
      ::xsd::cxx::tree::one< defaultInstrumentConfigurationRef_type > defaultInstrumentConfigurationRef_;
      defaultSourceFileRef_optional defaultSourceFileRef_;
      sampleRef_optional sampleRef_;
      startTimeStamp_optional startTimeStamp_;
    };

    class SourceFileRefType: public ::xml_schema::type
    {
      public:
      // ref
      //
      typedef ::xml_schema::idref ref_type;
      typedef ::xsd::cxx::tree::traits< ref_type, char > ref_traits;

      const ref_type&
      ref () const;

      ref_type&
      ref ();

      void
      ref (const ref_type& x);

      void
      ref (::std::unique_ptr< ref_type > p);

      // Constructors.
      //
      SourceFileRefType (const ref_type&);

      SourceFileRefType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      SourceFileRefType (const SourceFileRefType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual SourceFileRefType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SourceFileRefType&
      operator= (const SourceFileRefType& x);

      virtual 
      ~SourceFileRefType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ref_type > ref_;
    };

    class SourceFileRefListType: public ::xml_schema::type
    {
      public:
      // sourceFileRef
      //
      typedef ::ms::mzml::SourceFileRefType sourceFileRef_type;
      typedef ::xsd::cxx::tree::sequence< sourceFileRef_type > sourceFileRef_sequence;
      typedef sourceFileRef_sequence::iterator sourceFileRef_iterator;
      typedef sourceFileRef_sequence::const_iterator sourceFileRef_const_iterator;
      typedef ::xsd::cxx::tree::traits< sourceFileRef_type, char > sourceFileRef_traits;

      const sourceFileRef_sequence&
      sourceFileRef () const;

      sourceFileRef_sequence&
      sourceFileRef ();

      void
      sourceFileRef (const sourceFileRef_sequence& s);

      // count
      //
      typedef ::xml_schema::non_negative_integer count_type;
      typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      // Constructors.
      //
      SourceFileRefListType (const count_type&);

      SourceFileRefListType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      SourceFileRefListType (const SourceFileRefListType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual SourceFileRefListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SourceFileRefListType&
      operator= (const SourceFileRefListType& x);

      virtual 
      ~SourceFileRefListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      sourceFileRef_sequence sourceFileRef_;
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class SpectrumListType: public ::xml_schema::type
    {
      public:
      // spectrum
      //
      typedef ::ms::mzml::SpectrumType spectrum_type;
      typedef ::xsd::cxx::tree::sequence< spectrum_type > spectrum_sequence;
      typedef spectrum_sequence::iterator spectrum_iterator;
      typedef spectrum_sequence::const_iterator spectrum_const_iterator;
      typedef ::xsd::cxx::tree::traits< spectrum_type, char > spectrum_traits;

      const spectrum_sequence&
      spectrum () const;

      spectrum_sequence&
      spectrum ();

      void
      spectrum (const spectrum_sequence& s);

      // count
      //
      typedef ::xml_schema::non_negative_integer count_type;
      typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      // defaultDataProcessingRef
      //
      typedef ::xml_schema::idref defaultDataProcessingRef_type;
      typedef ::xsd::cxx::tree::traits< defaultDataProcessingRef_type, char > defaultDataProcessingRef_traits;

      const defaultDataProcessingRef_type&
      defaultDataProcessingRef () const;

      defaultDataProcessingRef_type&
      defaultDataProcessingRef ();

      void
      defaultDataProcessingRef (const defaultDataProcessingRef_type& x);

      void
      defaultDataProcessingRef (::std::unique_ptr< defaultDataProcessingRef_type > p);

      // Constructors.
      //
      SpectrumListType (const count_type&,
                        const defaultDataProcessingRef_type&);

      SpectrumListType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      SpectrumListType (const SpectrumListType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual SpectrumListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SpectrumListType&
      operator= (const SpectrumListType& x);

      virtual 
      ~SpectrumListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      spectrum_sequence spectrum_;
      ::xsd::cxx::tree::one< count_type > count_;
      ::xsd::cxx::tree::one< defaultDataProcessingRef_type > defaultDataProcessingRef_;
    };

    class ScanWindowListType: public ::xml_schema::type
    {
      public:
      // scanWindow
      //
      typedef ::ms::mzml::ParamGroupType scanWindow_type;
      typedef ::xsd::cxx::tree::sequence< scanWindow_type > scanWindow_sequence;
      typedef scanWindow_sequence::iterator scanWindow_iterator;
      typedef scanWindow_sequence::const_iterator scanWindow_const_iterator;
      typedef ::xsd::cxx::tree::traits< scanWindow_type, char > scanWindow_traits;

      const scanWindow_sequence&
      scanWindow () const;

      scanWindow_sequence&
      scanWindow ();

      void
      scanWindow (const scanWindow_sequence& s);

      // count
      //
      typedef ::xml_schema::int_ count_type;
      typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      // Constructors.
      //
      ScanWindowListType (const count_type&);

      ScanWindowListType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ScanWindowListType (const ScanWindowListType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual ScanWindowListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ScanWindowListType&
      operator= (const ScanWindowListType& x);

      virtual 
      ~ScanWindowListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      scanWindow_sequence scanWindow_;
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class ScanListType: public ::ms::mzml::ParamGroupType
    {
      public:
      // scan
      //
      typedef ::ms::mzml::ScanType scan_type;
      typedef ::xsd::cxx::tree::sequence< scan_type > scan_sequence;
      typedef scan_sequence::iterator scan_iterator;
      typedef scan_sequence::const_iterator scan_const_iterator;
      typedef ::xsd::cxx::tree::traits< scan_type, char > scan_traits;

      const scan_sequence&
      scan () const;

      scan_sequence&
      scan ();

      void
      scan (const scan_sequence& s);

      // count
      //
      typedef ::xml_schema::non_negative_integer count_type;
      typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      // Constructors.
      //
      ScanListType (const count_type&);

      ScanListType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ScanListType (const ScanListType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual ScanListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ScanListType&
      operator= (const ScanListType& x);

      virtual 
      ~ScanListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      scan_sequence scan_;
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class ScanType: public ::ms::mzml::ParamGroupType
    {
      public:
      // scanWindowList
      //
      typedef ::ms::mzml::ScanWindowListType scanWindowList_type;
      typedef ::xsd::cxx::tree::optional< scanWindowList_type > scanWindowList_optional;
      typedef ::xsd::cxx::tree::traits< scanWindowList_type, char > scanWindowList_traits;

      const scanWindowList_optional&
      scanWindowList () const;

      scanWindowList_optional&
      scanWindowList ();

      void
      scanWindowList (const scanWindowList_type& x);

      void
      scanWindowList (const scanWindowList_optional& x);

      void
      scanWindowList (::std::unique_ptr< scanWindowList_type > p);

      // spectrumRef
      //
      typedef ::xml_schema::string spectrumRef_type;
      typedef ::xsd::cxx::tree::optional< spectrumRef_type > spectrumRef_optional;
      typedef ::xsd::cxx::tree::traits< spectrumRef_type, char > spectrumRef_traits;

      const spectrumRef_optional&
      spectrumRef () const;

      spectrumRef_optional&
      spectrumRef ();

      void
      spectrumRef (const spectrumRef_type& x);

      void
      spectrumRef (const spectrumRef_optional& x);

      void
      spectrumRef (::std::unique_ptr< spectrumRef_type > p);

      // sourceFileRef
      //
      typedef ::xml_schema::idref sourceFileRef_type;
      typedef ::xsd::cxx::tree::optional< sourceFileRef_type > sourceFileRef_optional;
      typedef ::xsd::cxx::tree::traits< sourceFileRef_type, char > sourceFileRef_traits;

      const sourceFileRef_optional&
      sourceFileRef () const;

      sourceFileRef_optional&
      sourceFileRef ();

      void
      sourceFileRef (const sourceFileRef_type& x);

      void
      sourceFileRef (const sourceFileRef_optional& x);

      void
      sourceFileRef (::std::unique_ptr< sourceFileRef_type > p);

      // externalSpectrumID
      //
      typedef ::xml_schema::string externalSpectrumID_type;
      typedef ::xsd::cxx::tree::optional< externalSpectrumID_type > externalSpectrumID_optional;
      typedef ::xsd::cxx::tree::traits< externalSpectrumID_type, char > externalSpectrumID_traits;

      const externalSpectrumID_optional&
      externalSpectrumID () const;

      externalSpectrumID_optional&
      externalSpectrumID ();

      void
      externalSpectrumID (const externalSpectrumID_type& x);

      void
      externalSpectrumID (const externalSpectrumID_optional& x);

      void
      externalSpectrumID (::std::unique_ptr< externalSpectrumID_type > p);

      // instrumentConfigurationRef
      //
      typedef ::xml_schema::idref instrumentConfigurationRef_type;
      typedef ::xsd::cxx::tree::optional< instrumentConfigurationRef_type > instrumentConfigurationRef_optional;
      typedef ::xsd::cxx::tree::traits< instrumentConfigurationRef_type, char > instrumentConfigurationRef_traits;

      const instrumentConfigurationRef_optional&
      instrumentConfigurationRef () const;

      instrumentConfigurationRef_optional&
      instrumentConfigurationRef ();

      void
      instrumentConfigurationRef (const instrumentConfigurationRef_type& x);

      void
      instrumentConfigurationRef (const instrumentConfigurationRef_optional& x);

      void
      instrumentConfigurationRef (::std::unique_ptr< instrumentConfigurationRef_type > p);

      // Constructors.
      //
      ScanType ();

      ScanType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      ScanType (const ScanType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual ScanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ScanType&
      operator= (const ScanType& x);

      virtual 
      ~ScanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      scanWindowList_optional scanWindowList_;
      spectrumRef_optional spectrumRef_;
      sourceFileRef_optional sourceFileRef_;
      externalSpectrumID_optional externalSpectrumID_;
      instrumentConfigurationRef_optional instrumentConfigurationRef_;
    };

    class PrecursorListType: public ::xml_schema::type
    {
      public:
      // precursor
      //
      typedef ::ms::mzml::PrecursorType precursor_type;
      typedef ::xsd::cxx::tree::sequence< precursor_type > precursor_sequence;
      typedef precursor_sequence::iterator precursor_iterator;
      typedef precursor_sequence::const_iterator precursor_const_iterator;
      typedef ::xsd::cxx::tree::traits< precursor_type, char > precursor_traits;

      const precursor_sequence&
      precursor () const;

      precursor_sequence&
      precursor ();

      void
      precursor (const precursor_sequence& s);

      // count
      //
      typedef ::xml_schema::non_negative_integer count_type;
      typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      // Constructors.
      //
      PrecursorListType (const count_type&);

      PrecursorListType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      PrecursorListType (const PrecursorListType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual PrecursorListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PrecursorListType&
      operator= (const PrecursorListType& x);

      virtual 
      ~PrecursorListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      precursor_sequence precursor_;
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class PrecursorType: public ::xml_schema::type
    {
      public:
      // isolationWindow
      //
      typedef ::ms::mzml::ParamGroupType isolationWindow_type;
      typedef ::xsd::cxx::tree::optional< isolationWindow_type > isolationWindow_optional;
      typedef ::xsd::cxx::tree::traits< isolationWindow_type, char > isolationWindow_traits;

      const isolationWindow_optional&
      isolationWindow () const;

      isolationWindow_optional&
      isolationWindow ();

      void
      isolationWindow (const isolationWindow_type& x);

      void
      isolationWindow (const isolationWindow_optional& x);

      void
      isolationWindow (::std::unique_ptr< isolationWindow_type > p);

      // selectedIonList
      //
      typedef ::ms::mzml::SelectedIonListType selectedIonList_type;
      typedef ::xsd::cxx::tree::optional< selectedIonList_type > selectedIonList_optional;
      typedef ::xsd::cxx::tree::traits< selectedIonList_type, char > selectedIonList_traits;

      const selectedIonList_optional&
      selectedIonList () const;

      selectedIonList_optional&
      selectedIonList ();

      void
      selectedIonList (const selectedIonList_type& x);

      void
      selectedIonList (const selectedIonList_optional& x);

      void
      selectedIonList (::std::unique_ptr< selectedIonList_type > p);

      // activation
      //
      typedef ::ms::mzml::ParamGroupType activation_type;
      typedef ::xsd::cxx::tree::traits< activation_type, char > activation_traits;

      const activation_type&
      activation () const;

      activation_type&
      activation ();

      void
      activation (const activation_type& x);

      void
      activation (::std::unique_ptr< activation_type > p);

      // spectrumRef
      //
      typedef ::xml_schema::string spectrumRef_type;
      typedef ::xsd::cxx::tree::optional< spectrumRef_type > spectrumRef_optional;
      typedef ::xsd::cxx::tree::traits< spectrumRef_type, char > spectrumRef_traits;

      const spectrumRef_optional&
      spectrumRef () const;

      spectrumRef_optional&
      spectrumRef ();

      void
      spectrumRef (const spectrumRef_type& x);

      void
      spectrumRef (const spectrumRef_optional& x);

      void
      spectrumRef (::std::unique_ptr< spectrumRef_type > p);

      // sourceFileRef
      //
      typedef ::xml_schema::idref sourceFileRef_type;
      typedef ::xsd::cxx::tree::optional< sourceFileRef_type > sourceFileRef_optional;
      typedef ::xsd::cxx::tree::traits< sourceFileRef_type, char > sourceFileRef_traits;

      const sourceFileRef_optional&
      sourceFileRef () const;

      sourceFileRef_optional&
      sourceFileRef ();

      void
      sourceFileRef (const sourceFileRef_type& x);

      void
      sourceFileRef (const sourceFileRef_optional& x);

      void
      sourceFileRef (::std::unique_ptr< sourceFileRef_type > p);

      // externalSpectrumID
      //
      typedef ::xml_schema::string externalSpectrumID_type;
      typedef ::xsd::cxx::tree::optional< externalSpectrumID_type > externalSpectrumID_optional;
      typedef ::xsd::cxx::tree::traits< externalSpectrumID_type, char > externalSpectrumID_traits;

      const externalSpectrumID_optional&
      externalSpectrumID () const;

      externalSpectrumID_optional&
      externalSpectrumID ();

      void
      externalSpectrumID (const externalSpectrumID_type& x);

      void
      externalSpectrumID (const externalSpectrumID_optional& x);

      void
      externalSpectrumID (::std::unique_ptr< externalSpectrumID_type > p);

      // Constructors.
      //
      PrecursorType (const activation_type&);

      PrecursorType (::std::unique_ptr< activation_type >);

      PrecursorType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      PrecursorType (const PrecursorType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual PrecursorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PrecursorType&
      operator= (const PrecursorType& x);

      virtual 
      ~PrecursorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      isolationWindow_optional isolationWindow_;
      selectedIonList_optional selectedIonList_;
      ::xsd::cxx::tree::one< activation_type > activation_;
      spectrumRef_optional spectrumRef_;
      sourceFileRef_optional sourceFileRef_;
      externalSpectrumID_optional externalSpectrumID_;
    };

    class SelectedIonListType: public ::xml_schema::type
    {
      public:
      // selectedIon
      //
      typedef ::ms::mzml::ParamGroupType selectedIon_type;
      typedef ::xsd::cxx::tree::sequence< selectedIon_type > selectedIon_sequence;
      typedef selectedIon_sequence::iterator selectedIon_iterator;
      typedef selectedIon_sequence::const_iterator selectedIon_const_iterator;
      typedef ::xsd::cxx::tree::traits< selectedIon_type, char > selectedIon_traits;

      const selectedIon_sequence&
      selectedIon () const;

      selectedIon_sequence&
      selectedIon ();

      void
      selectedIon (const selectedIon_sequence& s);

      // count
      //
      typedef ::xml_schema::non_negative_integer count_type;
      typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      // Constructors.
      //
      SelectedIonListType (const count_type&);

      SelectedIonListType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      SelectedIonListType (const SelectedIonListType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual SelectedIonListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SelectedIonListType&
      operator= (const SelectedIonListType& x);

      virtual 
      ~SelectedIonListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      selectedIon_sequence selectedIon_;
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class ProductListType: public ::xml_schema::type
    {
      public:
      // product
      //
      typedef ::ms::mzml::ProductType product_type;
      typedef ::xsd::cxx::tree::sequence< product_type > product_sequence;
      typedef product_sequence::iterator product_iterator;
      typedef product_sequence::const_iterator product_const_iterator;
      typedef ::xsd::cxx::tree::traits< product_type, char > product_traits;

      const product_sequence&
      product () const;

      product_sequence&
      product ();

      void
      product (const product_sequence& s);

      // count
      //
      typedef ::xml_schema::non_negative_integer count_type;
      typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      // Constructors.
      //
      ProductListType (const count_type&);

      ProductListType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ProductListType (const ProductListType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual ProductListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ProductListType&
      operator= (const ProductListType& x);

      virtual 
      ~ProductListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      product_sequence product_;
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class ProductType: public ::xml_schema::type
    {
      public:
      // isolationWindow
      //
      typedef ::ms::mzml::ParamGroupType isolationWindow_type;
      typedef ::xsd::cxx::tree::optional< isolationWindow_type > isolationWindow_optional;
      typedef ::xsd::cxx::tree::traits< isolationWindow_type, char > isolationWindow_traits;

      const isolationWindow_optional&
      isolationWindow () const;

      isolationWindow_optional&
      isolationWindow ();

      void
      isolationWindow (const isolationWindow_type& x);

      void
      isolationWindow (const isolationWindow_optional& x);

      void
      isolationWindow (::std::unique_ptr< isolationWindow_type > p);

      // Constructors.
      //
      ProductType ();

      ProductType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      ProductType (const ProductType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual ProductType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ProductType&
      operator= (const ProductType& x);

      virtual 
      ~ProductType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      isolationWindow_optional isolationWindow_;
    };

    class BinaryDataArrayListType: public ::xml_schema::type
    {
      public:
      // binaryDataArray
      //
      typedef ::ms::mzml::BinaryDataArrayType binaryDataArray_type;
      typedef ::xsd::cxx::tree::sequence< binaryDataArray_type > binaryDataArray_sequence;
      typedef binaryDataArray_sequence::iterator binaryDataArray_iterator;
      typedef binaryDataArray_sequence::const_iterator binaryDataArray_const_iterator;
      typedef ::xsd::cxx::tree::traits< binaryDataArray_type, char > binaryDataArray_traits;

      const binaryDataArray_sequence&
      binaryDataArray () const;

      binaryDataArray_sequence&
      binaryDataArray ();

      void
      binaryDataArray (const binaryDataArray_sequence& s);

      // count
      //
      typedef ::xml_schema::non_negative_integer count_type;
      typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      // Constructors.
      //
      BinaryDataArrayListType (const count_type&);

      BinaryDataArrayListType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      BinaryDataArrayListType (const BinaryDataArrayListType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual BinaryDataArrayListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BinaryDataArrayListType&
      operator= (const BinaryDataArrayListType& x);

      virtual 
      ~BinaryDataArrayListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      binaryDataArray_sequence binaryDataArray_;
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class BinaryDataArrayType: public ::ms::mzml::ParamGroupType
    {
      public:
      // binary
      //
      typedef ::xml_schema::base64_binary binary_type;
      typedef ::xsd::cxx::tree::traits< binary_type, char > binary_traits;

      const binary_type&
      binary () const;

      binary_type&
      binary ();

      void
      binary (const binary_type& x);

      void
      binary (::std::unique_ptr< binary_type > p);

      // arrayLength
      //
      typedef ::xml_schema::non_negative_integer arrayLength_type;
      typedef ::xsd::cxx::tree::optional< arrayLength_type > arrayLength_optional;
      typedef ::xsd::cxx::tree::traits< arrayLength_type, char > arrayLength_traits;

      const arrayLength_optional&
      arrayLength () const;

      arrayLength_optional&
      arrayLength ();

      void
      arrayLength (const arrayLength_type& x);

      void
      arrayLength (const arrayLength_optional& x);

      // dataProcessingRef
      //
      typedef ::xml_schema::idref dataProcessingRef_type;
      typedef ::xsd::cxx::tree::optional< dataProcessingRef_type > dataProcessingRef_optional;
      typedef ::xsd::cxx::tree::traits< dataProcessingRef_type, char > dataProcessingRef_traits;

      const dataProcessingRef_optional&
      dataProcessingRef () const;

      dataProcessingRef_optional&
      dataProcessingRef ();

      void
      dataProcessingRef (const dataProcessingRef_type& x);

      void
      dataProcessingRef (const dataProcessingRef_optional& x);

      void
      dataProcessingRef (::std::unique_ptr< dataProcessingRef_type > p);

      // encodedLength
      //
      typedef ::xml_schema::non_negative_integer encodedLength_type;
      typedef ::xsd::cxx::tree::traits< encodedLength_type, char > encodedLength_traits;

      const encodedLength_type&
      encodedLength () const;

      encodedLength_type&
      encodedLength ();

      void
      encodedLength (const encodedLength_type& x);

      // Constructors.
      //
      BinaryDataArrayType (const binary_type&,
                           const encodedLength_type&);

      BinaryDataArrayType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      BinaryDataArrayType (const BinaryDataArrayType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual BinaryDataArrayType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BinaryDataArrayType&
      operator= (const BinaryDataArrayType& x);

      virtual 
      ~BinaryDataArrayType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< binary_type > binary_;
      arrayLength_optional arrayLength_;
      dataProcessingRef_optional dataProcessingRef_;
      ::xsd::cxx::tree::one< encodedLength_type > encodedLength_;
    };

    class SpectrumType: public ::ms::mzml::ParamGroupType
    {
      public:
      // scanList
      //
      typedef ::ms::mzml::ScanListType scanList_type;
      typedef ::xsd::cxx::tree::optional< scanList_type > scanList_optional;
      typedef ::xsd::cxx::tree::traits< scanList_type, char > scanList_traits;

      const scanList_optional&
      scanList () const;

      scanList_optional&
      scanList ();

      void
      scanList (const scanList_type& x);

      void
      scanList (const scanList_optional& x);

      void
      scanList (::std::unique_ptr< scanList_type > p);

      // precursorList
      //
      typedef ::ms::mzml::PrecursorListType precursorList_type;
      typedef ::xsd::cxx::tree::optional< precursorList_type > precursorList_optional;
      typedef ::xsd::cxx::tree::traits< precursorList_type, char > precursorList_traits;

      const precursorList_optional&
      precursorList () const;

      precursorList_optional&
      precursorList ();

      void
      precursorList (const precursorList_type& x);

      void
      precursorList (const precursorList_optional& x);

      void
      precursorList (::std::unique_ptr< precursorList_type > p);

      // productList
      //
      typedef ::ms::mzml::ProductListType productList_type;
      typedef ::xsd::cxx::tree::optional< productList_type > productList_optional;
      typedef ::xsd::cxx::tree::traits< productList_type, char > productList_traits;

      const productList_optional&
      productList () const;

      productList_optional&
      productList ();

      void
      productList (const productList_type& x);

      void
      productList (const productList_optional& x);

      void
      productList (::std::unique_ptr< productList_type > p);

      // binaryDataArrayList
      //
      typedef ::ms::mzml::BinaryDataArrayListType binaryDataArrayList_type;
      typedef ::xsd::cxx::tree::optional< binaryDataArrayList_type > binaryDataArrayList_optional;
      typedef ::xsd::cxx::tree::traits< binaryDataArrayList_type, char > binaryDataArrayList_traits;

      const binaryDataArrayList_optional&
      binaryDataArrayList () const;

      binaryDataArrayList_optional&
      binaryDataArrayList ();

      void
      binaryDataArrayList (const binaryDataArrayList_type& x);

      void
      binaryDataArrayList (const binaryDataArrayList_optional& x);

      void
      binaryDataArrayList (::std::unique_ptr< binaryDataArrayList_type > p);

      // id
      //
      typedef ::ms::mzml::id id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // spotID
      //
      typedef ::xml_schema::string spotID_type;
      typedef ::xsd::cxx::tree::optional< spotID_type > spotID_optional;
      typedef ::xsd::cxx::tree::traits< spotID_type, char > spotID_traits;

      const spotID_optional&
      spotID () const;

      spotID_optional&
      spotID ();

      void
      spotID (const spotID_type& x);

      void
      spotID (const spotID_optional& x);

      void
      spotID (::std::unique_ptr< spotID_type > p);

      // index
      //
      typedef ::xml_schema::non_negative_integer index_type;
      typedef ::xsd::cxx::tree::traits< index_type, char > index_traits;

      const index_type&
      index () const;

      index_type&
      index ();

      void
      index (const index_type& x);

      // defaultArrayLength
      //
      typedef ::xml_schema::int_ defaultArrayLength_type;
      typedef ::xsd::cxx::tree::traits< defaultArrayLength_type, char > defaultArrayLength_traits;

      const defaultArrayLength_type&
      defaultArrayLength () const;

      defaultArrayLength_type&
      defaultArrayLength ();

      void
      defaultArrayLength (const defaultArrayLength_type& x);

      // dataProcessingRef
      //
      typedef ::xml_schema::idref dataProcessingRef_type;
      typedef ::xsd::cxx::tree::optional< dataProcessingRef_type > dataProcessingRef_optional;
      typedef ::xsd::cxx::tree::traits< dataProcessingRef_type, char > dataProcessingRef_traits;

      const dataProcessingRef_optional&
      dataProcessingRef () const;

      dataProcessingRef_optional&
      dataProcessingRef ();

      void
      dataProcessingRef (const dataProcessingRef_type& x);

      void
      dataProcessingRef (const dataProcessingRef_optional& x);

      void
      dataProcessingRef (::std::unique_ptr< dataProcessingRef_type > p);

      // sourceFileRef
      //
      typedef ::xml_schema::idref sourceFileRef_type;
      typedef ::xsd::cxx::tree::optional< sourceFileRef_type > sourceFileRef_optional;
      typedef ::xsd::cxx::tree::traits< sourceFileRef_type, char > sourceFileRef_traits;

      const sourceFileRef_optional&
      sourceFileRef () const;

      sourceFileRef_optional&
      sourceFileRef ();

      void
      sourceFileRef (const sourceFileRef_type& x);

      void
      sourceFileRef (const sourceFileRef_optional& x);

      void
      sourceFileRef (::std::unique_ptr< sourceFileRef_type > p);

      // Constructors.
      //
      SpectrumType (const id_type&,
                    const index_type&,
                    const defaultArrayLength_type&);

      SpectrumType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      SpectrumType (const SpectrumType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual SpectrumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SpectrumType&
      operator= (const SpectrumType& x);

      virtual 
      ~SpectrumType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      scanList_optional scanList_;
      precursorList_optional precursorList_;
      productList_optional productList_;
      binaryDataArrayList_optional binaryDataArrayList_;
      ::xsd::cxx::tree::one< id_type > id_;
      spotID_optional spotID_;
      ::xsd::cxx::tree::one< index_type > index_;
      ::xsd::cxx::tree::one< defaultArrayLength_type > defaultArrayLength_;
      dataProcessingRef_optional dataProcessingRef_;
      sourceFileRef_optional sourceFileRef_;
    };

    class ChromatogramListType: public ::xml_schema::type
    {
      public:
      // chromatogram
      //
      typedef ::ms::mzml::ChromatogramType chromatogram_type;
      typedef ::xsd::cxx::tree::sequence< chromatogram_type > chromatogram_sequence;
      typedef chromatogram_sequence::iterator chromatogram_iterator;
      typedef chromatogram_sequence::const_iterator chromatogram_const_iterator;
      typedef ::xsd::cxx::tree::traits< chromatogram_type, char > chromatogram_traits;

      const chromatogram_sequence&
      chromatogram () const;

      chromatogram_sequence&
      chromatogram ();

      void
      chromatogram (const chromatogram_sequence& s);

      // count
      //
      typedef ::xml_schema::non_negative_integer count_type;
      typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      // defaultDataProcessingRef
      //
      typedef ::xml_schema::idref defaultDataProcessingRef_type;
      typedef ::xsd::cxx::tree::traits< defaultDataProcessingRef_type, char > defaultDataProcessingRef_traits;

      const defaultDataProcessingRef_type&
      defaultDataProcessingRef () const;

      defaultDataProcessingRef_type&
      defaultDataProcessingRef ();

      void
      defaultDataProcessingRef (const defaultDataProcessingRef_type& x);

      void
      defaultDataProcessingRef (::std::unique_ptr< defaultDataProcessingRef_type > p);

      // Constructors.
      //
      ChromatogramListType (const count_type&,
                            const defaultDataProcessingRef_type&);

      ChromatogramListType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ChromatogramListType (const ChromatogramListType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual ChromatogramListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ChromatogramListType&
      operator= (const ChromatogramListType& x);

      virtual 
      ~ChromatogramListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      chromatogram_sequence chromatogram_;
      ::xsd::cxx::tree::one< count_type > count_;
      ::xsd::cxx::tree::one< defaultDataProcessingRef_type > defaultDataProcessingRef_;
    };

    class ChromatogramType: public ::ms::mzml::ParamGroupType
    {
      public:
      // precursor
      //
      typedef ::ms::mzml::PrecursorType precursor_type;
      typedef ::xsd::cxx::tree::optional< precursor_type > precursor_optional;
      typedef ::xsd::cxx::tree::traits< precursor_type, char > precursor_traits;

      const precursor_optional&
      precursor () const;

      precursor_optional&
      precursor ();

      void
      precursor (const precursor_type& x);

      void
      precursor (const precursor_optional& x);

      void
      precursor (::std::unique_ptr< precursor_type > p);

      // product
      //
      typedef ::ms::mzml::ProductType product_type;
      typedef ::xsd::cxx::tree::optional< product_type > product_optional;
      typedef ::xsd::cxx::tree::traits< product_type, char > product_traits;

      const product_optional&
      product () const;

      product_optional&
      product ();

      void
      product (const product_type& x);

      void
      product (const product_optional& x);

      void
      product (::std::unique_ptr< product_type > p);

      // binaryDataArrayList
      //
      typedef ::ms::mzml::BinaryDataArrayListType binaryDataArrayList_type;
      typedef ::xsd::cxx::tree::traits< binaryDataArrayList_type, char > binaryDataArrayList_traits;

      const binaryDataArrayList_type&
      binaryDataArrayList () const;

      binaryDataArrayList_type&
      binaryDataArrayList ();

      void
      binaryDataArrayList (const binaryDataArrayList_type& x);

      void
      binaryDataArrayList (::std::unique_ptr< binaryDataArrayList_type > p);

      // id
      //
      typedef ::xml_schema::string id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // index
      //
      typedef ::xml_schema::non_negative_integer index_type;
      typedef ::xsd::cxx::tree::traits< index_type, char > index_traits;

      const index_type&
      index () const;

      index_type&
      index ();

      void
      index (const index_type& x);

      // defaultArrayLength
      //
      typedef ::xml_schema::int_ defaultArrayLength_type;
      typedef ::xsd::cxx::tree::traits< defaultArrayLength_type, char > defaultArrayLength_traits;

      const defaultArrayLength_type&
      defaultArrayLength () const;

      defaultArrayLength_type&
      defaultArrayLength ();

      void
      defaultArrayLength (const defaultArrayLength_type& x);

      // dataProcessingRef
      //
      typedef ::xml_schema::idref dataProcessingRef_type;
      typedef ::xsd::cxx::tree::optional< dataProcessingRef_type > dataProcessingRef_optional;
      typedef ::xsd::cxx::tree::traits< dataProcessingRef_type, char > dataProcessingRef_traits;

      const dataProcessingRef_optional&
      dataProcessingRef () const;

      dataProcessingRef_optional&
      dataProcessingRef ();

      void
      dataProcessingRef (const dataProcessingRef_type& x);

      void
      dataProcessingRef (const dataProcessingRef_optional& x);

      void
      dataProcessingRef (::std::unique_ptr< dataProcessingRef_type > p);

      // Constructors.
      //
      ChromatogramType (const binaryDataArrayList_type&,
                        const id_type&,
                        const index_type&,
                        const defaultArrayLength_type&);

      ChromatogramType (::std::unique_ptr< binaryDataArrayList_type >,
                        const id_type&,
                        const index_type&,
                        const defaultArrayLength_type&);

      ChromatogramType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ChromatogramType (const ChromatogramType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual ChromatogramType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ChromatogramType&
      operator= (const ChromatogramType& x);

      virtual 
      ~ChromatogramType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      precursor_optional precursor_;
      product_optional product_;
      ::xsd::cxx::tree::one< binaryDataArrayList_type > binaryDataArrayList_;
      ::xsd::cxx::tree::one< id_type > id_;
      ::xsd::cxx::tree::one< index_type > index_;
      ::xsd::cxx::tree::one< defaultArrayLength_type > defaultArrayLength_;
      dataProcessingRef_optional dataProcessingRef_;
    };

    class id: public ::xml_schema::string
    {
      public:
      // Constructors.
      //
      id ();

      id (const char*);

      id (const ::std::string&);

      id (const ::xml_schema::string&);

      id (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

      id (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

      id (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

      id (const id& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

      virtual id*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~id ();
    };

  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace ms
{
  namespace mzml
  {
    // Parse a URI or a local file.
    //

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (const ::std::string& uri,
          ::xml_schema::flags f = 0,
          const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (const ::std::string& uri,
          ::xml_schema::error_handler& eh,
          ::xml_schema::flags f = 0,
          const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (const ::std::string& uri,
          ::xercesc::DOMErrorHandler& eh,
          ::xml_schema::flags f = 0,
          const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse std::istream.
    //

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (::std::istream& is,
          ::xml_schema::flags f = 0,
          const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (::std::istream& is,
          ::xml_schema::error_handler& eh,
          ::xml_schema::flags f = 0,
          const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (::std::istream& is,
          ::xercesc::DOMErrorHandler& eh,
          ::xml_schema::flags f = 0,
          const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (::std::istream& is,
          const ::std::string& id,
          ::xml_schema::flags f = 0,
          const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (::std::istream& is,
          const ::std::string& id,
          ::xml_schema::error_handler& eh,
          ::xml_schema::flags f = 0,
          const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (::std::istream& is,
          const ::std::string& id,
          ::xercesc::DOMErrorHandler& eh,
          ::xml_schema::flags f = 0,
          const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse xercesc::InputSource.
    //

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (::xercesc::InputSource& is,
          ::xml_schema::flags f = 0,
          const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (::xercesc::InputSource& is,
          ::xml_schema::error_handler& eh,
          ::xml_schema::flags f = 0,
          const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (::xercesc::InputSource& is,
          ::xercesc::DOMErrorHandler& eh,
          ::xml_schema::flags f = 0,
          const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse xercesc::DOMDocument.
    //

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (const ::xercesc::DOMDocument& d,
          ::xml_schema::flags f = 0,
          const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f = 0,
          const ::xml_schema::properties& p = ::xml_schema::properties ());
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace ms
{
  namespace mzml
  {
    void
    operator<< (::xercesc::DOMElement&, const mzMLType&);

    void
    operator<< (::xercesc::DOMElement&, const FileDescriptionType&);

    void
    operator<< (::xercesc::DOMElement&, const SourceFileListType&);

    void
    operator<< (::xercesc::DOMElement&, const ParamGroupType&);

    void
    operator<< (::xercesc::DOMElement&, const SourceFileType&);

    void
    operator<< (::xercesc::DOMElement&, const CVType&);

    void
    operator<< (::xercesc::DOMElement&, const CVListType&);

    void
    operator<< (::xercesc::DOMElement&, const ReferenceableParamGroupListType&);

    void
    operator<< (::xercesc::DOMElement&, const ReferenceableParamGroupType&);

    void
    operator<< (::xercesc::DOMElement&, const CVParamType&);

    void
    operator<< (::xercesc::DOMElement&, const UserParamType&);

    void
    operator<< (::xercesc::DOMElement&, const ReferenceableParamGroupRefType&);

    void
    operator<< (::xercesc::DOMElement&, const SampleListType&);

    void
    operator<< (::xercesc::DOMElement&, const SampleType&);

    void
    operator<< (::xercesc::DOMElement&, const InstrumentConfigurationListType&);

    void
    operator<< (::xercesc::DOMElement&, const ComponentType&);

    void
    operator<< (::xercesc::DOMElement&, const SourceComponentType&);

    void
    operator<< (::xercesc::DOMElement&, const DetectorComponentType&);

    void
    operator<< (::xercesc::DOMElement&, const AnalyzerComponentType&);

    void
    operator<< (::xercesc::DOMElement&, const ComponentListType&);

    void
    operator<< (::xercesc::DOMElement&, const InstrumentConfigurationType&);

    void
    operator<< (::xercesc::DOMElement&, const SoftwareRefType&);

    void
    operator<< (::xercesc::DOMElement&, const SoftwareListType&);

    void
    operator<< (::xercesc::DOMElement&, const SoftwareType&);

    void
    operator<< (::xercesc::DOMElement&, const DataProcessingListType&);

    void
    operator<< (::xercesc::DOMElement&, const DataProcessingType&);

    void
    operator<< (::xercesc::DOMElement&, const ProcessingMethodType&);

    void
    operator<< (::xercesc::DOMElement&, const ScanSettingsListType&);

    void
    operator<< (::xercesc::DOMElement&, const ScanSettingsType&);

    void
    operator<< (::xercesc::DOMElement&, const TargetListType&);

    void
    operator<< (::xercesc::DOMElement&, const RunType&);

    void
    operator<< (::xercesc::DOMElement&, const SourceFileRefType&);

    void
    operator<< (::xercesc::DOMElement&, const SourceFileRefListType&);

    void
    operator<< (::xercesc::DOMElement&, const SpectrumListType&);

    void
    operator<< (::xercesc::DOMElement&, const ScanWindowListType&);

    void
    operator<< (::xercesc::DOMElement&, const ScanListType&);

    void
    operator<< (::xercesc::DOMElement&, const ScanType&);

    void
    operator<< (::xercesc::DOMElement&, const PrecursorListType&);

    void
    operator<< (::xercesc::DOMElement&, const PrecursorType&);

    void
    operator<< (::xercesc::DOMElement&, const SelectedIonListType&);

    void
    operator<< (::xercesc::DOMElement&, const ProductListType&);

    void
    operator<< (::xercesc::DOMElement&, const ProductType&);

    void
    operator<< (::xercesc::DOMElement&, const BinaryDataArrayListType&);

    void
    operator<< (::xercesc::DOMElement&, const BinaryDataArrayType&);

    void
    operator<< (::xercesc::DOMElement&, const SpectrumType&);

    void
    operator<< (::xercesc::DOMElement&, const ChromatogramListType&);

    void
    operator<< (::xercesc::DOMElement&, const ChromatogramType&);

    // Serialize to std::ostream.
    //

    void
    mzML (::std::ostream& os,
          const ::ms::mzml::mzMLType& x, 
          const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
          const ::std::string& e = "UTF-8",
          ::xml_schema::flags f = 0);

    void
    mzML (::std::ostream& os,
          const ::ms::mzml::mzMLType& x, 
          ::xml_schema::error_handler& eh,
          const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
          const ::std::string& e = "UTF-8",
          ::xml_schema::flags f = 0);

    void
    mzML (::std::ostream& os,
          const ::ms::mzml::mzMLType& x, 
          ::xercesc::DOMErrorHandler& eh,
          const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
          const ::std::string& e = "UTF-8",
          ::xml_schema::flags f = 0);

    // Serialize to xercesc::XMLFormatTarget.
    //

    void
    mzML (::xercesc::XMLFormatTarget& ft,
          const ::ms::mzml::mzMLType& x, 
          const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
          const ::std::string& e = "UTF-8",
          ::xml_schema::flags f = 0);

    void
    mzML (::xercesc::XMLFormatTarget& ft,
          const ::ms::mzml::mzMLType& x, 
          ::xml_schema::error_handler& eh,
          const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
          const ::std::string& e = "UTF-8",
          ::xml_schema::flags f = 0);

    void
    mzML (::xercesc::XMLFormatTarget& ft,
          const ::ms::mzml::mzMLType& x, 
          ::xercesc::DOMErrorHandler& eh,
          const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
          const ::std::string& e = "UTF-8",
          ::xml_schema::flags f = 0);

    // Serialize to an existing xercesc::DOMDocument.
    //

    void
    mzML (::xercesc::DOMDocument& d,
          const ::ms::mzml::mzMLType& x,
          ::xml_schema::flags f = 0);

    // Serialize to a new xercesc::DOMDocument.
    //

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    mzML (const ::ms::mzml::mzMLType& x, 
          const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
          ::xml_schema::flags f = 0);

    void
    operator<< (::xercesc::DOMElement&, const id&);

    void
    operator<< (::xercesc::DOMAttr&, const id&);

    void
    operator<< (::xml_schema::list_stream&,
                const id&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // MZ_ML1_1_0_H
