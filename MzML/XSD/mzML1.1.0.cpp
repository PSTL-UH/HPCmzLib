// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "mzML1.1.0.h"

namespace ms
{
  namespace mzml
  {
    // mzMLType
    // 

    const mzMLType::cvList_type& mzMLType::
    cvList () const
    {
      return this->cvList_.get ();
    }

    mzMLType::cvList_type& mzMLType::
    cvList ()
    {
      return this->cvList_.get ();
    }

    void mzMLType::
    cvList (const cvList_type& x)
    {
      this->cvList_.set (x);
    }

    void mzMLType::
    cvList (::std::unique_ptr< cvList_type > x)
    {
      this->cvList_.set (std::move (x));
    }

    const mzMLType::fileDescription_type& mzMLType::
    fileDescription () const
    {
      return this->fileDescription_.get ();
    }

    mzMLType::fileDescription_type& mzMLType::
    fileDescription ()
    {
      return this->fileDescription_.get ();
    }

    void mzMLType::
    fileDescription (const fileDescription_type& x)
    {
      this->fileDescription_.set (x);
    }

    void mzMLType::
    fileDescription (::std::unique_ptr< fileDescription_type > x)
    {
      this->fileDescription_.set (std::move (x));
    }

    const mzMLType::referenceableParamGroupList_optional& mzMLType::
    referenceableParamGroupList () const
    {
      return this->referenceableParamGroupList_;
    }

    mzMLType::referenceableParamGroupList_optional& mzMLType::
    referenceableParamGroupList ()
    {
      return this->referenceableParamGroupList_;
    }

    void mzMLType::
    referenceableParamGroupList (const referenceableParamGroupList_type& x)
    {
      this->referenceableParamGroupList_.set (x);
    }

    void mzMLType::
    referenceableParamGroupList (const referenceableParamGroupList_optional& x)
    {
      this->referenceableParamGroupList_ = x;
    }

    void mzMLType::
    referenceableParamGroupList (::std::unique_ptr< referenceableParamGroupList_type > x)
    {
      this->referenceableParamGroupList_.set (std::move (x));
    }

    const mzMLType::sampleList_optional& mzMLType::
    sampleList () const
    {
      return this->sampleList_;
    }

    mzMLType::sampleList_optional& mzMLType::
    sampleList ()
    {
      return this->sampleList_;
    }

    void mzMLType::
    sampleList (const sampleList_type& x)
    {
      this->sampleList_.set (x);
    }

    void mzMLType::
    sampleList (const sampleList_optional& x)
    {
      this->sampleList_ = x;
    }

    void mzMLType::
    sampleList (::std::unique_ptr< sampleList_type > x)
    {
      this->sampleList_.set (std::move (x));
    }

    const mzMLType::softwareList_type& mzMLType::
    softwareList () const
    {
      return this->softwareList_.get ();
    }

    mzMLType::softwareList_type& mzMLType::
    softwareList ()
    {
      return this->softwareList_.get ();
    }

    void mzMLType::
    softwareList (const softwareList_type& x)
    {
      this->softwareList_.set (x);
    }

    void mzMLType::
    softwareList (::std::unique_ptr< softwareList_type > x)
    {
      this->softwareList_.set (std::move (x));
    }

    const mzMLType::scanSettingsList_optional& mzMLType::
    scanSettingsList () const
    {
      return this->scanSettingsList_;
    }

    mzMLType::scanSettingsList_optional& mzMLType::
    scanSettingsList ()
    {
      return this->scanSettingsList_;
    }

    void mzMLType::
    scanSettingsList (const scanSettingsList_type& x)
    {
      this->scanSettingsList_.set (x);
    }

    void mzMLType::
    scanSettingsList (const scanSettingsList_optional& x)
    {
      this->scanSettingsList_ = x;
    }

    void mzMLType::
    scanSettingsList (::std::unique_ptr< scanSettingsList_type > x)
    {
      this->scanSettingsList_.set (std::move (x));
    }

    const mzMLType::instrumentConfigurationList_type& mzMLType::
    instrumentConfigurationList () const
    {
      return this->instrumentConfigurationList_.get ();
    }

    mzMLType::instrumentConfigurationList_type& mzMLType::
    instrumentConfigurationList ()
    {
      return this->instrumentConfigurationList_.get ();
    }

    void mzMLType::
    instrumentConfigurationList (const instrumentConfigurationList_type& x)
    {
      this->instrumentConfigurationList_.set (x);
    }

    void mzMLType::
    instrumentConfigurationList (::std::unique_ptr< instrumentConfigurationList_type > x)
    {
      this->instrumentConfigurationList_.set (std::move (x));
    }

    const mzMLType::dataProcessingList_type& mzMLType::
    dataProcessingList () const
    {
      return this->dataProcessingList_.get ();
    }

    mzMLType::dataProcessingList_type& mzMLType::
    dataProcessingList ()
    {
      return this->dataProcessingList_.get ();
    }

    void mzMLType::
    dataProcessingList (const dataProcessingList_type& x)
    {
      this->dataProcessingList_.set (x);
    }

    void mzMLType::
    dataProcessingList (::std::unique_ptr< dataProcessingList_type > x)
    {
      this->dataProcessingList_.set (std::move (x));
    }

    const mzMLType::run_type& mzMLType::
    run () const
    {
      return this->run_.get ();
    }

    mzMLType::run_type& mzMLType::
    run ()
    {
      return this->run_.get ();
    }

    void mzMLType::
    run (const run_type& x)
    {
      this->run_.set (x);
    }

    void mzMLType::
    run (::std::unique_ptr< run_type > x)
    {
      this->run_.set (std::move (x));
    }

    const mzMLType::accession_optional& mzMLType::
    accession () const
    {
      return this->accession_;
    }

    mzMLType::accession_optional& mzMLType::
    accession ()
    {
      return this->accession_;
    }

    void mzMLType::
    accession (const accession_type& x)
    {
      this->accession_.set (x);
    }

    void mzMLType::
    accession (const accession_optional& x)
    {
      this->accession_ = x;
    }

    void mzMLType::
    accession (::std::unique_ptr< accession_type > x)
    {
      this->accession_.set (std::move (x));
    }

    const mzMLType::version_type& mzMLType::
    version () const
    {
      return this->version_.get ();
    }

    mzMLType::version_type& mzMLType::
    version ()
    {
      return this->version_.get ();
    }

    void mzMLType::
    version (const version_type& x)
    {
      this->version_.set (x);
    }

    void mzMLType::
    version (::std::unique_ptr< version_type > x)
    {
      this->version_.set (std::move (x));
    }

    const mzMLType::id_optional& mzMLType::
    id () const
    {
      return this->id_;
    }

    mzMLType::id_optional& mzMLType::
    id ()
    {
      return this->id_;
    }

    void mzMLType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void mzMLType::
    id (const id_optional& x)
    {
      this->id_ = x;
    }

    void mzMLType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // FileDescriptionType
    // 

    const FileDescriptionType::fileContent_type& FileDescriptionType::
    fileContent () const
    {
      return this->fileContent_.get ();
    }

    FileDescriptionType::fileContent_type& FileDescriptionType::
    fileContent ()
    {
      return this->fileContent_.get ();
    }

    void FileDescriptionType::
    fileContent (const fileContent_type& x)
    {
      this->fileContent_.set (x);
    }

    void FileDescriptionType::
    fileContent (::std::unique_ptr< fileContent_type > x)
    {
      this->fileContent_.set (std::move (x));
    }

    const FileDescriptionType::sourceFileList_optional& FileDescriptionType::
    sourceFileList () const
    {
      return this->sourceFileList_;
    }

    FileDescriptionType::sourceFileList_optional& FileDescriptionType::
    sourceFileList ()
    {
      return this->sourceFileList_;
    }

    void FileDescriptionType::
    sourceFileList (const sourceFileList_type& x)
    {
      this->sourceFileList_.set (x);
    }

    void FileDescriptionType::
    sourceFileList (const sourceFileList_optional& x)
    {
      this->sourceFileList_ = x;
    }

    void FileDescriptionType::
    sourceFileList (::std::unique_ptr< sourceFileList_type > x)
    {
      this->sourceFileList_.set (std::move (x));
    }

    const FileDescriptionType::contact_sequence& FileDescriptionType::
    contact () const
    {
      return this->contact_;
    }

    FileDescriptionType::contact_sequence& FileDescriptionType::
    contact ()
    {
      return this->contact_;
    }

    void FileDescriptionType::
    contact (const contact_sequence& s)
    {
      this->contact_ = s;
    }


    // SourceFileListType
    // 

    const SourceFileListType::sourceFile_sequence& SourceFileListType::
    sourceFile () const
    {
      return this->sourceFile_;
    }

    SourceFileListType::sourceFile_sequence& SourceFileListType::
    sourceFile ()
    {
      return this->sourceFile_;
    }

    void SourceFileListType::
    sourceFile (const sourceFile_sequence& s)
    {
      this->sourceFile_ = s;
    }

    const SourceFileListType::count_type& SourceFileListType::
    count () const
    {
      return this->count_.get ();
    }

    SourceFileListType::count_type& SourceFileListType::
    count ()
    {
      return this->count_.get ();
    }

    void SourceFileListType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }


    // ParamGroupType
    // 

    const ParamGroupType::referenceableParamGroupRef_sequence& ParamGroupType::
    referenceableParamGroupRef () const
    {
      return this->referenceableParamGroupRef_;
    }

    ParamGroupType::referenceableParamGroupRef_sequence& ParamGroupType::
    referenceableParamGroupRef ()
    {
      return this->referenceableParamGroupRef_;
    }

    void ParamGroupType::
    referenceableParamGroupRef (const referenceableParamGroupRef_sequence& s)
    {
      this->referenceableParamGroupRef_ = s;
    }

    const ParamGroupType::cvParam_sequence& ParamGroupType::
    cvParam () const
    {
      return this->cvParam_;
    }

    ParamGroupType::cvParam_sequence& ParamGroupType::
    cvParam ()
    {
      return this->cvParam_;
    }

    void ParamGroupType::
    cvParam (const cvParam_sequence& s)
    {
      this->cvParam_ = s;
    }

    const ParamGroupType::userParam_sequence& ParamGroupType::
    userParam () const
    {
      return this->userParam_;
    }

    ParamGroupType::userParam_sequence& ParamGroupType::
    userParam ()
    {
      return this->userParam_;
    }

    void ParamGroupType::
    userParam (const userParam_sequence& s)
    {
      this->userParam_ = s;
    }


    // SourceFileType
    // 

    const SourceFileType::id_type& SourceFileType::
    id () const
    {
      return this->id_.get ();
    }

    SourceFileType::id_type& SourceFileType::
    id ()
    {
      return this->id_.get ();
    }

    void SourceFileType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void SourceFileType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const SourceFileType::name_type& SourceFileType::
    name () const
    {
      return this->name_.get ();
    }

    SourceFileType::name_type& SourceFileType::
    name ()
    {
      return this->name_.get ();
    }

    void SourceFileType::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void SourceFileType::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const SourceFileType::location_type& SourceFileType::
    location () const
    {
      return this->location_.get ();
    }

    SourceFileType::location_type& SourceFileType::
    location ()
    {
      return this->location_.get ();
    }

    void SourceFileType::
    location (const location_type& x)
    {
      this->location_.set (x);
    }

    void SourceFileType::
    location (::std::unique_ptr< location_type > x)
    {
      this->location_.set (std::move (x));
    }


    // CVType
    // 

    const CVType::id_type& CVType::
    id () const
    {
      return this->id_.get ();
    }

    CVType::id_type& CVType::
    id ()
    {
      return this->id_.get ();
    }

    void CVType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void CVType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const CVType::fullName_type& CVType::
    fullName () const
    {
      return this->fullName_.get ();
    }

    CVType::fullName_type& CVType::
    fullName ()
    {
      return this->fullName_.get ();
    }

    void CVType::
    fullName (const fullName_type& x)
    {
      this->fullName_.set (x);
    }

    void CVType::
    fullName (::std::unique_ptr< fullName_type > x)
    {
      this->fullName_.set (std::move (x));
    }

    const CVType::version_optional& CVType::
    version () const
    {
      return this->version_;
    }

    CVType::version_optional& CVType::
    version ()
    {
      return this->version_;
    }

    void CVType::
    version (const version_type& x)
    {
      this->version_.set (x);
    }

    void CVType::
    version (const version_optional& x)
    {
      this->version_ = x;
    }

    void CVType::
    version (::std::unique_ptr< version_type > x)
    {
      this->version_.set (std::move (x));
    }

    const CVType::URI_type& CVType::
    URI () const
    {
      return this->URI_.get ();
    }

    CVType::URI_type& CVType::
    URI ()
    {
      return this->URI_.get ();
    }

    void CVType::
    URI (const URI_type& x)
    {
      this->URI_.set (x);
    }

    void CVType::
    URI (::std::unique_ptr< URI_type > x)
    {
      this->URI_.set (std::move (x));
    }


    // CVListType
    // 

    const CVListType::cv_sequence& CVListType::
    cv () const
    {
      return this->cv_;
    }

    CVListType::cv_sequence& CVListType::
    cv ()
    {
      return this->cv_;
    }

    void CVListType::
    cv (const cv_sequence& s)
    {
      this->cv_ = s;
    }

    const CVListType::count_type& CVListType::
    count () const
    {
      return this->count_.get ();
    }

    CVListType::count_type& CVListType::
    count ()
    {
      return this->count_.get ();
    }

    void CVListType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }


    // ReferenceableParamGroupListType
    // 

    const ReferenceableParamGroupListType::referenceableParamGroup_sequence& ReferenceableParamGroupListType::
    referenceableParamGroup () const
    {
      return this->referenceableParamGroup_;
    }

    ReferenceableParamGroupListType::referenceableParamGroup_sequence& ReferenceableParamGroupListType::
    referenceableParamGroup ()
    {
      return this->referenceableParamGroup_;
    }

    void ReferenceableParamGroupListType::
    referenceableParamGroup (const referenceableParamGroup_sequence& s)
    {
      this->referenceableParamGroup_ = s;
    }

    const ReferenceableParamGroupListType::count_type& ReferenceableParamGroupListType::
    count () const
    {
      return this->count_.get ();
    }

    ReferenceableParamGroupListType::count_type& ReferenceableParamGroupListType::
    count ()
    {
      return this->count_.get ();
    }

    void ReferenceableParamGroupListType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }


    // ReferenceableParamGroupType
    // 

    const ReferenceableParamGroupType::cvParam_sequence& ReferenceableParamGroupType::
    cvParam () const
    {
      return this->cvParam_;
    }

    ReferenceableParamGroupType::cvParam_sequence& ReferenceableParamGroupType::
    cvParam ()
    {
      return this->cvParam_;
    }

    void ReferenceableParamGroupType::
    cvParam (const cvParam_sequence& s)
    {
      this->cvParam_ = s;
    }

    const ReferenceableParamGroupType::userParam_sequence& ReferenceableParamGroupType::
    userParam () const
    {
      return this->userParam_;
    }

    ReferenceableParamGroupType::userParam_sequence& ReferenceableParamGroupType::
    userParam ()
    {
      return this->userParam_;
    }

    void ReferenceableParamGroupType::
    userParam (const userParam_sequence& s)
    {
      this->userParam_ = s;
    }

    const ReferenceableParamGroupType::id_type& ReferenceableParamGroupType::
    id () const
    {
      return this->id_.get ();
    }

    ReferenceableParamGroupType::id_type& ReferenceableParamGroupType::
    id ()
    {
      return this->id_.get ();
    }

    void ReferenceableParamGroupType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void ReferenceableParamGroupType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // CVParamType
    // 

    const CVParamType::cvRef_type& CVParamType::
    cvRef () const
    {
      return this->cvRef_.get ();
    }

    CVParamType::cvRef_type& CVParamType::
    cvRef ()
    {
      return this->cvRef_.get ();
    }

    void CVParamType::
    cvRef (const cvRef_type& x)
    {
      this->cvRef_.set (x);
    }

    void CVParamType::
    cvRef (::std::unique_ptr< cvRef_type > x)
    {
      this->cvRef_.set (std::move (x));
    }

    const CVParamType::accession_type& CVParamType::
    accession () const
    {
      return this->accession_.get ();
    }

    CVParamType::accession_type& CVParamType::
    accession ()
    {
      return this->accession_.get ();
    }

    void CVParamType::
    accession (const accession_type& x)
    {
      this->accession_.set (x);
    }

    void CVParamType::
    accession (::std::unique_ptr< accession_type > x)
    {
      this->accession_.set (std::move (x));
    }

    const CVParamType::value_optional& CVParamType::
    value () const
    {
      return this->value_;
    }

    CVParamType::value_optional& CVParamType::
    value ()
    {
      return this->value_;
    }

    void CVParamType::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void CVParamType::
    value (const value_optional& x)
    {
      this->value_ = x;
    }

    void CVParamType::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    const CVParamType::name_type& CVParamType::
    name () const
    {
      return this->name_.get ();
    }

    CVParamType::name_type& CVParamType::
    name ()
    {
      return this->name_.get ();
    }

    void CVParamType::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void CVParamType::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const CVParamType::unitAccession_optional& CVParamType::
    unitAccession () const
    {
      return this->unitAccession_;
    }

    CVParamType::unitAccession_optional& CVParamType::
    unitAccession ()
    {
      return this->unitAccession_;
    }

    void CVParamType::
    unitAccession (const unitAccession_type& x)
    {
      this->unitAccession_.set (x);
    }

    void CVParamType::
    unitAccession (const unitAccession_optional& x)
    {
      this->unitAccession_ = x;
    }

    void CVParamType::
    unitAccession (::std::unique_ptr< unitAccession_type > x)
    {
      this->unitAccession_.set (std::move (x));
    }

    const CVParamType::unitName_optional& CVParamType::
    unitName () const
    {
      return this->unitName_;
    }

    CVParamType::unitName_optional& CVParamType::
    unitName ()
    {
      return this->unitName_;
    }

    void CVParamType::
    unitName (const unitName_type& x)
    {
      this->unitName_.set (x);
    }

    void CVParamType::
    unitName (const unitName_optional& x)
    {
      this->unitName_ = x;
    }

    void CVParamType::
    unitName (::std::unique_ptr< unitName_type > x)
    {
      this->unitName_.set (std::move (x));
    }

    const CVParamType::unitCvRef_optional& CVParamType::
    unitCvRef () const
    {
      return this->unitCvRef_;
    }

    CVParamType::unitCvRef_optional& CVParamType::
    unitCvRef ()
    {
      return this->unitCvRef_;
    }

    void CVParamType::
    unitCvRef (const unitCvRef_type& x)
    {
      this->unitCvRef_.set (x);
    }

    void CVParamType::
    unitCvRef (const unitCvRef_optional& x)
    {
      this->unitCvRef_ = x;
    }

    void CVParamType::
    unitCvRef (::std::unique_ptr< unitCvRef_type > x)
    {
      this->unitCvRef_.set (std::move (x));
    }


    // UserParamType
    // 

    const UserParamType::name_type& UserParamType::
    name () const
    {
      return this->name_.get ();
    }

    UserParamType::name_type& UserParamType::
    name ()
    {
      return this->name_.get ();
    }

    void UserParamType::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void UserParamType::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const UserParamType::type_optional& UserParamType::
    type () const
    {
      return this->type_;
    }

    UserParamType::type_optional& UserParamType::
    type ()
    {
      return this->type_;
    }

    void UserParamType::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void UserParamType::
    type (const type_optional& x)
    {
      this->type_ = x;
    }

    void UserParamType::
    type (::std::unique_ptr< type_type > x)
    {
      this->type_.set (std::move (x));
    }

    const UserParamType::value_optional& UserParamType::
    value () const
    {
      return this->value_;
    }

    UserParamType::value_optional& UserParamType::
    value ()
    {
      return this->value_;
    }

    void UserParamType::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void UserParamType::
    value (const value_optional& x)
    {
      this->value_ = x;
    }

    void UserParamType::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    const UserParamType::unitAccession_optional& UserParamType::
    unitAccession () const
    {
      return this->unitAccession_;
    }

    UserParamType::unitAccession_optional& UserParamType::
    unitAccession ()
    {
      return this->unitAccession_;
    }

    void UserParamType::
    unitAccession (const unitAccession_type& x)
    {
      this->unitAccession_.set (x);
    }

    void UserParamType::
    unitAccession (const unitAccession_optional& x)
    {
      this->unitAccession_ = x;
    }

    void UserParamType::
    unitAccession (::std::unique_ptr< unitAccession_type > x)
    {
      this->unitAccession_.set (std::move (x));
    }

    const UserParamType::unitName_optional& UserParamType::
    unitName () const
    {
      return this->unitName_;
    }

    UserParamType::unitName_optional& UserParamType::
    unitName ()
    {
      return this->unitName_;
    }

    void UserParamType::
    unitName (const unitName_type& x)
    {
      this->unitName_.set (x);
    }

    void UserParamType::
    unitName (const unitName_optional& x)
    {
      this->unitName_ = x;
    }

    void UserParamType::
    unitName (::std::unique_ptr< unitName_type > x)
    {
      this->unitName_.set (std::move (x));
    }

    const UserParamType::unitCvRef_optional& UserParamType::
    unitCvRef () const
    {
      return this->unitCvRef_;
    }

    UserParamType::unitCvRef_optional& UserParamType::
    unitCvRef ()
    {
      return this->unitCvRef_;
    }

    void UserParamType::
    unitCvRef (const unitCvRef_type& x)
    {
      this->unitCvRef_.set (x);
    }

    void UserParamType::
    unitCvRef (const unitCvRef_optional& x)
    {
      this->unitCvRef_ = x;
    }

    void UserParamType::
    unitCvRef (::std::unique_ptr< unitCvRef_type > x)
    {
      this->unitCvRef_.set (std::move (x));
    }


    // ReferenceableParamGroupRefType
    // 

    const ReferenceableParamGroupRefType::ref_type& ReferenceableParamGroupRefType::
    ref () const
    {
      return this->ref_.get ();
    }

    ReferenceableParamGroupRefType::ref_type& ReferenceableParamGroupRefType::
    ref ()
    {
      return this->ref_.get ();
    }

    void ReferenceableParamGroupRefType::
    ref (const ref_type& x)
    {
      this->ref_.set (x);
    }

    void ReferenceableParamGroupRefType::
    ref (::std::unique_ptr< ref_type > x)
    {
      this->ref_.set (std::move (x));
    }


    // SampleListType
    // 

    const SampleListType::sample_sequence& SampleListType::
    sample () const
    {
      return this->sample_;
    }

    SampleListType::sample_sequence& SampleListType::
    sample ()
    {
      return this->sample_;
    }

    void SampleListType::
    sample (const sample_sequence& s)
    {
      this->sample_ = s;
    }

    const SampleListType::count_type& SampleListType::
    count () const
    {
      return this->count_.get ();
    }

    SampleListType::count_type& SampleListType::
    count ()
    {
      return this->count_.get ();
    }

    void SampleListType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }


    // SampleType
    // 

    const SampleType::id_type& SampleType::
    id () const
    {
      return this->id_.get ();
    }

    SampleType::id_type& SampleType::
    id ()
    {
      return this->id_.get ();
    }

    void SampleType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void SampleType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const SampleType::name_optional& SampleType::
    name () const
    {
      return this->name_;
    }

    SampleType::name_optional& SampleType::
    name ()
    {
      return this->name_;
    }

    void SampleType::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void SampleType::
    name (const name_optional& x)
    {
      this->name_ = x;
    }

    void SampleType::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }


    // InstrumentConfigurationListType
    // 

    const InstrumentConfigurationListType::instrumentConfiguration_sequence& InstrumentConfigurationListType::
    instrumentConfiguration () const
    {
      return this->instrumentConfiguration_;
    }

    InstrumentConfigurationListType::instrumentConfiguration_sequence& InstrumentConfigurationListType::
    instrumentConfiguration ()
    {
      return this->instrumentConfiguration_;
    }

    void InstrumentConfigurationListType::
    instrumentConfiguration (const instrumentConfiguration_sequence& s)
    {
      this->instrumentConfiguration_ = s;
    }

    const InstrumentConfigurationListType::count_type& InstrumentConfigurationListType::
    count () const
    {
      return this->count_.get ();
    }

    InstrumentConfigurationListType::count_type& InstrumentConfigurationListType::
    count ()
    {
      return this->count_.get ();
    }

    void InstrumentConfigurationListType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }


    // ComponentType
    // 

    const ComponentType::order_type& ComponentType::
    order () const
    {
      return this->order_.get ();
    }

    ComponentType::order_type& ComponentType::
    order ()
    {
      return this->order_.get ();
    }

    void ComponentType::
    order (const order_type& x)
    {
      this->order_.set (x);
    }


    // SourceComponentType
    // 


    // DetectorComponentType
    // 


    // AnalyzerComponentType
    // 


    // ComponentListType
    // 

    const ComponentListType::source_sequence& ComponentListType::
    source () const
    {
      return this->source_;
    }

    ComponentListType::source_sequence& ComponentListType::
    source ()
    {
      return this->source_;
    }

    void ComponentListType::
    source (const source_sequence& s)
    {
      this->source_ = s;
    }

    const ComponentListType::analyzer_sequence& ComponentListType::
    analyzer () const
    {
      return this->analyzer_;
    }

    ComponentListType::analyzer_sequence& ComponentListType::
    analyzer ()
    {
      return this->analyzer_;
    }

    void ComponentListType::
    analyzer (const analyzer_sequence& s)
    {
      this->analyzer_ = s;
    }

    const ComponentListType::detector_sequence& ComponentListType::
    detector () const
    {
      return this->detector_;
    }

    ComponentListType::detector_sequence& ComponentListType::
    detector ()
    {
      return this->detector_;
    }

    void ComponentListType::
    detector (const detector_sequence& s)
    {
      this->detector_ = s;
    }

    const ComponentListType::count_type& ComponentListType::
    count () const
    {
      return this->count_.get ();
    }

    ComponentListType::count_type& ComponentListType::
    count ()
    {
      return this->count_.get ();
    }

    void ComponentListType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }


    // InstrumentConfigurationType
    // 

    const InstrumentConfigurationType::componentList_optional& InstrumentConfigurationType::
    componentList () const
    {
      return this->componentList_;
    }

    InstrumentConfigurationType::componentList_optional& InstrumentConfigurationType::
    componentList ()
    {
      return this->componentList_;
    }

    void InstrumentConfigurationType::
    componentList (const componentList_type& x)
    {
      this->componentList_.set (x);
    }

    void InstrumentConfigurationType::
    componentList (const componentList_optional& x)
    {
      this->componentList_ = x;
    }

    void InstrumentConfigurationType::
    componentList (::std::unique_ptr< componentList_type > x)
    {
      this->componentList_.set (std::move (x));
    }

    const InstrumentConfigurationType::softwareRef_optional& InstrumentConfigurationType::
    softwareRef () const
    {
      return this->softwareRef_;
    }

    InstrumentConfigurationType::softwareRef_optional& InstrumentConfigurationType::
    softwareRef ()
    {
      return this->softwareRef_;
    }

    void InstrumentConfigurationType::
    softwareRef (const softwareRef_type& x)
    {
      this->softwareRef_.set (x);
    }

    void InstrumentConfigurationType::
    softwareRef (const softwareRef_optional& x)
    {
      this->softwareRef_ = x;
    }

    void InstrumentConfigurationType::
    softwareRef (::std::unique_ptr< softwareRef_type > x)
    {
      this->softwareRef_.set (std::move (x));
    }

    const InstrumentConfigurationType::id_type& InstrumentConfigurationType::
    id () const
    {
      return this->id_.get ();
    }

    InstrumentConfigurationType::id_type& InstrumentConfigurationType::
    id ()
    {
      return this->id_.get ();
    }

    void InstrumentConfigurationType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void InstrumentConfigurationType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const InstrumentConfigurationType::scanSettingsRef_optional& InstrumentConfigurationType::
    scanSettingsRef () const
    {
      return this->scanSettingsRef_;
    }

    InstrumentConfigurationType::scanSettingsRef_optional& InstrumentConfigurationType::
    scanSettingsRef ()
    {
      return this->scanSettingsRef_;
    }

    void InstrumentConfigurationType::
    scanSettingsRef (const scanSettingsRef_type& x)
    {
      this->scanSettingsRef_.set (x);
    }

    void InstrumentConfigurationType::
    scanSettingsRef (const scanSettingsRef_optional& x)
    {
      this->scanSettingsRef_ = x;
    }

    void InstrumentConfigurationType::
    scanSettingsRef (::std::unique_ptr< scanSettingsRef_type > x)
    {
      this->scanSettingsRef_.set (std::move (x));
    }


    // SoftwareRefType
    // 

    const SoftwareRefType::ref_type& SoftwareRefType::
    ref () const
    {
      return this->ref_.get ();
    }

    SoftwareRefType::ref_type& SoftwareRefType::
    ref ()
    {
      return this->ref_.get ();
    }

    void SoftwareRefType::
    ref (const ref_type& x)
    {
      this->ref_.set (x);
    }

    void SoftwareRefType::
    ref (::std::unique_ptr< ref_type > x)
    {
      this->ref_.set (std::move (x));
    }


    // SoftwareListType
    // 

    const SoftwareListType::software_sequence& SoftwareListType::
    software () const
    {
      return this->software_;
    }

    SoftwareListType::software_sequence& SoftwareListType::
    software ()
    {
      return this->software_;
    }

    void SoftwareListType::
    software (const software_sequence& s)
    {
      this->software_ = s;
    }

    const SoftwareListType::count_type& SoftwareListType::
    count () const
    {
      return this->count_.get ();
    }

    SoftwareListType::count_type& SoftwareListType::
    count ()
    {
      return this->count_.get ();
    }

    void SoftwareListType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }


    // SoftwareType
    // 

    const SoftwareType::id_type& SoftwareType::
    id () const
    {
      return this->id_.get ();
    }

    SoftwareType::id_type& SoftwareType::
    id ()
    {
      return this->id_.get ();
    }

    void SoftwareType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void SoftwareType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const SoftwareType::version_type& SoftwareType::
    version () const
    {
      return this->version_.get ();
    }

    SoftwareType::version_type& SoftwareType::
    version ()
    {
      return this->version_.get ();
    }

    void SoftwareType::
    version (const version_type& x)
    {
      this->version_.set (x);
    }

    void SoftwareType::
    version (::std::unique_ptr< version_type > x)
    {
      this->version_.set (std::move (x));
    }


    // DataProcessingListType
    // 

    const DataProcessingListType::dataProcessing_sequence& DataProcessingListType::
    dataProcessing () const
    {
      return this->dataProcessing_;
    }

    DataProcessingListType::dataProcessing_sequence& DataProcessingListType::
    dataProcessing ()
    {
      return this->dataProcessing_;
    }

    void DataProcessingListType::
    dataProcessing (const dataProcessing_sequence& s)
    {
      this->dataProcessing_ = s;
    }

    const DataProcessingListType::count_type& DataProcessingListType::
    count () const
    {
      return this->count_.get ();
    }

    DataProcessingListType::count_type& DataProcessingListType::
    count ()
    {
      return this->count_.get ();
    }

    void DataProcessingListType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }


    // DataProcessingType
    // 

    const DataProcessingType::processingMethod_sequence& DataProcessingType::
    processingMethod () const
    {
      return this->processingMethod_;
    }

    DataProcessingType::processingMethod_sequence& DataProcessingType::
    processingMethod ()
    {
      return this->processingMethod_;
    }

    void DataProcessingType::
    processingMethod (const processingMethod_sequence& s)
    {
      this->processingMethod_ = s;
    }

    const DataProcessingType::id_type& DataProcessingType::
    id () const
    {
      return this->id_.get ();
    }

    DataProcessingType::id_type& DataProcessingType::
    id ()
    {
      return this->id_.get ();
    }

    void DataProcessingType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void DataProcessingType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // ProcessingMethodType
    // 

    const ProcessingMethodType::order_type& ProcessingMethodType::
    order () const
    {
      return this->order_.get ();
    }

    ProcessingMethodType::order_type& ProcessingMethodType::
    order ()
    {
      return this->order_.get ();
    }

    void ProcessingMethodType::
    order (const order_type& x)
    {
      this->order_.set (x);
    }

    const ProcessingMethodType::softwareRef_type& ProcessingMethodType::
    softwareRef () const
    {
      return this->softwareRef_.get ();
    }

    ProcessingMethodType::softwareRef_type& ProcessingMethodType::
    softwareRef ()
    {
      return this->softwareRef_.get ();
    }

    void ProcessingMethodType::
    softwareRef (const softwareRef_type& x)
    {
      this->softwareRef_.set (x);
    }

    void ProcessingMethodType::
    softwareRef (::std::unique_ptr< softwareRef_type > x)
    {
      this->softwareRef_.set (std::move (x));
    }


    // ScanSettingsListType
    // 

    const ScanSettingsListType::scanSettings_sequence& ScanSettingsListType::
    scanSettings () const
    {
      return this->scanSettings_;
    }

    ScanSettingsListType::scanSettings_sequence& ScanSettingsListType::
    scanSettings ()
    {
      return this->scanSettings_;
    }

    void ScanSettingsListType::
    scanSettings (const scanSettings_sequence& s)
    {
      this->scanSettings_ = s;
    }

    const ScanSettingsListType::count_type& ScanSettingsListType::
    count () const
    {
      return this->count_.get ();
    }

    ScanSettingsListType::count_type& ScanSettingsListType::
    count ()
    {
      return this->count_.get ();
    }

    void ScanSettingsListType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }


    // ScanSettingsType
    // 

    const ScanSettingsType::sourceFileRefList_optional& ScanSettingsType::
    sourceFileRefList () const
    {
      return this->sourceFileRefList_;
    }

    ScanSettingsType::sourceFileRefList_optional& ScanSettingsType::
    sourceFileRefList ()
    {
      return this->sourceFileRefList_;
    }

    void ScanSettingsType::
    sourceFileRefList (const sourceFileRefList_type& x)
    {
      this->sourceFileRefList_.set (x);
    }

    void ScanSettingsType::
    sourceFileRefList (const sourceFileRefList_optional& x)
    {
      this->sourceFileRefList_ = x;
    }

    void ScanSettingsType::
    sourceFileRefList (::std::unique_ptr< sourceFileRefList_type > x)
    {
      this->sourceFileRefList_.set (std::move (x));
    }

    const ScanSettingsType::targetList_optional& ScanSettingsType::
    targetList () const
    {
      return this->targetList_;
    }

    ScanSettingsType::targetList_optional& ScanSettingsType::
    targetList ()
    {
      return this->targetList_;
    }

    void ScanSettingsType::
    targetList (const targetList_type& x)
    {
      this->targetList_.set (x);
    }

    void ScanSettingsType::
    targetList (const targetList_optional& x)
    {
      this->targetList_ = x;
    }

    void ScanSettingsType::
    targetList (::std::unique_ptr< targetList_type > x)
    {
      this->targetList_.set (std::move (x));
    }

    const ScanSettingsType::id_type& ScanSettingsType::
    id () const
    {
      return this->id_.get ();
    }

    ScanSettingsType::id_type& ScanSettingsType::
    id ()
    {
      return this->id_.get ();
    }

    void ScanSettingsType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void ScanSettingsType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // TargetListType
    // 

    const TargetListType::target_sequence& TargetListType::
    target () const
    {
      return this->target_;
    }

    TargetListType::target_sequence& TargetListType::
    target ()
    {
      return this->target_;
    }

    void TargetListType::
    target (const target_sequence& s)
    {
      this->target_ = s;
    }

    const TargetListType::count_type& TargetListType::
    count () const
    {
      return this->count_.get ();
    }

    TargetListType::count_type& TargetListType::
    count ()
    {
      return this->count_.get ();
    }

    void TargetListType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }


    // RunType
    // 

    const RunType::spectrumList_optional& RunType::
    spectrumList () const
    {
      return this->spectrumList_;
    }

    RunType::spectrumList_optional& RunType::
    spectrumList ()
    {
      return this->spectrumList_;
    }

    void RunType::
    spectrumList (const spectrumList_type& x)
    {
      this->spectrumList_.set (x);
    }

    void RunType::
    spectrumList (const spectrumList_optional& x)
    {
      this->spectrumList_ = x;
    }

    void RunType::
    spectrumList (::std::unique_ptr< spectrumList_type > x)
    {
      this->spectrumList_.set (std::move (x));
    }

    const RunType::chromatogramList_optional& RunType::
    chromatogramList () const
    {
      return this->chromatogramList_;
    }

    RunType::chromatogramList_optional& RunType::
    chromatogramList ()
    {
      return this->chromatogramList_;
    }

    void RunType::
    chromatogramList (const chromatogramList_type& x)
    {
      this->chromatogramList_.set (x);
    }

    void RunType::
    chromatogramList (const chromatogramList_optional& x)
    {
      this->chromatogramList_ = x;
    }

    void RunType::
    chromatogramList (::std::unique_ptr< chromatogramList_type > x)
    {
      this->chromatogramList_.set (std::move (x));
    }

    const RunType::id_type& RunType::
    id () const
    {
      return this->id_.get ();
    }

    RunType::id_type& RunType::
    id ()
    {
      return this->id_.get ();
    }

    void RunType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void RunType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const RunType::defaultInstrumentConfigurationRef_type& RunType::
    defaultInstrumentConfigurationRef () const
    {
      return this->defaultInstrumentConfigurationRef_.get ();
    }

    RunType::defaultInstrumentConfigurationRef_type& RunType::
    defaultInstrumentConfigurationRef ()
    {
      return this->defaultInstrumentConfigurationRef_.get ();
    }

    void RunType::
    defaultInstrumentConfigurationRef (const defaultInstrumentConfigurationRef_type& x)
    {
      this->defaultInstrumentConfigurationRef_.set (x);
    }

    void RunType::
    defaultInstrumentConfigurationRef (::std::unique_ptr< defaultInstrumentConfigurationRef_type > x)
    {
      this->defaultInstrumentConfigurationRef_.set (std::move (x));
    }

    const RunType::defaultSourceFileRef_optional& RunType::
    defaultSourceFileRef () const
    {
      return this->defaultSourceFileRef_;
    }

    RunType::defaultSourceFileRef_optional& RunType::
    defaultSourceFileRef ()
    {
      return this->defaultSourceFileRef_;
    }

    void RunType::
    defaultSourceFileRef (const defaultSourceFileRef_type& x)
    {
      this->defaultSourceFileRef_.set (x);
    }

    void RunType::
    defaultSourceFileRef (const defaultSourceFileRef_optional& x)
    {
      this->defaultSourceFileRef_ = x;
    }

    void RunType::
    defaultSourceFileRef (::std::unique_ptr< defaultSourceFileRef_type > x)
    {
      this->defaultSourceFileRef_.set (std::move (x));
    }

    const RunType::sampleRef_optional& RunType::
    sampleRef () const
    {
      return this->sampleRef_;
    }

    RunType::sampleRef_optional& RunType::
    sampleRef ()
    {
      return this->sampleRef_;
    }

    void RunType::
    sampleRef (const sampleRef_type& x)
    {
      this->sampleRef_.set (x);
    }

    void RunType::
    sampleRef (const sampleRef_optional& x)
    {
      this->sampleRef_ = x;
    }

    void RunType::
    sampleRef (::std::unique_ptr< sampleRef_type > x)
    {
      this->sampleRef_.set (std::move (x));
    }

    const RunType::startTimeStamp_optional& RunType::
    startTimeStamp () const
    {
      return this->startTimeStamp_;
    }

    RunType::startTimeStamp_optional& RunType::
    startTimeStamp ()
    {
      return this->startTimeStamp_;
    }

    void RunType::
    startTimeStamp (const startTimeStamp_type& x)
    {
      this->startTimeStamp_.set (x);
    }

    void RunType::
    startTimeStamp (const startTimeStamp_optional& x)
    {
      this->startTimeStamp_ = x;
    }

    void RunType::
    startTimeStamp (::std::unique_ptr< startTimeStamp_type > x)
    {
      this->startTimeStamp_.set (std::move (x));
    }


    // SourceFileRefType
    // 

    const SourceFileRefType::ref_type& SourceFileRefType::
    ref () const
    {
      return this->ref_.get ();
    }

    SourceFileRefType::ref_type& SourceFileRefType::
    ref ()
    {
      return this->ref_.get ();
    }

    void SourceFileRefType::
    ref (const ref_type& x)
    {
      this->ref_.set (x);
    }

    void SourceFileRefType::
    ref (::std::unique_ptr< ref_type > x)
    {
      this->ref_.set (std::move (x));
    }


    // SourceFileRefListType
    // 

    const SourceFileRefListType::sourceFileRef_sequence& SourceFileRefListType::
    sourceFileRef () const
    {
      return this->sourceFileRef_;
    }

    SourceFileRefListType::sourceFileRef_sequence& SourceFileRefListType::
    sourceFileRef ()
    {
      return this->sourceFileRef_;
    }

    void SourceFileRefListType::
    sourceFileRef (const sourceFileRef_sequence& s)
    {
      this->sourceFileRef_ = s;
    }

    const SourceFileRefListType::count_type& SourceFileRefListType::
    count () const
    {
      return this->count_.get ();
    }

    SourceFileRefListType::count_type& SourceFileRefListType::
    count ()
    {
      return this->count_.get ();
    }

    void SourceFileRefListType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }


    // SpectrumListType
    // 

    const SpectrumListType::spectrum_sequence& SpectrumListType::
    spectrum () const
    {
      return this->spectrum_;
    }

    SpectrumListType::spectrum_sequence& SpectrumListType::
    spectrum ()
    {
      return this->spectrum_;
    }

    void SpectrumListType::
    spectrum (const spectrum_sequence& s)
    {
      this->spectrum_ = s;
    }

    const SpectrumListType::count_type& SpectrumListType::
    count () const
    {
      return this->count_.get ();
    }

    SpectrumListType::count_type& SpectrumListType::
    count ()
    {
      return this->count_.get ();
    }

    void SpectrumListType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }

    const SpectrumListType::defaultDataProcessingRef_type& SpectrumListType::
    defaultDataProcessingRef () const
    {
      return this->defaultDataProcessingRef_.get ();
    }

    SpectrumListType::defaultDataProcessingRef_type& SpectrumListType::
    defaultDataProcessingRef ()
    {
      return this->defaultDataProcessingRef_.get ();
    }

    void SpectrumListType::
    defaultDataProcessingRef (const defaultDataProcessingRef_type& x)
    {
      this->defaultDataProcessingRef_.set (x);
    }

    void SpectrumListType::
    defaultDataProcessingRef (::std::unique_ptr< defaultDataProcessingRef_type > x)
    {
      this->defaultDataProcessingRef_.set (std::move (x));
    }


    // ScanWindowListType
    // 

    const ScanWindowListType::scanWindow_sequence& ScanWindowListType::
    scanWindow () const
    {
      return this->scanWindow_;
    }

    ScanWindowListType::scanWindow_sequence& ScanWindowListType::
    scanWindow ()
    {
      return this->scanWindow_;
    }

    void ScanWindowListType::
    scanWindow (const scanWindow_sequence& s)
    {
      this->scanWindow_ = s;
    }

    const ScanWindowListType::count_type& ScanWindowListType::
    count () const
    {
      return this->count_.get ();
    }

    ScanWindowListType::count_type& ScanWindowListType::
    count ()
    {
      return this->count_.get ();
    }

    void ScanWindowListType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }


    // ScanListType
    // 

    const ScanListType::scan_sequence& ScanListType::
    scan () const
    {
      return this->scan_;
    }

    ScanListType::scan_sequence& ScanListType::
    scan ()
    {
      return this->scan_;
    }

    void ScanListType::
    scan (const scan_sequence& s)
    {
      this->scan_ = s;
    }

    const ScanListType::count_type& ScanListType::
    count () const
    {
      return this->count_.get ();
    }

    ScanListType::count_type& ScanListType::
    count ()
    {
      return this->count_.get ();
    }

    void ScanListType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }


    // ScanType
    // 

    const ScanType::scanWindowList_optional& ScanType::
    scanWindowList () const
    {
      return this->scanWindowList_;
    }

    ScanType::scanWindowList_optional& ScanType::
    scanWindowList ()
    {
      return this->scanWindowList_;
    }

    void ScanType::
    scanWindowList (const scanWindowList_type& x)
    {
      this->scanWindowList_.set (x);
    }

    void ScanType::
    scanWindowList (const scanWindowList_optional& x)
    {
      this->scanWindowList_ = x;
    }

    void ScanType::
    scanWindowList (::std::unique_ptr< scanWindowList_type > x)
    {
      this->scanWindowList_.set (std::move (x));
    }

    const ScanType::spectrumRef_optional& ScanType::
    spectrumRef () const
    {
      return this->spectrumRef_;
    }

    ScanType::spectrumRef_optional& ScanType::
    spectrumRef ()
    {
      return this->spectrumRef_;
    }

    void ScanType::
    spectrumRef (const spectrumRef_type& x)
    {
      this->spectrumRef_.set (x);
    }

    void ScanType::
    spectrumRef (const spectrumRef_optional& x)
    {
      this->spectrumRef_ = x;
    }

    void ScanType::
    spectrumRef (::std::unique_ptr< spectrumRef_type > x)
    {
      this->spectrumRef_.set (std::move (x));
    }

    const ScanType::sourceFileRef_optional& ScanType::
    sourceFileRef () const
    {
      return this->sourceFileRef_;
    }

    ScanType::sourceFileRef_optional& ScanType::
    sourceFileRef ()
    {
      return this->sourceFileRef_;
    }

    void ScanType::
    sourceFileRef (const sourceFileRef_type& x)
    {
      this->sourceFileRef_.set (x);
    }

    void ScanType::
    sourceFileRef (const sourceFileRef_optional& x)
    {
      this->sourceFileRef_ = x;
    }

    void ScanType::
    sourceFileRef (::std::unique_ptr< sourceFileRef_type > x)
    {
      this->sourceFileRef_.set (std::move (x));
    }

    const ScanType::externalSpectrumID_optional& ScanType::
    externalSpectrumID () const
    {
      return this->externalSpectrumID_;
    }

    ScanType::externalSpectrumID_optional& ScanType::
    externalSpectrumID ()
    {
      return this->externalSpectrumID_;
    }

    void ScanType::
    externalSpectrumID (const externalSpectrumID_type& x)
    {
      this->externalSpectrumID_.set (x);
    }

    void ScanType::
    externalSpectrumID (const externalSpectrumID_optional& x)
    {
      this->externalSpectrumID_ = x;
    }

    void ScanType::
    externalSpectrumID (::std::unique_ptr< externalSpectrumID_type > x)
    {
      this->externalSpectrumID_.set (std::move (x));
    }

    const ScanType::instrumentConfigurationRef_optional& ScanType::
    instrumentConfigurationRef () const
    {
      return this->instrumentConfigurationRef_;
    }

    ScanType::instrumentConfigurationRef_optional& ScanType::
    instrumentConfigurationRef ()
    {
      return this->instrumentConfigurationRef_;
    }

    void ScanType::
    instrumentConfigurationRef (const instrumentConfigurationRef_type& x)
    {
      this->instrumentConfigurationRef_.set (x);
    }

    void ScanType::
    instrumentConfigurationRef (const instrumentConfigurationRef_optional& x)
    {
      this->instrumentConfigurationRef_ = x;
    }

    void ScanType::
    instrumentConfigurationRef (::std::unique_ptr< instrumentConfigurationRef_type > x)
    {
      this->instrumentConfigurationRef_.set (std::move (x));
    }


    // PrecursorListType
    // 

    const PrecursorListType::precursor_sequence& PrecursorListType::
    precursor () const
    {
      return this->precursor_;
    }

    PrecursorListType::precursor_sequence& PrecursorListType::
    precursor ()
    {
      return this->precursor_;
    }

    void PrecursorListType::
    precursor (const precursor_sequence& s)
    {
      this->precursor_ = s;
    }

    const PrecursorListType::count_type& PrecursorListType::
    count () const
    {
      return this->count_.get ();
    }

    PrecursorListType::count_type& PrecursorListType::
    count ()
    {
      return this->count_.get ();
    }

    void PrecursorListType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }


    // PrecursorType
    // 

    const PrecursorType::isolationWindow_optional& PrecursorType::
    isolationWindow () const
    {
      return this->isolationWindow_;
    }

    PrecursorType::isolationWindow_optional& PrecursorType::
    isolationWindow ()
    {
      return this->isolationWindow_;
    }

    void PrecursorType::
    isolationWindow (const isolationWindow_type& x)
    {
      this->isolationWindow_.set (x);
    }

    void PrecursorType::
    isolationWindow (const isolationWindow_optional& x)
    {
      this->isolationWindow_ = x;
    }

    void PrecursorType::
    isolationWindow (::std::unique_ptr< isolationWindow_type > x)
    {
      this->isolationWindow_.set (std::move (x));
    }

    const PrecursorType::selectedIonList_optional& PrecursorType::
    selectedIonList () const
    {
      return this->selectedIonList_;
    }

    PrecursorType::selectedIonList_optional& PrecursorType::
    selectedIonList ()
    {
      return this->selectedIonList_;
    }

    void PrecursorType::
    selectedIonList (const selectedIonList_type& x)
    {
      this->selectedIonList_.set (x);
    }

    void PrecursorType::
    selectedIonList (const selectedIonList_optional& x)
    {
      this->selectedIonList_ = x;
    }

    void PrecursorType::
    selectedIonList (::std::unique_ptr< selectedIonList_type > x)
    {
      this->selectedIonList_.set (std::move (x));
    }

    const PrecursorType::activation_type& PrecursorType::
    activation () const
    {
      return this->activation_.get ();
    }

    PrecursorType::activation_type& PrecursorType::
    activation ()
    {
      return this->activation_.get ();
    }

    void PrecursorType::
    activation (const activation_type& x)
    {
      this->activation_.set (x);
    }

    void PrecursorType::
    activation (::std::unique_ptr< activation_type > x)
    {
      this->activation_.set (std::move (x));
    }

    const PrecursorType::spectrumRef_optional& PrecursorType::
    spectrumRef () const
    {
      return this->spectrumRef_;
    }

    PrecursorType::spectrumRef_optional& PrecursorType::
    spectrumRef ()
    {
      return this->spectrumRef_;
    }

    void PrecursorType::
    spectrumRef (const spectrumRef_type& x)
    {
      this->spectrumRef_.set (x);
    }

    void PrecursorType::
    spectrumRef (const spectrumRef_optional& x)
    {
      this->spectrumRef_ = x;
    }

    void PrecursorType::
    spectrumRef (::std::unique_ptr< spectrumRef_type > x)
    {
      this->spectrumRef_.set (std::move (x));
    }

    const PrecursorType::sourceFileRef_optional& PrecursorType::
    sourceFileRef () const
    {
      return this->sourceFileRef_;
    }

    PrecursorType::sourceFileRef_optional& PrecursorType::
    sourceFileRef ()
    {
      return this->sourceFileRef_;
    }

    void PrecursorType::
    sourceFileRef (const sourceFileRef_type& x)
    {
      this->sourceFileRef_.set (x);
    }

    void PrecursorType::
    sourceFileRef (const sourceFileRef_optional& x)
    {
      this->sourceFileRef_ = x;
    }

    void PrecursorType::
    sourceFileRef (::std::unique_ptr< sourceFileRef_type > x)
    {
      this->sourceFileRef_.set (std::move (x));
    }

    const PrecursorType::externalSpectrumID_optional& PrecursorType::
    externalSpectrumID () const
    {
      return this->externalSpectrumID_;
    }

    PrecursorType::externalSpectrumID_optional& PrecursorType::
    externalSpectrumID ()
    {
      return this->externalSpectrumID_;
    }

    void PrecursorType::
    externalSpectrumID (const externalSpectrumID_type& x)
    {
      this->externalSpectrumID_.set (x);
    }

    void PrecursorType::
    externalSpectrumID (const externalSpectrumID_optional& x)
    {
      this->externalSpectrumID_ = x;
    }

    void PrecursorType::
    externalSpectrumID (::std::unique_ptr< externalSpectrumID_type > x)
    {
      this->externalSpectrumID_.set (std::move (x));
    }


    // SelectedIonListType
    // 

    const SelectedIonListType::selectedIon_sequence& SelectedIonListType::
    selectedIon () const
    {
      return this->selectedIon_;
    }

    SelectedIonListType::selectedIon_sequence& SelectedIonListType::
    selectedIon ()
    {
      return this->selectedIon_;
    }

    void SelectedIonListType::
    selectedIon (const selectedIon_sequence& s)
    {
      this->selectedIon_ = s;
    }

    const SelectedIonListType::count_type& SelectedIonListType::
    count () const
    {
      return this->count_.get ();
    }

    SelectedIonListType::count_type& SelectedIonListType::
    count ()
    {
      return this->count_.get ();
    }

    void SelectedIonListType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }


    // ProductListType
    // 

    const ProductListType::product_sequence& ProductListType::
    product () const
    {
      return this->product_;
    }

    ProductListType::product_sequence& ProductListType::
    product ()
    {
      return this->product_;
    }

    void ProductListType::
    product (const product_sequence& s)
    {
      this->product_ = s;
    }

    const ProductListType::count_type& ProductListType::
    count () const
    {
      return this->count_.get ();
    }

    ProductListType::count_type& ProductListType::
    count ()
    {
      return this->count_.get ();
    }

    void ProductListType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }


    // ProductType
    // 

    const ProductType::isolationWindow_optional& ProductType::
    isolationWindow () const
    {
      return this->isolationWindow_;
    }

    ProductType::isolationWindow_optional& ProductType::
    isolationWindow ()
    {
      return this->isolationWindow_;
    }

    void ProductType::
    isolationWindow (const isolationWindow_type& x)
    {
      this->isolationWindow_.set (x);
    }

    void ProductType::
    isolationWindow (const isolationWindow_optional& x)
    {
      this->isolationWindow_ = x;
    }

    void ProductType::
    isolationWindow (::std::unique_ptr< isolationWindow_type > x)
    {
      this->isolationWindow_.set (std::move (x));
    }


    // BinaryDataArrayListType
    // 

    const BinaryDataArrayListType::binaryDataArray_sequence& BinaryDataArrayListType::
    binaryDataArray () const
    {
      return this->binaryDataArray_;
    }

    BinaryDataArrayListType::binaryDataArray_sequence& BinaryDataArrayListType::
    binaryDataArray ()
    {
      return this->binaryDataArray_;
    }

    void BinaryDataArrayListType::
    binaryDataArray (const binaryDataArray_sequence& s)
    {
      this->binaryDataArray_ = s;
    }

    const BinaryDataArrayListType::count_type& BinaryDataArrayListType::
    count () const
    {
      return this->count_.get ();
    }

    BinaryDataArrayListType::count_type& BinaryDataArrayListType::
    count ()
    {
      return this->count_.get ();
    }

    void BinaryDataArrayListType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }


    // BinaryDataArrayType
    // 

    const BinaryDataArrayType::binary_type& BinaryDataArrayType::
    binary () const
    {
      return this->binary_.get ();
    }

    BinaryDataArrayType::binary_type& BinaryDataArrayType::
    binary ()
    {
      return this->binary_.get ();
    }

    void BinaryDataArrayType::
    binary (const binary_type& x)
    {
      this->binary_.set (x);
    }

    void BinaryDataArrayType::
    binary (::std::unique_ptr< binary_type > x)
    {
      this->binary_.set (std::move (x));
    }

    const BinaryDataArrayType::arrayLength_optional& BinaryDataArrayType::
    arrayLength () const
    {
      return this->arrayLength_;
    }

    BinaryDataArrayType::arrayLength_optional& BinaryDataArrayType::
    arrayLength ()
    {
      return this->arrayLength_;
    }

    void BinaryDataArrayType::
    arrayLength (const arrayLength_type& x)
    {
      this->arrayLength_.set (x);
    }

    void BinaryDataArrayType::
    arrayLength (const arrayLength_optional& x)
    {
      this->arrayLength_ = x;
    }

    const BinaryDataArrayType::dataProcessingRef_optional& BinaryDataArrayType::
    dataProcessingRef () const
    {
      return this->dataProcessingRef_;
    }

    BinaryDataArrayType::dataProcessingRef_optional& BinaryDataArrayType::
    dataProcessingRef ()
    {
      return this->dataProcessingRef_;
    }

    void BinaryDataArrayType::
    dataProcessingRef (const dataProcessingRef_type& x)
    {
      this->dataProcessingRef_.set (x);
    }

    void BinaryDataArrayType::
    dataProcessingRef (const dataProcessingRef_optional& x)
    {
      this->dataProcessingRef_ = x;
    }

    void BinaryDataArrayType::
    dataProcessingRef (::std::unique_ptr< dataProcessingRef_type > x)
    {
      this->dataProcessingRef_.set (std::move (x));
    }

    const BinaryDataArrayType::encodedLength_type& BinaryDataArrayType::
    encodedLength () const
    {
      return this->encodedLength_.get ();
    }

    BinaryDataArrayType::encodedLength_type& BinaryDataArrayType::
    encodedLength ()
    {
      return this->encodedLength_.get ();
    }

    void BinaryDataArrayType::
    encodedLength (const encodedLength_type& x)
    {
      this->encodedLength_.set (x);
    }


    // SpectrumType
    // 

    const SpectrumType::scanList_optional& SpectrumType::
    scanList () const
    {
      return this->scanList_;
    }

    SpectrumType::scanList_optional& SpectrumType::
    scanList ()
    {
      return this->scanList_;
    }

    void SpectrumType::
    scanList (const scanList_type& x)
    {
      this->scanList_.set (x);
    }

    void SpectrumType::
    scanList (const scanList_optional& x)
    {
      this->scanList_ = x;
    }

    void SpectrumType::
    scanList (::std::unique_ptr< scanList_type > x)
    {
      this->scanList_.set (std::move (x));
    }

    const SpectrumType::precursorList_optional& SpectrumType::
    precursorList () const
    {
      return this->precursorList_;
    }

    SpectrumType::precursorList_optional& SpectrumType::
    precursorList ()
    {
      return this->precursorList_;
    }

    void SpectrumType::
    precursorList (const precursorList_type& x)
    {
      this->precursorList_.set (x);
    }

    void SpectrumType::
    precursorList (const precursorList_optional& x)
    {
      this->precursorList_ = x;
    }

    void SpectrumType::
    precursorList (::std::unique_ptr< precursorList_type > x)
    {
      this->precursorList_.set (std::move (x));
    }

    const SpectrumType::productList_optional& SpectrumType::
    productList () const
    {
      return this->productList_;
    }

    SpectrumType::productList_optional& SpectrumType::
    productList ()
    {
      return this->productList_;
    }

    void SpectrumType::
    productList (const productList_type& x)
    {
      this->productList_.set (x);
    }

    void SpectrumType::
    productList (const productList_optional& x)
    {
      this->productList_ = x;
    }

    void SpectrumType::
    productList (::std::unique_ptr< productList_type > x)
    {
      this->productList_.set (std::move (x));
    }

    const SpectrumType::binaryDataArrayList_optional& SpectrumType::
    binaryDataArrayList () const
    {
      return this->binaryDataArrayList_;
    }

    SpectrumType::binaryDataArrayList_optional& SpectrumType::
    binaryDataArrayList ()
    {
      return this->binaryDataArrayList_;
    }

    void SpectrumType::
    binaryDataArrayList (const binaryDataArrayList_type& x)
    {
      this->binaryDataArrayList_.set (x);
    }

    void SpectrumType::
    binaryDataArrayList (const binaryDataArrayList_optional& x)
    {
      this->binaryDataArrayList_ = x;
    }

    void SpectrumType::
    binaryDataArrayList (::std::unique_ptr< binaryDataArrayList_type > x)
    {
      this->binaryDataArrayList_.set (std::move (x));
    }

    const SpectrumType::id_type& SpectrumType::
    id () const
    {
      return this->id_.get ();
    }

    SpectrumType::id_type& SpectrumType::
    id ()
    {
      return this->id_.get ();
    }

    void SpectrumType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void SpectrumType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const SpectrumType::spotID_optional& SpectrumType::
    spotID () const
    {
      return this->spotID_;
    }

    SpectrumType::spotID_optional& SpectrumType::
    spotID ()
    {
      return this->spotID_;
    }

    void SpectrumType::
    spotID (const spotID_type& x)
    {
      this->spotID_.set (x);
    }

    void SpectrumType::
    spotID (const spotID_optional& x)
    {
      this->spotID_ = x;
    }

    void SpectrumType::
    spotID (::std::unique_ptr< spotID_type > x)
    {
      this->spotID_.set (std::move (x));
    }

    const SpectrumType::index_type& SpectrumType::
    index () const
    {
      return this->index_.get ();
    }

    SpectrumType::index_type& SpectrumType::
    index ()
    {
      return this->index_.get ();
    }

    void SpectrumType::
    index (const index_type& x)
    {
      this->index_.set (x);
    }

    const SpectrumType::defaultArrayLength_type& SpectrumType::
    defaultArrayLength () const
    {
      return this->defaultArrayLength_.get ();
    }

    SpectrumType::defaultArrayLength_type& SpectrumType::
    defaultArrayLength ()
    {
      return this->defaultArrayLength_.get ();
    }

    void SpectrumType::
    defaultArrayLength (const defaultArrayLength_type& x)
    {
      this->defaultArrayLength_.set (x);
    }

    const SpectrumType::dataProcessingRef_optional& SpectrumType::
    dataProcessingRef () const
    {
      return this->dataProcessingRef_;
    }

    SpectrumType::dataProcessingRef_optional& SpectrumType::
    dataProcessingRef ()
    {
      return this->dataProcessingRef_;
    }

    void SpectrumType::
    dataProcessingRef (const dataProcessingRef_type& x)
    {
      this->dataProcessingRef_.set (x);
    }

    void SpectrumType::
    dataProcessingRef (const dataProcessingRef_optional& x)
    {
      this->dataProcessingRef_ = x;
    }

    void SpectrumType::
    dataProcessingRef (::std::unique_ptr< dataProcessingRef_type > x)
    {
      this->dataProcessingRef_.set (std::move (x));
    }

    const SpectrumType::sourceFileRef_optional& SpectrumType::
    sourceFileRef () const
    {
      return this->sourceFileRef_;
    }

    SpectrumType::sourceFileRef_optional& SpectrumType::
    sourceFileRef ()
    {
      return this->sourceFileRef_;
    }

    void SpectrumType::
    sourceFileRef (const sourceFileRef_type& x)
    {
      this->sourceFileRef_.set (x);
    }

    void SpectrumType::
    sourceFileRef (const sourceFileRef_optional& x)
    {
      this->sourceFileRef_ = x;
    }

    void SpectrumType::
    sourceFileRef (::std::unique_ptr< sourceFileRef_type > x)
    {
      this->sourceFileRef_.set (std::move (x));
    }


    // ChromatogramListType
    // 

    const ChromatogramListType::chromatogram_sequence& ChromatogramListType::
    chromatogram () const
    {
      return this->chromatogram_;
    }

    ChromatogramListType::chromatogram_sequence& ChromatogramListType::
    chromatogram ()
    {
      return this->chromatogram_;
    }

    void ChromatogramListType::
    chromatogram (const chromatogram_sequence& s)
    {
      this->chromatogram_ = s;
    }

    const ChromatogramListType::count_type& ChromatogramListType::
    count () const
    {
      return this->count_.get ();
    }

    ChromatogramListType::count_type& ChromatogramListType::
    count ()
    {
      return this->count_.get ();
    }

    void ChromatogramListType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }

    const ChromatogramListType::defaultDataProcessingRef_type& ChromatogramListType::
    defaultDataProcessingRef () const
    {
      return this->defaultDataProcessingRef_.get ();
    }

    ChromatogramListType::defaultDataProcessingRef_type& ChromatogramListType::
    defaultDataProcessingRef ()
    {
      return this->defaultDataProcessingRef_.get ();
    }

    void ChromatogramListType::
    defaultDataProcessingRef (const defaultDataProcessingRef_type& x)
    {
      this->defaultDataProcessingRef_.set (x);
    }

    void ChromatogramListType::
    defaultDataProcessingRef (::std::unique_ptr< defaultDataProcessingRef_type > x)
    {
      this->defaultDataProcessingRef_.set (std::move (x));
    }


    // ChromatogramType
    // 

    const ChromatogramType::precursor_optional& ChromatogramType::
    precursor () const
    {
      return this->precursor_;
    }

    ChromatogramType::precursor_optional& ChromatogramType::
    precursor ()
    {
      return this->precursor_;
    }

    void ChromatogramType::
    precursor (const precursor_type& x)
    {
      this->precursor_.set (x);
    }

    void ChromatogramType::
    precursor (const precursor_optional& x)
    {
      this->precursor_ = x;
    }

    void ChromatogramType::
    precursor (::std::unique_ptr< precursor_type > x)
    {
      this->precursor_.set (std::move (x));
    }

    const ChromatogramType::product_optional& ChromatogramType::
    product () const
    {
      return this->product_;
    }

    ChromatogramType::product_optional& ChromatogramType::
    product ()
    {
      return this->product_;
    }

    void ChromatogramType::
    product (const product_type& x)
    {
      this->product_.set (x);
    }

    void ChromatogramType::
    product (const product_optional& x)
    {
      this->product_ = x;
    }

    void ChromatogramType::
    product (::std::unique_ptr< product_type > x)
    {
      this->product_.set (std::move (x));
    }

    const ChromatogramType::binaryDataArrayList_type& ChromatogramType::
    binaryDataArrayList () const
    {
      return this->binaryDataArrayList_.get ();
    }

    ChromatogramType::binaryDataArrayList_type& ChromatogramType::
    binaryDataArrayList ()
    {
      return this->binaryDataArrayList_.get ();
    }

    void ChromatogramType::
    binaryDataArrayList (const binaryDataArrayList_type& x)
    {
      this->binaryDataArrayList_.set (x);
    }

    void ChromatogramType::
    binaryDataArrayList (::std::unique_ptr< binaryDataArrayList_type > x)
    {
      this->binaryDataArrayList_.set (std::move (x));
    }

    const ChromatogramType::id_type& ChromatogramType::
    id () const
    {
      return this->id_.get ();
    }

    ChromatogramType::id_type& ChromatogramType::
    id ()
    {
      return this->id_.get ();
    }

    void ChromatogramType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void ChromatogramType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const ChromatogramType::index_type& ChromatogramType::
    index () const
    {
      return this->index_.get ();
    }

    ChromatogramType::index_type& ChromatogramType::
    index ()
    {
      return this->index_.get ();
    }

    void ChromatogramType::
    index (const index_type& x)
    {
      this->index_.set (x);
    }

    const ChromatogramType::defaultArrayLength_type& ChromatogramType::
    defaultArrayLength () const
    {
      return this->defaultArrayLength_.get ();
    }

    ChromatogramType::defaultArrayLength_type& ChromatogramType::
    defaultArrayLength ()
    {
      return this->defaultArrayLength_.get ();
    }

    void ChromatogramType::
    defaultArrayLength (const defaultArrayLength_type& x)
    {
      this->defaultArrayLength_.set (x);
    }

    const ChromatogramType::dataProcessingRef_optional& ChromatogramType::
    dataProcessingRef () const
    {
      return this->dataProcessingRef_;
    }

    ChromatogramType::dataProcessingRef_optional& ChromatogramType::
    dataProcessingRef ()
    {
      return this->dataProcessingRef_;
    }

    void ChromatogramType::
    dataProcessingRef (const dataProcessingRef_type& x)
    {
      this->dataProcessingRef_.set (x);
    }

    void ChromatogramType::
    dataProcessingRef (const dataProcessingRef_optional& x)
    {
      this->dataProcessingRef_ = x;
    }

    void ChromatogramType::
    dataProcessingRef (::std::unique_ptr< dataProcessingRef_type > x)
    {
      this->dataProcessingRef_.set (std::move (x));
    }


    // id
    // 
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace ms
{
  namespace mzml
  {
    // mzMLType
    //

    mzMLType::
    mzMLType ()
    : ::xml_schema::type (),
      cvList_ (this),
      fileDescription_ (this),
      referenceableParamGroupList_ (this),
      sampleList_ (this),
      softwareList_ (this),
      scanSettingsList_ (this),
      instrumentConfigurationList_ (this),
      dataProcessingList_ (this),
      run_ (this),
      accession_ (this),
      version_ (this),
      id_ (this)
    {
    }

    mzMLType::
    mzMLType (const cvList_type& cvList,
              const fileDescription_type& fileDescription,
              const softwareList_type& softwareList,
              const instrumentConfigurationList_type& instrumentConfigurationList,
              const dataProcessingList_type& dataProcessingList,
              const run_type& run,
              const version_type& version)
    : ::xml_schema::type (),
      cvList_ (cvList, this),
      fileDescription_ (fileDescription, this),
      referenceableParamGroupList_ (this),
      sampleList_ (this),
      softwareList_ (softwareList, this),
      scanSettingsList_ (this),
      instrumentConfigurationList_ (instrumentConfigurationList, this),
      dataProcessingList_ (dataProcessingList, this),
      run_ (run, this),
      accession_ (this),
      version_ (version, this),
      id_ (this)
    {
    }

    mzMLType::
    mzMLType (::std::unique_ptr< cvList_type > cvList,
              ::std::unique_ptr< fileDescription_type > fileDescription,
              ::std::unique_ptr< softwareList_type > softwareList,
              ::std::unique_ptr< instrumentConfigurationList_type > instrumentConfigurationList,
              ::std::unique_ptr< dataProcessingList_type > dataProcessingList,
              ::std::unique_ptr< run_type > run,
              const version_type& version)
    : ::xml_schema::type (),
      cvList_ (std::move (cvList), this),
      fileDescription_ (std::move (fileDescription), this),
      referenceableParamGroupList_ (this),
      sampleList_ (this),
      softwareList_ (std::move (softwareList), this),
      scanSettingsList_ (this),
      instrumentConfigurationList_ (std::move (instrumentConfigurationList), this),
      dataProcessingList_ (std::move (dataProcessingList), this),
      run_ (std::move (run), this),
      accession_ (this),
      version_ (version, this),
      id_ (this)
    {
    }

    mzMLType::
    mzMLType (const mzMLType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      cvList_ (x.cvList_, f, this),
      fileDescription_ (x.fileDescription_, f, this),
      referenceableParamGroupList_ (x.referenceableParamGroupList_, f, this),
      sampleList_ (x.sampleList_, f, this),
      softwareList_ (x.softwareList_, f, this),
      scanSettingsList_ (x.scanSettingsList_, f, this),
      instrumentConfigurationList_ (x.instrumentConfigurationList_, f, this),
      dataProcessingList_ (x.dataProcessingList_, f, this),
      run_ (x.run_, f, this),
      accession_ (x.accession_, f, this),
      version_ (x.version_, f, this),
      id_ (x.id_, f, this)
    {
    }

    mzMLType::
    mzMLType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      cvList_ (this),
      fileDescription_ (this),
      referenceableParamGroupList_ (this),
      sampleList_ (this),
      softwareList_ (this),
      scanSettingsList_ (this),
      instrumentConfigurationList_ (this),
      dataProcessingList_ (this),
      run_ (this),
      accession_ (this),
      version_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void mzMLType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // cvList
        //
        if (n.name () == "cvList" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< cvList_type > r (
            cvList_traits::create (i, f, this));

          if (!cvList_.present ())
          {
            this->cvList_.set (::std::move (r));
            continue;
          }
        }

        // fileDescription
        //
        if (n.name () == "fileDescription" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< fileDescription_type > r (
            fileDescription_traits::create (i, f, this));

          if (!fileDescription_.present ())
          {
            this->fileDescription_.set (::std::move (r));
            continue;
          }
        }

        // referenceableParamGroupList
        //
        if (n.name () == "referenceableParamGroupList" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< referenceableParamGroupList_type > r (
            referenceableParamGroupList_traits::create (i, f, this));

          if (!this->referenceableParamGroupList_)
          {
            this->referenceableParamGroupList_.set (::std::move (r));
            continue;
          }
        }

        // sampleList
        //
        if (n.name () == "sampleList" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< sampleList_type > r (
            sampleList_traits::create (i, f, this));

          if (!this->sampleList_)
          {
            this->sampleList_.set (::std::move (r));
            continue;
          }
        }

        // softwareList
        //
        if (n.name () == "softwareList" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< softwareList_type > r (
            softwareList_traits::create (i, f, this));

          if (!softwareList_.present ())
          {
            this->softwareList_.set (::std::move (r));
            continue;
          }
        }

        // scanSettingsList
        //
        if (n.name () == "scanSettingsList" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< scanSettingsList_type > r (
            scanSettingsList_traits::create (i, f, this));

          if (!this->scanSettingsList_)
          {
            this->scanSettingsList_.set (::std::move (r));
            continue;
          }
        }

        // instrumentConfigurationList
        //
        if (n.name () == "instrumentConfigurationList" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< instrumentConfigurationList_type > r (
            instrumentConfigurationList_traits::create (i, f, this));

          if (!instrumentConfigurationList_.present ())
          {
            this->instrumentConfigurationList_.set (::std::move (r));
            continue;
          }
        }

        // dataProcessingList
        //
        if (n.name () == "dataProcessingList" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< dataProcessingList_type > r (
            dataProcessingList_traits::create (i, f, this));

          if (!dataProcessingList_.present ())
          {
            this->dataProcessingList_.set (::std::move (r));
            continue;
          }
        }

        // run
        //
        if (n.name () == "run" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< run_type > r (
            run_traits::create (i, f, this));

          if (!run_.present ())
          {
            this->run_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!cvList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "cvList",
          "http://psi.hupo.org/ms/mzml");
      }

      if (!fileDescription_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "fileDescription",
          "http://psi.hupo.org/ms/mzml");
      }

      if (!softwareList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "softwareList",
          "http://psi.hupo.org/ms/mzml");
      }

      if (!instrumentConfigurationList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "instrumentConfigurationList",
          "http://psi.hupo.org/ms/mzml");
      }

      if (!dataProcessingList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "dataProcessingList",
          "http://psi.hupo.org/ms/mzml");
      }

      if (!run_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "run",
          "http://psi.hupo.org/ms/mzml");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "accession" && n.namespace_ ().empty ())
        {
          this->accession_.set (accession_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "version" && n.namespace_ ().empty ())
        {
          this->version_.set (version_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!version_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "version",
          "");
      }
    }

    mzMLType* mzMLType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class mzMLType (*this, f, c);
    }

    mzMLType& mzMLType::
    operator= (const mzMLType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->cvList_ = x.cvList_;
        this->fileDescription_ = x.fileDescription_;
        this->referenceableParamGroupList_ = x.referenceableParamGroupList_;
        this->sampleList_ = x.sampleList_;
        this->softwareList_ = x.softwareList_;
        this->scanSettingsList_ = x.scanSettingsList_;
        this->instrumentConfigurationList_ = x.instrumentConfigurationList_;
        this->dataProcessingList_ = x.dataProcessingList_;
        this->run_ = x.run_;
        this->accession_ = x.accession_;
        this->version_ = x.version_;
        this->id_ = x.id_;
      }

      return *this;
    }

    mzMLType::
    ~mzMLType ()
    {
    }

    // FileDescriptionType
    //

    FileDescriptionType::
    FileDescriptionType ()
    : ::xml_schema::type (),
      fileContent_ (this),
      sourceFileList_ (this),
      contact_ (this)
    {
    }

    FileDescriptionType::
    FileDescriptionType (const fileContent_type& fileContent)
    : ::xml_schema::type (),
      fileContent_ (fileContent, this),
      sourceFileList_ (this),
      contact_ (this)
    {
    }

    FileDescriptionType::
    FileDescriptionType (::std::unique_ptr< fileContent_type > fileContent)
    : ::xml_schema::type (),
      fileContent_ (std::move (fileContent), this),
      sourceFileList_ (this),
      contact_ (this)
    {
    }

    FileDescriptionType::
    FileDescriptionType (const FileDescriptionType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      fileContent_ (x.fileContent_, f, this),
      sourceFileList_ (x.sourceFileList_, f, this),
      contact_ (x.contact_, f, this)
    {
    }

    FileDescriptionType::
    FileDescriptionType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      fileContent_ (this),
      sourceFileList_ (this),
      contact_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FileDescriptionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // fileContent
        //
        if (n.name () == "fileContent" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< fileContent_type > r (
            fileContent_traits::create (i, f, this));

          if (!fileContent_.present ())
          {
            this->fileContent_.set (::std::move (r));
            continue;
          }
        }

        // sourceFileList
        //
        if (n.name () == "sourceFileList" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< sourceFileList_type > r (
            sourceFileList_traits::create (i, f, this));

          if (!this->sourceFileList_)
          {
            this->sourceFileList_.set (::std::move (r));
            continue;
          }
        }

        // contact
        //
        if (n.name () == "contact" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< contact_type > r (
            contact_traits::create (i, f, this));

          this->contact_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      if (!fileContent_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "fileContent",
          "http://psi.hupo.org/ms/mzml");
      }
    }

    FileDescriptionType* FileDescriptionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FileDescriptionType (*this, f, c);
    }

    FileDescriptionType& FileDescriptionType::
    operator= (const FileDescriptionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->fileContent_ = x.fileContent_;
        this->sourceFileList_ = x.sourceFileList_;
        this->contact_ = x.contact_;
      }

      return *this;
    }

    FileDescriptionType::
    ~FileDescriptionType ()
    {
    }

    // SourceFileListType
    //

    SourceFileListType::
    SourceFileListType ()
    : ::xml_schema::type (),
      sourceFile_ (this),
      count_ (this)
    {
    }

    SourceFileListType::
    SourceFileListType (const count_type& count)
    : ::xml_schema::type (),
      sourceFile_ (this),
      count_ (count, this)
    {
    }

    SourceFileListType::
    SourceFileListType (const SourceFileListType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      sourceFile_ (x.sourceFile_, f, this),
      count_ (x.count_, f, this)
    {
    }

    SourceFileListType::
    SourceFileListType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      sourceFile_ (this),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SourceFileListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // sourceFile
        //
        if (n.name () == "sourceFile" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< sourceFile_type > r (
            sourceFile_traits::create (i, f, this));

          this->sourceFile_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }
    }

    SourceFileListType* SourceFileListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SourceFileListType (*this, f, c);
    }

    SourceFileListType& SourceFileListType::
    operator= (const SourceFileListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->sourceFile_ = x.sourceFile_;
        this->count_ = x.count_;
      }

      return *this;
    }

    SourceFileListType::
    ~SourceFileListType ()
    {
    }

    // ParamGroupType
    //

    ParamGroupType::
    ParamGroupType ()
    : ::xml_schema::type (),
      referenceableParamGroupRef_ (this),
      cvParam_ (this),
      userParam_ (this)
    {
    }

    ParamGroupType::
    ParamGroupType (const ParamGroupType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      referenceableParamGroupRef_ (x.referenceableParamGroupRef_, f, this),
      cvParam_ (x.cvParam_, f, this),
      userParam_ (x.userParam_, f, this)
    {
    }

    ParamGroupType::
    ParamGroupType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      referenceableParamGroupRef_ (this),
      cvParam_ (this),
      userParam_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ParamGroupType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // referenceableParamGroupRef
        //
        if (n.name () == "referenceableParamGroupRef" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< referenceableParamGroupRef_type > r (
            referenceableParamGroupRef_traits::create (i, f, this));

          this->referenceableParamGroupRef_.push_back (::std::move (r));
          continue;
        }

        // cvParam
        //
        if (n.name () == "cvParam" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< cvParam_type > r (
            cvParam_traits::create (i, f, this));

          this->cvParam_.push_back (::std::move (r));
          continue;
        }

        // userParam
        //
        if (n.name () == "userParam" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< userParam_type > r (
            userParam_traits::create (i, f, this));

          this->userParam_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    ParamGroupType* ParamGroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ParamGroupType (*this, f, c);
    }

    ParamGroupType& ParamGroupType::
    operator= (const ParamGroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->referenceableParamGroupRef_ = x.referenceableParamGroupRef_;
        this->cvParam_ = x.cvParam_;
        this->userParam_ = x.userParam_;
      }

      return *this;
    }

    ParamGroupType::
    ~ParamGroupType ()
    {
    }

    // SourceFileType
    //

    SourceFileType::
    SourceFileType ()
    : ::ms::mzml::ParamGroupType (),
      id_ (this),
      name_ (this),
      location_ (this)
    {
    }

    SourceFileType::
    SourceFileType (const id_type& id,
                    const name_type& name,
                    const location_type& location)
    : ::ms::mzml::ParamGroupType (),
      id_ (id, this),
      name_ (name, this),
      location_ (location, this)
    {
    }

    SourceFileType::
    SourceFileType (const SourceFileType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (x, f, c),
      id_ (x.id_, f, this),
      name_ (x.name_, f, this),
      location_ (x.location_, f, this)
    {
    }

    SourceFileType::
    SourceFileType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      name_ (this),
      location_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SourceFileType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::ms::mzml::ParamGroupType::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "location" && n.namespace_ ().empty ())
        {
          this->location_.set (location_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!location_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "location",
          "");
      }
    }

    SourceFileType* SourceFileType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SourceFileType (*this, f, c);
    }

    SourceFileType& SourceFileType::
    operator= (const SourceFileType& x)
    {
      if (this != &x)
      {
        static_cast< ::ms::mzml::ParamGroupType& > (*this) = x;
        this->id_ = x.id_;
        this->name_ = x.name_;
        this->location_ = x.location_;
      }

      return *this;
    }

    SourceFileType::
    ~SourceFileType ()
    {
    }

    // CVType
    //

    CVType::
    CVType ()
    : ::xml_schema::type (),
      id_ (this),
      fullName_ (this),
      version_ (this),
      URI_ (this)
    {
    }

    CVType::
    CVType (const id_type& id,
            const fullName_type& fullName,
            const URI_type& URI)
    : ::xml_schema::type (),
      id_ (id, this),
      fullName_ (fullName, this),
      version_ (this),
      URI_ (URI, this)
    {
    }

    CVType::
    CVType (const CVType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this),
      fullName_ (x.fullName_, f, this),
      version_ (x.version_, f, this),
      URI_ (x.URI_, f, this)
    {
    }

    CVType::
    CVType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      fullName_ (this),
      version_ (this),
      URI_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void CVType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "fullName" && n.namespace_ ().empty ())
        {
          this->fullName_.set (fullName_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "version" && n.namespace_ ().empty ())
        {
          this->version_.set (version_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "URI" && n.namespace_ ().empty ())
        {
          this->URI_.set (URI_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }

      if (!fullName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "fullName",
          "");
      }

      if (!URI_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "URI",
          "");
      }
    }

    CVType* CVType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CVType (*this, f, c);
    }

    CVType& CVType::
    operator= (const CVType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
        this->fullName_ = x.fullName_;
        this->version_ = x.version_;
        this->URI_ = x.URI_;
      }

      return *this;
    }

    CVType::
    ~CVType ()
    {
    }

    // CVListType
    //

    CVListType::
    CVListType ()
    : ::xml_schema::type (),
      cv_ (this),
      count_ (this)
    {
    }

    CVListType::
    CVListType (const count_type& count)
    : ::xml_schema::type (),
      cv_ (this),
      count_ (count, this)
    {
    }

    CVListType::
    CVListType (const CVListType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      cv_ (x.cv_, f, this),
      count_ (x.count_, f, this)
    {
    }

    CVListType::
    CVListType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      cv_ (this),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CVListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // cv
        //
        if (n.name () == "cv" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< cv_type > r (
            cv_traits::create (i, f, this));

          this->cv_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }
    }

    CVListType* CVListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CVListType (*this, f, c);
    }

    CVListType& CVListType::
    operator= (const CVListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->cv_ = x.cv_;
        this->count_ = x.count_;
      }

      return *this;
    }

    CVListType::
    ~CVListType ()
    {
    }

    // ReferenceableParamGroupListType
    //

    ReferenceableParamGroupListType::
    ReferenceableParamGroupListType ()
    : ::xml_schema::type (),
      referenceableParamGroup_ (this),
      count_ (this)
    {
    }

    ReferenceableParamGroupListType::
    ReferenceableParamGroupListType (const count_type& count)
    : ::xml_schema::type (),
      referenceableParamGroup_ (this),
      count_ (count, this)
    {
    }

    ReferenceableParamGroupListType::
    ReferenceableParamGroupListType (const ReferenceableParamGroupListType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      referenceableParamGroup_ (x.referenceableParamGroup_, f, this),
      count_ (x.count_, f, this)
    {
    }

    ReferenceableParamGroupListType::
    ReferenceableParamGroupListType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      referenceableParamGroup_ (this),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ReferenceableParamGroupListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // referenceableParamGroup
        //
        if (n.name () == "referenceableParamGroup" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< referenceableParamGroup_type > r (
            referenceableParamGroup_traits::create (i, f, this));

          this->referenceableParamGroup_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }
    }

    ReferenceableParamGroupListType* ReferenceableParamGroupListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ReferenceableParamGroupListType (*this, f, c);
    }

    ReferenceableParamGroupListType& ReferenceableParamGroupListType::
    operator= (const ReferenceableParamGroupListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->referenceableParamGroup_ = x.referenceableParamGroup_;
        this->count_ = x.count_;
      }

      return *this;
    }

    ReferenceableParamGroupListType::
    ~ReferenceableParamGroupListType ()
    {
    }

    // ReferenceableParamGroupType
    //

    ReferenceableParamGroupType::
    ReferenceableParamGroupType ()
    : ::xml_schema::type (),
      cvParam_ (this),
      userParam_ (this),
      id_ (this)
    {
    }

    ReferenceableParamGroupType::
    ReferenceableParamGroupType (const id_type& id)
    : ::xml_schema::type (),
      cvParam_ (this),
      userParam_ (this),
      id_ (id, this)
    {
    }

    ReferenceableParamGroupType::
    ReferenceableParamGroupType (const ReferenceableParamGroupType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      cvParam_ (x.cvParam_, f, this),
      userParam_ (x.userParam_, f, this),
      id_ (x.id_, f, this)
    {
    }

    ReferenceableParamGroupType::
    ReferenceableParamGroupType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      cvParam_ (this),
      userParam_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ReferenceableParamGroupType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // cvParam
        //
        if (n.name () == "cvParam" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< cvParam_type > r (
            cvParam_traits::create (i, f, this));

          this->cvParam_.push_back (::std::move (r));
          continue;
        }

        // userParam
        //
        if (n.name () == "userParam" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< userParam_type > r (
            userParam_traits::create (i, f, this));

          this->userParam_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    ReferenceableParamGroupType* ReferenceableParamGroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ReferenceableParamGroupType (*this, f, c);
    }

    ReferenceableParamGroupType& ReferenceableParamGroupType::
    operator= (const ReferenceableParamGroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->cvParam_ = x.cvParam_;
        this->userParam_ = x.userParam_;
        this->id_ = x.id_;
      }

      return *this;
    }

    ReferenceableParamGroupType::
    ~ReferenceableParamGroupType ()
    {
    }

    // CVParamType
    //

    CVParamType::
    CVParamType ()
    : ::xml_schema::type (),
      cvRef_ (this),
      accession_ (this),
      value_ (this),
      name_ (this),
      unitAccession_ (this),
      unitName_ (this),
      unitCvRef_ (this)
    {
    }

    CVParamType::
    CVParamType (const cvRef_type& cvRef,
                 const accession_type& accession,
                 const name_type& name)
    : ::xml_schema::type (),
      cvRef_ (cvRef, this),
      accession_ (accession, this),
      value_ (this),
      name_ (name, this),
      unitAccession_ (this),
      unitName_ (this),
      unitCvRef_ (this)
    {
    }

    CVParamType::
    CVParamType (const CVParamType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      cvRef_ (x.cvRef_, f, this),
      accession_ (x.accession_, f, this),
      value_ (x.value_, f, this),
      name_ (x.name_, f, this),
      unitAccession_ (x.unitAccession_, f, this),
      unitName_ (x.unitName_, f, this),
      unitCvRef_ (x.unitCvRef_, f, this)
    {
    }

    CVParamType::
    CVParamType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      cvRef_ (this),
      accession_ (this),
      value_ (this),
      name_ (this),
      unitAccession_ (this),
      unitName_ (this),
      unitCvRef_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void CVParamType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "cvRef" && n.namespace_ ().empty ())
        {
          this->cvRef_.set (cvRef_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "accession" && n.namespace_ ().empty ())
        {
          this->accession_.set (accession_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "unitAccession" && n.namespace_ ().empty ())
        {
          this->unitAccession_.set (unitAccession_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "unitName" && n.namespace_ ().empty ())
        {
          this->unitName_.set (unitName_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "unitCvRef" && n.namespace_ ().empty ())
        {
          this->unitCvRef_.set (unitCvRef_traits::create (i, f, this));
          continue;
        }
      }

      if (!cvRef_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "cvRef",
          "");
      }

      if (!accession_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "accession",
          "");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    CVParamType* CVParamType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CVParamType (*this, f, c);
    }

    CVParamType& CVParamType::
    operator= (const CVParamType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->cvRef_ = x.cvRef_;
        this->accession_ = x.accession_;
        this->value_ = x.value_;
        this->name_ = x.name_;
        this->unitAccession_ = x.unitAccession_;
        this->unitName_ = x.unitName_;
        this->unitCvRef_ = x.unitCvRef_;
      }

      return *this;
    }

    CVParamType::
    ~CVParamType ()
    {
    }

    // UserParamType
    //

    UserParamType::
    UserParamType ()
    : ::xml_schema::type (),
      name_ (this),
      type_ (this),
      value_ (this),
      unitAccession_ (this),
      unitName_ (this),
      unitCvRef_ (this)
    {
    }

    UserParamType::
    UserParamType (const name_type& name)
    : ::xml_schema::type (),
      name_ (name, this),
      type_ (this),
      value_ (this),
      unitAccession_ (this),
      unitName_ (this),
      unitCvRef_ (this)
    {
    }

    UserParamType::
    UserParamType (const UserParamType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      type_ (x.type_, f, this),
      value_ (x.value_, f, this),
      unitAccession_ (x.unitAccession_, f, this),
      unitName_ (x.unitName_, f, this),
      unitCvRef_ (x.unitCvRef_, f, this)
    {
    }

    UserParamType::
    UserParamType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (this),
      type_ (this),
      value_ (this),
      unitAccession_ (this),
      unitName_ (this),
      unitCvRef_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void UserParamType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "unitAccession" && n.namespace_ ().empty ())
        {
          this->unitAccession_.set (unitAccession_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "unitName" && n.namespace_ ().empty ())
        {
          this->unitName_.set (unitName_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "unitCvRef" && n.namespace_ ().empty ())
        {
          this->unitCvRef_.set (unitCvRef_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    UserParamType* UserParamType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserParamType (*this, f, c);
    }

    UserParamType& UserParamType::
    operator= (const UserParamType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->name_ = x.name_;
        this->type_ = x.type_;
        this->value_ = x.value_;
        this->unitAccession_ = x.unitAccession_;
        this->unitName_ = x.unitName_;
        this->unitCvRef_ = x.unitCvRef_;
      }

      return *this;
    }

    UserParamType::
    ~UserParamType ()
    {
    }

    // ReferenceableParamGroupRefType
    //

    ReferenceableParamGroupRefType::
    ReferenceableParamGroupRefType ()
    : ::xml_schema::type (),
      ref_ (this)
    {
    }

    ReferenceableParamGroupRefType::
    ReferenceableParamGroupRefType (const ref_type& ref)
    : ::xml_schema::type (),
      ref_ (ref, this)
    {
    }

    ReferenceableParamGroupRefType::
    ReferenceableParamGroupRefType (const ReferenceableParamGroupRefType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ref_ (x.ref_, f, this)
    {
    }

    ReferenceableParamGroupRefType::
    ReferenceableParamGroupRefType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ref_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ReferenceableParamGroupRefType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "ref" && n.namespace_ ().empty ())
        {
          this->ref_.set (ref_traits::create (i, f, this));
          continue;
        }
      }

      if (!ref_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ref",
          "");
      }
    }

    ReferenceableParamGroupRefType* ReferenceableParamGroupRefType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ReferenceableParamGroupRefType (*this, f, c);
    }

    ReferenceableParamGroupRefType& ReferenceableParamGroupRefType::
    operator= (const ReferenceableParamGroupRefType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ref_ = x.ref_;
      }

      return *this;
    }

    ReferenceableParamGroupRefType::
    ~ReferenceableParamGroupRefType ()
    {
    }

    // SampleListType
    //

    SampleListType::
    SampleListType ()
    : ::xml_schema::type (),
      sample_ (this),
      count_ (this)
    {
    }

    SampleListType::
    SampleListType (const count_type& count)
    : ::xml_schema::type (),
      sample_ (this),
      count_ (count, this)
    {
    }

    SampleListType::
    SampleListType (const SampleListType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      sample_ (x.sample_, f, this),
      count_ (x.count_, f, this)
    {
    }

    SampleListType::
    SampleListType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      sample_ (this),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SampleListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // sample
        //
        if (n.name () == "sample" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< sample_type > r (
            sample_traits::create (i, f, this));

          this->sample_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }
    }

    SampleListType* SampleListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SampleListType (*this, f, c);
    }

    SampleListType& SampleListType::
    operator= (const SampleListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->sample_ = x.sample_;
        this->count_ = x.count_;
      }

      return *this;
    }

    SampleListType::
    ~SampleListType ()
    {
    }

    // SampleType
    //

    SampleType::
    SampleType ()
    : ::ms::mzml::ParamGroupType (),
      id_ (this),
      name_ (this)
    {
    }

    SampleType::
    SampleType (const id_type& id)
    : ::ms::mzml::ParamGroupType (),
      id_ (id, this),
      name_ (this)
    {
    }

    SampleType::
    SampleType (const SampleType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (x, f, c),
      id_ (x.id_, f, this),
      name_ (x.name_, f, this)
    {
    }

    SampleType::
    SampleType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      name_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SampleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::ms::mzml::ParamGroupType::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    SampleType* SampleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SampleType (*this, f, c);
    }

    SampleType& SampleType::
    operator= (const SampleType& x)
    {
      if (this != &x)
      {
        static_cast< ::ms::mzml::ParamGroupType& > (*this) = x;
        this->id_ = x.id_;
        this->name_ = x.name_;
      }

      return *this;
    }

    SampleType::
    ~SampleType ()
    {
    }

    // InstrumentConfigurationListType
    //

    InstrumentConfigurationListType::
    InstrumentConfigurationListType ()
    : ::xml_schema::type (),
      instrumentConfiguration_ (this),
      count_ (this)
    {
    }

    InstrumentConfigurationListType::
    InstrumentConfigurationListType (const count_type& count)
    : ::xml_schema::type (),
      instrumentConfiguration_ (this),
      count_ (count, this)
    {
    }

    InstrumentConfigurationListType::
    InstrumentConfigurationListType (const InstrumentConfigurationListType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      instrumentConfiguration_ (x.instrumentConfiguration_, f, this),
      count_ (x.count_, f, this)
    {
    }

    InstrumentConfigurationListType::
    InstrumentConfigurationListType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      instrumentConfiguration_ (this),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void InstrumentConfigurationListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // instrumentConfiguration
        //
        if (n.name () == "instrumentConfiguration" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< instrumentConfiguration_type > r (
            instrumentConfiguration_traits::create (i, f, this));

          this->instrumentConfiguration_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }
    }

    InstrumentConfigurationListType* InstrumentConfigurationListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class InstrumentConfigurationListType (*this, f, c);
    }

    InstrumentConfigurationListType& InstrumentConfigurationListType::
    operator= (const InstrumentConfigurationListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->instrumentConfiguration_ = x.instrumentConfiguration_;
        this->count_ = x.count_;
      }

      return *this;
    }

    InstrumentConfigurationListType::
    ~InstrumentConfigurationListType ()
    {
    }

    // ComponentType
    //

    ComponentType::
    ComponentType ()
    : ::ms::mzml::ParamGroupType (),
      order_ (this)
    {
    }

    ComponentType::
    ComponentType (const order_type& order)
    : ::ms::mzml::ParamGroupType (),
      order_ (order, this)
    {
    }

    ComponentType::
    ComponentType (const ComponentType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (x, f, c),
      order_ (x.order_, f, this)
    {
    }

    ComponentType::
    ComponentType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (e, f | ::xml_schema::flags::base, c),
      order_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ComponentType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::ms::mzml::ParamGroupType::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "order" && n.namespace_ ().empty ())
        {
          this->order_.set (order_traits::create (i, f, this));
          continue;
        }
      }

      if (!order_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "order",
          "");
      }
    }

    ComponentType* ComponentType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ComponentType (*this, f, c);
    }

    ComponentType& ComponentType::
    operator= (const ComponentType& x)
    {
      if (this != &x)
      {
        static_cast< ::ms::mzml::ParamGroupType& > (*this) = x;
        this->order_ = x.order_;
      }

      return *this;
    }

    ComponentType::
    ~ComponentType ()
    {
    }

    // SourceComponentType
    //

    SourceComponentType::
    SourceComponentType ()
    : ::ms::mzml::ComponentType ()
    {
    }

    SourceComponentType::
    SourceComponentType (const order_type& order)
    : ::ms::mzml::ComponentType (order)
    {
    }

    SourceComponentType::
    SourceComponentType (const SourceComponentType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::ms::mzml::ComponentType (x, f, c)
    {
    }

    SourceComponentType::
    SourceComponentType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::ms::mzml::ComponentType (e, f, c)
    {
    }

    SourceComponentType* SourceComponentType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SourceComponentType (*this, f, c);
    }

    SourceComponentType::
    ~SourceComponentType ()
    {
    }

    // DetectorComponentType
    //

    DetectorComponentType::
    DetectorComponentType ()
    : ::ms::mzml::ComponentType ()
    {
    }

    DetectorComponentType::
    DetectorComponentType (const order_type& order)
    : ::ms::mzml::ComponentType (order)
    {
    }

    DetectorComponentType::
    DetectorComponentType (const DetectorComponentType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::ms::mzml::ComponentType (x, f, c)
    {
    }

    DetectorComponentType::
    DetectorComponentType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::ms::mzml::ComponentType (e, f, c)
    {
    }

    DetectorComponentType* DetectorComponentType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DetectorComponentType (*this, f, c);
    }

    DetectorComponentType::
    ~DetectorComponentType ()
    {
    }

    // AnalyzerComponentType
    //

    AnalyzerComponentType::
    AnalyzerComponentType ()
    : ::ms::mzml::ComponentType ()
    {
    }

    AnalyzerComponentType::
    AnalyzerComponentType (const order_type& order)
    : ::ms::mzml::ComponentType (order)
    {
    }

    AnalyzerComponentType::
    AnalyzerComponentType (const AnalyzerComponentType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::ms::mzml::ComponentType (x, f, c)
    {
    }

    AnalyzerComponentType::
    AnalyzerComponentType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::ms::mzml::ComponentType (e, f, c)
    {
    }

    AnalyzerComponentType* AnalyzerComponentType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AnalyzerComponentType (*this, f, c);
    }

    AnalyzerComponentType::
    ~AnalyzerComponentType ()
    {
    }

    // ComponentListType
    //

    ComponentListType::
    ComponentListType ()
    : ::xml_schema::type (),
      source_ (this),
      analyzer_ (this),
      detector_ (this),
      count_ (this)
    {
    }

    ComponentListType::
    ComponentListType (const count_type& count)
    : ::xml_schema::type (),
      source_ (this),
      analyzer_ (this),
      detector_ (this),
      count_ (count, this)
    {
    }

    ComponentListType::
    ComponentListType (const ComponentListType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      source_ (x.source_, f, this),
      analyzer_ (x.analyzer_, f, this),
      detector_ (x.detector_, f, this),
      count_ (x.count_, f, this)
    {
    }

    ComponentListType::
    ComponentListType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      source_ (this),
      analyzer_ (this),
      detector_ (this),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ComponentListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // source
        //
        if (n.name () == "source" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< source_type > r (
            source_traits::create (i, f, this));

          this->source_.push_back (::std::move (r));
          continue;
        }

        // analyzer
        //
        if (n.name () == "analyzer" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< analyzer_type > r (
            analyzer_traits::create (i, f, this));

          this->analyzer_.push_back (::std::move (r));
          continue;
        }

        // detector
        //
        if (n.name () == "detector" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< detector_type > r (
            detector_traits::create (i, f, this));

          this->detector_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }
    }

    ComponentListType* ComponentListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ComponentListType (*this, f, c);
    }

    ComponentListType& ComponentListType::
    operator= (const ComponentListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->source_ = x.source_;
        this->analyzer_ = x.analyzer_;
        this->detector_ = x.detector_;
        this->count_ = x.count_;
      }

      return *this;
    }

    ComponentListType::
    ~ComponentListType ()
    {
    }

    // InstrumentConfigurationType
    //

    InstrumentConfigurationType::
    InstrumentConfigurationType ()
    : ::ms::mzml::ParamGroupType (),
      componentList_ (this),
      softwareRef_ (this),
      id_ (this),
      scanSettingsRef_ (this)
    {
    }

    InstrumentConfigurationType::
    InstrumentConfigurationType (const id_type& id)
    : ::ms::mzml::ParamGroupType (),
      componentList_ (this),
      softwareRef_ (this),
      id_ (id, this),
      scanSettingsRef_ (this)
    {
    }

    InstrumentConfigurationType::
    InstrumentConfigurationType (const InstrumentConfigurationType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (x, f, c),
      componentList_ (x.componentList_, f, this),
      softwareRef_ (x.softwareRef_, f, this),
      id_ (x.id_, f, this),
      scanSettingsRef_ (x.scanSettingsRef_, f, this)
    {
    }

    InstrumentConfigurationType::
    InstrumentConfigurationType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (e, f | ::xml_schema::flags::base, c),
      componentList_ (this),
      softwareRef_ (this),
      id_ (this),
      scanSettingsRef_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void InstrumentConfigurationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::ms::mzml::ParamGroupType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // componentList
        //
        if (n.name () == "componentList" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< componentList_type > r (
            componentList_traits::create (i, f, this));

          if (!this->componentList_)
          {
            this->componentList_.set (::std::move (r));
            continue;
          }
        }

        // softwareRef
        //
        if (n.name () == "softwareRef" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< softwareRef_type > r (
            softwareRef_traits::create (i, f, this));

          if (!this->softwareRef_)
          {
            this->softwareRef_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "scanSettingsRef" && n.namespace_ ().empty ())
        {
          this->scanSettingsRef_.set (scanSettingsRef_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    InstrumentConfigurationType* InstrumentConfigurationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class InstrumentConfigurationType (*this, f, c);
    }

    InstrumentConfigurationType& InstrumentConfigurationType::
    operator= (const InstrumentConfigurationType& x)
    {
      if (this != &x)
      {
        static_cast< ::ms::mzml::ParamGroupType& > (*this) = x;
        this->componentList_ = x.componentList_;
        this->softwareRef_ = x.softwareRef_;
        this->id_ = x.id_;
        this->scanSettingsRef_ = x.scanSettingsRef_;
      }

      return *this;
    }

    InstrumentConfigurationType::
    ~InstrumentConfigurationType ()
    {
    }

    // SoftwareRefType
    //

    SoftwareRefType::
    SoftwareRefType ()
    : ::xml_schema::type (),
      ref_ (this)
    {
    }

    SoftwareRefType::
    SoftwareRefType (const ref_type& ref)
    : ::xml_schema::type (),
      ref_ (ref, this)
    {
    }

    SoftwareRefType::
    SoftwareRefType (const SoftwareRefType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ref_ (x.ref_, f, this)
    {
    }

    SoftwareRefType::
    SoftwareRefType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ref_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SoftwareRefType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "ref" && n.namespace_ ().empty ())
        {
          this->ref_.set (ref_traits::create (i, f, this));
          continue;
        }
      }

      if (!ref_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ref",
          "");
      }
    }

    SoftwareRefType* SoftwareRefType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SoftwareRefType (*this, f, c);
    }

    SoftwareRefType& SoftwareRefType::
    operator= (const SoftwareRefType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ref_ = x.ref_;
      }

      return *this;
    }

    SoftwareRefType::
    ~SoftwareRefType ()
    {
    }

    // SoftwareListType
    //

    SoftwareListType::
    SoftwareListType ()
    : ::xml_schema::type (),
      software_ (this),
      count_ (this)
    {
    }

    SoftwareListType::
    SoftwareListType (const count_type& count)
    : ::xml_schema::type (),
      software_ (this),
      count_ (count, this)
    {
    }

    SoftwareListType::
    SoftwareListType (const SoftwareListType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      software_ (x.software_, f, this),
      count_ (x.count_, f, this)
    {
    }

    SoftwareListType::
    SoftwareListType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      software_ (this),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SoftwareListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // software
        //
        if (n.name () == "software" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< software_type > r (
            software_traits::create (i, f, this));

          this->software_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }
    }

    SoftwareListType* SoftwareListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SoftwareListType (*this, f, c);
    }

    SoftwareListType& SoftwareListType::
    operator= (const SoftwareListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->software_ = x.software_;
        this->count_ = x.count_;
      }

      return *this;
    }

    SoftwareListType::
    ~SoftwareListType ()
    {
    }

    // SoftwareType
    //

    SoftwareType::
    SoftwareType ()
    : ::ms::mzml::ParamGroupType (),
      id_ (this),
      version_ (this)
    {
    }

    SoftwareType::
    SoftwareType (const id_type& id,
                  const version_type& version)
    : ::ms::mzml::ParamGroupType (),
      id_ (id, this),
      version_ (version, this)
    {
    }

    SoftwareType::
    SoftwareType (const SoftwareType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (x, f, c),
      id_ (x.id_, f, this),
      version_ (x.version_, f, this)
    {
    }

    SoftwareType::
    SoftwareType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      version_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SoftwareType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::ms::mzml::ParamGroupType::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "version" && n.namespace_ ().empty ())
        {
          this->version_.set (version_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }

      if (!version_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "version",
          "");
      }
    }

    SoftwareType* SoftwareType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SoftwareType (*this, f, c);
    }

    SoftwareType& SoftwareType::
    operator= (const SoftwareType& x)
    {
      if (this != &x)
      {
        static_cast< ::ms::mzml::ParamGroupType& > (*this) = x;
        this->id_ = x.id_;
        this->version_ = x.version_;
      }

      return *this;
    }

    SoftwareType::
    ~SoftwareType ()
    {
    }

    // DataProcessingListType
    //

    DataProcessingListType::
    DataProcessingListType ()
    : ::xml_schema::type (),
      dataProcessing_ (this),
      count_ (this)
    {
    }

    DataProcessingListType::
    DataProcessingListType (const count_type& count)
    : ::xml_schema::type (),
      dataProcessing_ (this),
      count_ (count, this)
    {
    }

    DataProcessingListType::
    DataProcessingListType (const DataProcessingListType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      dataProcessing_ (x.dataProcessing_, f, this),
      count_ (x.count_, f, this)
    {
    }

    DataProcessingListType::
    DataProcessingListType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dataProcessing_ (this),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DataProcessingListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // dataProcessing
        //
        if (n.name () == "dataProcessing" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< dataProcessing_type > r (
            dataProcessing_traits::create (i, f, this));

          this->dataProcessing_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }
    }

    DataProcessingListType* DataProcessingListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DataProcessingListType (*this, f, c);
    }

    DataProcessingListType& DataProcessingListType::
    operator= (const DataProcessingListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->dataProcessing_ = x.dataProcessing_;
        this->count_ = x.count_;
      }

      return *this;
    }

    DataProcessingListType::
    ~DataProcessingListType ()
    {
    }

    // DataProcessingType
    //

    DataProcessingType::
    DataProcessingType ()
    : ::xml_schema::type (),
      processingMethod_ (this),
      id_ (this)
    {
    }

    DataProcessingType::
    DataProcessingType (const id_type& id)
    : ::xml_schema::type (),
      processingMethod_ (this),
      id_ (id, this)
    {
    }

    DataProcessingType::
    DataProcessingType (const DataProcessingType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      processingMethod_ (x.processingMethod_, f, this),
      id_ (x.id_, f, this)
    {
    }

    DataProcessingType::
    DataProcessingType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      processingMethod_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DataProcessingType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // processingMethod
        //
        if (n.name () == "processingMethod" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< processingMethod_type > r (
            processingMethod_traits::create (i, f, this));

          this->processingMethod_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    DataProcessingType* DataProcessingType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DataProcessingType (*this, f, c);
    }

    DataProcessingType& DataProcessingType::
    operator= (const DataProcessingType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->processingMethod_ = x.processingMethod_;
        this->id_ = x.id_;
      }

      return *this;
    }

    DataProcessingType::
    ~DataProcessingType ()
    {
    }

    // ProcessingMethodType
    //

    ProcessingMethodType::
    ProcessingMethodType ()
    : ::ms::mzml::ParamGroupType (),
      order_ (this),
      softwareRef_ (this)
    {
    }

    ProcessingMethodType::
    ProcessingMethodType (const order_type& order,
                          const softwareRef_type& softwareRef)
    : ::ms::mzml::ParamGroupType (),
      order_ (order, this),
      softwareRef_ (softwareRef, this)
    {
    }

    ProcessingMethodType::
    ProcessingMethodType (const ProcessingMethodType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (x, f, c),
      order_ (x.order_, f, this),
      softwareRef_ (x.softwareRef_, f, this)
    {
    }

    ProcessingMethodType::
    ProcessingMethodType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (e, f | ::xml_schema::flags::base, c),
      order_ (this),
      softwareRef_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ProcessingMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::ms::mzml::ParamGroupType::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "order" && n.namespace_ ().empty ())
        {
          this->order_.set (order_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "softwareRef" && n.namespace_ ().empty ())
        {
          this->softwareRef_.set (softwareRef_traits::create (i, f, this));
          continue;
        }
      }

      if (!order_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "order",
          "");
      }

      if (!softwareRef_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "softwareRef",
          "");
      }
    }

    ProcessingMethodType* ProcessingMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProcessingMethodType (*this, f, c);
    }

    ProcessingMethodType& ProcessingMethodType::
    operator= (const ProcessingMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::ms::mzml::ParamGroupType& > (*this) = x;
        this->order_ = x.order_;
        this->softwareRef_ = x.softwareRef_;
      }

      return *this;
    }

    ProcessingMethodType::
    ~ProcessingMethodType ()
    {
    }

    // ScanSettingsListType
    //

    ScanSettingsListType::
    ScanSettingsListType ()
    : ::xml_schema::type (),
      scanSettings_ (this),
      count_ (this)
    {
    }

    ScanSettingsListType::
    ScanSettingsListType (const count_type& count)
    : ::xml_schema::type (),
      scanSettings_ (this),
      count_ (count, this)
    {
    }

    ScanSettingsListType::
    ScanSettingsListType (const ScanSettingsListType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      scanSettings_ (x.scanSettings_, f, this),
      count_ (x.count_, f, this)
    {
    }

    ScanSettingsListType::
    ScanSettingsListType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      scanSettings_ (this),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ScanSettingsListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // scanSettings
        //
        if (n.name () == "scanSettings" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< scanSettings_type > r (
            scanSettings_traits::create (i, f, this));

          this->scanSettings_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }
    }

    ScanSettingsListType* ScanSettingsListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ScanSettingsListType (*this, f, c);
    }

    ScanSettingsListType& ScanSettingsListType::
    operator= (const ScanSettingsListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->scanSettings_ = x.scanSettings_;
        this->count_ = x.count_;
      }

      return *this;
    }

    ScanSettingsListType::
    ~ScanSettingsListType ()
    {
    }

    // ScanSettingsType
    //

    ScanSettingsType::
    ScanSettingsType ()
    : ::ms::mzml::ParamGroupType (),
      sourceFileRefList_ (this),
      targetList_ (this),
      id_ (this)
    {
    }

    ScanSettingsType::
    ScanSettingsType (const id_type& id)
    : ::ms::mzml::ParamGroupType (),
      sourceFileRefList_ (this),
      targetList_ (this),
      id_ (id, this)
    {
    }

    ScanSettingsType::
    ScanSettingsType (const ScanSettingsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (x, f, c),
      sourceFileRefList_ (x.sourceFileRefList_, f, this),
      targetList_ (x.targetList_, f, this),
      id_ (x.id_, f, this)
    {
    }

    ScanSettingsType::
    ScanSettingsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (e, f | ::xml_schema::flags::base, c),
      sourceFileRefList_ (this),
      targetList_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ScanSettingsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::ms::mzml::ParamGroupType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // sourceFileRefList
        //
        if (n.name () == "sourceFileRefList" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< sourceFileRefList_type > r (
            sourceFileRefList_traits::create (i, f, this));

          if (!this->sourceFileRefList_)
          {
            this->sourceFileRefList_.set (::std::move (r));
            continue;
          }
        }

        // targetList
        //
        if (n.name () == "targetList" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< targetList_type > r (
            targetList_traits::create (i, f, this));

          if (!this->targetList_)
          {
            this->targetList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    ScanSettingsType* ScanSettingsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ScanSettingsType (*this, f, c);
    }

    ScanSettingsType& ScanSettingsType::
    operator= (const ScanSettingsType& x)
    {
      if (this != &x)
      {
        static_cast< ::ms::mzml::ParamGroupType& > (*this) = x;
        this->sourceFileRefList_ = x.sourceFileRefList_;
        this->targetList_ = x.targetList_;
        this->id_ = x.id_;
      }

      return *this;
    }

    ScanSettingsType::
    ~ScanSettingsType ()
    {
    }

    // TargetListType
    //

    TargetListType::
    TargetListType ()
    : ::xml_schema::type (),
      target_ (this),
      count_ (this)
    {
    }

    TargetListType::
    TargetListType (const count_type& count)
    : ::xml_schema::type (),
      target_ (this),
      count_ (count, this)
    {
    }

    TargetListType::
    TargetListType (const TargetListType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      target_ (x.target_, f, this),
      count_ (x.count_, f, this)
    {
    }

    TargetListType::
    TargetListType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      target_ (this),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TargetListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // target
        //
        if (n.name () == "target" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< target_type > r (
            target_traits::create (i, f, this));

          this->target_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }
    }

    TargetListType* TargetListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TargetListType (*this, f, c);
    }

    TargetListType& TargetListType::
    operator= (const TargetListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->target_ = x.target_;
        this->count_ = x.count_;
      }

      return *this;
    }

    TargetListType::
    ~TargetListType ()
    {
    }

    // RunType
    //

    RunType::
    RunType ()
    : ::ms::mzml::ParamGroupType (),
      spectrumList_ (this),
      chromatogramList_ (this),
      id_ (this),
      defaultInstrumentConfigurationRef_ (this),
      defaultSourceFileRef_ (this),
      sampleRef_ (this),
      startTimeStamp_ (this)
    {
    }

    RunType::
    RunType (const id_type& id,
             const defaultInstrumentConfigurationRef_type& defaultInstrumentConfigurationRef)
    : ::ms::mzml::ParamGroupType (),
      spectrumList_ (this),
      chromatogramList_ (this),
      id_ (id, this),
      defaultInstrumentConfigurationRef_ (defaultInstrumentConfigurationRef, this),
      defaultSourceFileRef_ (this),
      sampleRef_ (this),
      startTimeStamp_ (this)
    {
    }

    RunType::
    RunType (const RunType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (x, f, c),
      spectrumList_ (x.spectrumList_, f, this),
      chromatogramList_ (x.chromatogramList_, f, this),
      id_ (x.id_, f, this),
      defaultInstrumentConfigurationRef_ (x.defaultInstrumentConfigurationRef_, f, this),
      defaultSourceFileRef_ (x.defaultSourceFileRef_, f, this),
      sampleRef_ (x.sampleRef_, f, this),
      startTimeStamp_ (x.startTimeStamp_, f, this)
    {
    }

    RunType::
    RunType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (e, f | ::xml_schema::flags::base, c),
      spectrumList_ (this),
      chromatogramList_ (this),
      id_ (this),
      defaultInstrumentConfigurationRef_ (this),
      defaultSourceFileRef_ (this),
      sampleRef_ (this),
      startTimeStamp_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void RunType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::ms::mzml::ParamGroupType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // spectrumList
        //
        if (n.name () == "spectrumList" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< spectrumList_type > r (
            spectrumList_traits::create (i, f, this));

          if (!this->spectrumList_)
          {
            this->spectrumList_.set (::std::move (r));
            continue;
          }
        }

        // chromatogramList
        //
        if (n.name () == "chromatogramList" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< chromatogramList_type > r (
            chromatogramList_traits::create (i, f, this));

          if (!this->chromatogramList_)
          {
            this->chromatogramList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "defaultInstrumentConfigurationRef" && n.namespace_ ().empty ())
        {
          this->defaultInstrumentConfigurationRef_.set (defaultInstrumentConfigurationRef_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "defaultSourceFileRef" && n.namespace_ ().empty ())
        {
          this->defaultSourceFileRef_.set (defaultSourceFileRef_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "sampleRef" && n.namespace_ ().empty ())
        {
          this->sampleRef_.set (sampleRef_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "startTimeStamp" && n.namespace_ ().empty ())
        {
          this->startTimeStamp_.set (startTimeStamp_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }

      if (!defaultInstrumentConfigurationRef_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "defaultInstrumentConfigurationRef",
          "");
      }
    }

    RunType* RunType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RunType (*this, f, c);
    }

    RunType& RunType::
    operator= (const RunType& x)
    {
      if (this != &x)
      {
        static_cast< ::ms::mzml::ParamGroupType& > (*this) = x;
        this->spectrumList_ = x.spectrumList_;
        this->chromatogramList_ = x.chromatogramList_;
        this->id_ = x.id_;
        this->defaultInstrumentConfigurationRef_ = x.defaultInstrumentConfigurationRef_;
        this->defaultSourceFileRef_ = x.defaultSourceFileRef_;
        this->sampleRef_ = x.sampleRef_;
        this->startTimeStamp_ = x.startTimeStamp_;
      }

      return *this;
    }

    RunType::
    ~RunType ()
    {
    }

    // SourceFileRefType
    //

    SourceFileRefType::
    SourceFileRefType ()
    : ::xml_schema::type (),
      ref_ (this)
    {
    }

    SourceFileRefType::
    SourceFileRefType (const ref_type& ref)
    : ::xml_schema::type (),
      ref_ (ref, this)
    {
    }

    SourceFileRefType::
    SourceFileRefType (const SourceFileRefType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ref_ (x.ref_, f, this)
    {
    }

    SourceFileRefType::
    SourceFileRefType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ref_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SourceFileRefType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "ref" && n.namespace_ ().empty ())
        {
          this->ref_.set (ref_traits::create (i, f, this));
          continue;
        }
      }

      if (!ref_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ref",
          "");
      }
    }

    SourceFileRefType* SourceFileRefType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SourceFileRefType (*this, f, c);
    }

    SourceFileRefType& SourceFileRefType::
    operator= (const SourceFileRefType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ref_ = x.ref_;
      }

      return *this;
    }

    SourceFileRefType::
    ~SourceFileRefType ()
    {
    }

    // SourceFileRefListType
    //

    SourceFileRefListType::
    SourceFileRefListType ()
    : ::xml_schema::type (),
      sourceFileRef_ (this),
      count_ (this)
    {
    }

    SourceFileRefListType::
    SourceFileRefListType (const count_type& count)
    : ::xml_schema::type (),
      sourceFileRef_ (this),
      count_ (count, this)
    {
    }

    SourceFileRefListType::
    SourceFileRefListType (const SourceFileRefListType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      sourceFileRef_ (x.sourceFileRef_, f, this),
      count_ (x.count_, f, this)
    {
    }

    SourceFileRefListType::
    SourceFileRefListType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      sourceFileRef_ (this),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SourceFileRefListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // sourceFileRef
        //
        if (n.name () == "sourceFileRef" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< sourceFileRef_type > r (
            sourceFileRef_traits::create (i, f, this));

          this->sourceFileRef_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }
    }

    SourceFileRefListType* SourceFileRefListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SourceFileRefListType (*this, f, c);
    }

    SourceFileRefListType& SourceFileRefListType::
    operator= (const SourceFileRefListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->sourceFileRef_ = x.sourceFileRef_;
        this->count_ = x.count_;
      }

      return *this;
    }

    SourceFileRefListType::
    ~SourceFileRefListType ()
    {
    }

    // SpectrumListType
    //

    SpectrumListType::
    SpectrumListType ()
    : ::xml_schema::type (),
      spectrum_ (this),
      count_ (this),
      defaultDataProcessingRef_ (this)
    {
    }

    SpectrumListType::
    SpectrumListType (const count_type& count,
                      const defaultDataProcessingRef_type& defaultDataProcessingRef)
    : ::xml_schema::type (),
      spectrum_ (this),
      count_ (count, this),
      defaultDataProcessingRef_ (defaultDataProcessingRef, this)
    {
    }

    SpectrumListType::
    SpectrumListType (const SpectrumListType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      spectrum_ (x.spectrum_, f, this),
      count_ (x.count_, f, this),
      defaultDataProcessingRef_ (x.defaultDataProcessingRef_, f, this)
    {
    }

    SpectrumListType::
    SpectrumListType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      spectrum_ (this),
      count_ (this),
      defaultDataProcessingRef_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SpectrumListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // spectrum
        //
        if (n.name () == "spectrum" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< spectrum_type > r (
            spectrum_traits::create (i, f, this));

          this->spectrum_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "defaultDataProcessingRef" && n.namespace_ ().empty ())
        {
          this->defaultDataProcessingRef_.set (defaultDataProcessingRef_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }

      if (!defaultDataProcessingRef_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "defaultDataProcessingRef",
          "");
      }
    }

    SpectrumListType* SpectrumListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SpectrumListType (*this, f, c);
    }

    SpectrumListType& SpectrumListType::
    operator= (const SpectrumListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->spectrum_ = x.spectrum_;
        this->count_ = x.count_;
        this->defaultDataProcessingRef_ = x.defaultDataProcessingRef_;
      }

      return *this;
    }

    SpectrumListType::
    ~SpectrumListType ()
    {
    }

    // ScanWindowListType
    //

    ScanWindowListType::
    ScanWindowListType ()
    : ::xml_schema::type (),
      scanWindow_ (this),
      count_ (this)
    {
    }

    ScanWindowListType::
    ScanWindowListType (const count_type& count)
    : ::xml_schema::type (),
      scanWindow_ (this),
      count_ (count, this)
    {
    }

    ScanWindowListType::
    ScanWindowListType (const ScanWindowListType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      scanWindow_ (x.scanWindow_, f, this),
      count_ (x.count_, f, this)
    {
    }

    ScanWindowListType::
    ScanWindowListType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      scanWindow_ (this),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ScanWindowListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // scanWindow
        //
        if (n.name () == "scanWindow" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< scanWindow_type > r (
            scanWindow_traits::create (i, f, this));

          this->scanWindow_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }
    }

    ScanWindowListType* ScanWindowListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ScanWindowListType (*this, f, c);
    }

    ScanWindowListType& ScanWindowListType::
    operator= (const ScanWindowListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->scanWindow_ = x.scanWindow_;
        this->count_ = x.count_;
      }

      return *this;
    }

    ScanWindowListType::
    ~ScanWindowListType ()
    {
    }

    // ScanListType
    //

    ScanListType::
    ScanListType ()
    : ::ms::mzml::ParamGroupType (),
      scan_ (this),
      count_ (this)
    {
    }

    ScanListType::
    ScanListType (const count_type& count)
    : ::ms::mzml::ParamGroupType (),
      scan_ (this),
      count_ (count, this)
    {
    }

    ScanListType::
    ScanListType (const ScanListType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (x, f, c),
      scan_ (x.scan_, f, this),
      count_ (x.count_, f, this)
    {
    }

    ScanListType::
    ScanListType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (e, f | ::xml_schema::flags::base, c),
      scan_ (this),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ScanListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::ms::mzml::ParamGroupType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // scan
        //
        if (n.name () == "scan" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< scan_type > r (
            scan_traits::create (i, f, this));

          this->scan_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }
    }

    ScanListType* ScanListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ScanListType (*this, f, c);
    }

    ScanListType& ScanListType::
    operator= (const ScanListType& x)
    {
      if (this != &x)
      {
        static_cast< ::ms::mzml::ParamGroupType& > (*this) = x;
        this->scan_ = x.scan_;
        this->count_ = x.count_;
      }

      return *this;
    }

    ScanListType::
    ~ScanListType ()
    {
    }

    // ScanType
    //

    ScanType::
    ScanType ()
    : ::ms::mzml::ParamGroupType (),
      scanWindowList_ (this),
      spectrumRef_ (this),
      sourceFileRef_ (this),
      externalSpectrumID_ (this),
      instrumentConfigurationRef_ (this)
    {
    }

    ScanType::
    ScanType (const ScanType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (x, f, c),
      scanWindowList_ (x.scanWindowList_, f, this),
      spectrumRef_ (x.spectrumRef_, f, this),
      sourceFileRef_ (x.sourceFileRef_, f, this),
      externalSpectrumID_ (x.externalSpectrumID_, f, this),
      instrumentConfigurationRef_ (x.instrumentConfigurationRef_, f, this)
    {
    }

    ScanType::
    ScanType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (e, f | ::xml_schema::flags::base, c),
      scanWindowList_ (this),
      spectrumRef_ (this),
      sourceFileRef_ (this),
      externalSpectrumID_ (this),
      instrumentConfigurationRef_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::ms::mzml::ParamGroupType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // scanWindowList
        //
        if (n.name () == "scanWindowList" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< scanWindowList_type > r (
            scanWindowList_traits::create (i, f, this));

          if (!this->scanWindowList_)
          {
            this->scanWindowList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "spectrumRef" && n.namespace_ ().empty ())
        {
          this->spectrumRef_.set (spectrumRef_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "sourceFileRef" && n.namespace_ ().empty ())
        {
          this->sourceFileRef_.set (sourceFileRef_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "externalSpectrumID" && n.namespace_ ().empty ())
        {
          this->externalSpectrumID_.set (externalSpectrumID_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "instrumentConfigurationRef" && n.namespace_ ().empty ())
        {
          this->instrumentConfigurationRef_.set (instrumentConfigurationRef_traits::create (i, f, this));
          continue;
        }
      }
    }

    ScanType* ScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ScanType (*this, f, c);
    }

    ScanType& ScanType::
    operator= (const ScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::ms::mzml::ParamGroupType& > (*this) = x;
        this->scanWindowList_ = x.scanWindowList_;
        this->spectrumRef_ = x.spectrumRef_;
        this->sourceFileRef_ = x.sourceFileRef_;
        this->externalSpectrumID_ = x.externalSpectrumID_;
        this->instrumentConfigurationRef_ = x.instrumentConfigurationRef_;
      }

      return *this;
    }

    ScanType::
    ~ScanType ()
    {
    }

    // PrecursorListType
    //

    PrecursorListType::
    PrecursorListType ()
    : ::xml_schema::type (),
      precursor_ (this),
      count_ (this)
    {
    }

    PrecursorListType::
    PrecursorListType (const count_type& count)
    : ::xml_schema::type (),
      precursor_ (this),
      count_ (count, this)
    {
    }

    PrecursorListType::
    PrecursorListType (const PrecursorListType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      precursor_ (x.precursor_, f, this),
      count_ (x.count_, f, this)
    {
    }

    PrecursorListType::
    PrecursorListType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      precursor_ (this),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PrecursorListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // precursor
        //
        if (n.name () == "precursor" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< precursor_type > r (
            precursor_traits::create (i, f, this));

          this->precursor_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }
    }

    PrecursorListType* PrecursorListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PrecursorListType (*this, f, c);
    }

    PrecursorListType& PrecursorListType::
    operator= (const PrecursorListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->precursor_ = x.precursor_;
        this->count_ = x.count_;
      }

      return *this;
    }

    PrecursorListType::
    ~PrecursorListType ()
    {
    }

    // PrecursorType
    //

    PrecursorType::
    PrecursorType ()
    : ::xml_schema::type (),
      isolationWindow_ (this),
      selectedIonList_ (this),
      activation_ (this),
      spectrumRef_ (this),
      sourceFileRef_ (this),
      externalSpectrumID_ (this)
    {
    }

    PrecursorType::
    PrecursorType (const activation_type& activation)
    : ::xml_schema::type (),
      isolationWindow_ (this),
      selectedIonList_ (this),
      activation_ (activation, this),
      spectrumRef_ (this),
      sourceFileRef_ (this),
      externalSpectrumID_ (this)
    {
    }

    PrecursorType::
    PrecursorType (::std::unique_ptr< activation_type > activation)
    : ::xml_schema::type (),
      isolationWindow_ (this),
      selectedIonList_ (this),
      activation_ (std::move (activation), this),
      spectrumRef_ (this),
      sourceFileRef_ (this),
      externalSpectrumID_ (this)
    {
    }

    PrecursorType::
    PrecursorType (const PrecursorType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      isolationWindow_ (x.isolationWindow_, f, this),
      selectedIonList_ (x.selectedIonList_, f, this),
      activation_ (x.activation_, f, this),
      spectrumRef_ (x.spectrumRef_, f, this),
      sourceFileRef_ (x.sourceFileRef_, f, this),
      externalSpectrumID_ (x.externalSpectrumID_, f, this)
    {
    }

    PrecursorType::
    PrecursorType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      isolationWindow_ (this),
      selectedIonList_ (this),
      activation_ (this),
      spectrumRef_ (this),
      sourceFileRef_ (this),
      externalSpectrumID_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PrecursorType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // isolationWindow
        //
        if (n.name () == "isolationWindow" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< isolationWindow_type > r (
            isolationWindow_traits::create (i, f, this));

          if (!this->isolationWindow_)
          {
            this->isolationWindow_.set (::std::move (r));
            continue;
          }
        }

        // selectedIonList
        //
        if (n.name () == "selectedIonList" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< selectedIonList_type > r (
            selectedIonList_traits::create (i, f, this));

          if (!this->selectedIonList_)
          {
            this->selectedIonList_.set (::std::move (r));
            continue;
          }
        }

        // activation
        //
        if (n.name () == "activation" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< activation_type > r (
            activation_traits::create (i, f, this));

          if (!activation_.present ())
          {
            this->activation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!activation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "activation",
          "http://psi.hupo.org/ms/mzml");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "spectrumRef" && n.namespace_ ().empty ())
        {
          this->spectrumRef_.set (spectrumRef_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "sourceFileRef" && n.namespace_ ().empty ())
        {
          this->sourceFileRef_.set (sourceFileRef_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "externalSpectrumID" && n.namespace_ ().empty ())
        {
          this->externalSpectrumID_.set (externalSpectrumID_traits::create (i, f, this));
          continue;
        }
      }
    }

    PrecursorType* PrecursorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PrecursorType (*this, f, c);
    }

    PrecursorType& PrecursorType::
    operator= (const PrecursorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->isolationWindow_ = x.isolationWindow_;
        this->selectedIonList_ = x.selectedIonList_;
        this->activation_ = x.activation_;
        this->spectrumRef_ = x.spectrumRef_;
        this->sourceFileRef_ = x.sourceFileRef_;
        this->externalSpectrumID_ = x.externalSpectrumID_;
      }

      return *this;
    }

    PrecursorType::
    ~PrecursorType ()
    {
    }

    // SelectedIonListType
    //

    SelectedIonListType::
    SelectedIonListType ()
    : ::xml_schema::type (),
      selectedIon_ (this),
      count_ (this)
    {
    }

    SelectedIonListType::
    SelectedIonListType (const count_type& count)
    : ::xml_schema::type (),
      selectedIon_ (this),
      count_ (count, this)
    {
    }

    SelectedIonListType::
    SelectedIonListType (const SelectedIonListType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      selectedIon_ (x.selectedIon_, f, this),
      count_ (x.count_, f, this)
    {
    }

    SelectedIonListType::
    SelectedIonListType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      selectedIon_ (this),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SelectedIonListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // selectedIon
        //
        if (n.name () == "selectedIon" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< selectedIon_type > r (
            selectedIon_traits::create (i, f, this));

          this->selectedIon_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }
    }

    SelectedIonListType* SelectedIonListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SelectedIonListType (*this, f, c);
    }

    SelectedIonListType& SelectedIonListType::
    operator= (const SelectedIonListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->selectedIon_ = x.selectedIon_;
        this->count_ = x.count_;
      }

      return *this;
    }

    SelectedIonListType::
    ~SelectedIonListType ()
    {
    }

    // ProductListType
    //

    ProductListType::
    ProductListType ()
    : ::xml_schema::type (),
      product_ (this),
      count_ (this)
    {
    }

    ProductListType::
    ProductListType (const count_type& count)
    : ::xml_schema::type (),
      product_ (this),
      count_ (count, this)
    {
    }

    ProductListType::
    ProductListType (const ProductListType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      product_ (x.product_, f, this),
      count_ (x.count_, f, this)
    {
    }

    ProductListType::
    ProductListType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      product_ (this),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ProductListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // product
        //
        if (n.name () == "product" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< product_type > r (
            product_traits::create (i, f, this));

          this->product_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }
    }

    ProductListType* ProductListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProductListType (*this, f, c);
    }

    ProductListType& ProductListType::
    operator= (const ProductListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->product_ = x.product_;
        this->count_ = x.count_;
      }

      return *this;
    }

    ProductListType::
    ~ProductListType ()
    {
    }

    // ProductType
    //

    ProductType::
    ProductType ()
    : ::xml_schema::type (),
      isolationWindow_ (this)
    {
    }

    ProductType::
    ProductType (const ProductType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      isolationWindow_ (x.isolationWindow_, f, this)
    {
    }

    ProductType::
    ProductType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      isolationWindow_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ProductType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // isolationWindow
        //
        if (n.name () == "isolationWindow" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< isolationWindow_type > r (
            isolationWindow_traits::create (i, f, this));

          if (!this->isolationWindow_)
          {
            this->isolationWindow_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ProductType* ProductType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProductType (*this, f, c);
    }

    ProductType& ProductType::
    operator= (const ProductType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->isolationWindow_ = x.isolationWindow_;
      }

      return *this;
    }

    ProductType::
    ~ProductType ()
    {
    }

    // BinaryDataArrayListType
    //

    BinaryDataArrayListType::
    BinaryDataArrayListType ()
    : ::xml_schema::type (),
      binaryDataArray_ (this),
      count_ (this)
    {
    }

    BinaryDataArrayListType::
    BinaryDataArrayListType (const count_type& count)
    : ::xml_schema::type (),
      binaryDataArray_ (this),
      count_ (count, this)
    {
    }

    BinaryDataArrayListType::
    BinaryDataArrayListType (const BinaryDataArrayListType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      binaryDataArray_ (x.binaryDataArray_, f, this),
      count_ (x.count_, f, this)
    {
    }

    BinaryDataArrayListType::
    BinaryDataArrayListType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      binaryDataArray_ (this),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void BinaryDataArrayListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // binaryDataArray
        //
        if (n.name () == "binaryDataArray" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< binaryDataArray_type > r (
            binaryDataArray_traits::create (i, f, this));

          this->binaryDataArray_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }
    }

    BinaryDataArrayListType* BinaryDataArrayListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BinaryDataArrayListType (*this, f, c);
    }

    BinaryDataArrayListType& BinaryDataArrayListType::
    operator= (const BinaryDataArrayListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->binaryDataArray_ = x.binaryDataArray_;
        this->count_ = x.count_;
      }

      return *this;
    }

    BinaryDataArrayListType::
    ~BinaryDataArrayListType ()
    {
    }

    // BinaryDataArrayType
    //

    BinaryDataArrayType::
    BinaryDataArrayType ()
    : ::ms::mzml::ParamGroupType (),
      binary_ (this),
      arrayLength_ (this),
      dataProcessingRef_ (this),
      encodedLength_ (this)
    {
    }

    BinaryDataArrayType::
    BinaryDataArrayType (const binary_type& binary,
                         const encodedLength_type& encodedLength)
    : ::ms::mzml::ParamGroupType (),
      binary_ (binary, this),
      arrayLength_ (this),
      dataProcessingRef_ (this),
      encodedLength_ (encodedLength, this)
    {
    }

    BinaryDataArrayType::
    BinaryDataArrayType (const BinaryDataArrayType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (x, f, c),
      binary_ (x.binary_, f, this),
      arrayLength_ (x.arrayLength_, f, this),
      dataProcessingRef_ (x.dataProcessingRef_, f, this),
      encodedLength_ (x.encodedLength_, f, this)
    {
    }

    BinaryDataArrayType::
    BinaryDataArrayType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (e, f | ::xml_schema::flags::base, c),
      binary_ (this),
      arrayLength_ (this),
      dataProcessingRef_ (this),
      encodedLength_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void BinaryDataArrayType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::ms::mzml::ParamGroupType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // binary
        //
        if (n.name () == "binary" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< binary_type > r (
            binary_traits::create (i, f, this));

          if (!binary_.present ())
          {
            this->binary_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!binary_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "binary",
          "http://psi.hupo.org/ms/mzml");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "arrayLength" && n.namespace_ ().empty ())
        {
          this->arrayLength_.set (arrayLength_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "dataProcessingRef" && n.namespace_ ().empty ())
        {
          this->dataProcessingRef_.set (dataProcessingRef_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "encodedLength" && n.namespace_ ().empty ())
        {
          this->encodedLength_.set (encodedLength_traits::create (i, f, this));
          continue;
        }
      }

      if (!encodedLength_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "encodedLength",
          "");
      }
    }

    BinaryDataArrayType* BinaryDataArrayType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BinaryDataArrayType (*this, f, c);
    }

    BinaryDataArrayType& BinaryDataArrayType::
    operator= (const BinaryDataArrayType& x)
    {
      if (this != &x)
      {
        static_cast< ::ms::mzml::ParamGroupType& > (*this) = x;
        this->binary_ = x.binary_;
        this->arrayLength_ = x.arrayLength_;
        this->dataProcessingRef_ = x.dataProcessingRef_;
        this->encodedLength_ = x.encodedLength_;
      }

      return *this;
    }

    BinaryDataArrayType::
    ~BinaryDataArrayType ()
    {
    }

    // SpectrumType
    //

    SpectrumType::
    SpectrumType ()
    : ::ms::mzml::ParamGroupType (),
      scanList_ (this),
      precursorList_ (this),
      productList_ (this),
      binaryDataArrayList_ (this),
      id_ (this),
      spotID_ (this),
      index_ (this),
      defaultArrayLength_ (this),
      dataProcessingRef_ (this),
      sourceFileRef_ (this)
    {
    }

    SpectrumType::
    SpectrumType (const id_type& id,
                  const index_type& index,
                  const defaultArrayLength_type& defaultArrayLength)
    : ::ms::mzml::ParamGroupType (),
      scanList_ (this),
      precursorList_ (this),
      productList_ (this),
      binaryDataArrayList_ (this),
      id_ (id, this),
      spotID_ (this),
      index_ (index, this),
      defaultArrayLength_ (defaultArrayLength, this),
      dataProcessingRef_ (this),
      sourceFileRef_ (this)
    {
    }

    SpectrumType::
    SpectrumType (const SpectrumType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (x, f, c),
      scanList_ (x.scanList_, f, this),
      precursorList_ (x.precursorList_, f, this),
      productList_ (x.productList_, f, this),
      binaryDataArrayList_ (x.binaryDataArrayList_, f, this),
      id_ (x.id_, f, this),
      spotID_ (x.spotID_, f, this),
      index_ (x.index_, f, this),
      defaultArrayLength_ (x.defaultArrayLength_, f, this),
      dataProcessingRef_ (x.dataProcessingRef_, f, this),
      sourceFileRef_ (x.sourceFileRef_, f, this)
    {
    }

    SpectrumType::
    SpectrumType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (e, f | ::xml_schema::flags::base, c),
      scanList_ (this),
      precursorList_ (this),
      productList_ (this),
      binaryDataArrayList_ (this),
      id_ (this),
      spotID_ (this),
      index_ (this),
      defaultArrayLength_ (this),
      dataProcessingRef_ (this),
      sourceFileRef_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SpectrumType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::ms::mzml::ParamGroupType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // scanList
        //
        if (n.name () == "scanList" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< scanList_type > r (
            scanList_traits::create (i, f, this));

          if (!this->scanList_)
          {
            this->scanList_.set (::std::move (r));
            continue;
          }
        }

        // precursorList
        //
        if (n.name () == "precursorList" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< precursorList_type > r (
            precursorList_traits::create (i, f, this));

          if (!this->precursorList_)
          {
            this->precursorList_.set (::std::move (r));
            continue;
          }
        }

        // productList
        //
        if (n.name () == "productList" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< productList_type > r (
            productList_traits::create (i, f, this));

          if (!this->productList_)
          {
            this->productList_.set (::std::move (r));
            continue;
          }
        }

        // binaryDataArrayList
        //
        if (n.name () == "binaryDataArrayList" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< binaryDataArrayList_type > r (
            binaryDataArrayList_traits::create (i, f, this));

          if (!this->binaryDataArrayList_)
          {
            this->binaryDataArrayList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "spotID" && n.namespace_ ().empty ())
        {
          this->spotID_.set (spotID_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "index" && n.namespace_ ().empty ())
        {
          this->index_.set (index_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "defaultArrayLength" && n.namespace_ ().empty ())
        {
          this->defaultArrayLength_.set (defaultArrayLength_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "dataProcessingRef" && n.namespace_ ().empty ())
        {
          this->dataProcessingRef_.set (dataProcessingRef_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "sourceFileRef" && n.namespace_ ().empty ())
        {
          this->sourceFileRef_.set (sourceFileRef_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }

      if (!index_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "index",
          "");
      }

      if (!defaultArrayLength_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "defaultArrayLength",
          "");
      }
    }

    SpectrumType* SpectrumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SpectrumType (*this, f, c);
    }

    SpectrumType& SpectrumType::
    operator= (const SpectrumType& x)
    {
      if (this != &x)
      {
        static_cast< ::ms::mzml::ParamGroupType& > (*this) = x;
        this->scanList_ = x.scanList_;
        this->precursorList_ = x.precursorList_;
        this->productList_ = x.productList_;
        this->binaryDataArrayList_ = x.binaryDataArrayList_;
        this->id_ = x.id_;
        this->spotID_ = x.spotID_;
        this->index_ = x.index_;
        this->defaultArrayLength_ = x.defaultArrayLength_;
        this->dataProcessingRef_ = x.dataProcessingRef_;
        this->sourceFileRef_ = x.sourceFileRef_;
      }

      return *this;
    }

    SpectrumType::
    ~SpectrumType ()
    {
    }

    // ChromatogramListType
    //

    ChromatogramListType::
    ChromatogramListType ()
    : ::xml_schema::type (),
      chromatogram_ (this),
      count_ (this),
      defaultDataProcessingRef_ (this)
    {
    }

    ChromatogramListType::
    ChromatogramListType (const count_type& count,
                          const defaultDataProcessingRef_type& defaultDataProcessingRef)
    : ::xml_schema::type (),
      chromatogram_ (this),
      count_ (count, this),
      defaultDataProcessingRef_ (defaultDataProcessingRef, this)
    {
    }

    ChromatogramListType::
    ChromatogramListType (const ChromatogramListType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      chromatogram_ (x.chromatogram_, f, this),
      count_ (x.count_, f, this),
      defaultDataProcessingRef_ (x.defaultDataProcessingRef_, f, this)
    {
    }

    ChromatogramListType::
    ChromatogramListType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      chromatogram_ (this),
      count_ (this),
      defaultDataProcessingRef_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ChromatogramListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // chromatogram
        //
        if (n.name () == "chromatogram" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< chromatogram_type > r (
            chromatogram_traits::create (i, f, this));

          this->chromatogram_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "defaultDataProcessingRef" && n.namespace_ ().empty ())
        {
          this->defaultDataProcessingRef_.set (defaultDataProcessingRef_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }

      if (!defaultDataProcessingRef_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "defaultDataProcessingRef",
          "");
      }
    }

    ChromatogramListType* ChromatogramListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ChromatogramListType (*this, f, c);
    }

    ChromatogramListType& ChromatogramListType::
    operator= (const ChromatogramListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->chromatogram_ = x.chromatogram_;
        this->count_ = x.count_;
        this->defaultDataProcessingRef_ = x.defaultDataProcessingRef_;
      }

      return *this;
    }

    ChromatogramListType::
    ~ChromatogramListType ()
    {
    }

    // ChromatogramType
    //

    ChromatogramType::
    ChromatogramType ()
    : ::ms::mzml::ParamGroupType (),
      precursor_ (this),
      product_ (this),
      binaryDataArrayList_ (this),
      id_ (this),
      index_ (this),
      defaultArrayLength_ (this),
      dataProcessingRef_ (this)
    {
    }

    ChromatogramType::
    ChromatogramType (const binaryDataArrayList_type& binaryDataArrayList,
                      const id_type& id,
                      const index_type& index,
                      const defaultArrayLength_type& defaultArrayLength)
    : ::ms::mzml::ParamGroupType (),
      precursor_ (this),
      product_ (this),
      binaryDataArrayList_ (binaryDataArrayList, this),
      id_ (id, this),
      index_ (index, this),
      defaultArrayLength_ (defaultArrayLength, this),
      dataProcessingRef_ (this)
    {
    }

    ChromatogramType::
    ChromatogramType (::std::unique_ptr< binaryDataArrayList_type > binaryDataArrayList,
                      const id_type& id,
                      const index_type& index,
                      const defaultArrayLength_type& defaultArrayLength)
    : ::ms::mzml::ParamGroupType (),
      precursor_ (this),
      product_ (this),
      binaryDataArrayList_ (std::move (binaryDataArrayList), this),
      id_ (id, this),
      index_ (index, this),
      defaultArrayLength_ (defaultArrayLength, this),
      dataProcessingRef_ (this)
    {
    }

    ChromatogramType::
    ChromatogramType (const ChromatogramType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (x, f, c),
      precursor_ (x.precursor_, f, this),
      product_ (x.product_, f, this),
      binaryDataArrayList_ (x.binaryDataArrayList_, f, this),
      id_ (x.id_, f, this),
      index_ (x.index_, f, this),
      defaultArrayLength_ (x.defaultArrayLength_, f, this),
      dataProcessingRef_ (x.dataProcessingRef_, f, this)
    {
    }

    ChromatogramType::
    ChromatogramType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::ms::mzml::ParamGroupType (e, f | ::xml_schema::flags::base, c),
      precursor_ (this),
      product_ (this),
      binaryDataArrayList_ (this),
      id_ (this),
      index_ (this),
      defaultArrayLength_ (this),
      dataProcessingRef_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ChromatogramType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::ms::mzml::ParamGroupType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // precursor
        //
        if (n.name () == "precursor" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< precursor_type > r (
            precursor_traits::create (i, f, this));

          if (!this->precursor_)
          {
            this->precursor_.set (::std::move (r));
            continue;
          }
        }

        // product
        //
        if (n.name () == "product" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< product_type > r (
            product_traits::create (i, f, this));

          if (!this->product_)
          {
            this->product_.set (::std::move (r));
            continue;
          }
        }

        // binaryDataArrayList
        //
        if (n.name () == "binaryDataArrayList" && n.namespace_ () == "http://psi.hupo.org/ms/mzml")
        {
          ::std::unique_ptr< binaryDataArrayList_type > r (
            binaryDataArrayList_traits::create (i, f, this));

          if (!binaryDataArrayList_.present ())
          {
            this->binaryDataArrayList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!binaryDataArrayList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "binaryDataArrayList",
          "http://psi.hupo.org/ms/mzml");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "index" && n.namespace_ ().empty ())
        {
          this->index_.set (index_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "defaultArrayLength" && n.namespace_ ().empty ())
        {
          this->defaultArrayLength_.set (defaultArrayLength_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "dataProcessingRef" && n.namespace_ ().empty ())
        {
          this->dataProcessingRef_.set (dataProcessingRef_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }

      if (!index_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "index",
          "");
      }

      if (!defaultArrayLength_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "defaultArrayLength",
          "");
      }
    }

    ChromatogramType* ChromatogramType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ChromatogramType (*this, f, c);
    }

    ChromatogramType& ChromatogramType::
    operator= (const ChromatogramType& x)
    {
      if (this != &x)
      {
        static_cast< ::ms::mzml::ParamGroupType& > (*this) = x;
        this->precursor_ = x.precursor_;
        this->product_ = x.product_;
        this->binaryDataArrayList_ = x.binaryDataArrayList_;
        this->id_ = x.id_;
        this->index_ = x.index_;
        this->defaultArrayLength_ = x.defaultArrayLength_;
        this->dataProcessingRef_ = x.dataProcessingRef_;
      }

      return *this;
    }

    ChromatogramType::
    ~ChromatogramType ()
    {
    }

    // id
    //

    id::
    id ()
    : ::xml_schema::string ()
    {
    }

    id::
    id (const char* _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    id::
    id (const ::std::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    id::
    id (const ::xml_schema::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    id::
    id (const id& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    id::
    id (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    id::
    id (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    id::
    id (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    id* id::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class id (*this, f, c);
    }

    id::
    ~id ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace ms
{
  namespace mzml
  {
    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::ms::mzml::mzMLType > (
        ::ms::mzml::mzML (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::ms::mzml::mzMLType > (
        ::ms::mzml::mzML (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::ms::mzml::mzMLType > (
        ::ms::mzml::mzML (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::ms::mzml::mzML (isrc, f, p);
    }

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::ms::mzml::mzML (isrc, h, f, p);
    }

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::ms::mzml::mzML (isrc, h, f, p);
    }

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::ms::mzml::mzML (isrc, f, p);
    }

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::ms::mzml::mzML (isrc, h, f, p);
    }

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::ms::mzml::mzML (isrc, h, f, p);
    }

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::ms::mzml::mzMLType > (
        ::ms::mzml::mzML (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::ms::mzml::mzMLType > (
        ::ms::mzml::mzML (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::ms::mzml::mzMLType > (
        ::ms::mzml::mzML (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::ms::mzml::mzMLType > (
          ::ms::mzml::mzML (
            std::move (d), f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "mzML" &&
          n.namespace_ () == "http://psi.hupo.org/ms/mzml")
      {
        ::std::unique_ptr< ::ms::mzml::mzMLType > r (
          ::xsd::cxx::tree::traits< ::ms::mzml::mzMLType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "mzML",
        "http://psi.hupo.org/ms/mzml");
    }

    ::std::unique_ptr< ::ms::mzml::mzMLType >
    mzML (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "mzML" &&
          n.namespace_ () == "http://psi.hupo.org/ms/mzml")
      {
        ::std::unique_ptr< ::ms::mzml::mzMLType > r (
          ::xsd::cxx::tree::traits< ::ms::mzml::mzMLType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "mzML",
        "http://psi.hupo.org/ms/mzml");
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace ms
{
  namespace mzml
  {
    void
    operator<< (::xercesc::DOMElement& e, const mzMLType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // cvList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "cvList",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << i.cvList ();
      }

      // fileDescription
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "fileDescription",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << i.fileDescription ();
      }

      // referenceableParamGroupList
      //
      if (i.referenceableParamGroupList ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "referenceableParamGroupList",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *i.referenceableParamGroupList ();
      }

      // sampleList
      //
      if (i.sampleList ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "sampleList",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *i.sampleList ();
      }

      // softwareList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "softwareList",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << i.softwareList ();
      }

      // scanSettingsList
      //
      if (i.scanSettingsList ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "scanSettingsList",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *i.scanSettingsList ();
      }

      // instrumentConfigurationList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "instrumentConfigurationList",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << i.instrumentConfigurationList ();
      }

      // dataProcessingList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "dataProcessingList",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << i.dataProcessingList ();
      }

      // run
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "run",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << i.run ();
      }

      // accession
      //
      if (i.accession ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "accession",
            e));

        a << *i.accession ();
      }

      // version
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "version",
            e));

        a << i.version ();
      }

      // id
      //
      if (i.id ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FileDescriptionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // fileContent
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "fileContent",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << i.fileContent ();
      }

      // sourceFileList
      //
      if (i.sourceFileList ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "sourceFileList",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *i.sourceFileList ();
      }

      // contact
      //
      for (FileDescriptionType::contact_const_iterator
           b (i.contact ().begin ()), n (i.contact ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "contact",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SourceFileListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // sourceFile
      //
      for (SourceFileListType::sourceFile_const_iterator
           b (i.sourceFile ().begin ()), n (i.sourceFile ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "sourceFile",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // count
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ParamGroupType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // referenceableParamGroupRef
      //
      for (ParamGroupType::referenceableParamGroupRef_const_iterator
           b (i.referenceableParamGroupRef ().begin ()), n (i.referenceableParamGroupRef ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "referenceableParamGroupRef",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // cvParam
      //
      for (ParamGroupType::cvParam_const_iterator
           b (i.cvParam ().begin ()), n (i.cvParam ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "cvParam",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // userParam
      //
      for (ParamGroupType::userParam_const_iterator
           b (i.userParam ().begin ()), n (i.userParam ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "userParam",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SourceFileType& i)
    {
      e << static_cast< const ::ms::mzml::ParamGroupType& > (i);

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.name ();
      }

      // location
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "location",
            e));

        a << i.location ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CVType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }

      // fullName
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "fullName",
            e));

        a << i.fullName ();
      }

      // version
      //
      if (i.version ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "version",
            e));

        a << *i.version ();
      }

      // URI
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "URI",
            e));

        a << i.URI ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CVListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // cv
      //
      for (CVListType::cv_const_iterator
           b (i.cv ().begin ()), n (i.cv ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "cv",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // count
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ReferenceableParamGroupListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // referenceableParamGroup
      //
      for (ReferenceableParamGroupListType::referenceableParamGroup_const_iterator
           b (i.referenceableParamGroup ().begin ()), n (i.referenceableParamGroup ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "referenceableParamGroup",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // count
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ReferenceableParamGroupType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // cvParam
      //
      for (ReferenceableParamGroupType::cvParam_const_iterator
           b (i.cvParam ().begin ()), n (i.cvParam ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "cvParam",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // userParam
      //
      for (ReferenceableParamGroupType::userParam_const_iterator
           b (i.userParam ().begin ()), n (i.userParam ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "userParam",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CVParamType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // cvRef
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "cvRef",
            e));

        a << i.cvRef ();
      }

      // accession
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "accession",
            e));

        a << i.accession ();
      }

      // value
      //
      if (i.value ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "value",
            e));

        a << *i.value ();
      }

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.name ();
      }

      // unitAccession
      //
      if (i.unitAccession ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "unitAccession",
            e));

        a << *i.unitAccession ();
      }

      // unitName
      //
      if (i.unitName ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "unitName",
            e));

        a << *i.unitName ();
      }

      // unitCvRef
      //
      if (i.unitCvRef ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "unitCvRef",
            e));

        a << *i.unitCvRef ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const UserParamType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.name ();
      }

      // type
      //
      if (i.type ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << *i.type ();
      }

      // value
      //
      if (i.value ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "value",
            e));

        a << *i.value ();
      }

      // unitAccession
      //
      if (i.unitAccession ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "unitAccession",
            e));

        a << *i.unitAccession ();
      }

      // unitName
      //
      if (i.unitName ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "unitName",
            e));

        a << *i.unitName ();
      }

      // unitCvRef
      //
      if (i.unitCvRef ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "unitCvRef",
            e));

        a << *i.unitCvRef ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ReferenceableParamGroupRefType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ref
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ref",
            e));

        a << i.ref ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SampleListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // sample
      //
      for (SampleListType::sample_const_iterator
           b (i.sample ().begin ()), n (i.sample ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "sample",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // count
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SampleType& i)
    {
      e << static_cast< const ::ms::mzml::ParamGroupType& > (i);

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }

      // name
      //
      if (i.name ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << *i.name ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const InstrumentConfigurationListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // instrumentConfiguration
      //
      for (InstrumentConfigurationListType::instrumentConfiguration_const_iterator
           b (i.instrumentConfiguration ().begin ()), n (i.instrumentConfiguration ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "instrumentConfiguration",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // count
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ComponentType& i)
    {
      e << static_cast< const ::ms::mzml::ParamGroupType& > (i);

      // order
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "order",
            e));

        a << i.order ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SourceComponentType& i)
    {
      e << static_cast< const ::ms::mzml::ComponentType& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const DetectorComponentType& i)
    {
      e << static_cast< const ::ms::mzml::ComponentType& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const AnalyzerComponentType& i)
    {
      e << static_cast< const ::ms::mzml::ComponentType& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const ComponentListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // source
      //
      for (ComponentListType::source_const_iterator
           b (i.source ().begin ()), n (i.source ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "source",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // analyzer
      //
      for (ComponentListType::analyzer_const_iterator
           b (i.analyzer ().begin ()), n (i.analyzer ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "analyzer",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // detector
      //
      for (ComponentListType::detector_const_iterator
           b (i.detector ().begin ()), n (i.detector ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "detector",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // count
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const InstrumentConfigurationType& i)
    {
      e << static_cast< const ::ms::mzml::ParamGroupType& > (i);

      // componentList
      //
      if (i.componentList ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "componentList",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *i.componentList ();
      }

      // softwareRef
      //
      if (i.softwareRef ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "softwareRef",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *i.softwareRef ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }

      // scanSettingsRef
      //
      if (i.scanSettingsRef ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "scanSettingsRef",
            e));

        a << *i.scanSettingsRef ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SoftwareRefType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ref
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ref",
            e));

        a << i.ref ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SoftwareListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // software
      //
      for (SoftwareListType::software_const_iterator
           b (i.software ().begin ()), n (i.software ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "software",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // count
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SoftwareType& i)
    {
      e << static_cast< const ::ms::mzml::ParamGroupType& > (i);

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }

      // version
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "version",
            e));

        a << i.version ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DataProcessingListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // dataProcessing
      //
      for (DataProcessingListType::dataProcessing_const_iterator
           b (i.dataProcessing ().begin ()), n (i.dataProcessing ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "dataProcessing",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // count
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DataProcessingType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // processingMethod
      //
      for (DataProcessingType::processingMethod_const_iterator
           b (i.processingMethod ().begin ()), n (i.processingMethod ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "processingMethod",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ProcessingMethodType& i)
    {
      e << static_cast< const ::ms::mzml::ParamGroupType& > (i);

      // order
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "order",
            e));

        a << i.order ();
      }

      // softwareRef
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "softwareRef",
            e));

        a << i.softwareRef ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ScanSettingsListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // scanSettings
      //
      for (ScanSettingsListType::scanSettings_const_iterator
           b (i.scanSettings ().begin ()), n (i.scanSettings ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "scanSettings",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // count
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ScanSettingsType& i)
    {
      e << static_cast< const ::ms::mzml::ParamGroupType& > (i);

      // sourceFileRefList
      //
      if (i.sourceFileRefList ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "sourceFileRefList",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *i.sourceFileRefList ();
      }

      // targetList
      //
      if (i.targetList ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "targetList",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *i.targetList ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TargetListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // target
      //
      for (TargetListType::target_const_iterator
           b (i.target ().begin ()), n (i.target ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "target",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // count
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const RunType& i)
    {
      e << static_cast< const ::ms::mzml::ParamGroupType& > (i);

      // spectrumList
      //
      if (i.spectrumList ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "spectrumList",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *i.spectrumList ();
      }

      // chromatogramList
      //
      if (i.chromatogramList ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "chromatogramList",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *i.chromatogramList ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }

      // defaultInstrumentConfigurationRef
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "defaultInstrumentConfigurationRef",
            e));

        a << i.defaultInstrumentConfigurationRef ();
      }

      // defaultSourceFileRef
      //
      if (i.defaultSourceFileRef ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "defaultSourceFileRef",
            e));

        a << *i.defaultSourceFileRef ();
      }

      // sampleRef
      //
      if (i.sampleRef ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "sampleRef",
            e));

        a << *i.sampleRef ();
      }

      // startTimeStamp
      //
      if (i.startTimeStamp ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "startTimeStamp",
            e));

        a << *i.startTimeStamp ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SourceFileRefType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ref
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ref",
            e));

        a << i.ref ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SourceFileRefListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // sourceFileRef
      //
      for (SourceFileRefListType::sourceFileRef_const_iterator
           b (i.sourceFileRef ().begin ()), n (i.sourceFileRef ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "sourceFileRef",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // count
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SpectrumListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // spectrum
      //
      for (SpectrumListType::spectrum_const_iterator
           b (i.spectrum ().begin ()), n (i.spectrum ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "spectrum",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // count
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "count",
            e));

        a << i.count ();
      }

      // defaultDataProcessingRef
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "defaultDataProcessingRef",
            e));

        a << i.defaultDataProcessingRef ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ScanWindowListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // scanWindow
      //
      for (ScanWindowListType::scanWindow_const_iterator
           b (i.scanWindow ().begin ()), n (i.scanWindow ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "scanWindow",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // count
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ScanListType& i)
    {
      e << static_cast< const ::ms::mzml::ParamGroupType& > (i);

      // scan
      //
      for (ScanListType::scan_const_iterator
           b (i.scan ().begin ()), n (i.scan ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "scan",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // count
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ScanType& i)
    {
      e << static_cast< const ::ms::mzml::ParamGroupType& > (i);

      // scanWindowList
      //
      if (i.scanWindowList ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "scanWindowList",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *i.scanWindowList ();
      }

      // spectrumRef
      //
      if (i.spectrumRef ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "spectrumRef",
            e));

        a << *i.spectrumRef ();
      }

      // sourceFileRef
      //
      if (i.sourceFileRef ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "sourceFileRef",
            e));

        a << *i.sourceFileRef ();
      }

      // externalSpectrumID
      //
      if (i.externalSpectrumID ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "externalSpectrumID",
            e));

        a << *i.externalSpectrumID ();
      }

      // instrumentConfigurationRef
      //
      if (i.instrumentConfigurationRef ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "instrumentConfigurationRef",
            e));

        a << *i.instrumentConfigurationRef ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PrecursorListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // precursor
      //
      for (PrecursorListType::precursor_const_iterator
           b (i.precursor ().begin ()), n (i.precursor ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "precursor",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // count
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PrecursorType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // isolationWindow
      //
      if (i.isolationWindow ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "isolationWindow",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *i.isolationWindow ();
      }

      // selectedIonList
      //
      if (i.selectedIonList ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "selectedIonList",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *i.selectedIonList ();
      }

      // activation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "activation",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << i.activation ();
      }

      // spectrumRef
      //
      if (i.spectrumRef ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "spectrumRef",
            e));

        a << *i.spectrumRef ();
      }

      // sourceFileRef
      //
      if (i.sourceFileRef ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "sourceFileRef",
            e));

        a << *i.sourceFileRef ();
      }

      // externalSpectrumID
      //
      if (i.externalSpectrumID ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "externalSpectrumID",
            e));

        a << *i.externalSpectrumID ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SelectedIonListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // selectedIon
      //
      for (SelectedIonListType::selectedIon_const_iterator
           b (i.selectedIon ().begin ()), n (i.selectedIon ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "selectedIon",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // count
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ProductListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // product
      //
      for (ProductListType::product_const_iterator
           b (i.product ().begin ()), n (i.product ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "product",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // count
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ProductType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // isolationWindow
      //
      if (i.isolationWindow ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "isolationWindow",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *i.isolationWindow ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const BinaryDataArrayListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // binaryDataArray
      //
      for (BinaryDataArrayListType::binaryDataArray_const_iterator
           b (i.binaryDataArray ().begin ()), n (i.binaryDataArray ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "binaryDataArray",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // count
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const BinaryDataArrayType& i)
    {
      e << static_cast< const ::ms::mzml::ParamGroupType& > (i);

      // binary
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "binary",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << i.binary ();
      }

      // arrayLength
      //
      if (i.arrayLength ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "arrayLength",
            e));

        a << *i.arrayLength ();
      }

      // dataProcessingRef
      //
      if (i.dataProcessingRef ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "dataProcessingRef",
            e));

        a << *i.dataProcessingRef ();
      }

      // encodedLength
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "encodedLength",
            e));

        a << i.encodedLength ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SpectrumType& i)
    {
      e << static_cast< const ::ms::mzml::ParamGroupType& > (i);

      // scanList
      //
      if (i.scanList ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "scanList",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *i.scanList ();
      }

      // precursorList
      //
      if (i.precursorList ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "precursorList",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *i.precursorList ();
      }

      // productList
      //
      if (i.productList ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "productList",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *i.productList ();
      }

      // binaryDataArrayList
      //
      if (i.binaryDataArrayList ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "binaryDataArrayList",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *i.binaryDataArrayList ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }

      // spotID
      //
      if (i.spotID ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "spotID",
            e));

        a << *i.spotID ();
      }

      // index
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "index",
            e));

        a << i.index ();
      }

      // defaultArrayLength
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "defaultArrayLength",
            e));

        a << i.defaultArrayLength ();
      }

      // dataProcessingRef
      //
      if (i.dataProcessingRef ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "dataProcessingRef",
            e));

        a << *i.dataProcessingRef ();
      }

      // sourceFileRef
      //
      if (i.sourceFileRef ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "sourceFileRef",
            e));

        a << *i.sourceFileRef ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ChromatogramListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // chromatogram
      //
      for (ChromatogramListType::chromatogram_const_iterator
           b (i.chromatogram ().begin ()), n (i.chromatogram ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "chromatogram",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *b;
      }

      // count
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "count",
            e));

        a << i.count ();
      }

      // defaultDataProcessingRef
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "defaultDataProcessingRef",
            e));

        a << i.defaultDataProcessingRef ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ChromatogramType& i)
    {
      e << static_cast< const ::ms::mzml::ParamGroupType& > (i);

      // precursor
      //
      if (i.precursor ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "precursor",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *i.precursor ();
      }

      // product
      //
      if (i.product ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "product",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << *i.product ();
      }

      // binaryDataArrayList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "binaryDataArrayList",
            "http://psi.hupo.org/ms/mzml",
            e));

        s << i.binaryDataArrayList ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }

      // index
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "index",
            e));

        a << i.index ();
      }

      // defaultArrayLength
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "defaultArrayLength",
            e));

        a << i.defaultArrayLength ();
      }

      // dataProcessingRef
      //
      if (i.dataProcessingRef ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "dataProcessingRef",
            e));

        a << *i.dataProcessingRef ();
      }
    }

    void
    mzML (::std::ostream& o,
          const ::ms::mzml::mzMLType& s,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::ms::mzml::mzML (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    mzML (::std::ostream& o,
          const ::ms::mzml::mzMLType& s,
          ::xml_schema::error_handler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::ms::mzml::mzML (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    mzML (::std::ostream& o,
          const ::ms::mzml::mzMLType& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::ms::mzml::mzML (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    mzML (::xercesc::XMLFormatTarget& t,
          const ::ms::mzml::mzMLType& s,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::ms::mzml::mzML (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    mzML (::xercesc::XMLFormatTarget& t,
          const ::ms::mzml::mzMLType& s,
          ::xml_schema::error_handler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::ms::mzml::mzML (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    mzML (::xercesc::XMLFormatTarget& t,
          const ::ms::mzml::mzMLType& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::ms::mzml::mzML (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    mzML (::xercesc::DOMDocument& d,
          const ::ms::mzml::mzMLType& s,
          ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "mzML" &&
          n.namespace_ () == "http://psi.hupo.org/ms/mzml")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "mzML",
          "http://psi.hupo.org/ms/mzml");
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    mzML (const ::ms::mzml::mzMLType& s,
          const ::xml_schema::namespace_infomap& m,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "mzML",
          "http://psi.hupo.org/ms/mzml",
          m, f));

      ::ms::mzml::mzML (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const id& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const id& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const id& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

